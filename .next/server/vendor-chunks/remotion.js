"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/remotion";
exports.ids = ["vendor-chunks/remotion"];
exports.modules = {

/***/ "(ssr)/./node_modules/remotion/dist/esm/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/remotion/dist/esm/index.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsoluteFill: () => (/* binding */ AbsoluteFill),\n/* harmony export */   AnimatedImage: () => (/* binding */ AnimatedImage),\n/* harmony export */   Artifact: () => (/* binding */ Artifact),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   Composition: () => (/* binding */ Composition),\n/* harmony export */   Config: () => (/* binding */ Config),\n/* harmony export */   Easing: () => (/* binding */ Easing),\n/* harmony export */   Experimental: () => (/* binding */ Experimental),\n/* harmony export */   Folder: () => (/* binding */ Folder),\n/* harmony export */   FolderContext: () => (/* binding */ FolderContext),\n/* harmony export */   Freeze: () => (/* binding */ Freeze),\n/* harmony export */   IFrame: () => (/* binding */ IFrame),\n/* harmony export */   Img: () => (/* binding */ Img),\n/* harmony export */   Internals: () => (/* binding */ Internals),\n/* harmony export */   Loop: () => (/* binding */ Loop),\n/* harmony export */   OffthreadVideo: () => (/* binding */ OffthreadVideo),\n/* harmony export */   Sequence: () => (/* binding */ Sequence),\n/* harmony export */   Series: () => (/* binding */ Series),\n/* harmony export */   Still: () => (/* binding */ Still),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Video: () => (/* binding */ Video),\n/* harmony export */   cancelRender: () => (/* binding */ cancelRender),\n/* harmony export */   continueRender: () => (/* binding */ continueRender),\n/* harmony export */   delayRender: () => (/* binding */ delayRender),\n/* harmony export */   getInputProps: () => (/* binding */ getInputProps),\n/* harmony export */   getRemotionEnvironment: () => (/* binding */ getRemotionEnvironment),\n/* harmony export */   getStaticFiles: () => (/* binding */ getStaticFiles),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   interpolateColors: () => (/* binding */ interpolateColors),\n/* harmony export */   measureSpring: () => (/* binding */ measureSpring),\n/* harmony export */   prefetch: () => (/* binding */ prefetch),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   registerRoot: () => (/* binding */ registerRoot),\n/* harmony export */   spring: () => (/* binding */ spring),\n/* harmony export */   staticFile: () => (/* binding */ staticFile),\n/* harmony export */   useBufferState: () => (/* binding */ useBufferState),\n/* harmony export */   useCurrentFrame: () => (/* binding */ useCurrentFrame),\n/* harmony export */   useCurrentScale: () => (/* binding */ useCurrentScale),\n/* harmony export */   useVideoConfig: () => (/* binding */ useVideoConfig),\n/* harmony export */   watchStaticFile: () => (/* binding */ watchStaticFile)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true,\n        configurable: true,\n        set: (newValue)=>all[name] = ()=>newValue\n    });\n};\n// src/_check-rsc.ts\n\nif (typeof react__WEBPACK_IMPORTED_MODULE_0__.createContext !== \"function\") {\n    const err = [\n        'Remotion requires React.createContext, but it is \"undefined\".',\n        'If you are in a React Server Component, turn it into a client component by adding \"use client\" at the top of the file.',\n        \"\",\n        \"Before:\",\n        '  import {useCurrentFrame} from \"remotion\";',\n        \"\",\n        \"After:\",\n        '  \"use client\";',\n        '  import {useCurrentFrame} from \"remotion\";'\n    ];\n    throw new Error(err.join(`\n`));\n}\n// src/Clipper.tsx\nvar Clipper = ()=>{\n    throw new Error(\"<Clipper> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.\");\n};\n// src/enable-sequence-stack-traces.ts\n\n// src/get-remotion-environment.ts\nfunction getNodeEnvString() {\n    return [\n        \"NOD\",\n        \"E_EN\",\n        \"V\"\n    ].join(\"\");\n}\nvar getEnvString = ()=>{\n    return [\n        \"e\",\n        \"nv\"\n    ].join(\"\");\n};\nvar getRemotionEnvironment = ()=>{\n    const isPlayer =  false && 0;\n    const isRendering =  false && (0);\n    const isStudio =  false && 0;\n    const isReadOnlyStudio =  false && 0;\n    return {\n        isStudio,\n        isRendering,\n        isPlayer,\n        isReadOnlyStudio\n    };\n};\n// src/enable-sequence-stack-traces.ts\nvar originalCreateElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement;\nvar componentsToAddStacksTo = [];\nvar enableSequenceStackTraces = ()=>{\n    if (!getRemotionEnvironment().isStudio) {\n        return;\n    }\n    const proxy = new Proxy(originalCreateElement, {\n        apply (target, thisArg, argArray) {\n            if (componentsToAddStacksTo.includes(argArray[0])) {\n                const [first, props, ...rest] = argArray;\n                const newProps = {\n                    ...props ?? {},\n                    stack: new Error().stack\n                };\n                return Reflect.apply(target, thisArg, [\n                    first,\n                    newProps,\n                    ...rest\n                ]);\n            }\n            return Reflect.apply(target, thisArg, argArray);\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement = proxy;\n};\nvar addSequenceStackTraces = (component)=>{\n    componentsToAddStacksTo.push(component);\n    enableSequenceStackTraces();\n};\n// src/is-player.tsx\n\n\nvar IsPlayerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsPlayerContextProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsPlayerContext.Provider, {\n        value: true,\n        children\n    });\n};\nvar useIsPlayer = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IsPlayerContext);\n};\n// src/truthy.ts\nfunction truthy(value) {\n    return Boolean(value);\n}\n// src/version.ts\nvar VERSION = \"4.0.290\";\n// src/multiple-versions-warning.ts\nvar checkMultipleRemotionVersions = ()=>{\n    if (typeof globalThis === \"undefined\") {\n        return;\n    }\n    const set = ()=>{\n        globalThis.remotion_imported = VERSION;\n        if (false) {}\n    };\n    const alreadyImported = globalThis.remotion_imported ||  false && 0;\n    if (alreadyImported) {\n        if (alreadyImported === VERSION) {\n            return;\n        }\n        if (typeof alreadyImported === \"string\" && alreadyImported.includes(\"webcodecs\")) {\n            set();\n            return;\n        }\n        throw new TypeError(`\\uD83D\\uDEA8 Multiple versions of Remotion detected: ${[\n            VERSION,\n            typeof alreadyImported === \"string\" ? alreadyImported : \"an older version\"\n        ].filter(truthy).join(\" and \")}. This will cause things to break in an unexpected way.\nCheck that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \\`npx remotion versions\\` from your terminal to see which versions are mismatching.`);\n    }\n    set();\n};\n// src/Null.tsx\nvar Null = ()=>{\n    throw new Error(\"<Null> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.\");\n};\n// src/Sequence.tsx\n\n// src/AbsoluteFill.tsx\n\n\nvar hasTailwindClassName = (className, classPrefix)=>{\n    if (!className) {\n        return false;\n    }\n    return classPrefix.some((prefix)=>{\n        return className.startsWith(prefix) || className.includes(` ${prefix}`) || className.includes(`:${prefix}`);\n    });\n};\nvar AbsoluteFillRefForwarding = (props, ref)=>{\n    const { style, ...other } = props;\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            position: \"absolute\",\n            top: hasTailwindClassName(other.className, [\n                \"top-\",\n                \"inset-\"\n            ]) ? undefined : 0,\n            left: hasTailwindClassName(other.className, [\n                \"left-\",\n                \"inset-\"\n            ]) ? undefined : 0,\n            right: hasTailwindClassName(other.className, [\n                \"right-\",\n                \"inset-\"\n            ]) ? undefined : 0,\n            bottom: hasTailwindClassName(other.className, [\n                \"bottom-\",\n                \"inset-\"\n            ]) ? undefined : 0,\n            width: hasTailwindClassName(other.className, [\n                \"w-\"\n            ]) ? undefined : \"100%\",\n            height: hasTailwindClassName(other.className, [\n                \"h-\"\n            ]) ? undefined : \"100%\",\n            display: hasTailwindClassName(other.className, [\n                \"block\",\n                \"inline-block\",\n                \"inline\",\n                \"flex\",\n                \"inline-flex\",\n                \"flow-root\",\n                \"grid\",\n                \"inline-grid\",\n                \"contents\",\n                \"list-item\",\n                \"hidden\"\n            ]) ? undefined : \"flex\",\n            flexDirection: hasTailwindClassName(other.className, [\n                \"flex-row\",\n                \"flex-col\",\n                \"flex-row-reverse\",\n                \"flex-col-reverse\"\n            ]) ? undefined : \"column\",\n            ...style\n        };\n    }, [\n        other.className,\n        style\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref,\n        style: actualStyle,\n        ...other\n    });\n};\nvar AbsoluteFill = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AbsoluteFillRefForwarding);\n// src/SequenceContext.tsx\n\nvar SequenceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n// src/SequenceManager.tsx\n\n\nvar SequenceManager = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    registerSequence: ()=>{\n        throw new Error(\"SequenceManagerContext not initialized\");\n    },\n    unregisterSequence: ()=>{\n        throw new Error(\"SequenceManagerContext not initialized\");\n    },\n    sequences: []\n});\nvar SequenceVisibilityToggleContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    hidden: {},\n    setHidden: ()=>{\n        throw new Error(\"SequenceVisibilityToggle not initialized\");\n    }\n});\nvar SequenceManagerProvider = ({ children })=>{\n    const [sequences, setSequences] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [hidden, setHidden] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const registerSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq)=>{\n        setSequences((seqs)=>{\n            return [\n                ...seqs,\n                seq\n            ];\n        });\n    }, []);\n    const unregisterSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq)=>{\n        setSequences((seqs)=>seqs.filter((s)=>s.id !== seq));\n    }, []);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            registerSequence,\n            sequences,\n            unregisterSequence\n        };\n    }, [\n        registerSequence,\n        sequences,\n        unregisterSequence\n    ]);\n    const hiddenContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            hidden,\n            setHidden\n        };\n    }, [\n        hidden\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n        value: sequenceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceVisibilityToggleContext.Provider, {\n            value: hiddenContext,\n            children\n        })\n    });\n};\n// src/nonce.ts\n\nvar NonceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    getNonce: ()=>0,\n    fastRefreshes: 0\n});\nvar useNonce = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    const [nonce, setNonce] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>context.getNonce());\n    const lastContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(context);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (lastContext.current === context) {\n            return;\n        }\n        lastContext.current = context;\n        setNonce(context.getNonce);\n    }, [\n        context\n    ]);\n    return nonce;\n};\n// src/timeline-position-state.ts\nvar exports_timeline_position_state = {};\n__export(exports_timeline_position_state, {\n    useTimelineSetFrame: ()=>useTimelineSetFrame,\n    useTimelinePosition: ()=>useTimelinePosition,\n    usePlayingState: ()=>usePlayingState,\n    persistCurrentFrame: ()=>persistCurrentFrame,\n    getInitialFrameState: ()=>getInitialFrameState,\n    getFrameForComposition: ()=>getFrameForComposition,\n    TimelineContext: ()=>TimelineContext,\n    SetTimelineContext: ()=>SetTimelineContext\n});\n\n// src/use-video.ts\n\n// src/CompositionManagerContext.tsx\n\nvar CompositionManager = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    compositions: [],\n    folders: [],\n    currentCompositionMetadata: null,\n    canvasContent: null\n});\nvar CompositionSetters = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    registerComposition: ()=>{\n        return;\n    },\n    unregisterComposition: ()=>{\n        return;\n    },\n    registerFolder: ()=>{\n        return;\n    },\n    unregisterFolder: ()=>{\n        return;\n    },\n    setCanvasContent: ()=>{\n        return;\n    },\n    updateCompositionDefaultProps: ()=>{\n        return;\n    },\n    onlyRenderComposition: null\n});\n// src/ResolveCompositionConfig.tsx\n\n// src/EditorProps.tsx\n\n\nvar EditorPropsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    props: {},\n    updateProps: ()=>{\n        throw new Error(\"Not implemented\");\n    },\n    resetUnsaved: ()=>{\n        throw new Error(\"Not implemented\");\n    }\n});\nvar editorPropsProviderRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar timeValueRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar EditorPropsProvider = ({ children })=>{\n    const [props, setProps] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});\n    const updateProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ defaultProps, id, newProps })=>{\n        setProps((prev)=>{\n            return {\n                ...prev,\n                [id]: typeof newProps === \"function\" ? newProps(prev[id] ?? defaultProps) : newProps\n            };\n        });\n    }, []);\n    const resetUnsaved = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setProps({});\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(editorPropsProviderRef, ()=>{\n        return {\n            getProps: ()=>props,\n            setProps\n        };\n    }, [\n        props\n    ]);\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            props,\n            updateProps,\n            resetUnsaved\n        };\n    }, [\n        props,\n        resetUnsaved,\n        updateProps\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsContext.Provider, {\n        value: ctx,\n        children\n    });\n};\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithDate = ({ data, indent, staticBase })=>{\n    let customDateUsed = false;\n    let customFileUsed = false;\n    let mapUsed = false;\n    let setUsed = false;\n    try {\n        const serializedString = JSON.stringify(data, function(key, value) {\n            const item = this[key];\n            if (item instanceof Date) {\n                customDateUsed = true;\n                return `${DATE_TOKEN}${item.toISOString()}`;\n            }\n            if (item instanceof Map) {\n                mapUsed = true;\n                return value;\n            }\n            if (item instanceof Set) {\n                setUsed = true;\n                return value;\n            }\n            if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n                customFileUsed = true;\n                return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n            }\n            return value;\n        }, indent);\n        return {\n            serializedString,\n            customDateUsed,\n            customFileUsed,\n            mapUsed,\n            setUsed\n        };\n    } catch (err) {\n        throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n    }\n};\nvar deserializeJSONWithCustomFields = (data)=>{\n    return JSON.parse(data, (_, value)=>{\n        if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n            return new Date(value.replace(DATE_TOKEN, \"\"));\n        }\n        if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n            return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, \"\")}`;\n        }\n        return value;\n    });\n};\nvar serializeThenDeserialize = (props)=>{\n    return deserializeJSONWithCustomFields(serializeJSONWithDate({\n        data: props,\n        indent: 2,\n        staticBase: window.remotion_staticBase\n    }).serializedString);\n};\nvar serializeThenDeserializeInStudio = (props)=>{\n    if (getRemotionEnvironment().isStudio) {\n        return serializeThenDeserialize(props);\n    }\n    return props;\n};\n// src/config/input-props.ts\nvar didWarnSSRImport = false;\nvar warnOnceSSRImport = ()=>{\n    if (didWarnSSRImport) {\n        return;\n    }\n    didWarnSSRImport = true;\n    console.warn(\"Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object.\");\n    console.warn(\"To hide this warning, don't call this function on the server:\");\n    console.warn(\"  typeof window === 'undefined' ? {} : getInputProps()\");\n};\nvar getInputProps = ()=>{\n    if (true) {\n        warnOnceSSRImport();\n        return {};\n    }\n    if (getRemotionEnvironment().isPlayer) {\n        throw new Error(\"You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.\");\n    }\n    const param = window.remotion_inputProps;\n    if (!param) {\n        return {};\n    }\n    const parsed = deserializeJSONWithCustomFields(param);\n    return parsed;\n};\n// src/codec.ts\nvar validCodecs = [\n    \"h264\",\n    \"h265\",\n    \"vp8\",\n    \"vp9\",\n    \"mp3\",\n    \"aac\",\n    \"wav\",\n    \"prores\",\n    \"h264-mkv\",\n    \"h264-ts\",\n    \"gif\"\n];\n// src/validation/validate-default-codec.ts\nfunction validateDefaultCodec(defaultCodec, location) {\n    if (typeof defaultCodec === \"undefined\") {\n        return;\n    }\n    if (typeof defaultCodec !== \"string\") {\n        throw new TypeError(`The \"defaultCodec\" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);\n    }\n    if (!validCodecs.includes(defaultCodec)) {\n        throw new Error(`The \"defaultCodec\" prop ${location} must be one of ${validCodecs.join(\", \")}, but you passed ${defaultCodec}.`);\n    }\n}\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n    if (typeof amount !== \"number\") {\n        throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n    }\n    if (isNaN(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n    }\n    if (!Number.isFinite(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n    }\n    if (amount % 1 !== 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n    }\n    if (amount <= 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n    }\n}\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n    const { allowFloats, component } = options;\n    if (typeof durationInFrames === \"undefined\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n    }\n    if (!allowFloats && durationInFrames % 1 !== 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n    }\n    if (!Number.isFinite(durationInFrames)) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n    }\n}\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n    if (typeof fps !== \"number\") {\n        throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n    }\n    if (!Number.isFinite(fps)) {\n        throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n    }\n    if (isNaN(fps)) {\n        throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n    }\n    if (fps <= 0) {\n        throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n    }\n    if (isGif && fps > 50) {\n        throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n    }\n}\n// src/resolve-video-config.ts\nvar validateCalculated = ({ calculated, compositionId, compositionFps, compositionHeight, compositionWidth, compositionDurationInFrames })=>{\n    const calculateMetadataErrorLocation = `calculated by calculateMetadata() for the composition \"${compositionId}\"`;\n    const defaultErrorLocation = `of the \"<Composition />\" component with the id \"${compositionId}\"`;\n    const width = calculated?.width ?? compositionWidth ?? undefined;\n    validateDimension(width, \"width\", calculated?.width ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const height = calculated?.height ?? compositionHeight ?? undefined;\n    validateDimension(height, \"height\", calculated?.height ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const fps = calculated?.fps ?? compositionFps ?? null;\n    validateFps(fps, calculated?.fps ? calculateMetadataErrorLocation : defaultErrorLocation, false);\n    const durationInFrames = calculated?.durationInFrames ?? compositionDurationInFrames ?? null;\n    validateDurationInFrames(durationInFrames, {\n        allowFloats: false,\n        component: `of the \"<Composition />\" component with the id \"${compositionId}\"`\n    });\n    const defaultCodec = calculated?.defaultCodec;\n    validateDefaultCodec(defaultCodec, calculateMetadataErrorLocation);\n    const defaultOutName = calculated?.defaultOutName;\n    return {\n        width,\n        height,\n        fps,\n        durationInFrames,\n        defaultCodec,\n        defaultOutName\n    };\n};\nvar resolveVideoConfig = ({ calculateMetadata, signal, defaultProps, originalProps, compositionId, compositionDurationInFrames, compositionFps, compositionHeight, compositionWidth })=>{\n    const calculatedProm = calculateMetadata ? calculateMetadata({\n        defaultProps,\n        props: originalProps,\n        abortSignal: signal,\n        compositionId\n    }) : null;\n    if (calculatedProm !== null && typeof calculatedProm === \"object\" && \"then\" in calculatedProm) {\n        return calculatedProm.then((c)=>{\n            const { height, width, durationInFrames, fps, defaultCodec, defaultOutName } = validateCalculated({\n                calculated: c,\n                compositionDurationInFrames,\n                compositionFps,\n                compositionHeight,\n                compositionWidth,\n                compositionId\n            });\n            return {\n                width,\n                height,\n                fps,\n                durationInFrames,\n                id: compositionId,\n                defaultProps: serializeThenDeserializeInStudio(defaultProps),\n                props: serializeThenDeserializeInStudio(c.props ?? originalProps),\n                defaultCodec: defaultCodec ?? null,\n                defaultOutName: defaultOutName ?? null\n            };\n        });\n    }\n    const data = validateCalculated({\n        calculated: calculatedProm,\n        compositionDurationInFrames,\n        compositionFps,\n        compositionHeight,\n        compositionWidth,\n        compositionId\n    });\n    if (calculatedProm === null) {\n        return {\n            ...data,\n            id: compositionId,\n            defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n            props: serializeThenDeserializeInStudio(originalProps),\n            defaultCodec: null,\n            defaultOutName: null\n        };\n    }\n    return {\n        ...data,\n        id: compositionId,\n        defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n        props: serializeThenDeserializeInStudio(calculatedProm.props ?? originalProps),\n        defaultCodec: calculatedProm.defaultCodec ?? null,\n        defaultOutName: calculatedProm.defaultOutName ?? null\n    };\n};\nvar resolveVideoConfigOrCatch = (params)=>{\n    try {\n        const promiseOrReturnValue = resolveVideoConfig(params);\n        return {\n            type: \"success\",\n            result: promiseOrReturnValue\n        };\n    } catch (err) {\n        return {\n            type: \"error\",\n            error: err\n        };\n    }\n};\n// src/ResolveCompositionConfig.tsx\n\nvar ResolveCompositionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar resolveCompositionsRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar needsResolution = (composition)=>{\n    return Boolean(composition.calculateMetadata);\n};\nvar PROPS_UPDATED_EXTERNALLY = \"remotion.propsUpdatedExternally\";\nvar ResolveCompositionConfig = ({ children })=>{\n    const [currentRenderModalComposition, setCurrentRenderModalComposition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const { fastRefreshes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    const selectedComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return compositions.find((c)=>canvasContent && canvasContent.type === \"composition\" && canvasContent.compositionId === c.id);\n    }, [\n        canvasContent,\n        compositions\n    ]);\n    const renderModalComposition = compositions.find((c)=>c.id === currentRenderModalComposition);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const inputProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return  true ? {} : 0;\n    }, []);\n    const [resolvedConfigs, setResolvedConfigs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return selectedComposition ? allEditorProps[selectedComposition.id] ?? {} : {};\n    }, [\n        allEditorProps,\n        selectedComposition\n    ]);\n    const renderModalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return renderModalComposition ? allEditorProps[renderModalComposition.id] ?? {} : {};\n    }, [\n        allEditorProps,\n        renderModalComposition\n    ]);\n    const hasResolution = Boolean(currentCompositionMetadata);\n    const doResolution = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ calculateMetadata, combinedProps, compositionDurationInFrames, compositionFps, compositionHeight, compositionId, compositionWidth, defaultProps })=>{\n        const controller = new AbortController;\n        if (hasResolution) {\n            return controller;\n        }\n        const { signal } = controller;\n        const result = resolveVideoConfigOrCatch({\n            compositionId,\n            calculateMetadata,\n            originalProps: combinedProps,\n            signal,\n            defaultProps,\n            compositionDurationInFrames,\n            compositionFps,\n            compositionHeight,\n            compositionWidth\n        });\n        if (result.type === \"error\") {\n            setResolvedConfigs((r)=>({\n                    ...r,\n                    [compositionId]: {\n                        type: \"error\",\n                        error: result.error\n                    }\n                }));\n            return controller;\n        }\n        const promOrNot = result.result;\n        if (typeof promOrNot === \"object\" && \"then\" in promOrNot) {\n            setResolvedConfigs((r)=>{\n                const prev = r[compositionId];\n                if (prev?.type === \"success\" || prev?.type === \"success-and-refreshing\") {\n                    return {\n                        ...r,\n                        [compositionId]: {\n                            type: \"success-and-refreshing\",\n                            result: prev.result\n                        }\n                    };\n                }\n                return {\n                    ...r,\n                    [compositionId]: {\n                        type: \"loading\"\n                    }\n                };\n            });\n            promOrNot.then((c)=>{\n                if (controller.signal.aborted) {\n                    return;\n                }\n                setResolvedConfigs((r)=>({\n                        ...r,\n                        [compositionId]: {\n                            type: \"success\",\n                            result: c\n                        }\n                    }));\n            }).catch((err)=>{\n                if (controller.signal.aborted) {\n                    return;\n                }\n                setResolvedConfigs((r)=>({\n                        ...r,\n                        [compositionId]: {\n                            type: \"error\",\n                            error: err\n                        }\n                    }));\n            });\n        } else {\n            setResolvedConfigs((r)=>({\n                    ...r,\n                    [compositionId]: {\n                        type: \"success\",\n                        result: promOrNot\n                    }\n                }));\n        }\n        return controller;\n    }, [\n        hasResolution\n    ]);\n    const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(resolveCompositionsRef, ()=>{\n        return {\n            setCurrentRenderModalComposition: (id)=>{\n                setCurrentRenderModalComposition(id);\n            },\n            reloadCurrentlySelectedComposition: ()=>{\n                if (!currentComposition) {\n                    return;\n                }\n                const composition = compositions.find((c)=>c.id === currentComposition);\n                if (!composition) {\n                    throw new Error(`Could not find composition with id ${currentComposition}`);\n                }\n                const editorProps = allEditorProps[currentComposition] ?? {};\n                const defaultProps = {\n                    ...composition.defaultProps ?? {},\n                    ...editorProps ?? {}\n                };\n                const props = {\n                    ...defaultProps,\n                    ...inputProps ?? {}\n                };\n                doResolution({\n                    defaultProps,\n                    calculateMetadata: composition.calculateMetadata,\n                    combinedProps: props,\n                    compositionDurationInFrames: composition.durationInFrames ?? null,\n                    compositionFps: composition.fps ?? null,\n                    compositionHeight: composition.height ?? null,\n                    compositionWidth: composition.width ?? null,\n                    compositionId: composition.id\n                });\n            }\n        };\n    }, [\n        allEditorProps,\n        compositions,\n        currentComposition,\n        doResolution,\n        inputProps\n    ]);\n    const isTheSame = selectedComposition?.id === renderModalComposition?.id;\n    const currentDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...selectedComposition?.defaultProps ?? {},\n            ...selectedEditorProps ?? {}\n        };\n    }, [\n        selectedComposition?.defaultProps,\n        selectedEditorProps\n    ]);\n    const originalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...currentDefaultProps,\n            ...inputProps ?? {}\n        };\n    }, [\n        currentDefaultProps,\n        inputProps\n    ]);\n    const canResolve = selectedComposition && needsResolution(selectedComposition);\n    const shouldIgnoreUpdate =  false && 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (shouldIgnoreUpdate) {\n            return;\n        }\n        if (canResolve) {\n            const controller = doResolution({\n                calculateMetadata: selectedComposition.calculateMetadata,\n                combinedProps: originalProps,\n                compositionDurationInFrames: selectedComposition.durationInFrames ?? null,\n                compositionFps: selectedComposition.fps ?? null,\n                compositionHeight: selectedComposition.height ?? null,\n                compositionWidth: selectedComposition.width ?? null,\n                defaultProps: currentDefaultProps,\n                compositionId: selectedComposition.id\n            });\n            return ()=>{\n                controller.abort();\n            };\n        }\n    }, [\n        canResolve,\n        currentDefaultProps,\n        doResolution,\n        originalProps,\n        selectedComposition?.calculateMetadata,\n        selectedComposition?.durationInFrames,\n        selectedComposition?.fps,\n        selectedComposition?.height,\n        selectedComposition?.id,\n        selectedComposition?.width,\n        shouldIgnoreUpdate\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (shouldIgnoreUpdate) {\n            return;\n        }\n        window.dispatchEvent(new CustomEvent(PROPS_UPDATED_EXTERNALLY, {\n            detail: {\n                resetUnsaved: true\n            }\n        }));\n    }, [\n        fastRefreshes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (renderModalComposition && !isTheSame) {\n            const combinedProps = {\n                ...renderModalComposition.defaultProps ?? {},\n                ...renderModalProps ?? {},\n                ...inputProps ?? {}\n            };\n            const controller = doResolution({\n                calculateMetadata: renderModalComposition.calculateMetadata,\n                compositionDurationInFrames: renderModalComposition.durationInFrames ?? null,\n                compositionFps: renderModalComposition.fps ?? null,\n                compositionHeight: renderModalComposition.height ?? null,\n                compositionId: renderModalComposition.id,\n                compositionWidth: renderModalComposition.width ?? null,\n                defaultProps: currentDefaultProps,\n                combinedProps\n            });\n            return ()=>{\n                controller.abort();\n            };\n        }\n    }, [\n        currentDefaultProps,\n        doResolution,\n        inputProps,\n        isTheSame,\n        renderModalComposition,\n        renderModalProps\n    ]);\n    const resolvedConfigsIncludingStaticOnes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const staticComps = compositions.filter((c)=>{\n            return c.calculateMetadata === null;\n        });\n        return {\n            ...resolvedConfigs,\n            ...staticComps.reduce((acc, curr)=>{\n                return {\n                    ...acc,\n                    [curr.id]: {\n                        type: \"success\",\n                        result: {\n                            ...curr,\n                            defaultProps: curr.defaultProps ?? {}\n                        }\n                    }\n                };\n            }, {})\n        };\n    }, [\n        compositions,\n        resolvedConfigs\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n        value: resolvedConfigsIncludingStaticOnes,\n        children\n    });\n};\nvar useResolvedVideoConfig = (preferredCompositionId)=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ResolveCompositionContext);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n    const compositionId = preferredCompositionId ?? currentComposition;\n    const composition = compositions.find((c)=>c.id === compositionId);\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return composition ? allEditorProps[composition.id] ?? {} : {};\n    }, [\n        allEditorProps,\n        composition\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!composition) {\n            return null;\n        }\n        if (currentCompositionMetadata) {\n            return {\n                type: \"success\",\n                result: {\n                    ...currentCompositionMetadata,\n                    id: composition.id,\n                    defaultProps: composition.defaultProps ?? {}\n                }\n            };\n        }\n        if (!needsResolution(composition)) {\n            validateDurationInFrames(composition.durationInFrames, {\n                allowFloats: false,\n                component: `in <Composition id=\"${composition.id}\">`\n            });\n            validateFps(composition.fps, `in <Composition id=\"${composition.id}\">`, false);\n            validateDimension(composition.width, \"width\", `in <Composition id=\"${composition.id}\">`);\n            validateDimension(composition.height, \"height\", `in <Composition id=\"${composition.id}\">`);\n            return {\n                type: \"success\",\n                result: {\n                    width: composition.width,\n                    height: composition.height,\n                    fps: composition.fps,\n                    id: composition.id,\n                    durationInFrames: composition.durationInFrames,\n                    defaultProps: composition.defaultProps ?? {},\n                    props: {\n                        ...composition.defaultProps ?? {},\n                        ...selectedEditorProps ?? {},\n                        ... true ? {} : 0\n                    },\n                    defaultCodec: null,\n                    defaultOutName: null\n                }\n            };\n        }\n        if (!context[composition.id]) {\n            return null;\n        }\n        return context[composition.id];\n    }, [\n        composition,\n        context,\n        currentCompositionMetadata,\n        selectedEditorProps\n    ]);\n};\n// src/use-video.ts\nvar useVideo = ()=>{\n    const { canvasContent, compositions, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const selected = compositions.find((c)=>{\n        return canvasContent?.type === \"composition\" && c.id === canvasContent.compositionId;\n    });\n    const resolved = useResolvedVideoConfig(selected?.id ?? null);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!resolved) {\n            return null;\n        }\n        if (resolved.type === \"error\") {\n            return null;\n        }\n        if (resolved.type === \"loading\") {\n            return null;\n        }\n        if (!selected) {\n            return null;\n        }\n        return {\n            ...resolved.result,\n            defaultProps: selected.defaultProps ?? {},\n            id: selected.id,\n            ...currentCompositionMetadata ?? {},\n            component: selected.component\n        };\n    }, [\n        currentCompositionMetadata,\n        resolved,\n        selected\n    ]);\n};\n// src/timeline-position-state.ts\nvar TimelineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    frame: {},\n    playing: false,\n    playbackRate: 1,\n    rootId: \"\",\n    imperativePlaying: {\n        current: false\n    },\n    setPlaybackRate: ()=>{\n        throw new Error(\"default\");\n    },\n    audioAndVideoTags: {\n        current: []\n    }\n});\nvar SetTimelineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setFrame: ()=>{\n        throw new Error(\"default\");\n    },\n    setPlaying: ()=>{\n        throw new Error(\"default\");\n    }\n});\nvar makeKey = ()=>{\n    return `remotion.time-all`;\n};\nvar persistCurrentFrame = (time)=>{\n    localStorage.setItem(makeKey(), JSON.stringify(time));\n};\nvar getInitialFrameState = ()=>{\n    const item = localStorage.getItem(makeKey()) ?? \"{}\";\n    const obj = JSON.parse(item);\n    return obj;\n};\nvar getFrameForComposition = (composition)=>{\n    const item = localStorage.getItem(makeKey()) ?? \"{}\";\n    const obj = JSON.parse(item);\n    if (obj[composition] !== undefined) {\n        return Number(obj[composition]);\n    }\n    if (true) {\n        return 0;\n    }\n    return window.remotion_initialFrame ?? 0;\n};\nvar useTimelinePosition = ()=>{\n    const videoConfig = useVideo();\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    if (!videoConfig) {\n        return  true ? 0 : 0;\n    }\n    const unclamped = state.frame[videoConfig.id] ?? (getRemotionEnvironment().isPlayer ? 0 : getFrameForComposition(videoConfig.id));\n    return Math.min(videoConfig.durationInFrames - 1, unclamped);\n};\nvar useTimelineSetFrame = ()=>{\n    const { setFrame } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return setFrame;\n};\nvar usePlayingState = ()=>{\n    const { playing, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const { setPlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            playing,\n            setPlaying,\n            imperativePlaying\n        ], [\n        imperativePlaying,\n        playing,\n        setPlaying\n    ]);\n};\n// src/use-video-config.ts\n\n// src/CanUseRemotionHooks.tsx\n\n\nvar CanUseRemotionHooks = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar CanUseRemotionHooksProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n        value: true,\n        children\n    });\n};\n// src/use-unsafe-video-config.ts\n\nvar useUnsafeVideoConfig = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const ctxWidth = context?.width ?? null;\n    const ctxHeight = context?.height ?? null;\n    const ctxDuration = context?.durationInFrames ?? null;\n    const video = useVideo();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!video) {\n            return null;\n        }\n        const { id, durationInFrames, fps, height, width, defaultProps, props, defaultCodec, defaultOutName } = video;\n        return {\n            id,\n            width: ctxWidth ?? width,\n            height: ctxHeight ?? height,\n            fps,\n            durationInFrames: ctxDuration ?? durationInFrames,\n            defaultProps,\n            props,\n            defaultCodec,\n            defaultOutName\n        };\n    }, [\n        ctxDuration,\n        ctxHeight,\n        ctxWidth,\n        video\n    ]);\n};\n// src/use-video-config.ts\nvar useVideoConfig = ()=>{\n    const videoConfig = useUnsafeVideoConfig();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    const isPlayer = useIsPlayer();\n    if (!videoConfig) {\n        if ( false || isPlayer) {\n            throw new Error([\n                \"No video config found. Likely reasons:\",\n                \"- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.\",\n                \"- You have multiple versions of Remotion installed which causes the React context to get lost.\"\n            ].join(\"-\"));\n        }\n        throw new Error(\"No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.\");\n    }\n    if (!context) {\n        throw new Error(\"Called useVideoConfig() outside a Remotion composition.\");\n    }\n    return videoConfig;\n};\n// src/freeze.tsx\n\n// src/use-current-frame.ts\n\nvar useCurrentFrame = ()=>{\n    const canUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (!canUseRemotionHooks) {\n        if (getRemotionEnvironment().isPlayer) {\n            throw new Error(`useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples`);\n        }\n        throw new Error(`useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions`);\n    }\n    const frame = useTimelinePosition();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const contextOffset = context ? context.cumulatedFrom + context.relativeFrom : 0;\n    return frame - contextOffset;\n};\n// src/freeze.tsx\n\nvar Freeze = ({ frame: frameToFreeze, children, active = true })=>{\n    const frame = useCurrentFrame();\n    const videoConfig = useVideoConfig();\n    if (typeof frameToFreeze === \"undefined\") {\n        throw new Error(`The <Freeze /> component requires a 'frame' prop, but none was passed.`);\n    }\n    if (typeof frameToFreeze !== \"number\") {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof frameToFreeze}`);\n    }\n    if (Number.isNaN(frameToFreeze)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a real number, but it is NaN.`);\n    }\n    if (!Number.isFinite(frameToFreeze)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${frameToFreeze}.`);\n    }\n    const isActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof active === \"boolean\") {\n            return active;\n        }\n        if (typeof active === \"function\") {\n            return active(frame);\n        }\n    }, [\n        active,\n        frame\n    ]);\n    const timelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const relativeFrom = sequenceContext?.relativeFrom ?? 0;\n    const timelineValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!isActive) {\n            return timelineContext;\n        }\n        return {\n            ...timelineContext,\n            playing: false,\n            imperativePlaying: {\n                current: false\n            },\n            frame: {\n                [videoConfig.id]: frameToFreeze + relativeFrom\n            }\n        };\n    }, [\n        isActive,\n        timelineContext,\n        videoConfig.id,\n        frameToFreeze,\n        relativeFrom\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n        value: timelineValue,\n        children\n    });\n};\n// src/Sequence.tsx\n\nvar RegularSequenceRefForwardingFunction = ({ from = 0, durationInFrames = Infinity, children, name, height, width, showInTimeline = true, _remotionInternalLoopDisplay: loopDisplay, _remotionInternalStack: stack, _remotionInternalPremountDisplay: premountDisplay, ...other }, ref)=>{\n    const { layout = \"absolute-fill\" } = other;\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(Math.random()));\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const cumulatedFrom = parentSequence ? parentSequence.cumulatedFrom + parentSequence.relativeFrom : 0;\n    const nonce = useNonce();\n    if (layout !== \"absolute-fill\" && layout !== \"none\") {\n        throw new TypeError(`The layout prop of <Sequence /> expects either \"absolute-fill\" or \"none\", but you passed: ${layout}`);\n    }\n    if (layout === \"none\" && typeof other.style !== \"undefined\") {\n        throw new TypeError('If layout=\"none\", you may not pass a style.');\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new TypeError(`You passed to durationInFrames an argument of type ${typeof durationInFrames}, but it must be a number.`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`durationInFrames must be positive, but got ${durationInFrames}`);\n    }\n    if (typeof from !== \"number\") {\n        throw new TypeError(`You passed to the \"from\" props of your <Sequence> an argument of type ${typeof from}, but it must be a number.`);\n    }\n    if (!Number.isFinite(from)) {\n        throw new TypeError(`The \"from\" prop of a sequence must be finite, but got ${from}.`);\n    }\n    const absoluteFrame = useTimelinePosition();\n    const videoConfig = useVideoConfig();\n    const parentSequenceDuration = parentSequence ? Math.min(parentSequence.durationInFrames - from, durationInFrames) : durationInFrames;\n    const actualDurationInFrames = Math.max(0, Math.min(videoConfig.durationInFrames - from, parentSequenceDuration));\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    const premounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return parentSequence?.premounting || Boolean(other._remotionInternalIsPremounting);\n    }, [\n        other._remotionInternalIsPremounting,\n        parentSequence?.premounting\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            cumulatedFrom,\n            relativeFrom: from,\n            durationInFrames: actualDurationInFrames,\n            parentFrom: parentSequence?.relativeFrom ?? 0,\n            id,\n            height: height ?? parentSequence?.height ?? null,\n            width: width ?? parentSequence?.width ?? null,\n            premounting\n        };\n    }, [\n        cumulatedFrom,\n        from,\n        actualDurationInFrames,\n        parentSequence,\n        id,\n        height,\n        width,\n        premounting\n    ]);\n    const timelineClipName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return name ?? \"\";\n    }, [\n        name\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!getRemotionEnvironment().isStudio) {\n            return;\n        }\n        registerSequence({\n            from,\n            duration: actualDurationInFrames,\n            id,\n            displayName: timelineClipName,\n            parent: parentSequence?.id ?? null,\n            type: \"sequence\",\n            rootId,\n            showInTimeline,\n            nonce,\n            loopDisplay,\n            stack: stack ?? null,\n            premountDisplay: premountDisplay ?? null\n        });\n        return ()=>{\n            unregisterSequence(id);\n        };\n    }, [\n        durationInFrames,\n        id,\n        name,\n        registerSequence,\n        timelineClipName,\n        unregisterSequence,\n        parentSequence?.id,\n        actualDurationInFrames,\n        rootId,\n        from,\n        showInTimeline,\n        nonce,\n        loopDisplay,\n        stack,\n        premountDisplay\n    ]);\n    const endThreshold = Math.ceil(cumulatedFrom + from + durationInFrames - 1);\n    const content = absoluteFrame < cumulatedFrom + from ? null : absoluteFrame > endThreshold ? null : children;\n    const styleIfThere = other.layout === \"none\" ? undefined : other.style;\n    const defaultStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            flexDirection: undefined,\n            ...width ? {\n                width\n            } : {},\n            ...height ? {\n                height\n            } : {},\n            ...styleIfThere ?? {}\n        };\n    }, [\n        height,\n        styleIfThere,\n        width\n    ]);\n    if (ref !== null && layout === \"none\") {\n        throw new TypeError('It is not supported to pass both a `ref` and `layout=\"none\"` to <Sequence />.');\n    }\n    const isSequenceHidden = hidden[id] ?? false;\n    if (isSequenceHidden) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n        value: contextValue,\n        children: content === null ? null : other.layout === \"none\" ? content : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, {\n            ref,\n            style: defaultStyle,\n            className: other.className,\n            children: content\n        })\n    });\n};\nvar RegularSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(RegularSequenceRefForwardingFunction);\nvar PremountedSequenceRefForwardingFunction = (props, ref)=>{\n    const frame = useCurrentFrame();\n    if (props.layout === \"none\") {\n        throw new Error('`<Sequence>` with `premountFor` prop does not support layout=\"none\"');\n    }\n    const { style: passedStyle, from = 0, premountFor = 0, styleWhilePremounted, ...otherProps } = props;\n    const premountingActive = frame < from && frame >= from - premountFor;\n    const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...passedStyle,\n            opacity: premountingActive ? 0 : 1,\n            pointerEvents: premountingActive ? \"none\" : passedStyle?.pointerEvents ?? undefined,\n            ...premountingActive ? styleWhilePremounted : {}\n        };\n    }, [\n        passedStyle,\n        premountingActive,\n        styleWhilePremounted\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Freeze, {\n        frame: from,\n        active: premountingActive,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            ref,\n            from,\n            style,\n            _remotionInternalPremountDisplay: premountFor,\n            _remotionInternalIsPremounting: premountingActive,\n            ...otherProps\n        })\n    });\n};\nvar PremountedSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(PremountedSequenceRefForwardingFunction);\nvar SequenceRefForwardingFunction = (props, ref)=>{\n    if (props.layout !== \"none\" && props.premountFor && !getRemotionEnvironment().isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PremountedSequence, {\n            ...props,\n            ref\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RegularSequence, {\n        ...props,\n        ref\n    });\n};\nvar Sequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SequenceRefForwardingFunction);\n// src/animated-image/AnimatedImage.tsx\n\n// src/cancel-render.ts\nvar isErrorLike = (err)=>{\n    if (err instanceof Error) {\n        return true;\n    }\n    if (err === null) {\n        return false;\n    }\n    if (typeof err !== \"object\") {\n        return false;\n    }\n    if (!(\"stack\" in err)) {\n        return false;\n    }\n    if (typeof err.stack !== \"string\") {\n        return false;\n    }\n    if (!(\"message\" in err)) {\n        return false;\n    }\n    if (typeof err.message !== \"string\") {\n        return false;\n    }\n    return true;\n};\nfunction cancelRender(err) {\n    let error;\n    if (isErrorLike(err)) {\n        error = err;\n        if (!error.stack) {\n            error.stack = new Error(error.message).stack;\n        }\n    } else if (typeof err === \"string\") {\n        error = Error(err);\n    } else {\n        error = Error(\"Rendering was cancelled\");\n    }\n    window.remotion_cancelledError = error.stack;\n    throw error;\n}\n// src/log.ts\nvar logLevels = [\n    \"trace\",\n    \"verbose\",\n    \"info\",\n    \"warn\",\n    \"error\"\n];\nvar getNumberForLogLevel = (level)=>{\n    return logLevels.indexOf(level);\n};\nvar isEqualOrBelowLogLevel = (currentLevel, level)=>{\n    return getNumberForLogLevel(currentLevel) <= getNumberForLogLevel(level);\n};\nvar Log = {\n    trace: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"trace\")) {\n            return console.log(...args);\n        }\n    },\n    verbose: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"verbose\")) {\n            return console.log(...args);\n        }\n    },\n    info: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"info\")) {\n            return console.log(...args);\n        }\n    },\n    warn: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"warn\")) {\n            return console.warn(...args);\n        }\n    },\n    error: (...args)=>{\n        return console.error(...args);\n    }\n};\n// src/delay-render.ts\nif (false) {}\nvar handles = [];\nif (false) {}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar DELAY_RENDER_CLEAR_TOKEN = \"handle was cleared after\";\nvar defaultTimeout = 30000;\nvar delayRender = (label, options)=>{\n    if (typeof label !== \"string\" && typeof label !== \"undefined\") {\n        throw new Error(\"The label parameter of delayRender() must be a string or undefined, got: \" + JSON.stringify(label));\n    }\n    const handle = Math.random();\n    handles.push(handle);\n    const called = Error().stack?.replace(/^Error/g, \"\") ?? \"\";\n    if (getRemotionEnvironment().isRendering) {\n        const timeoutToUse = (options?.timeoutInMilliseconds ?? ( true ? defaultTimeout : 0)) - 2000;\n        if (false) {}\n    }\n    if (false) {}\n    return handle;\n};\nvar continueRender = (handle)=>{\n    if (typeof handle === \"undefined\") {\n        throw new TypeError(\"The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.\");\n    }\n    if (typeof handle !== \"number\") {\n        throw new TypeError(\"The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: \" + JSON.stringify(handle));\n    }\n    handles = handles.filter((h)=>{\n        if (h === handle) {\n            if (getRemotionEnvironment().isRendering) {\n                if (!window.remotion_delayRenderTimeouts[handle]) {\n                    return false;\n                }\n                const { label, startTime, timeout } = window.remotion_delayRenderTimeouts[handle];\n                clearTimeout(timeout);\n                const message = [\n                    label ? `delayRender() \"${label}\"` : \"A delayRender()\",\n                    DELAY_RENDER_CLEAR_TOKEN,\n                    `${Date.now() - startTime}ms`\n                ].filter(truthy).join(\" \");\n                Log.verbose(window.remotion_logLevel, message);\n                delete window.remotion_delayRenderTimeouts[handle];\n            }\n            return false;\n        }\n        return true;\n    });\n    if (handles.length === 0 && \"undefined\" !== \"undefined\") {}\n};\n// src/animated-image/canvas.tsx\n\n\nvar calcArgs = (fit, frameSize, canvasSize)=>{\n    switch(fit){\n        case \"fill\":\n            {\n                return [\n                    0,\n                    0,\n                    frameSize.width,\n                    frameSize.height,\n                    0,\n                    0,\n                    canvasSize.width,\n                    canvasSize.height\n                ];\n            }\n        case \"contain\":\n            {\n                const ratio = Math.min(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n                const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n                const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n                return [\n                    0,\n                    0,\n                    frameSize.width,\n                    frameSize.height,\n                    centerX,\n                    centerY,\n                    frameSize.width * ratio,\n                    frameSize.height * ratio\n                ];\n            }\n        case \"cover\":\n            {\n                const ratio = Math.max(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n                const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n                const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n                return [\n                    0,\n                    0,\n                    frameSize.width,\n                    frameSize.height,\n                    centerX,\n                    centerY,\n                    frameSize.width * ratio,\n                    frameSize.height * ratio\n                ];\n            }\n        default:\n            throw new Error(\"Unknown fit: \" + fit);\n    }\n};\nvar CanvasRefForwardingFunction = ({ width, height, fit, className, style }, ref)=>{\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const draw = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((imageData)=>{\n        const canvas = canvasRef.current;\n        const canvasWidth = width ?? imageData.displayWidth;\n        const canvasHeight = height ?? imageData.displayHeight;\n        if (!canvas) {\n            throw new Error(\"Canvas ref is not set\");\n        }\n        const ctx = canvasRef.current?.getContext(\"2d\");\n        if (!ctx) {\n            throw new Error(\"Could not get 2d context\");\n        }\n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n        ctx.drawImage(imageData, ...calcArgs(fit, {\n            height: imageData.displayHeight,\n            width: imageData.displayWidth\n        }, {\n            width: canvasWidth,\n            height: canvasHeight\n        }));\n    }, [\n        fit,\n        height,\n        width\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return {\n            draw,\n            getCanvas: ()=>{\n                if (!canvasRef.current) {\n                    throw new Error(\"Canvas ref is not set\");\n                }\n                return canvasRef.current;\n            },\n            clear: ()=>{\n                const ctx = canvasRef.current?.getContext(\"2d\");\n                if (!ctx) {\n                    throw new Error(\"Could not get 2d context\");\n                }\n                ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n            }\n        };\n    }, [\n        draw\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"canvas\", {\n        ref: canvasRef,\n        className,\n        style\n    });\n};\nvar Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CanvasRefForwardingFunction);\n// src/animated-image/decode-image.ts\nvar CACHE_SIZE = 5;\nvar getActualTime = ({ loopBehavior, durationFound, timeInSec })=>{\n    return loopBehavior === \"loop\" ? durationFound ? timeInSec % durationFound : timeInSec : Math.min(timeInSec, durationFound || Infinity);\n};\nvar decodeImage = async ({ resolvedSrc, signal, currentTime, initialLoopBehavior })=>{\n    if (typeof ImageDecoder === \"undefined\") {\n        throw new Error(\"Your browser does not support the WebCodecs ImageDecoder API.\");\n    }\n    const res = await fetch(resolvedSrc, {\n        signal\n    });\n    const { body } = res;\n    if (!body) {\n        throw new Error(\"Got no body\");\n    }\n    const decoder = new ImageDecoder({\n        data: body,\n        type: res.headers.get(\"Content-Type\") || \"image/gif\"\n    });\n    await decoder.completed;\n    const { selectedTrack } = decoder.tracks;\n    if (!selectedTrack) {\n        throw new Error(\"No selected track\");\n    }\n    const cache = [];\n    let durationFound = null;\n    const getFrameByIndex = async (frameIndex)=>{\n        const foundInCache = cache.find((c)=>c.frameIndex === frameIndex);\n        if (foundInCache && foundInCache.frame) {\n            return foundInCache;\n        }\n        const frame = await decoder.decode({\n            frameIndex,\n            completeFramesOnly: true\n        });\n        if (foundInCache) {\n            foundInCache.frame = frame.image;\n        } else {\n            cache.push({\n                frame: frame.image,\n                frameIndex,\n                timeInSeconds: frame.image.timestamp / 1e6\n            });\n        }\n        return {\n            frame: frame.image,\n            frameIndex,\n            timeInSeconds: frame.image.timestamp / 1e6\n        };\n    };\n    const clearCache = (closeToTimeInSec)=>{\n        const itemsInCache = cache.filter((c)=>c.frame);\n        const sortByClosestToCurrentTime = itemsInCache.sort((a, b)=>{\n            const aDiff = Math.abs(a.timeInSeconds - closeToTimeInSec);\n            const bDiff = Math.abs(b.timeInSeconds - closeToTimeInSec);\n            return aDiff - bDiff;\n        });\n        for(let i = 0; i < sortByClosestToCurrentTime.length; i++){\n            if (i < CACHE_SIZE) {\n                continue;\n            }\n            const item = sortByClosestToCurrentTime[i];\n            item.frame = null;\n        }\n    };\n    const ensureFrameBeforeAndAfter = async ({ timeInSec, loopBehavior })=>{\n        const actualTimeInSec = getActualTime({\n            durationFound,\n            loopBehavior,\n            timeInSec\n        });\n        const framesBefore = cache.filter((c)=>c.timeInSeconds <= actualTimeInSec);\n        const biggestIndex = framesBefore.map((c)=>c.frameIndex).reduce((a, b)=>Math.max(a, b), 0);\n        let i = biggestIndex;\n        while(true){\n            const f = await getFrameByIndex(i);\n            i++;\n            if (!f.frame) {\n                throw new Error(\"No frame found\");\n            }\n            if (!f.frame.duration) {\n                break;\n            }\n            if (i === selectedTrack.frameCount && durationFound === null) {\n                const duration = (f.frame.timestamp + f.frame.duration) / 1e6;\n                durationFound = duration;\n            }\n            if (f.timeInSeconds > actualTimeInSec || i === selectedTrack.frameCount) {\n                break;\n            }\n        }\n        if (selectedTrack.frameCount - biggestIndex < 3 && loopBehavior === \"loop\") {\n            await getFrameByIndex(0);\n        }\n        clearCache(actualTimeInSec);\n    };\n    await ensureFrameBeforeAndAfter({\n        timeInSec: currentTime,\n        loopBehavior: initialLoopBehavior\n    });\n    await ensureFrameBeforeAndAfter({\n        timeInSec: currentTime,\n        loopBehavior: initialLoopBehavior\n    });\n    const getFrame = async (timeInSec, loopBehavior)=>{\n        if (durationFound !== null && timeInSec > durationFound && loopBehavior === \"clear-after-finish\") {\n            return null;\n        }\n        const actualTimeInSec = getActualTime({\n            loopBehavior,\n            durationFound,\n            timeInSec\n        });\n        await ensureFrameBeforeAndAfter({\n            timeInSec: actualTimeInSec,\n            loopBehavior\n        });\n        const itemsInCache = cache.filter((c)=>c.frame);\n        const closest = itemsInCache.reduce((a, b)=>{\n            const aDiff = Math.abs(a.timeInSeconds - actualTimeInSec);\n            const bDiff = Math.abs(b.timeInSeconds - actualTimeInSec);\n            return aDiff < bDiff ? a : b;\n        });\n        if (!closest.frame) {\n            throw new Error(\"No frame found\");\n        }\n        return closest;\n    };\n    return {\n        getFrame,\n        frameCount: selectedTrack.frameCount\n    };\n};\n// src/animated-image/resolve-image-source.tsx\nvar resolveAnimatedImageSource = (src)=>{\n    if (true) {\n        return src;\n    }\n    return new URL(src, window.origin).href;\n};\n// src/animated-image/AnimatedImage.tsx\n\nvar AnimatedImage = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ src, width, height, onError, loopBehavior = \"loop\", playbackRate = 1, fit = \"fill\", ...props }, canvasRef)=>{\n    const mountState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isMounted: true\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = mountState;\n        current.isMounted = true;\n        return ()=>{\n            current.isMounted = false;\n        };\n    }, []);\n    const resolvedSrc = resolveAnimatedImageSource(src);\n    const [imageDecoder, setImageDecoder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [decodeHandle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>delayRender(`Rendering <AnimatedImage/> with src=\"${resolvedSrc}\"`));\n    const frame = useCurrentFrame();\n    const { fps } = useVideoConfig();\n    const currentTime = frame / playbackRate / fps;\n    const currentTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentTime);\n    currentTimeRef.current = currentTime;\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(canvasRef, ()=>{\n        const c = ref.current?.getCanvas();\n        if (!c) {\n            throw new Error(\"Canvas ref is not set\");\n        }\n        return c;\n    }, []);\n    const [initialLoopBehavior] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>loopBehavior);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const controller = new AbortController;\n        decodeImage({\n            resolvedSrc,\n            signal: controller.signal,\n            currentTime: currentTimeRef.current,\n            initialLoopBehavior\n        }).then((d)=>{\n            setImageDecoder(d);\n            continueRender(decodeHandle);\n        }).catch((err)=>{\n            if (err.name === \"AbortError\") {\n                continueRender(decodeHandle);\n                return;\n            }\n            if (onError) {\n                onError?.(err);\n                continueRender(decodeHandle);\n            } else {\n                cancelRender(err);\n            }\n        });\n        return ()=>{\n            controller.abort();\n        };\n    }, [\n        resolvedSrc,\n        decodeHandle,\n        onError,\n        initialLoopBehavior\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!imageDecoder) {\n            return;\n        }\n        const delay = delayRender(`Rendering frame at ${currentTime} of <AnimatedImage src=\"${src}\"/>`);\n        imageDecoder.getFrame(currentTime, loopBehavior).then((videoFrame)=>{\n            if (mountState.current.isMounted) {\n                if (videoFrame === null) {\n                    ref.current?.clear();\n                } else {\n                    ref.current?.draw(videoFrame.frame);\n                }\n            }\n            continueRender(delay);\n        }).catch((err)=>{\n            if (onError) {\n                onError(err);\n                continueRender(delay);\n            } else {\n                cancelRender(err);\n            }\n        });\n    }, [\n        currentTime,\n        imageDecoder,\n        loopBehavior,\n        onError,\n        src\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Canvas, {\n        ref,\n        width,\n        height,\n        fit,\n        ...props\n    });\n});\n// src/Artifact.tsx\n\n// src/RenderAssetManager.tsx\n\n// src/validation/validate-artifact.ts\nvar validateArtifactFilename = (filename)=>{\n    if (typeof filename !== \"string\") {\n        throw new TypeError(`The \"filename\" must be a string, but you passed a value of type ${typeof filename}`);\n    }\n    if (filename.trim() === \"\") {\n        throw new Error(\"The `filename` must not be empty\");\n    }\n    if (!filename.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g)) {\n        throw new Error('The `filename` must match \"/^([0-9a-zA-Z-!_.*\\'()/:&$@=;+,?]+)/g\". Use forward slashes only, even on Windows.');\n    }\n};\nvar validateContent = (content)=>{\n    if (typeof content !== \"string\" && !(content instanceof Uint8Array)) {\n        throw new TypeError(`The \"content\" must be a string or Uint8Array, but you passed a value of type ${typeof content}`);\n    }\n    if (typeof content === \"string\" && content.trim() === \"\") {\n        throw new Error(\"The `content` must not be empty\");\n    }\n};\nvar validateRenderAsset = (artifact)=>{\n    if (artifact.type !== \"artifact\") {\n        return;\n    }\n    validateArtifactFilename(artifact.filename);\n    if (artifact.contentType === \"thumbnail\") {\n        return;\n    }\n    validateContent(artifact.content);\n};\n// src/RenderAssetManager.tsx\n\nvar RenderAssetManager = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    registerRenderAsset: ()=>{\n        return;\n    },\n    unregisterRenderAsset: ()=>{\n        return;\n    },\n    renderAssets: []\n});\nvar RenderAssetManagerProvider = ({ children })=>{\n    const [renderAssets, setRenderAssets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const registerRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((renderAsset)=>{\n        validateRenderAsset(renderAsset);\n        setRenderAssets((assets)=>{\n            return [\n                ...assets,\n                renderAsset\n            ];\n        });\n    }, []);\n    const unregisterRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        setRenderAssets((assts)=>{\n            return assts.filter((a)=>a.id !== id);\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (false) {}\n    }, [\n        renderAssets\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            registerRenderAsset,\n            unregisterRenderAsset,\n            renderAssets\n        };\n    }, [\n        renderAssets,\n        registerRenderAsset,\n        unregisterRenderAsset\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n        value: contextValue,\n        children\n    });\n};\n// src/Artifact.tsx\nvar ArtifactThumbnail = Symbol(\"Thumbnail\");\nvar Artifact = ({ filename, content })=>{\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const [env] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>getRemotionEnvironment());\n    const frame = useCurrentFrame();\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>{\n        return String(Math.random());\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!env.isRendering) {\n            return;\n        }\n        if (content instanceof Uint8Array) {\n            registerRenderAsset({\n                type: \"artifact\",\n                id,\n                content: btoa(new TextDecoder(\"utf8\").decode(content)),\n                filename,\n                frame,\n                contentType: \"binary\"\n            });\n        } else if (content === ArtifactThumbnail) {\n            registerRenderAsset({\n                type: \"artifact\",\n                id,\n                filename,\n                frame,\n                contentType: \"thumbnail\"\n            });\n        } else {\n            registerRenderAsset({\n                type: \"artifact\",\n                id,\n                content,\n                filename,\n                frame,\n                contentType: \"text\"\n            });\n        }\n        return ()=>{\n            return unregisterRenderAsset(id);\n        };\n    }, [\n        content,\n        env.isRendering,\n        filename,\n        frame,\n        id,\n        registerRenderAsset,\n        unregisterRenderAsset\n    ]);\n    return null;\n};\nArtifact.Thumbnail = ArtifactThumbnail;\n// src/audio/Audio.tsx\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc)=>{\n    if (true) {\n        return relativeSrc;\n    }\n    return new URL(relativeSrc, window.origin).href;\n};\n// src/calculate-loop.ts\nvar calculateLoopDuration = ({ endAt, mediaDuration, playbackRate, startFrom })=>{\n    let duration = mediaDuration;\n    if (typeof endAt !== \"undefined\") {\n        duration = endAt;\n    }\n    if (typeof startFrom !== \"undefined\") {\n        duration -= startFrom;\n    }\n    const actualDuration = duration / playbackRate;\n    return Math.floor(actualDuration);\n};\n// src/loop/index.tsx\n\n\nvar LoopContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useLoop = ()=>{\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LoopContext);\n};\nvar Loop = ({ durationInFrames, times = Infinity, children, name, ...props })=>{\n    const currentFrame = useCurrentFrame();\n    const { durationInFrames: compDuration } = useVideoConfig();\n    validateDurationInFrames(durationInFrames, {\n        component: \"of the <Loop /> component\",\n        allowFloats: true\n    });\n    if (typeof times !== \"number\") {\n        throw new TypeError(`You passed to \"times\" an argument of type ${typeof times}, but it must be a number.`);\n    }\n    if (times !== Infinity && times % 1 !== 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be an integer, but got ${times}.`);\n    }\n    if (times < 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be at least 0, but got ${times}`);\n    }\n    const maxTimes = Math.ceil(compDuration / durationInFrames);\n    const actualTimes = Math.min(maxTimes, times);\n    const style = props.layout === \"none\" ? undefined : props.style;\n    const maxFrame = durationInFrames * (actualTimes - 1);\n    const iteration = Math.floor(currentFrame / durationInFrames);\n    const start = iteration * durationInFrames;\n    const from = Math.min(start, maxFrame);\n    const loopDisplay = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            numberOfTimes: actualTimes,\n            startOffset: -from,\n            durationInFrames\n        };\n    }, [\n        actualTimes,\n        durationInFrames,\n        from\n    ]);\n    const loopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            iteration: Math.floor(currentFrame / durationInFrames),\n            durationInFrames\n        };\n    }, [\n        currentFrame,\n        durationInFrames\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LoopContext.Provider, {\n        value: loopContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            durationInFrames,\n            from,\n            name: name ?? \"<Loop>\",\n            _remotionInternalLoopDisplay: loopDisplay,\n            layout: props.layout,\n            style,\n            children\n        })\n    });\n};\nLoop.useLoop = useLoop;\n// src/prefetch.ts\n\n// src/playback-logging.ts\nvar playbackLogging = ({ logLevel, tag, message, mountTime })=>{\n    const tags = [\n        mountTime ? Date.now() - mountTime + \"ms \" : null,\n        tag\n    ].filter(Boolean).join(\" \");\n    Log.trace(logLevel, `[${tags}]`, message);\n};\n// src/prefetch-state.tsx\n\n\nvar PreloadContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar preloads = {};\nvar updaters = [];\nvar setPreloads = (updater)=>{\n    preloads = updater(preloads);\n    updaters.forEach((u)=>u());\n};\nvar PrefetchProvider = ({ children })=>{\n    const [_preloads, _setPreloads] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>preloads);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const updaterFunction = ()=>{\n            _setPreloads(preloads);\n        };\n        updaters.push(updaterFunction);\n        return ()=>{\n            updaters = updaters.filter((u)=>u !== updaterFunction);\n        };\n    }, []);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n        value: _preloads,\n        children\n    });\n};\n// src/prefetch.ts\nvar removeAndGetHashFragment = (src)=>{\n    const hashIndex = src.indexOf(\"#\");\n    if (hashIndex === -1) {\n        return null;\n    }\n    return hashIndex;\n};\nvar getSrcWithoutHash = (src)=>{\n    const hashIndex = removeAndGetHashFragment(src);\n    if (hashIndex === null) {\n        return src;\n    }\n    return src.slice(0, hashIndex);\n};\nvar usePreload = (src)=>{\n    const preloads2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PreloadContext);\n    const hashFragmentIndex = removeAndGetHashFragment(src);\n    const withoutHashFragment = getSrcWithoutHash(src);\n    if (!preloads2[withoutHashFragment]) {\n        return src;\n    }\n    if (hashFragmentIndex !== null) {\n        return preloads2[withoutHashFragment] + src.slice(hashFragmentIndex);\n    }\n    return preloads2[withoutHashFragment];\n};\nvar blobToBase64 = function(blob) {\n    const reader = new FileReader;\n    return new Promise((resolve, reject)=>{\n        reader.onload = function() {\n            const dataUrl = reader.result;\n            resolve(dataUrl);\n        };\n        reader.onerror = (err)=>{\n            return reject(err);\n        };\n        reader.readAsDataURL(blob);\n    });\n};\nvar getBlobFromReader = async ({ reader, contentType, contentLength, onProgress })=>{\n    let receivedLength = 0;\n    const chunks = [];\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        chunks.push(value);\n        receivedLength += value.length;\n        if (onProgress) {\n            onProgress({\n                loadedBytes: receivedLength,\n                totalBytes: contentLength\n            });\n        }\n    }\n    const chunksAll = new Uint8Array(receivedLength);\n    let position = 0;\n    for (const chunk of chunks){\n        chunksAll.set(chunk, position);\n        position += chunk.length;\n    }\n    return new Blob([\n        chunksAll\n    ], {\n        type: contentType ?? undefined\n    });\n};\nvar prefetch = (src, options)=>{\n    const method = options?.method ?? \"blob-url\";\n    const logLevel = options?.logLevel ?? \"info\";\n    const srcWithoutHash = getSrcWithoutHash(src);\n    if (getRemotionEnvironment().isRendering) {\n        return {\n            free: ()=>{\n                return;\n            },\n            waitUntilDone: ()=>Promise.resolve(srcWithoutHash)\n        };\n    }\n    Log.verbose(logLevel, `[prefetch] Starting prefetch ${srcWithoutHash}`);\n    let canceled = false;\n    let objectUrl = null;\n    let resolve = ()=>{\n        return;\n    };\n    let reject = ()=>{\n        return;\n    };\n    const waitUntilDone = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    const controller = new AbortController;\n    let canBeAborted = true;\n    fetch(srcWithoutHash, {\n        signal: controller.signal,\n        credentials: options?.credentials ?? undefined\n    }).then((res)=>{\n        canBeAborted = false;\n        if (canceled) {\n            return null;\n        }\n        if (!res.ok) {\n            throw new Error(`HTTP error, status = ${res.status}`);\n        }\n        const headerContentType = res.headers.get(\"Content-Type\");\n        const contentType = options?.contentType ?? headerContentType;\n        const hasProperContentType = contentType && (contentType.startsWith(\"video/\") || contentType.startsWith(\"audio/\") || contentType.startsWith(\"image/\"));\n        if (!hasProperContentType) {\n            console.warn(`Called prefetch() on ${srcWithoutHash} which returned a \"Content-Type\" of ${headerContentType}. Prefetched content should have a proper content type (video/... or audio/...) or a contentType passed the options of prefetch(). Otherwise, prefetching will not work properly in all browsers.`);\n        }\n        if (!res.body) {\n            throw new Error(`HTTP response of ${srcWithoutHash} has no body`);\n        }\n        const reader = res.body.getReader();\n        return getBlobFromReader({\n            reader,\n            contentType: options?.contentType ?? headerContentType ?? null,\n            contentLength: res.headers.get(\"Content-Length\") ? parseInt(res.headers.get(\"Content-Length\"), 10) : null,\n            onProgress: options?.onProgress\n        });\n    }).then((buf)=>{\n        if (!buf) {\n            return;\n        }\n        const actualBlob = options?.contentType ? new Blob([\n            buf\n        ], {\n            type: options.contentType\n        }) : buf;\n        if (method === \"base64\") {\n            return blobToBase64(actualBlob);\n        }\n        return URL.createObjectURL(actualBlob);\n    }).then((url)=>{\n        if (canceled) {\n            return;\n        }\n        playbackLogging({\n            logLevel,\n            tag: \"prefetch\",\n            message: `Finished prefetch ${srcWithoutHash} with method ${method}`,\n            mountTime: null\n        });\n        objectUrl = url;\n        setPreloads((p)=>({\n                ...p,\n                [srcWithoutHash]: objectUrl\n            }));\n        resolve(objectUrl);\n    }).catch((err)=>{\n        if (err?.message.includes(\"free() called\")) {\n            return;\n        }\n        reject(err);\n    });\n    return {\n        free: ()=>{\n            playbackLogging({\n                logLevel,\n                tag: \"prefetch\",\n                message: `Freeing ${srcWithoutHash}`,\n                mountTime: null\n            });\n            if (objectUrl) {\n                if (method === \"blob-url\") {\n                    URL.revokeObjectURL(objectUrl);\n                }\n                setPreloads((p)=>{\n                    const copy = {\n                        ...p\n                    };\n                    delete copy[srcWithoutHash];\n                    return copy;\n                });\n            } else {\n                canceled = true;\n                if (canBeAborted) {\n                    try {\n                        controller.abort(new Error(\"free() called\"));\n                    } catch  {}\n                }\n            }\n        },\n        waitUntilDone: ()=>{\n            return waitUntilDone;\n        }\n    };\n};\n// src/validate-media-props.ts\nvar validateMediaProps = (props, component)=>{\n    if (typeof props.volume !== \"number\" && typeof props.volume !== \"function\" && typeof props.volume !== \"undefined\") {\n        throw new TypeError(`You have passed a volume of type ${typeof props.volume} to your <${component} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);\n    }\n    if (typeof props.volume === \"number\" && props.volume < 0) {\n        throw new TypeError(`You have passed a volume below 0 to your <${component} /> component. Volume must be between 0 and 1`);\n    }\n    if (typeof props.playbackRate !== \"number\" && typeof props.playbackRate !== \"undefined\") {\n        throw new TypeError(`You have passed a playbackRate of type ${typeof props.playbackRate} to your <${component} /> component. Playback rate must a real number or undefined.`);\n    }\n    if (typeof props.playbackRate === \"number\" && (isNaN(props.playbackRate) || !Number.isFinite(props.playbackRate) || props.playbackRate <= 0)) {\n        throw new TypeError(`You have passed a playbackRate of ${props.playbackRate} to your <${component} /> component. Playback rate must be a real number above 0.`);\n    }\n};\n// src/validate-start-from-props.ts\nvar validateStartFromProps = (startFrom, endAt)=>{\n    if (typeof startFrom !== \"undefined\") {\n        if (typeof startFrom !== \"number\") {\n            throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof startFrom}.`);\n        }\n        if (isNaN(startFrom) || startFrom === Infinity) {\n            throw new TypeError(\"startFrom prop can not be NaN or Infinity.\");\n        }\n        if (startFrom < 0) {\n            throw new TypeError(`startFrom must be greater than equal to 0 instead got ${startFrom}.`);\n        }\n    }\n    if (typeof endAt !== \"undefined\") {\n        if (typeof endAt !== \"number\") {\n            throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof endAt}.`);\n        }\n        if (isNaN(endAt)) {\n            throw new TypeError(\"endAt prop can not be NaN.\");\n        }\n        if (endAt <= 0) {\n            throw new TypeError(`endAt must be a positive number, instead got ${endAt}.`);\n        }\n    }\n    if (endAt < startFrom) {\n        throw new TypeError(\"endAt prop must be greater than startFrom prop.\");\n    }\n};\n// src/video/duration-state.tsx\n\n\nvar durationReducer = (state, action)=>{\n    switch(action.type){\n        case \"got-duration\":\n            {\n                const absoluteSrc = getAbsoluteSrc(action.src);\n                if (state[absoluteSrc] === action.durationInSeconds) {\n                    return state;\n                }\n                return {\n                    ...state,\n                    [absoluteSrc]: action.durationInSeconds\n                };\n            }\n        default:\n            return state;\n    }\n};\nvar DurationsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    durations: {},\n    setDurations: ()=>{\n        throw new Error(\"context missing\");\n    }\n});\nvar DurationsContextProvider = ({ children })=>{\n    const [durations, setDurations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(durationReducer, {});\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            durations,\n            setDurations\n        };\n    }, [\n        durations\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContext.Provider, {\n        value,\n        children\n    });\n};\n// src/audio/AudioForPreview.tsx\n\n// src/log-level-context.tsx\n\n\nvar LogLevelContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    logLevel: \"info\",\n    mountTime: 0\n});\nvar useLogLevel = ()=>{\n    const { logLevel } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n    if (logLevel === null) {\n        throw new Error(\"useLogLevel must be used within a LogLevelProvider\");\n    }\n    return logLevel;\n};\nvar useMountTime = ()=>{\n    const { mountTime } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n    if (mountTime === null) {\n        throw new Error(\"useMountTime must be used within a LogLevelProvider\");\n    }\n    return mountTime;\n};\n// src/random.ts\nfunction mulberry32(a) {\n    let t = a + 1831565813;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n    let i = 0;\n    let chr = 0;\n    let hash = 0;\n    for(i = 0; i < str.length; i++){\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0;\n    }\n    return hash;\n}\nvar random = (seed, dummy)=>{\n    if (dummy !== undefined) {\n        throw new TypeError(\"random() takes only one argument\");\n    }\n    if (seed === null) {\n        return Math.random();\n    }\n    if (typeof seed === \"string\") {\n        return mulberry32(hashCode(seed));\n    }\n    if (typeof seed === \"number\") {\n        return mulberry32(seed * 10000000000);\n    }\n    throw new Error(\"random() argument must be a number or a string\");\n};\n// src/use-amplification.ts\n\nvar warned = false;\nvar warnOnce = (logLevel)=>{\n    if (warned) {\n        return;\n    }\n    warned = true;\n    Log.warn(logLevel, \"AudioContext is not supported in this browser\");\n};\nvar getShouldAmplify = (volume)=>{\n    return volume > 1;\n};\nvar useAmplification = ({ mediaRef, volume, logLevel })=>{\n    const shouldAmplify = getShouldAmplify(volume);\n    const audioStuffRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const currentVolumeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(volume);\n    currentVolumeRef.current = volume;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!shouldAmplify) {\n            return;\n        }\n        if (!AudioContext) {\n            warnOnce(logLevel);\n            return;\n        }\n        if (!mediaRef.current) {\n            return;\n        }\n        if (audioStuffRef.current) {\n            return;\n        }\n        const audioContext = new AudioContext({\n            latencyHint: \"interactive\"\n        });\n        const source = new MediaElementAudioSourceNode(audioContext, {\n            mediaElement: mediaRef.current\n        });\n        const gainNode = new GainNode(audioContext, {\n            gain: Math.max(currentVolumeRef.current, 1)\n        });\n        audioStuffRef.current = {\n            gainNode,\n            source,\n            audioContext\n        };\n        source.connect(gainNode);\n        gainNode.connect(audioContext.destination);\n        Log.trace(logLevel, `Starting to amplify ${mediaRef.current?.src}. Gain = ${currentVolumeRef.current}`);\n    }, [\n        logLevel,\n        mediaRef,\n        shouldAmplify\n    ]);\n    if (audioStuffRef.current) {\n        const valueToSet = Math.max(volume, 1);\n        if (audioStuffRef.current.gainNode.gain.value !== valueToSet) {\n            audioStuffRef.current.gainNode.gain.value = valueToSet;\n            Log.trace(logLevel, `Setting gain to ${valueToSet} for ${mediaRef.current?.src}`);\n        }\n    }\n    return audioStuffRef;\n};\n// src/use-media-in-timeline.ts\n\n// src/audio/use-audio-frame.ts\n\nvar useMediaStartsAt = ()=>{\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const startsAt = Math.min(0, parentSequence?.relativeFrom ?? 0);\n    return startsAt;\n};\nvar useFrameForVolumeProp = (behavior)=>{\n    const loop = Loop.useLoop();\n    const frame = useCurrentFrame();\n    const startsAt = useMediaStartsAt();\n    if (behavior === \"repeat\" || loop === null) {\n        return frame + startsAt;\n    }\n    return frame + startsAt + loop.durationInFrames * loop.iteration;\n};\n// src/get-asset-file-name.ts\nvar getAssetDisplayName = (filename)=>{\n    if (/data:|blob:/.test(filename.substring(0, 5))) {\n        return \"Data URL\";\n    }\n    const splitted = filename.split(\"/\").map((s)=>s.split(\"\\\\\")).flat(1);\n    return splitted[splitted.length - 1];\n};\n// src/play-and-handle-not-allowed-error.ts\nvar playAndHandleNotAllowedError = ({ mediaRef, mediaType, onAutoPlayError, logLevel, mountTime, reason })=>{\n    const { current } = mediaRef;\n    if (!current) {\n        return;\n    }\n    playbackLogging({\n        logLevel,\n        tag: \"play\",\n        message: `Attempting to play ${current.src}. Reason: ${reason}`,\n        mountTime\n    });\n    const prom = current.play();\n    if (!prom.catch) {\n        return;\n    }\n    prom.catch((err)=>{\n        if (!current) {\n            return;\n        }\n        if (err.message.includes(\"request was interrupted by a call to pause\")) {\n            return;\n        }\n        if (err.message.includes(\"The operation was aborted.\")) {\n            return;\n        }\n        if (err.message.includes(\"The fetching process for the media resource was aborted by the user agent\")) {\n            return;\n        }\n        if (err.message.includes(\"request was interrupted by a new load request\")) {\n            return;\n        }\n        if (err.message.includes(\"because the media was removed from the document\")) {\n            return;\n        }\n        if (err.message.includes(\"user didn't interact with the document\") && current.muted) {\n            return;\n        }\n        console.log(`Could not play ${mediaType} due to following error: `, err);\n        if (!current.muted) {\n            if (onAutoPlayError) {\n                onAutoPlayError();\n                return;\n            }\n            console.log(`The video will be muted and we'll retry playing it.`);\n            if (mediaType === \"video\" && getRemotionEnvironment().isPlayer) {\n                console.log(\"Use onAutoPlayError() to handle this error yourself.\");\n            }\n            current.muted = true;\n            current.play();\n        }\n    });\n};\n// src/volume-prop.ts\nvar evaluateVolume = ({ frame, volume, mediaVolume = 1 })=>{\n    if (typeof volume === \"number\") {\n        return volume * mediaVolume;\n    }\n    if (typeof volume === \"undefined\") {\n        return Number(mediaVolume);\n    }\n    const evaluated = volume(frame) * mediaVolume;\n    if (typeof evaluated !== \"number\") {\n        throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof evaluated} for frame ${frame}`);\n    }\n    if (Number.isNaN(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${frame}.`);\n    }\n    if (!Number.isFinite(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${frame}.`);\n    }\n    return Math.max(0, evaluated);\n};\n// src/use-media-in-timeline.ts\nvar didWarn = {};\nvar warnOnce2 = (message)=>{\n    if (didWarn[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn[message] = true;\n};\nvar useMediaInTimeline = ({ volume, mediaVolume, mediaRef, src, mediaType, playbackRate, displayName, id, stack, showInTimeline, premountDisplay, onAutoPlayError, isPremounting })=>{\n    const videoConfig = useVideoConfig();\n    const { rootId, audioAndVideoTags } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const actualFrom = parentSequence ? parentSequence.relativeFrom + parentSequence.cumulatedFrom : 0;\n    const { imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const startsAt = useMediaStartsAt();\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const [initialVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>volume);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const nonce = useNonce();\n    const duration = parentSequence ? Math.min(parentSequence.durationInFrames, videoConfig.durationInFrames) : videoConfig.durationInFrames;\n    const doesVolumeChange = typeof volume === \"function\";\n    const volumes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof volume === \"number\") {\n            return volume;\n        }\n        return new Array(Math.floor(Math.max(0, duration + startsAt))).fill(true).map((_, i)=>{\n            return evaluateVolume({\n                frame: i + startsAt,\n                volume,\n                mediaVolume\n            });\n        }).join(\",\");\n    }, [\n        duration,\n        startsAt,\n        volume,\n        mediaVolume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (typeof volume === \"number\" && volume !== initialVolume) {\n            warnOnce2(`Remotion: The ${mediaType} with src ${src} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/audio/volume`);\n        }\n    }, [\n        initialVolume,\n        mediaType,\n        src,\n        volume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!mediaRef.current) {\n            return;\n        }\n        if (!src) {\n            throw new Error(\"No src passed\");\n        }\n        if (!getRemotionEnvironment().isStudio && window.process?.env?.NODE_ENV !== \"test\") {\n            return;\n        }\n        if (!showInTimeline) {\n            return;\n        }\n        registerSequence({\n            type: mediaType,\n            src,\n            id,\n            duration,\n            from: 0,\n            parent: parentSequence?.id ?? null,\n            displayName: displayName ?? getAssetDisplayName(src),\n            rootId,\n            volume: volumes,\n            showInTimeline: true,\n            nonce,\n            startMediaFrom: 0 - startsAt,\n            doesVolumeChange,\n            loopDisplay: undefined,\n            playbackRate,\n            stack,\n            premountDisplay\n        });\n        return ()=>{\n            unregisterSequence(id);\n        };\n    }, [\n        actualFrom,\n        duration,\n        id,\n        parentSequence,\n        src,\n        registerSequence,\n        rootId,\n        unregisterSequence,\n        videoConfig,\n        volumes,\n        doesVolumeChange,\n        nonce,\n        mediaRef,\n        mediaType,\n        startsAt,\n        playbackRate,\n        displayName,\n        stack,\n        showInTimeline,\n        premountDisplay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const tag = {\n            id,\n            play: (reason)=>{\n                if (!imperativePlaying.current) {\n                    return;\n                }\n                if (isPremounting) {\n                    return;\n                }\n                return playAndHandleNotAllowedError({\n                    mediaRef,\n                    mediaType,\n                    onAutoPlayError,\n                    logLevel,\n                    mountTime,\n                    reason\n                });\n            }\n        };\n        audioAndVideoTags.current.push(tag);\n        return ()=>{\n            audioAndVideoTags.current = audioAndVideoTags.current.filter((a)=>a.id !== id);\n        };\n    }, [\n        audioAndVideoTags,\n        id,\n        mediaRef,\n        mediaType,\n        onAutoPlayError,\n        imperativePlaying,\n        isPremounting,\n        logLevel,\n        mountTime\n    ]);\n};\n// src/use-media-playback.ts\n\n// src/buffer-until-first-frame.ts\n\n// src/use-buffer-state.ts\n\n// src/buffering.tsx\n\n\nvar useBufferManager = (logLevel, mountTime)=>{\n    const [blocks, setBlocks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [onBufferingCallbacks, setOnBufferingCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [onResumeCallbacks, setOnResumeCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const addBlock = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((block)=>{\n        setBlocks((b)=>[\n                ...b,\n                block\n            ]);\n        return {\n            unblock: ()=>{\n                setBlocks((b)=>{\n                    const newArr = b.filter((bx)=>bx !== block);\n                    if (newArr.length === b.length) {\n                        return b;\n                    }\n                    return newArr;\n                });\n            }\n        };\n    }, []);\n    const listenForBuffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n        setOnBufferingCallbacks((c)=>[\n                ...c,\n                callback\n            ]);\n        return {\n            remove: ()=>{\n                setOnBufferingCallbacks((c)=>c.filter((cb)=>cb !== callback));\n            }\n        };\n    }, []);\n    const listenForResume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n        setOnResumeCallbacks((c)=>[\n                ...c,\n                callback\n            ]);\n        return {\n            remove: ()=>{\n                setOnResumeCallbacks((c)=>c.filter((cb)=>cb !== callback));\n            }\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (blocks.length > 0) {\n            onBufferingCallbacks.forEach((c)=>c());\n            playbackLogging({\n                logLevel,\n                message: \"Player is entering buffer state\",\n                mountTime,\n                tag: \"player\"\n            });\n        }\n    }, [\n        blocks\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (blocks.length === 0) {\n            onResumeCallbacks.forEach((c)=>c());\n            playbackLogging({\n                logLevel,\n                message: \"Player is exiting buffer state\",\n                mountTime,\n                tag: \"player\"\n            });\n        }\n    }, [\n        blocks\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            addBlock,\n            listenForBuffering,\n            listenForResume,\n            buffering\n        };\n    }, [\n        addBlock,\n        buffering,\n        listenForBuffering,\n        listenForResume\n    ]);\n};\nvar BufferingContextReact = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar BufferingProvider = ({ children })=>{\n    const { logLevel, mountTime } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LogLevelContext);\n    const bufferManager = useBufferManager(logLevel ?? \"info\", mountTime);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n        value: bufferManager,\n        children\n    });\n};\nvar useIsPlayerBuffering = (bufferManager)=>{\n    const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(bufferManager.buffering.current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const onBuffer = ()=>{\n            setIsBuffering(true);\n        };\n        const onResume = ()=>{\n            setIsBuffering(false);\n        };\n        bufferManager.listenForBuffering(onBuffer);\n        bufferManager.listenForResume(onResume);\n        return ()=>{\n            bufferManager.listenForBuffering(()=>{\n                return;\n            });\n            bufferManager.listenForResume(()=>{\n                return;\n            });\n        };\n    }, [\n        bufferManager\n    ]);\n    return isBuffering;\n};\n// src/use-buffer-state.ts\nvar useBufferState = ()=>{\n    const buffer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n    const addBlock = buffer ? buffer.addBlock : null;\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            delayPlayback: ()=>{\n                if (!addBlock) {\n                    throw new Error(\"Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state\");\n                }\n                const { unblock } = addBlock({\n                    id: String(Math.random())\n                });\n                return {\n                    unblock\n                };\n            }\n        }), [\n        addBlock\n    ]);\n};\n// src/buffer-until-first-frame.ts\nvar isSafariWebkit = ()=>{\n    const isSafari = /^((?!chrome|android).)*safari/i.test(window.navigator.userAgent);\n    return isSafari;\n};\nvar useBufferUntilFirstFrame = ({ mediaRef, mediaType, onVariableFpsVideoDetected, pauseWhenBuffering, logLevel, mountTime })=>{\n    const bufferingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const { delayPlayback } = useBufferState();\n    const bufferUntilFirstFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((requestedTime)=>{\n        if (mediaType !== \"video\") {\n            return;\n        }\n        if (!pauseWhenBuffering) {\n            return;\n        }\n        const current = mediaRef.current;\n        if (!current) {\n            return;\n        }\n        if (current.readyState >= current.HAVE_ENOUGH_DATA && !isSafariWebkit()) {\n            playbackLogging({\n                logLevel,\n                message: `Not using buffer until first frame, because readyState is ${current.readyState} and is not Safari`,\n                mountTime,\n                tag: \"buffer\"\n            });\n            return;\n        }\n        if (!current.requestVideoFrameCallback) {\n            playbackLogging({\n                logLevel,\n                message: `Not using buffer until first frame, because requestVideoFrameCallback is not supported`,\n                mountTime,\n                tag: \"buffer\"\n            });\n            return;\n        }\n        bufferingRef.current = true;\n        playbackLogging({\n            logLevel,\n            message: `Buffering ${mediaRef.current?.src} until the first frame is received`,\n            mountTime,\n            tag: \"buffer\"\n        });\n        const playback = delayPlayback();\n        const unblock = ()=>{\n            playback.unblock();\n            current.removeEventListener(\"ended\", unblock, {\n                once: true\n            });\n            current.removeEventListener(\"pause\", unblock, {\n                once: true\n            });\n            bufferingRef.current = false;\n        };\n        const onEndedOrPauseOrCanPlay = ()=>{\n            unblock();\n        };\n        current.requestVideoFrameCallback((_, info)=>{\n            const differenceFromRequested = Math.abs(info.mediaTime - requestedTime);\n            if (differenceFromRequested > 0.5) {\n                onVariableFpsVideoDetected();\n            }\n            unblock();\n        });\n        current.addEventListener(\"ended\", onEndedOrPauseOrCanPlay, {\n            once: true\n        });\n        current.addEventListener(\"pause\", onEndedOrPauseOrCanPlay, {\n            once: true\n        });\n        current.addEventListener(\"canplay\", onEndedOrPauseOrCanPlay, {\n            once: true\n        });\n    }, [\n        delayPlayback,\n        logLevel,\n        mediaRef,\n        mediaType,\n        mountTime,\n        onVariableFpsVideoDetected,\n        pauseWhenBuffering\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            isBuffering: ()=>bufferingRef.current,\n            bufferUntilFirstFrame\n        };\n    }, [\n        bufferUntilFirstFrame\n    ]);\n};\n// src/video/video-fragment.ts\n\nvar toSeconds = (time, fps)=>{\n    return Math.round(time / fps * 100) / 100;\n};\nvar isIosSafari = ()=>{\n    if (true) {\n        return false;\n    }\n    const isIpadIPodIPhone = /iP(ad|od|hone)/i.test(window.navigator.userAgent);\n    const isAppleWebKit = /AppleWebKit/.test(window.navigator.userAgent);\n    return isIpadIPodIPhone && isAppleWebKit;\n};\nvar isIOSSafariAndBlob = (actualSrc)=>{\n    return isIosSafari() && actualSrc.startsWith(\"blob:\");\n};\nvar getVideoFragmentStart = ({ actualFrom, fps })=>{\n    return toSeconds(Math.max(0, -actualFrom), fps);\n};\nvar getVideoFragmentEnd = ({ duration, fps })=>{\n    return toSeconds(duration, fps);\n};\nvar appendVideoFragment = ({ actualSrc, actualFrom, duration, fps })=>{\n    if (isIOSSafariAndBlob(actualSrc)) {\n        return actualSrc;\n    }\n    if (actualSrc.startsWith(\"data:\")) {\n        return actualSrc;\n    }\n    const existingHash = Boolean(new URL(actualSrc, ( null) ?? \"http://localhost:3000\").hash);\n    if (existingHash) {\n        return actualSrc;\n    }\n    if (!Number.isFinite(actualFrom)) {\n        return actualSrc;\n    }\n    const withStartHash = `${actualSrc}#t=${getVideoFragmentStart({\n        actualFrom,\n        fps\n    })}`;\n    if (!Number.isFinite(duration)) {\n        return withStartHash;\n    }\n    return `${withStartHash},${getVideoFragmentEnd({\n        duration,\n        fps\n    })}`;\n};\nvar isSubsetOfDuration = ({ prevStartFrom, newStartFrom, prevDuration, newDuration, fps })=>{\n    const previousFrom = getVideoFragmentStart({\n        actualFrom: prevStartFrom,\n        fps\n    });\n    const newFrom = getVideoFragmentStart({\n        actualFrom: newStartFrom,\n        fps\n    });\n    const previousEnd = getVideoFragmentEnd({\n        duration: prevDuration,\n        fps\n    });\n    const newEnd = getVideoFragmentEnd({\n        duration: newDuration,\n        fps\n    });\n    if (newFrom < previousFrom) {\n        return false;\n    }\n    if (newEnd > previousEnd) {\n        return false;\n    }\n    return true;\n};\nvar useAppendVideoFragment = ({ actualSrc: initialActualSrc, actualFrom: initialActualFrom, duration: initialDuration, fps })=>{\n    const actualFromRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualFrom);\n    const actualDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialDuration);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualSrc);\n    if (!isSubsetOfDuration({\n        prevStartFrom: actualFromRef.current,\n        newStartFrom: initialActualFrom,\n        prevDuration: actualDuration.current,\n        newDuration: initialDuration,\n        fps\n    }) || initialActualSrc !== actualSrc.current) {\n        actualFromRef.current = initialActualFrom;\n        actualDuration.current = initialDuration;\n        actualSrc.current = initialActualSrc;\n    }\n    const appended = appendVideoFragment({\n        actualSrc: actualSrc.current,\n        actualFrom: actualFromRef.current,\n        duration: actualDuration.current,\n        fps\n    });\n    return appended;\n};\n// src/seek.ts\nvar seek = ({ mediaRef, time, logLevel, why, mountTime })=>{\n    const timeToSet = isIosSafari() ? Number(time.toFixed(1)) : time;\n    playbackLogging({\n        logLevel,\n        tag: \"seek\",\n        message: `Seeking from ${mediaRef.currentTime} to ${timeToSet}. src= ${mediaRef.src} Reason: ${why}`,\n        mountTime\n    });\n    mediaRef.currentTime = timeToSet;\n    return timeToSet;\n};\n// src/use-media-buffering.ts\n\nvar useMediaBuffering = ({ element, shouldBuffer, isPremounting, logLevel, mountTime })=>{\n    const buffer = useBufferState();\n    const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let cleanupFns = [];\n        const { current } = element;\n        if (!current) {\n            return;\n        }\n        if (!shouldBuffer) {\n            return;\n        }\n        if (isPremounting) {\n            if (current.readyState < current.HAVE_FUTURE_DATA) {\n                if (!navigator.userAgent.includes(\"Firefox/\")) {\n                    playbackLogging({\n                        logLevel,\n                        message: `Calling .load() on ${current.src} because readyState is ${current.readyState} and it is not Firefox. Element is premounted`,\n                        tag: \"load\",\n                        mountTime\n                    });\n                    current.load();\n                }\n            }\n            return;\n        }\n        const cleanup = (reason)=>{\n            let didDoSomething = false;\n            cleanupFns.forEach((fn)=>{\n                fn(reason);\n                didDoSomething = true;\n            });\n            cleanupFns = [];\n            setIsBuffering((previous)=>{\n                if (previous) {\n                    didDoSomething = true;\n                }\n                return false;\n            });\n            if (didDoSomething) {\n                playbackLogging({\n                    logLevel,\n                    message: `Unmarking as buffering: ${current.src}. Reason: ${reason}`,\n                    tag: \"buffer\",\n                    mountTime\n                });\n            }\n        };\n        const blockMedia = (reason)=>{\n            setIsBuffering(true);\n            playbackLogging({\n                logLevel,\n                message: `Marking as buffering: ${current.src}. Reason: ${reason}`,\n                tag: \"buffer\",\n                mountTime\n            });\n            const { unblock } = buffer.delayPlayback();\n            const onCanPlay = ()=>{\n                cleanup('\"canplay\" was fired');\n                init();\n            };\n            const onError = ()=>{\n                cleanup('\"error\" event was occurred');\n                init();\n            };\n            current.addEventListener(\"canplay\", onCanPlay, {\n                once: true\n            });\n            cleanupFns.push(()=>{\n                current.removeEventListener(\"canplay\", onCanPlay);\n            });\n            current.addEventListener(\"error\", onError, {\n                once: true\n            });\n            cleanupFns.push(()=>{\n                current.removeEventListener(\"error\", onError);\n            });\n            cleanupFns.push((cleanupReason)=>{\n                playbackLogging({\n                    logLevel,\n                    message: `Unblocking ${current.src} from buffer. Reason: ${cleanupReason}`,\n                    tag: \"buffer\",\n                    mountTime\n                });\n                unblock();\n            });\n        };\n        const init = ()=>{\n            if (current.readyState < current.HAVE_FUTURE_DATA) {\n                blockMedia(`readyState is ${current.readyState}, which is less than HAVE_FUTURE_DATA`);\n                if (!navigator.userAgent.includes(\"Firefox/\")) {\n                    playbackLogging({\n                        logLevel,\n                        message: `Calling .load() on ${current.src} because readyState is ${current.readyState} and it is not Firefox.`,\n                        tag: \"load\",\n                        mountTime\n                    });\n                    current.load();\n                }\n            } else {\n                const onWaiting = ()=>{\n                    blockMedia('\"waiting\" event was fired');\n                };\n                current.addEventListener(\"waiting\", onWaiting);\n                cleanupFns.push(()=>{\n                    current.removeEventListener(\"waiting\", onWaiting);\n                });\n            }\n        };\n        init();\n        return ()=>{\n            cleanup(\"element was unmounted or prop changed\");\n        };\n    }, [\n        buffer,\n        element,\n        isPremounting,\n        logLevel,\n        shouldBuffer,\n        mountTime\n    ]);\n    return isBuffering;\n};\n// src/use-request-video-callback-time.ts\n\nvar useRequestVideoCallbackTime = ({ mediaRef, mediaType, lastSeek, onVariableFpsVideoDetected })=>{\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = mediaRef;\n        if (current) {\n            currentTime.current = current.currentTime;\n        } else {\n            currentTime.current = null;\n            return;\n        }\n        if (mediaType !== \"video\") {\n            currentTime.current = null;\n            return;\n        }\n        const videoTag = current;\n        if (!videoTag.requestVideoFrameCallback) {\n            return;\n        }\n        let cancel = ()=>{\n            return;\n        };\n        const request = ()=>{\n            if (!videoTag) {\n                return;\n            }\n            const cb = videoTag.requestVideoFrameCallback((_, info)=>{\n                if (currentTime.current !== null) {\n                    const difference = Math.abs(currentTime.current - info.mediaTime);\n                    const differenceToLastSeek = Math.abs(lastSeek.current === null ? Infinity : info.mediaTime - lastSeek.current);\n                    if (difference > 0.5 && differenceToLastSeek > 0.5 && info.mediaTime > currentTime.current) {\n                        onVariableFpsVideoDetected();\n                    }\n                }\n                currentTime.current = info.mediaTime;\n                request();\n            });\n            cancel = ()=>{\n                videoTag.cancelVideoFrameCallback(cb);\n                cancel = ()=>{\n                    return;\n                };\n            };\n        };\n        request();\n        return ()=>{\n            cancel();\n        };\n    }, [\n        lastSeek,\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected\n    ]);\n    return currentTime;\n};\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n    const { extrapolateLeft, extrapolateRight, easing } = options;\n    let result = input;\n    const [inputMin, inputMax] = inputRange;\n    const [outputMin, outputMax] = outputRange;\n    if (result < inputMin) {\n        if (extrapolateLeft === \"identity\") {\n            return result;\n        }\n        if (extrapolateLeft === \"clamp\") {\n            result = inputMin;\n        } else if (extrapolateLeft === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateLeft === \"extend\") {}\n    }\n    if (result > inputMax) {\n        if (extrapolateRight === \"identity\") {\n            return result;\n        }\n        if (extrapolateRight === \"clamp\") {\n            result = inputMax;\n        } else if (extrapolateRight === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateRight === \"extend\") {}\n    }\n    if (outputMin === outputMax) {\n        return outputMin;\n    }\n    result = (result - inputMin) / (inputMax - inputMin);\n    result = easing(result);\n    result = result * (outputMax - outputMin) + outputMin;\n    return result;\n}\nfunction findRange(input, inputRange) {\n    let i;\n    for(i = 1; i < inputRange.length - 1; ++i){\n        if (inputRange[i] >= input) {\n            break;\n        }\n    }\n    return i - 1;\n}\nfunction checkValidInputRange(arr) {\n    for(let i = 1; i < arr.length; ++i){\n        if (!(arr[i] > arr[i - 1])) {\n            throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction checkInfiniteRange(name, arr) {\n    if (arr.length < 2) {\n        throw new Error(name + \" must have at least 2 elements\");\n    }\n    for (const element of arr){\n        if (typeof element !== \"number\") {\n            throw new Error(`${name} must contain only numbers`);\n        }\n        if (!Number.isFinite(element)) {\n            throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n    if (typeof input === \"undefined\") {\n        throw new Error(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new Error(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new Error(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n    }\n    checkInfiniteRange(\"inputRange\", inputRange);\n    checkInfiniteRange(\"outputRange\", outputRange);\n    checkValidInputRange(inputRange);\n    const easing = options?.easing ?? ((num)=>num);\n    let extrapolateLeft = \"extend\";\n    if (options?.extrapolateLeft !== undefined) {\n        extrapolateLeft = options.extrapolateLeft;\n    }\n    let extrapolateRight = \"extend\";\n    if (options?.extrapolateRight !== undefined) {\n        extrapolateRight = options.extrapolateRight;\n    }\n    if (typeof input !== \"number\") {\n        throw new TypeError(\"Cannot interpolate an input which is not a number\");\n    }\n    const range = findRange(input, inputRange);\n    return interpolateFunction(input, [\n        inputRange[range],\n        inputRange[range + 1]\n    ], [\n        outputRange[range],\n        outputRange[range + 1]\n    ], {\n        easing,\n        extrapolateLeft,\n        extrapolateRight\n    });\n}\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({ frame, playbackRate, startFrom })=>{\n    return interpolate(frame, [\n        -1,\n        startFrom,\n        startFrom + 1\n    ], [\n        -1,\n        startFrom,\n        startFrom + playbackRate\n    ]);\n};\nvar getMediaTime = ({ fps, frame, playbackRate, startFrom })=>{\n    const expectedFrame = getExpectedMediaFrameUncorrected({\n        frame,\n        playbackRate,\n        startFrom\n    });\n    const msPerFrame = 1000 / fps;\n    return expectedFrame * msPerFrame / 1000;\n};\n// src/warn-about-non-seekable-media.ts\nvar alreadyWarned = {};\nvar warnAboutNonSeekableMedia = (ref, type)=>{\n    if (ref === null) {\n        return;\n    }\n    if (ref.seekable.length === 0) {\n        return;\n    }\n    if (ref.seekable.length > 1) {\n        return;\n    }\n    if (alreadyWarned[ref.src]) {\n        return;\n    }\n    const range = {\n        start: ref.seekable.start(0),\n        end: ref.seekable.end(0)\n    };\n    if (range.start === 0 && range.end === 0) {\n        const msg = [\n            `The media ${ref.src} cannot be seeked. This could be one of few reasons:`,\n            \"1) The media resource was replaced while the video is playing but it was not loaded yet.\",\n            \"2) The media does not support seeking.\",\n            \"3) The media was loaded with security headers prventing it from being included.\",\n            \"Please see https://remotion.dev/docs/non-seekable-media for assistance.\"\n        ].join(`\n`);\n        if (type === \"console-error\") {\n            console.error(msg);\n        } else if (type === \"console-warning\") {\n            console.warn(`The media ${ref.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);\n        } else {\n            throw new Error(msg);\n        }\n        alreadyWarned[ref.src] = true;\n    }\n};\n// src/use-media-playback.ts\nvar useMediaPlayback = ({ mediaRef, src, mediaType, playbackRate: localPlaybackRate, onlyWarnForMediaSeekingError, acceptableTimeshift, pauseWhenBuffering, isPremounting, onAutoPlayError, userPreferredVolume })=>{\n    const { playbackRate: globalPlaybackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const frame = useCurrentFrame();\n    const absoluteFrame = useTimelinePosition();\n    const [playing] = usePlayingState();\n    const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n    const { fps } = useVideoConfig();\n    const mediaStartsAt = useMediaStartsAt();\n    const lastSeekDueToShift = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const lastSeek = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    if (!buffering) {\n        throw new Error(\"useMediaPlayback must be used inside a <BufferingContext>\");\n    }\n    const isVariableFpsVideoMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const onVariableFpsVideoDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!src) {\n            return;\n        }\n        Log.verbose(logLevel, `Detected ${src} as a variable FPS video. Disabling buffering while seeking.`);\n        isVariableFpsVideoMap.current[src] = true;\n    }, [\n        logLevel,\n        src\n    ]);\n    const currentTime = useRequestVideoCallbackTime({\n        mediaRef,\n        mediaType,\n        lastSeek,\n        onVariableFpsVideoDetected\n    });\n    const desiredUnclampedTime = getMediaTime({\n        frame,\n        playbackRate: localPlaybackRate,\n        startFrom: -mediaStartsAt,\n        fps\n    });\n    const isMediaTagBuffering = useMediaBuffering({\n        element: mediaRef,\n        shouldBuffer: pauseWhenBuffering,\n        isPremounting,\n        logLevel,\n        mountTime\n    });\n    const { bufferUntilFirstFrame, isBuffering } = useBufferUntilFirstFrame({\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected,\n        pauseWhenBuffering,\n        logLevel,\n        mountTime\n    });\n    const playbackRate = localPlaybackRate * globalPlaybackRate;\n    const acceptableTimeShiftButLessThanDuration = (()=>{\n        const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK = 0.45;\n        const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION = DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK + 0.2;\n        const defaultAcceptableTimeshift = getShouldAmplify(userPreferredVolume) ? DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION : DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK;\n        if (mediaRef.current?.duration) {\n            return Math.min(mediaRef.current.duration, acceptableTimeshift ?? defaultAcceptableTimeshift);\n        }\n        return acceptableTimeshift ?? defaultAcceptableTimeshift;\n    })();\n    const isPlayerBuffering = useIsPlayerBuffering(buffering);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (mediaRef.current?.paused) {\n            return;\n        }\n        if (!playing) {\n            playbackLogging({\n                logLevel,\n                tag: \"pause\",\n                message: `Pausing ${mediaRef.current?.src} because ${isPremounting ? \"media is premounting\" : \"Player is not playing\"}`,\n                mountTime\n            });\n            mediaRef.current?.pause();\n            return;\n        }\n        const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n        const playerBufferingNotStateButLive = buffering.buffering.current;\n        if (playerBufferingNotStateButLive && !isMediaTagBufferingOrStalled) {\n            playbackLogging({\n                logLevel,\n                tag: \"pause\",\n                message: `Pausing ${mediaRef.current?.src} because player is buffering but media tag is not`,\n                mountTime\n            });\n            mediaRef.current?.pause();\n        }\n    }, [\n        isBuffering,\n        isMediaTagBuffering,\n        buffering,\n        isPlayerBuffering,\n        isPremounting,\n        logLevel,\n        mediaRef,\n        mediaType,\n        mountTime,\n        playing\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const tagName = mediaType === \"audio\" ? \"<Audio>\" : \"<Video>\";\n        if (!mediaRef.current) {\n            throw new Error(`No ${mediaType} ref found`);\n        }\n        if (!src) {\n            throw new Error(`No 'src' attribute was passed to the ${tagName} element.`);\n        }\n        const playbackRateToSet = Math.max(0, playbackRate);\n        if (mediaRef.current.playbackRate !== playbackRateToSet) {\n            mediaRef.current.playbackRate = playbackRateToSet;\n        }\n        const { duration } = mediaRef.current;\n        const shouldBeTime = !Number.isNaN(duration) && Number.isFinite(duration) ? Math.min(duration, desiredUnclampedTime) : desiredUnclampedTime;\n        const mediaTagTime = mediaRef.current.currentTime;\n        const rvcTime = currentTime.current ?? null;\n        const isVariableFpsVideo = isVariableFpsVideoMap.current[src];\n        const timeShiftMediaTag = Math.abs(shouldBeTime - mediaTagTime);\n        const timeShiftRvcTag = rvcTime ? Math.abs(shouldBeTime - rvcTime) : null;\n        const timeShift = timeShiftRvcTag && !isVariableFpsVideo ? timeShiftRvcTag : timeShiftMediaTag;\n        if (timeShift > acceptableTimeShiftButLessThanDuration && lastSeekDueToShift.current !== shouldBeTime) {\n            lastSeek.current = seek({\n                mediaRef: mediaRef.current,\n                time: shouldBeTime,\n                logLevel,\n                why: `because time shift is too big. shouldBeTime = ${shouldBeTime}, isTime = ${mediaTagTime}, requestVideoCallbackTime = ${rvcTime}, timeShift = ${timeShift}${isVariableFpsVideo ? \", isVariableFpsVideo = true\" : \"\"}, isPremounting = ${isPremounting}, pauseWhenBuffering = ${pauseWhenBuffering}`,\n                mountTime\n            });\n            lastSeekDueToShift.current = lastSeek.current;\n            if (playing) {\n                if (playbackRate > 0) {\n                    bufferUntilFirstFrame(shouldBeTime);\n                }\n                if (mediaRef.current.paused) {\n                    playAndHandleNotAllowedError({\n                        mediaRef,\n                        mediaType,\n                        onAutoPlayError,\n                        logLevel,\n                        mountTime,\n                        reason: \"player is playing but media tag is paused, and just seeked\"\n                    });\n                }\n            }\n            if (!onlyWarnForMediaSeekingError) {\n                warnAboutNonSeekableMedia(mediaRef.current, onlyWarnForMediaSeekingError ? \"console-warning\" : \"console-error\");\n            }\n            return;\n        }\n        const seekThreshold = playing ? 0.15 : 0.01;\n        const makesSenseToSeek = Math.abs(mediaRef.current.currentTime - shouldBeTime) > seekThreshold;\n        const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n        const isSomethingElseBuffering = buffering.buffering.current && !isMediaTagBufferingOrStalled;\n        if (!playing || isSomethingElseBuffering) {\n            if (makesSenseToSeek) {\n                lastSeek.current = seek({\n                    mediaRef: mediaRef.current,\n                    time: shouldBeTime,\n                    logLevel,\n                    why: `not playing or something else is buffering. time offset is over seek threshold (${seekThreshold})`,\n                    mountTime\n                });\n            }\n            return;\n        }\n        if (!playing || buffering.buffering.current) {\n            return;\n        }\n        const pausedCondition = mediaRef.current.paused && !mediaRef.current.ended;\n        const firstFrameCondition = absoluteFrame === 0;\n        if (pausedCondition || firstFrameCondition) {\n            const reason = pausedCondition ? \"media tag is paused\" : \"absolute frame is 0\";\n            if (makesSenseToSeek) {\n                lastSeek.current = seek({\n                    mediaRef: mediaRef.current,\n                    time: shouldBeTime,\n                    logLevel,\n                    why: `is over timeshift threshold (threshold = ${seekThreshold}) and ${reason}`,\n                    mountTime\n                });\n            }\n            playAndHandleNotAllowedError({\n                mediaRef,\n                mediaType,\n                onAutoPlayError,\n                logLevel,\n                mountTime,\n                reason: `player is playing and ${reason}`\n            });\n            if (!isVariableFpsVideo && playbackRate > 0) {\n                bufferUntilFirstFrame(shouldBeTime);\n            }\n        }\n    }, [\n        absoluteFrame,\n        acceptableTimeShiftButLessThanDuration,\n        bufferUntilFirstFrame,\n        buffering.buffering,\n        currentTime,\n        logLevel,\n        desiredUnclampedTime,\n        isBuffering,\n        isMediaTagBuffering,\n        mediaRef,\n        mediaType,\n        onlyWarnForMediaSeekingError,\n        playbackRate,\n        playing,\n        src,\n        onAutoPlayError,\n        isPremounting,\n        pauseWhenBuffering,\n        mountTime\n    ]);\n};\n// src/use-sync-volume-with-media-tag.ts\n\n// src/is-approximately-the-same.ts\nvar FLOATING_POINT_ERROR_THRESHOLD = 0.00001;\nvar isApproximatelyTheSame = (num1, num2)=>{\n    return Math.abs(num1 - num2) < FLOATING_POINT_ERROR_THRESHOLD;\n};\n// src/use-sync-volume-with-media-tag.ts\nvar useSyncVolumeWithMediaTag = ({ volumePropFrame, volume, mediaVolume, mediaRef })=>{\n    const adjustVolume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!mediaRef.current) {\n            return;\n        }\n        const userPreferredVolume = evaluateVolume({\n            frame: volumePropFrame,\n            volume,\n            mediaVolume\n        });\n        if (!isApproximatelyTheSame(userPreferredVolume, mediaRef.current.volume)) {\n            mediaRef.current.volume = Math.min(userPreferredVolume, 1);\n        }\n    }, [\n        mediaRef,\n        mediaVolume,\n        volume,\n        volumePropFrame\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        adjustVolume();\n    }, [\n        adjustVolume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const media = mediaRef.current;\n        if (!media) {\n            return;\n        }\n        const handleVolumeChange = ()=>{\n            adjustVolume();\n        };\n        media.addEventListener(\"volumechange\", handleVolumeChange);\n        return ()=>{\n            media.removeEventListener(\"volumechange\", handleVolumeChange);\n        };\n    }, [\n        adjustVolume,\n        mediaRef\n    ]);\n};\n// src/volume-position-state.ts\n\nvar MediaVolumeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    mediaMuted: false,\n    mediaVolume: 1\n});\nvar SetMediaVolumeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setMediaMuted: ()=>{\n        throw new Error(\"default\");\n    },\n    setMediaVolume: ()=>{\n        throw new Error(\"default\");\n    }\n});\nvar useMediaVolumeState = ()=>{\n    const { mediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return [\n            mediaVolume,\n            setMediaVolume\n        ];\n    }, [\n        mediaVolume,\n        setMediaVolume\n    ]);\n};\nvar useMediaMutedState = ()=>{\n    const { mediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return [\n            mediaMuted,\n            setMediaMuted\n        ];\n    }, [\n        mediaMuted,\n        setMediaMuted\n    ]);\n};\n// src/audio/shared-audio-tags.tsx\n\n\nvar EMPTY_AUDIO = \"data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\";\nvar compareProps = (obj1, obj2)=>{\n    const keysA = Object.keys(obj1).sort();\n    const keysB = Object.keys(obj2).sort();\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    for(let i = 0; i < keysA.length; i++){\n        if (keysA[i] !== keysB[i]) {\n            return false;\n        }\n        if (obj1[keysA[i]] !== obj2[keysB[i]]) {\n            return false;\n        }\n    }\n    return true;\n};\nvar didPropChange = (key, newProp, prevProp)=>{\n    if (key === \"src\" && !prevProp.startsWith(\"data:\") && !newProp.startsWith(\"data:\")) {\n        return new URL(prevProp, window.origin).toString() !== new URL(newProp, window.origin).toString();\n    }\n    if (prevProp === newProp) {\n        return false;\n    }\n    return true;\n};\nvar SharedAudioContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar SharedAudioContextProvider = ({ children, numberOfAudioTags, component })=>{\n    const audios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const [initialNumberOfAudioTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(numberOfAudioTags);\n    if (numberOfAudioTags !== initialNumberOfAudioTags) {\n        throw new Error(\"The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.\");\n    }\n    const refs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new Array(numberOfAudioTags).fill(true).map(()=>{\n            return {\n                id: Math.random(),\n                ref: /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)()\n            };\n        });\n    }, [\n        numberOfAudioTags\n    ]);\n    const takenAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(numberOfAudioTags).fill(false));\n    const rerenderAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        refs.forEach(({ ref, id })=>{\n            const data = audios.current?.find((a)=>a.id === id);\n            const { current } = ref;\n            if (!current) {\n                return;\n            }\n            if (data === undefined) {\n                current.src = EMPTY_AUDIO;\n                return;\n            }\n            if (!data) {\n                throw new TypeError(\"Expected audio data to be there\");\n            }\n            Object.keys(data.props).forEach((key)=>{\n                if (didPropChange(key, data.props[key], current[key])) {\n                    current[key] = data.props[key];\n                }\n            });\n        });\n    }, [\n        refs\n    ]);\n    const registerAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((aud, audioId)=>{\n        const found = audios.current?.find((a)=>a.audioId === audioId);\n        if (found) {\n            return found;\n        }\n        const firstFreeAudio = takenAudios.current.findIndex((a)=>a === false);\n        if (firstFreeAudio === -1) {\n            throw new Error(`Tried to simultaneously mount ${numberOfAudioTags + 1} <Audio /> tags at the same time. With the current settings, the maximum amount of <Audio /> tags is limited to ${numberOfAudioTags} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#using-the-numberofsharedaudiotags-prop for more information on how to increase this limit.`);\n        }\n        const { id, ref } = refs[firstFreeAudio];\n        const cloned = [\n            ...takenAudios.current\n        ];\n        cloned[firstFreeAudio] = id;\n        takenAudios.current = cloned;\n        const newElem = {\n            props: aud,\n            id,\n            el: ref,\n            audioId\n        };\n        audios.current?.push(newElem);\n        rerenderAudios();\n        return newElem;\n    }, [\n        numberOfAudioTags,\n        refs,\n        rerenderAudios\n    ]);\n    const unregisterAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        const cloned = [\n            ...takenAudios.current\n        ];\n        const index = refs.findIndex((r)=>r.id === id);\n        if (index === -1) {\n            throw new TypeError(\"Error occured in \");\n        }\n        cloned[index] = false;\n        takenAudios.current = cloned;\n        audios.current = audios.current?.filter((a)=>a.id !== id);\n        rerenderAudios();\n    }, [\n        refs,\n        rerenderAudios\n    ]);\n    const updateAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ aud, audioId, id })=>{\n        let changed = false;\n        audios.current = audios.current?.map((prevA)=>{\n            if (prevA.id === id) {\n                const isTheSame = compareProps(aud, prevA.props);\n                if (isTheSame) {\n                    return prevA;\n                }\n                changed = true;\n                return {\n                    ...prevA,\n                    props: aud,\n                    audioId\n                };\n            }\n            return prevA;\n        });\n        if (changed) {\n            rerenderAudios();\n        }\n    }, [\n        rerenderAudios\n    ]);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const playAllAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        refs.forEach((ref)=>{\n            playAndHandleNotAllowedError({\n                mediaRef: ref.ref,\n                mediaType: \"audio\",\n                onAutoPlayError: null,\n                logLevel,\n                mountTime,\n                reason: \"playing all audios\"\n            });\n        });\n    }, [\n        logLevel,\n        mountTime,\n        refs\n    ]);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            registerAudio,\n            unregisterAudio,\n            updateAudio,\n            playAllAudios,\n            numberOfAudioTags\n        };\n    }, [\n        numberOfAudioTags,\n        playAllAudios,\n        registerAudio,\n        unregisterAudio,\n        updateAudio\n    ]);\n    const resetAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        takenAudios.current = new Array(numberOfAudioTags).fill(false);\n        audios.current = [];\n        rerenderAudios();\n    }, [\n        numberOfAudioTags,\n        rerenderAudios\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            resetAudio();\n        };\n    }, [\n        component,\n        resetAudio\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SharedAudioContext.Provider, {\n        value,\n        children: [\n            refs.map(({ id, ref })=>{\n                return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n                    ref,\n                    preload: \"metadata\",\n                    src: EMPTY_AUDIO\n                }, id);\n            }),\n            children\n        ]\n    });\n};\nvar useSharedAudio = (aud, audioId)=>{\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const [elem] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>{\n        if (ctx && ctx.numberOfAudioTags > 0) {\n            return ctx.registerAudio(aud, audioId);\n        }\n        return {\n            el: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n            id: Math.random(),\n            props: aud,\n            audioId\n        };\n    });\n    const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n    if (typeof document !== \"undefined\") {\n        effectToUse(()=>{\n            if (ctx && ctx.numberOfAudioTags > 0) {\n                ctx.updateAudio({\n                    id: elem.id,\n                    aud,\n                    audioId\n                });\n            }\n        }, [\n            aud,\n            ctx,\n            elem.id,\n            audioId\n        ]);\n        effectToUse(()=>{\n            return ()=>{\n                if (ctx && ctx.numberOfAudioTags > 0) {\n                    ctx.unregisterAudio(elem.id);\n                }\n            };\n        }, [\n            ctx,\n            elem.id\n        ]);\n    }\n    return elem;\n};\n// src/audio/AudioForPreview.tsx\n\nvar AudioForDevelopmentForwardRefFunction = (props, ref)=>{\n    const [initialShouldPreMountAudioElements] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.shouldPreMountAudioTags);\n    if (props.shouldPreMountAudioTags !== initialShouldPreMountAudioElements) {\n        throw new Error(\"Cannot change the behavior for pre-mounting audio tags dynamically.\");\n    }\n    const logLevel = useLogLevel();\n    const { volume, muted, playbackRate, shouldPreMountAudioTags, src, onDuration, acceptableTimeShiftInSeconds, _remotionInternalNeedsDurationCalculation, _remotionInternalNativeLoopPassed, _remotionInternalStack, allowAmplificationDuringRender, name, pauseWhenBuffering, showInTimeline, loopVolumeCurveBehavior, stack, ...nativeProps } = props;\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    if (!src) {\n        throw new TypeError(\"No 'src' was passed to <Audio>.\");\n    }\n    const preloadedSrc = usePreload(src);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(Math.random()));\n    const isSequenceHidden = hidden[timelineId] ?? false;\n    const userPreferredVolume = evaluateVolume({\n        frame: volumePropFrame,\n        volume,\n        mediaVolume\n    });\n    const propsToPass = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n            src: preloadedSrc,\n            loop: _remotionInternalNativeLoopPassed,\n            ...nativeProps\n        };\n    }, [\n        _remotionInternalNativeLoopPassed,\n        isSequenceHidden,\n        mediaMuted,\n        muted,\n        nativeProps,\n        preloadedSrc,\n        userPreferredVolume\n    ]);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`audio-${random(src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}-muted:${props.muted}-loop:${props.loop}`, [\n        src,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.durationInFrames,\n        props.muted,\n        props.loop\n    ]);\n    const audioRef = useSharedAudio(propsToPass, id).el;\n    useSyncVolumeWithMediaTag({\n        volumePropFrame,\n        volume,\n        mediaVolume,\n        mediaRef: audioRef\n    });\n    useMediaInTimeline({\n        volume,\n        mediaVolume,\n        mediaRef: audioRef,\n        src,\n        mediaType: \"audio\",\n        playbackRate: playbackRate ?? 1,\n        displayName: name ?? null,\n        id: timelineId,\n        stack: _remotionInternalStack,\n        showInTimeline,\n        premountDisplay: null,\n        onAutoPlayError: null,\n        isPremounting: Boolean(sequenceContext?.premounting)\n    });\n    useAmplification({\n        logLevel,\n        mediaRef: audioRef,\n        volume: userPreferredVolume\n    });\n    useMediaPlayback({\n        mediaRef: audioRef,\n        src,\n        mediaType: \"audio\",\n        playbackRate: playbackRate ?? 1,\n        onlyWarnForMediaSeekingError: false,\n        acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,\n        isPremounting: Boolean(sequenceContext?.premounting),\n        pauseWhenBuffering,\n        onAutoPlayError: null,\n        userPreferredVolume\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return audioRef.current;\n    }, [\n        audioRef\n    ]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);\n    currentOnDurationCallback.current = onDuration;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = audioRef;\n        if (!current) {\n            return;\n        }\n        if (current.duration) {\n            currentOnDurationCallback.current?.(current.src, current.duration);\n            return;\n        }\n        const onLoadedMetadata = ()=>{\n            currentOnDurationCallback.current?.(current.src, current.duration);\n        };\n        current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n        return ()=>{\n            current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n        };\n    }, [\n        audioRef,\n        src\n    ]);\n    if (initialShouldPreMountAudioElements) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n        ref: audioRef,\n        preload: \"metadata\",\n        ...propsToPass\n    });\n};\nvar AudioForPreview = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForDevelopmentForwardRefFunction);\n// src/audio/AudioForRendering.tsx\n\n\nvar AudioForRenderingRefForwardingFunction = (props, ref)=>{\n    const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { volume: volumeProp, playbackRate, allowAmplificationDuringRender, onDuration, toneFrequency, _remotionInternalNeedsDurationCalculation, _remotionInternalNativeLoopPassed, acceptableTimeShiftInSeconds, name, onError, delayRenderRetries, delayRenderTimeoutInMilliseconds, loopVolumeCurveBehavior, pauseWhenBuffering, ...nativeProps } = props;\n    const absoluteFrame = useTimelinePosition();\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const frame = useCurrentFrame();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`audio-${random(props.src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}`, [\n        props.src,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropFrame,\n        mediaVolume: 1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return audioRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!props.src) {\n            throw new Error(\"No src passed\");\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        if (props.muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        registerRenderAsset({\n            type: \"audio\",\n            src: getAbsoluteSrc(props.src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: props.playbackRate ?? 1,\n            toneFrequency: toneFrequency ?? null,\n            audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n        });\n        return ()=>unregisterRenderAsset(id);\n    }, [\n        props.muted,\n        props.src,\n        registerRenderAsset,\n        absoluteFrame,\n        id,\n        unregisterRenderAsset,\n        volume,\n        volumePropFrame,\n        frame,\n        playbackRate,\n        props.playbackRate,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    const { src } = props;\n    const needsToRenderAudioTag = ref || _remotionInternalNeedsDurationCalculation;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (window.process?.env?.NODE_ENV === \"test\") {\n            return;\n        }\n        if (!needsToRenderAudioTag) {\n            return;\n        }\n        const newHandle = delayRender(\"Loading <Audio> duration with src=\" + src, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        });\n        const { current } = audioRef;\n        const didLoad = ()=>{\n            if (current?.duration) {\n                onDuration(current.src, current.duration);\n            }\n            continueRender(newHandle);\n        };\n        if (current?.duration) {\n            onDuration(current.src, current.duration);\n            continueRender(newHandle);\n        } else {\n            current?.addEventListener(\"loadedmetadata\", didLoad, {\n                once: true\n            });\n        }\n        return ()=>{\n            current?.removeEventListener(\"loadedmetadata\", didLoad);\n            continueRender(newHandle);\n        };\n    }, [\n        src,\n        onDuration,\n        needsToRenderAudioTag,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds\n    ]);\n    if (!needsToRenderAudioTag) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n        ref: audioRef,\n        ...nativeProps\n    });\n};\nvar AudioForRendering = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForRenderingRefForwardingFunction);\n// src/audio/Audio.tsx\n\nvar AudioRefForwardingFunction = (props, ref)=>{\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const { startFrom, endAt, name, stack, pauseWhenBuffering, showInTimeline, ...otherProps } = props;\n    const { loop, ...propsOtherThanLoop } = props;\n    const { fps } = useVideoConfig();\n    const environment = getRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof props.src !== \"string\") {\n        throw new TypeError(`The \\`<Audio>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props.src)} instead.`);\n    }\n    const preloadedSrc = usePreload(props.src);\n    const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        console.log(e.currentTarget.error);\n        const errMessage = `Could not play audio with src ${preloadedSrc}: ${e.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;\n        if (loop) {\n            cancelRender(new Error(errMessage));\n        } else {\n            console.warn(errMessage);\n        }\n    }, [\n        loop,\n        preloadedSrc\n    ]);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds)=>{\n        setDurations({\n            type: \"got-duration\",\n            durationInSeconds,\n            src\n        });\n    }, [\n        setDurations\n    ]);\n    const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props.src)];\n    if (loop && durationFetched !== undefined) {\n        if (!Number.isFinite(durationFetched)) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            });\n        }\n        const duration = durationFetched * fps;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n            layout: \"none\",\n            durationInFrames: calculateLoopDuration({\n                endAt,\n                mediaDuration: duration,\n                playbackRate: props.playbackRate ?? 1,\n                startFrom\n            }),\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            })\n        });\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                _remotionInternalNeedsDurationCalculation: Boolean(loop),\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps,\n                ref\n            })\n        });\n    }\n    validateMediaProps(props, \"Audio\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForRendering, {\n            onDuration,\n            ...props,\n            ref,\n            onError,\n            _remotionInternalNeedsDurationCalculation: Boolean(loop)\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForPreview, {\n        _remotionInternalNativeLoopPassed: props._remotionInternalNativeLoopPassed ?? false,\n        _remotionInternalStack: stack ?? null,\n        shouldPreMountAudioTags: audioContext !== null && audioContext.numberOfAudioTags > 0,\n        ...props,\n        ref,\n        onError,\n        onDuration,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        _remotionInternalNeedsDurationCalculation: Boolean(loop),\n        showInTimeline: showInTimeline ?? true\n    });\n};\nvar Audio = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioRefForwardingFunction);\naddSequenceStackTraces(Audio);\n// src/Composition.tsx\n\n\n// src/Folder.tsx\n\n// src/validation/validate-folder-name.ts\nvar getRegex = ()=>/^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isFolderNameValid = (name)=>name.match(getRegex());\nvar validateFolderName = (name)=>{\n    if (name === undefined || name === null) {\n        throw new TypeError(\"You must pass a name to a <Folder />.\");\n    }\n    if (typeof name !== \"string\") {\n        throw new TypeError(`The \"name\" you pass into <Folder /> must be a string. Got: ${typeof name}`);\n    }\n    if (!isFolderNameValid(name)) {\n        throw new Error(`Folder name can only contain a-z, A-Z, 0-9 and -. You passed ${name}`);\n    }\n};\nvar invalidFolderNameErrorMessage = `Folder name must match ${String(getRegex())}`;\n// src/Folder.tsx\n\nvar FolderContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    folderName: null,\n    parentName: null\n});\nvar Folder = ({ name, children })=>{\n    const parent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    const { registerFolder, unregisterFolder } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n    validateFolderName(name);\n    const parentNameArr = [\n        parent.parentName,\n        parent.folderName\n    ].filter(truthy);\n    const parentName = parentNameArr.length === 0 ? null : parentNameArr.join(\"/\");\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            folderName: name,\n            parentName\n        };\n    }, [\n        name,\n        parentName\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        registerFolder(name, parentName);\n        return ()=>{\n            unregisterFolder(name, parentName);\n        };\n    }, [\n        name,\n        parent.folderName,\n        parentName,\n        registerFolder,\n        unregisterFolder\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FolderContext.Provider, {\n        value,\n        children\n    });\n};\n// src/loading-indicator.tsx\n\nvar rotate = {\n    transform: `rotate(90deg)`\n};\nvar ICON_SIZE = 40;\nvar label = {\n    color: \"white\",\n    fontSize: 14,\n    fontFamily: \"sans-serif\"\n};\nvar container = {\n    justifyContent: \"center\",\n    alignItems: \"center\"\n};\nvar Loading = ()=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(AbsoluteFill, {\n        style: container,\n        id: \"remotion-comp-loading\",\n        children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"style\", {\n                type: \"text/css\",\n                children: `\n\t\t\t\t@keyframes anim {\n\t\t\t\t\tfrom {\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t}\n\t\t\t\t\tto {\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#remotion-comp-loading {\n\t\t\t\t\tanimation: anim 2s;\n\t\t\t\t\tanimation-fill-mode: forwards;\n\t\t\t\t}\n\t\t\t`\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", {\n                width: ICON_SIZE,\n                height: ICON_SIZE,\n                viewBox: \"-100 -100 400 400\",\n                style: rotate,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n                    fill: \"#555\",\n                    stroke: \"#555\",\n                    strokeWidth: \"100\",\n                    strokeLinejoin: \"round\",\n                    d: \"M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z\"\n                })\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"p\", {\n                style: label,\n                children: [\n                    \"Resolving \",\n                    \"<Suspense>\",\n                    \"...\"\n                ]\n            })\n        ]\n    });\n};\n// src/portal-node.ts\nvar _portalNode = null;\nvar portalNode = ()=>{\n    if (!_portalNode) {\n        if (typeof document === \"undefined\") {\n            throw new Error(\"Tried to call an API that only works in the browser from outside the browser\");\n        }\n        _portalNode = document.createElement(\"div\");\n        _portalNode.style.position = \"absolute\";\n        _portalNode.style.top = \"0px\";\n        _portalNode.style.left = \"0px\";\n        _portalNode.style.right = \"0px\";\n        _portalNode.style.bottom = \"0px\";\n        _portalNode.style.width = \"100%\";\n        _portalNode.style.height = \"100%\";\n        _portalNode.style.display = \"flex\";\n        _portalNode.style.flexDirection = \"column\";\n        const containerNode = document.createElement(\"div\");\n        containerNode.style.position = \"fixed\";\n        containerNode.style.top = -999999 + \"px\";\n        containerNode.appendChild(_portalNode);\n        document.body.appendChild(containerNode);\n    }\n    return _portalNode;\n};\n// src/use-lazy-component.ts\n\nvar useLazyComponent = ({ compProps, componentName, noSuspense })=>{\n    const lazy = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (\"component\" in compProps) {\n            if (typeof document === \"undefined\" || noSuspense) {\n                return compProps.component;\n            }\n            if (typeof compProps.component === \"undefined\") {\n                throw new Error(`A value of \\`undefined\\` was passed to the \\`component\\` prop. Check the value you are passing to the <${componentName}/> component.`);\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.lazy(()=>Promise.resolve({\n                    default: compProps.component\n                }));\n        }\n        if (\"lazyComponent\" in compProps && typeof compProps.lazyComponent !== \"undefined\") {\n            if (typeof compProps.lazyComponent === \"undefined\") {\n                throw new Error(`A value of \\`undefined\\` was passed to the \\`lazyComponent\\` prop. Check the value you are passing to the <${componentName}/> component.`);\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.lazy(compProps.lazyComponent);\n        }\n        throw new Error(\"You must pass either 'component' or 'lazyComponent'\");\n    }, [\n        compProps.component,\n        compProps.lazyComponent\n    ]);\n    return lazy;\n};\n// src/validation/validate-composition-id.ts\nvar getRegex2 = ()=>/^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isCompositionIdValid = (id)=>id.match(getRegex2());\nvar validateCompositionId = (id)=>{\n    if (!isCompositionIdValid(id)) {\n        throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${id}`);\n    }\n};\nvar invalidCompositionErrorMessage = `Composition ID must match ${String(getRegex2())}`;\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId)=>{\n    if (!defaultProps) {\n        return;\n    }\n    if (typeof defaultProps !== \"object\") {\n        throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n    }\n    if (Array.isArray(defaultProps)) {\n        throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n    }\n};\n// src/Composition.tsx\n\nvar Fallback = ()=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const fallback = delayRender(\"Waiting for Root component to unsuspend\");\n        return ()=>continueRender(fallback);\n    }, []);\n    return null;\n};\nvar InnerComposition = ({ width, height, fps, durationInFrames, id, defaultProps, schema, ...compProps })=>{\n    const compManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n    const { registerComposition, unregisterComposition } = compManager;\n    const video = useVideo();\n    const lazy = useLazyComponent({\n        compProps,\n        componentName: \"Composition\",\n        noSuspense: false\n    });\n    const nonce = useNonce();\n    const isPlayer = useIsPlayer();\n    const environment = getRemotionEnvironment();\n    const canUseComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (canUseComposition) {\n        if (isPlayer) {\n            throw new Error(\"<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n        }\n        throw new Error(\"<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n    }\n    const { folderName, parentName } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!id) {\n            throw new Error(\"No id for composition passed.\");\n        }\n        validateCompositionId(id);\n        validateDefaultAndInputProps(defaultProps, \"defaultProps\", id);\n        registerComposition({\n            durationInFrames: durationInFrames ?? undefined,\n            fps: fps ?? undefined,\n            height: height ?? undefined,\n            width: width ?? undefined,\n            id,\n            folderName,\n            component: lazy,\n            defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n            nonce,\n            parentFolderName: parentName,\n            schema: schema ?? null,\n            calculateMetadata: compProps.calculateMetadata ?? null\n        });\n        return ()=>{\n            unregisterComposition(id);\n        };\n    }, [\n        durationInFrames,\n        fps,\n        height,\n        lazy,\n        id,\n        folderName,\n        defaultProps,\n        width,\n        nonce,\n        parentName,\n        schema,\n        compProps.calculateMetadata,\n        registerComposition,\n        unregisterComposition\n    ]);\n    const resolved = useResolvedVideoConfig(id);\n    if (environment.isStudio && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== \"success\") {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loading, {}),\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n                    ...resolved.result.props ?? {}\n                })\n            })\n        }), portalNode());\n    }\n    if (environment.isRendering && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== \"success\") {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Fallback, {}),\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n                    ...resolved.result.props ?? {}\n                })\n            })\n        }), portalNode());\n    }\n    return null;\n};\nvar Composition = (props2)=>{\n    const { onlyRenderComposition } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n    if (onlyRenderComposition && onlyRenderComposition !== props2.id) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerComposition, {\n        ...props2\n    });\n};\n// src/bezier.ts\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nvar float32ArraySupported = typeof Float32Array === \"function\";\nfunction a(aA1, aA2) {\n    return 1 - 3 * aA2 + 3 * aA1;\n}\nfunction b(aA1, aA2) {\n    return 3 * aA2 - 6 * aA1;\n}\nfunction c(aA1) {\n    return 3 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n    return ((a(aA1, aA2) * aT + b(aA1, aA2)) * aT + c(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n    return 3 * a(aA1, aA2) * aT * aT + 2 * b(aA1, aA2) * aT + c(aA1);\n}\nfunction binarySubdivide({ aX, _aA, _aB, mX1, mX2 }) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    let aA = _aA;\n    let aB = _aB;\n    do {\n        currentT = aA + (aB - aA) / 2;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0) {\n            aB = currentT;\n        } else {\n            aA = currentT;\n        }\n    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n}\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n    let aGuessT = _aGuessT;\n    for(let i = 0; i < NEWTON_ITERATIONS; ++i){\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n        throw new Error(\"bezier x values must be in [0, 1] range\");\n    }\n    const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    if (mX1 !== mY1 || mX2 !== mY2) {\n        for(let i = 0; i < kSplineTableSize; ++i){\n            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n        }\n    }\n    function getTForX(aX) {\n        let intervalStart = 0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        if (initialSlope === 0) {\n            return guessForT;\n        }\n        return binarySubdivide({\n            aX,\n            _aA: intervalStart,\n            _aB: intervalStart + kSampleStepSize,\n            mX1,\n            mX2\n        });\n    }\n    return function(x) {\n        if (mX1 === mY1 && mX2 === mY2) {\n            return x;\n        }\n        if (x === 0) {\n            return 0;\n        }\n        if (x === 1) {\n            return 1;\n        }\n        return calcBezier(getTForX(x), mY1, mY2);\n    };\n}\n// src/easing.ts\nclass Easing {\n    static step0(n) {\n        return n > 0 ? 1 : 0;\n    }\n    static step1(n) {\n        return n >= 1 ? 1 : 0;\n    }\n    static linear(t) {\n        return t;\n    }\n    static ease(t) {\n        return Easing.bezier(0.42, 0, 1, 1)(t);\n    }\n    static quad(t) {\n        return t * t;\n    }\n    static cubic(t) {\n        return t * t * t;\n    }\n    static poly(n) {\n        return (t)=>t ** n;\n    }\n    static sin(t) {\n        return 1 - Math.cos(t * Math.PI / 2);\n    }\n    static circle(t) {\n        return 1 - Math.sqrt(1 - t * t);\n    }\n    static exp(t) {\n        return 2 ** (10 * (t - 1));\n    }\n    static elastic(bounciness = 1) {\n        const p = bounciness * Math.PI;\n        return (t)=>1 - Math.cos(t * Math.PI / 2) ** 3 * Math.cos(t * p);\n    }\n    static back(s = 1.70158) {\n        return (t)=>t * t * ((s + 1) * t - s);\n    }\n    static bounce(t) {\n        if (t < 1 / 2.75) {\n            return 7.5625 * t * t;\n        }\n        if (t < 2 / 2.75) {\n            const t2_ = t - 1.5 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.75;\n        }\n        if (t < 2.5 / 2.75) {\n            const t2_ = t - 2.25 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.9375;\n        }\n        const t2 = t - 2.625 / 2.75;\n        return 7.5625 * t2 * t2 + 0.984375;\n    }\n    static bezier(x1, y1, x2, y2) {\n        return bezier(x1, y1, x2, y2);\n    }\n    static in(easing) {\n        return easing;\n    }\n    static out(easing) {\n        return (t)=>1 - easing(1 - t);\n    }\n    static inOut(easing) {\n        return (t)=>{\n            if (t < 0.5) {\n                return easing(t * 2) / 2;\n            }\n            return 1 - easing((1 - t) * 2) / 2;\n        };\n    }\n}\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n// src/get-static-files.ts\nvar warnedServer = false;\nvar warnedPlayer = false;\nvar warnServerOnce = ()=>{\n    if (warnedServer) {\n        return;\n    }\n    warnedServer = true;\n    console.warn(\"Called getStaticFiles() on the server. The API is only available in the browser. An empty array was returned.\");\n};\nvar warnPlayerOnce = ()=>{\n    if (warnedPlayer) {\n        return;\n    }\n    warnedPlayer = true;\n    console.warn(\"Called getStaticFiles() while using the Remotion Player. The API is only available while using the Remotion Studio. An empty array was returned.\");\n};\nvar getStaticFiles = ()=>{\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        throw new Error(\"getStaticFiles() has moved into the `@remotion/studio` package. Update your imports.\");\n    }\n    if (typeof document === \"undefined\") {\n        warnServerOnce();\n        return [];\n    }\n    if (window.remotion_isPlayer) {\n        warnPlayerOnce();\n        return [];\n    }\n    return window.remotion_staticFiles;\n};\n// src/IFrame.tsx\n\n\nvar IFrameRefForwarding = ({ onLoad, onError, delayRenderRetries, delayRenderTimeoutInMilliseconds, ...props2 }, ref)=>{\n    const [handle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>delayRender(`Loading <IFrame> with source ${props2.src}`, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        }));\n    const didLoad = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        continueRender(handle);\n        onLoad?.(e);\n    }, [\n        handle,\n        onLoad\n    ]);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        continueRender(handle);\n        if (onError) {\n            onError(e);\n        } else {\n            console.error(\"Error loading iframe:\", e, \"Handle the event using the onError() prop to make this message disappear.\");\n        }\n    }, [\n        handle,\n        onError\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"iframe\", {\n        ...props2,\n        ref,\n        onError: didGetError,\n        onLoad: didLoad\n    });\n};\nvar IFrame = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(IFrameRefForwarding);\n// src/Img.tsx\n\n\nfunction exponentialBackoff(errorCount) {\n    return 1000 * 2 ** (errorCount - 1);\n}\nvar ImgRefForwarding = ({ onError, maxRetries = 2, src, pauseWhenLoading, delayRenderRetries, delayRenderTimeoutInMilliseconds, onImageFrame, ...props2 }, ref)=>{\n    const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const errors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const { delayPlayback } = useBufferState();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    if (!src) {\n        throw new Error('No \"src\" prop was passed to <Img>.');\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return imageRef.current;\n    }, []);\n    const actualSrc = usePreload(src);\n    const retryIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((timeout)=>{\n        if (!imageRef.current) {\n            return;\n        }\n        const currentSrc = imageRef.current.src;\n        setTimeout(()=>{\n            if (!imageRef.current) {\n                return;\n            }\n            const newSrc = imageRef.current?.src;\n            if (newSrc !== currentSrc) {\n                return;\n            }\n            imageRef.current.removeAttribute(\"src\");\n            imageRef.current.setAttribute(\"src\", newSrc);\n        }, timeout);\n    }, []);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!errors.current) {\n            return;\n        }\n        errors.current[imageRef.current?.src] = (errors.current[imageRef.current?.src] ?? 0) + 1;\n        if (onError && (errors.current[imageRef.current?.src] ?? 0) > maxRetries) {\n            onError(e);\n            return;\n        }\n        if ((errors.current[imageRef.current?.src] ?? 0) <= maxRetries) {\n            const backoff = exponentialBackoff(errors.current[imageRef.current?.src] ?? 0);\n            console.warn(`Could not load image with source ${imageRef.current?.src}, retrying again in ${backoff}ms`);\n            retryIn(backoff);\n            return;\n        }\n        cancelRender(\"Error loading image with src: \" + imageRef.current?.src);\n    }, [\n        maxRetries,\n        onError,\n        retryIn\n    ]);\n    if (false) {}\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"img\", {\n        ...props2,\n        ref: imageRef,\n        onError: didGetError\n    });\n};\nvar Img = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ImgRefForwarding);\n// src/internals.ts\n\n// src/CompositionManager.tsx\n\n\nvar compositionsRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar CompositionManagerProvider = ({ children, numberOfAudioTags, onlyRenderComposition, currentCompositionMetadata })=>{\n    const [compositions, setCompositions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const currentcompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(compositions);\n    const [folders, setFolders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [canvasContent, setCanvasContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const updateCompositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updateComps)=>{\n        setCompositions((comps)=>{\n            const updated = updateComps(comps);\n            currentcompositionsRef.current = updated;\n            return updated;\n        });\n    }, []);\n    const registerComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((comp)=>{\n        updateCompositions((comps)=>{\n            if (comps.find((c2)=>c2.id === comp.id)) {\n                throw new Error(`Multiple composition with id ${comp.id} are registered.`);\n            }\n            const value = [\n                ...comps,\n                comp\n            ].slice().sort((a2, b2)=>a2.nonce - b2.nonce);\n            return value;\n        });\n    }, [\n        updateCompositions\n    ]);\n    const unregisterComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        setCompositions((comps)=>{\n            return comps.filter((c2)=>c2.id !== id);\n        });\n    }, []);\n    const registerFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent)=>{\n        setFolders((prevFolders)=>{\n            return [\n                ...prevFolders,\n                {\n                    name,\n                    parent\n                }\n            ];\n        });\n    }, []);\n    const unregisterFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent)=>{\n        setFolders((prevFolders)=>{\n            return prevFolders.filter((p)=>!(p.name === name && p.parent === parent));\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(compositionsRef, ()=>{\n        return {\n            getCompositions: ()=>currentcompositionsRef.current\n        };\n    }, []);\n    const composition = compositions.find((c2)=>canvasContent?.type === \"composition\" ? c2.id === canvasContent.compositionId : null);\n    const updateCompositionDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id, newDefaultProps)=>{\n        setCompositions((comps)=>{\n            const updated = comps.map((c2)=>{\n                if (c2.id === id) {\n                    return {\n                        ...c2,\n                        defaultProps: newDefaultProps\n                    };\n                }\n                return c2;\n            });\n            return updated;\n        });\n    }, []);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            compositions,\n            folders,\n            currentCompositionMetadata,\n            canvasContent\n        };\n    }, [\n        compositions,\n        folders,\n        currentCompositionMetadata,\n        canvasContent\n    ]);\n    const setters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            registerComposition,\n            unregisterComposition,\n            registerFolder,\n            unregisterFolder,\n            setCanvasContent,\n            updateCompositionDefaultProps,\n            onlyRenderComposition\n        };\n    }, [\n        registerComposition,\n        registerFolder,\n        unregisterComposition,\n        unregisterFolder,\n        updateCompositionDefaultProps,\n        onlyRenderComposition\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n        value: contextValue,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionSetters.Provider, {\n            value: setters,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManagerProvider, {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManagerProvider, {\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionConfig, {\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SharedAudioContextProvider, {\n                            numberOfAudioTags,\n                            component: composition?.component ?? null,\n                            children\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/default-css.ts\nvar exports_default_css = {};\n__export(exports_default_css, {\n    makeDefaultPreviewCSS: ()=>makeDefaultPreviewCSS,\n    injectCSS: ()=>injectCSS,\n    OFFTHREAD_VIDEO_CLASS_NAME: ()=>OFFTHREAD_VIDEO_CLASS_NAME\n});\nvar injected = {};\nvar injectCSS = (css)=>{\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    if (injected[css]) {\n        return;\n    }\n    const head = document.head || document.getElementsByTagName(\"head\")[0];\n    const style = document.createElement(\"style\");\n    style.appendChild(document.createTextNode(css));\n    head.prepend(style);\n    injected[css] = true;\n};\nvar OFFTHREAD_VIDEO_CLASS_NAME = \"__remotion_offthreadvideo\";\nvar makeDefaultPreviewCSS = (scope, backgroundColor)=>{\n    if (!scope) {\n        return `\n    * {\n      box-sizing: border-box;\n    }\n    body {\n      margin: 0;\n\t    background-color: ${backgroundColor};\n    }\n    .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n    `;\n    }\n    return `\n    ${scope} * {\n      box-sizing: border-box;\n    }\n    ${scope} *:-webkit-full-screen {\n      width: 100%;\n      height: 100%;\n    }\n    ${scope} .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n  `;\n};\n// src/get-preview-dom-element.ts\nvar REMOTION_STUDIO_CONTAINER_ELEMENT = \"__remotion-studio-container\";\nvar getPreviewDomElement = ()=>{\n    return document.getElementById(REMOTION_STUDIO_CONTAINER_ELEMENT);\n};\n// src/register-root.ts\nvar Root = null;\nvar listeners = [];\nvar registerRoot = (comp)=>{\n    if (!comp) {\n        throw new Error(`You must pass a React component to registerRoot(), but ${JSON.stringify(comp)} was passed.`);\n    }\n    if (Root) {\n        throw new Error(\"registerRoot() was called more than once.\");\n    }\n    Root = comp;\n    listeners.forEach((l)=>{\n        l(comp);\n    });\n};\nvar getRoot = ()=>{\n    return Root;\n};\nvar waitForRoot = (fn)=>{\n    if (Root) {\n        fn(Root);\n        return ()=>{\n            return;\n        };\n    }\n    listeners.push(fn);\n    return ()=>{\n        listeners = listeners.filter((l)=>l !== fn);\n    };\n};\n// src/RemotionRoot.tsx\n\n\nvar RemotionRoot = ({ children, numberOfAudioTags, logLevel, onlyRenderComposition, currentCompositionMetadata })=>{\n    const [remotionRootId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(random(null)));\n    const [frame, setFrame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>getInitialFrameState());\n    const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const imperativePlaying = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [fastRefreshes, setFastRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [playbackRate, setPlaybackRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const audioAndVideoTags = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    if (false) {}\n    const timelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            frame,\n            playing,\n            imperativePlaying,\n            rootId: remotionRootId,\n            playbackRate,\n            setPlaybackRate,\n            audioAndVideoTags\n        };\n    }, [\n        frame,\n        playbackRate,\n        playing,\n        remotionRootId\n    ]);\n    const setTimelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            setFrame,\n            setPlaying\n        };\n    }, []);\n    const nonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let counter = 0;\n        return {\n            getNonce: ()=>counter++,\n            fastRefreshes\n        };\n    }, [\n        fastRefreshes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            if (__webpack_module__.hot) {\n                __webpack_module__.hot.addStatusHandler((status)=>{\n                    if (status === \"idle\") {\n                        setFastRefreshes((i)=>i + 1);\n                    }\n                });\n            }\n        }\n    }, []);\n    const logging = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            logLevel,\n            mountTime: Date.now()\n        };\n    }, [\n        logLevel\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {\n        value: logging,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n            value: nonceContext,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n                value: timelineContextValue,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                    value: setTimelineContextValue,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsProvider, {\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PrefetchProvider, {\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManagerProvider, {\n                                numberOfAudioTags,\n                                onlyRenderComposition,\n                                currentCompositionMetadata,\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContextProvider, {\n                                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingProvider, {\n                                        children\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/setup-env-variables.ts\nvar getEnvVariables = ()=>{\n    if (getRemotionEnvironment().isRendering) {\n        const param = window.remotion_envVariables;\n        if (!param) {\n            return {};\n        }\n        return {\n            ...JSON.parse(param),\n            NODE_ENV: \"production\"\n        };\n    }\n    if (false) {}\n    return {\n        NODE_ENV: \"production\"\n    };\n};\nvar setupEnvVariables = ()=>{\n    const env = getEnvVariables();\n    if (!window.process) {\n        window.process = {};\n    }\n    if (!window.process.env) {\n        window.process.env = {};\n    }\n    Object.keys(env).forEach((key)=>{\n        window.process.env[key] = env[key];\n    });\n};\n// src/use-current-scale.ts\n\nvar CurrentScaleContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar PreviewSizeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setSize: ()=>{\n        return;\n    },\n    size: {\n        size: \"auto\",\n        translation: {\n            x: 0,\n            y: 0\n        }\n    }\n});\nvar calculateScale = ({ canvasSize, compositionHeight, compositionWidth, previewSize })=>{\n    const heightRatio = canvasSize.height / compositionHeight;\n    const widthRatio = canvasSize.width / compositionWidth;\n    const ratio = Math.min(heightRatio, widthRatio);\n    return previewSize === \"auto\" ? ratio : Number(previewSize);\n};\nvar useCurrentScale = (options)=>{\n    const hasContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CurrentScaleContext);\n    const zoomContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreviewSizeContext);\n    const config = useUnsafeVideoConfig();\n    if (hasContext === null || config === null || zoomContext === null) {\n        if (options?.dontThrowIfOutsideOfRemotion) {\n            return 1;\n        }\n        if (getRemotionEnvironment().isRendering) {\n            return 1;\n        }\n        throw new Error([\n            \"useCurrentScale() was called outside of a Remotion context.\",\n            \"This hook can only be called in a component that is being rendered by Remotion.\",\n            \"If you want to this hook to return 1 outside of Remotion, pass {dontThrowIfOutsideOfRemotion: true} as an option.\",\n            \"If you think you called this hook in a Remotion component, make sure all versions of Remotion are aligned.\"\n        ].join(`\n`));\n    }\n    if (hasContext.type === \"scale\") {\n        return hasContext.scale;\n    }\n    return calculateScale({\n        canvasSize: hasContext.canvasSize,\n        compositionHeight: config.height,\n        compositionWidth: config.width,\n        previewSize: zoomContext.size.size\n    });\n};\n// src/watch-static-file.ts\nvar WATCH_REMOTION_STATIC_FILES = \"remotion_staticFilesChanged\";\nvar watchStaticFile = (fileName, callback)=>{\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        throw new Error(\"watchStaticFile() has moved into the `@remotion/studio` package. Update your imports.\");\n    }\n    if (!getRemotionEnvironment().isStudio) {\n        console.warn(\"The watchStaticFile() API is only available while using the Remotion Studio.\");\n        return {\n            cancel: ()=>{\n                return;\n            }\n        };\n    }\n    const withoutStaticBase = fileName.startsWith(window.remotion_staticBase) ? fileName.replace(window.remotion_staticBase, \"\") : fileName;\n    const withoutLeadingSlash = withoutStaticBase.startsWith(\"/\") ? withoutStaticBase.slice(1) : withoutStaticBase;\n    let prevFileData = window.remotion_staticFiles.find((file)=>file.name === withoutLeadingSlash);\n    const checkFile = (event)=>{\n        const staticFiles = event.detail.files;\n        const newFileData = staticFiles.find((file)=>file.name === withoutLeadingSlash);\n        if (!newFileData) {\n            if (prevFileData !== undefined) {\n                callback(null);\n            }\n            prevFileData = undefined;\n            return;\n        }\n        if (prevFileData === undefined || prevFileData.lastModified !== newFileData.lastModified) {\n            callback(newFileData);\n            prevFileData = newFileData;\n        }\n    };\n    window.addEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n    const cancel = ()=>{\n        return window.removeEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n    };\n    return {\n        cancel\n    };\n};\n// src/wrap-remotion-context.tsx\n\n\nfunction useRemotionContexts() {\n    const compositionManagerCtx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositionManager);\n    const timelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TimelineContext);\n    const setTimelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SetTimelineContext);\n    const sequenceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceContext);\n    const nonceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NonceContext);\n    const canUseRemotionHooksContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CanUseRemotionHooks);\n    const preloadContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreloadContext);\n    const resolveCompositionContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ResolveCompositionContext);\n    const renderAssetManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RenderAssetManager);\n    const sequenceManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceManager);\n    const bufferManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(BufferingContextReact);\n    const logLevelContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            compositionManagerCtx,\n            timelineContext,\n            setTimelineContext,\n            sequenceContext,\n            nonceContext,\n            canUseRemotionHooksContext,\n            preloadContext,\n            resolveCompositionContext,\n            renderAssetManagerContext,\n            sequenceManagerContext,\n            bufferManagerContext,\n            logLevelContext\n        }), [\n        compositionManagerCtx,\n        nonceContext,\n        sequenceContext,\n        setTimelineContext,\n        timelineContext,\n        canUseRemotionHooksContext,\n        preloadContext,\n        resolveCompositionContext,\n        renderAssetManagerContext,\n        sequenceManagerContext,\n        bufferManagerContext,\n        logLevelContext\n    ]);\n}\nvar RemotionContextProvider = (props2)=>{\n    const { children, contexts } = props2;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {\n        value: contexts.logLevelContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n            value: contexts.canUseRemotionHooksContext,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n                value: contexts.nonceContext,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n                    value: contexts.preloadContext,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n                        value: contexts.compositionManagerCtx,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n                            value: contexts.sequenceManagerContext,\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n                                value: contexts.renderAssetManagerContext,\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n                                    value: contexts.resolveCompositionContext,\n                                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n                                        value: contexts.timelineContext,\n                                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                                            value: contexts.setTimelineContext,\n                                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n                                                value: contexts.sequenceContext,\n                                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n                                                    value: contexts.bufferManagerContext,\n                                                    children\n                                                })\n                                            })\n                                        })\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/internals.ts\nvar compositionSelectorRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar Internals = {\n    useUnsafeVideoConfig,\n    Timeline: exports_timeline_position_state,\n    CompositionManager,\n    CompositionSetters,\n    SequenceManager,\n    SequenceVisibilityToggleContext,\n    RemotionRoot,\n    useVideo,\n    getRoot,\n    useMediaVolumeState,\n    useMediaMutedState,\n    useLazyComponent,\n    truthy,\n    SequenceContext,\n    useRemotionContexts,\n    RemotionContextProvider,\n    CSSUtils: exports_default_css,\n    setupEnvVariables,\n    MediaVolumeContext,\n    SetMediaVolumeContext,\n    getRemotionEnvironment,\n    SharedAudioContext,\n    SharedAudioContextProvider,\n    invalidCompositionErrorMessage,\n    isCompositionIdValid,\n    getPreviewDomElement,\n    compositionsRef,\n    portalNode,\n    waitForRoot,\n    CanUseRemotionHooksProvider,\n    CanUseRemotionHooks,\n    PrefetchProvider,\n    DurationsContextProvider,\n    IsPlayerContextProvider,\n    useIsPlayer,\n    EditorPropsProvider,\n    EditorPropsContext,\n    usePreload,\n    NonceContext,\n    resolveVideoConfig,\n    useResolvedVideoConfig,\n    resolveCompositionsRef,\n    ResolveCompositionConfig,\n    REMOTION_STUDIO_CONTAINER_ELEMENT,\n    RenderAssetManager,\n    persistCurrentFrame,\n    useTimelineSetFrame,\n    isIosSafari,\n    WATCH_REMOTION_STATIC_FILES,\n    addSequenceStackTraces,\n    useMediaStartsAt,\n    BufferingProvider,\n    BufferingContextReact,\n    enableSequenceStackTraces,\n    CurrentScaleContext,\n    PreviewSizeContext,\n    calculateScale,\n    editorPropsProviderRef,\n    PROPS_UPDATED_EXTERNALLY,\n    validateRenderAsset,\n    Log,\n    LogLevelContext,\n    useLogLevel,\n    playbackLogging,\n    timeValueRef,\n    compositionSelectorRef\n};\n// src/interpolate-colors.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...args) {\n    return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n    const cachedMatchers = {\n        rgb: undefined,\n        rgba: undefined,\n        hsl: undefined,\n        hsla: undefined,\n        hex3: undefined,\n        hex4: undefined,\n        hex5: undefined,\n        hex6: undefined,\n        hex8: undefined\n    };\n    if (cachedMatchers.rgb === undefined) {\n        cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n        cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n        cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n        cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n        cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n        cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n    }\n    return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 1 / 2) {\n        return q;\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n}\nfunction hslToRgb(h, s, l) {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    const r = hue2rgb(p, q, h + 1 / 3);\n    const g = hue2rgb(p, q, h);\n    const b2 = hue2rgb(p, q, h - 1 / 3);\n    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;\n}\nfunction parse255(str) {\n    const int = Number.parseInt(str, 10);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 255) {\n        return 255;\n    }\n    return int;\n}\nfunction parse360(str) {\n    const int = Number.parseFloat(str);\n    return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n    const num = Number.parseFloat(str);\n    if (num < 0) {\n        return 0;\n    }\n    if (num > 1) {\n        return 255;\n    }\n    return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n    const int = Number.parseFloat(str);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 100) {\n        return 1;\n    }\n    return int / 100;\n}\nvar colorNames = {\n    transparent: 0,\n    aliceblue: 4042850303,\n    antiquewhite: 4209760255,\n    aqua: 16777215,\n    aquamarine: 2147472639,\n    azure: 4043309055,\n    beige: 4126530815,\n    bisque: 4293182719,\n    black: 255,\n    blanchedalmond: 4293643775,\n    blue: 65535,\n    blueviolet: 2318131967,\n    brown: 2771004159,\n    burlywood: 3736635391,\n    burntsienna: 3934150143,\n    cadetblue: 1604231423,\n    chartreuse: 2147418367,\n    chocolate: 3530104575,\n    coral: 4286533887,\n    cornflowerblue: 1687547391,\n    cornsilk: 4294499583,\n    crimson: 3692313855,\n    cyan: 16777215,\n    darkblue: 35839,\n    darkcyan: 9145343,\n    darkgoldenrod: 3095792639,\n    darkgray: 2846468607,\n    darkgreen: 6553855,\n    darkgrey: 2846468607,\n    darkkhaki: 3182914559,\n    darkmagenta: 2332068863,\n    darkolivegreen: 1433087999,\n    darkorange: 4287365375,\n    darkorchid: 2570243327,\n    darkred: 2332033279,\n    darksalmon: 3918953215,\n    darkseagreen: 2411499519,\n    darkslateblue: 1211993087,\n    darkslategray: 793726975,\n    darkslategrey: 793726975,\n    darkturquoise: 13554175,\n    darkviolet: 2483082239,\n    deeppink: 4279538687,\n    deepskyblue: 12582911,\n    dimgray: 1768516095,\n    dimgrey: 1768516095,\n    dodgerblue: 512819199,\n    firebrick: 2988581631,\n    floralwhite: 4294635775,\n    forestgreen: 579543807,\n    fuchsia: 4278255615,\n    gainsboro: 3705462015,\n    ghostwhite: 4177068031,\n    gold: 4292280575,\n    goldenrod: 3668254975,\n    gray: 2155905279,\n    green: 8388863,\n    greenyellow: 2919182335,\n    grey: 2155905279,\n    honeydew: 4043305215,\n    hotpink: 4285117695,\n    indianred: 3445382399,\n    indigo: 1258324735,\n    ivory: 4294963455,\n    khaki: 4041641215,\n    lavender: 3873897215,\n    lavenderblush: 4293981695,\n    lawngreen: 2096890111,\n    lemonchiffon: 4294626815,\n    lightblue: 2916673279,\n    lightcoral: 4034953471,\n    lightcyan: 3774873599,\n    lightgoldenrodyellow: 4210742015,\n    lightgray: 3553874943,\n    lightgreen: 2431553791,\n    lightgrey: 3553874943,\n    lightpink: 4290167295,\n    lightsalmon: 4288707327,\n    lightseagreen: 548580095,\n    lightskyblue: 2278488831,\n    lightslategray: 2005441023,\n    lightslategrey: 2005441023,\n    lightsteelblue: 2965692159,\n    lightyellow: 4294959359,\n    lime: 16711935,\n    limegreen: 852308735,\n    linen: 4210091775,\n    magenta: 4278255615,\n    maroon: 2147483903,\n    mediumaquamarine: 1724754687,\n    mediumblue: 52735,\n    mediumorchid: 3126187007,\n    mediumpurple: 2473647103,\n    mediumseagreen: 1018393087,\n    mediumslateblue: 2070474495,\n    mediumspringgreen: 16423679,\n    mediumturquoise: 1221709055,\n    mediumvioletred: 3340076543,\n    midnightblue: 421097727,\n    mintcream: 4127193855,\n    mistyrose: 4293190143,\n    moccasin: 4293178879,\n    navajowhite: 4292783615,\n    navy: 33023,\n    oldlace: 4260751103,\n    olive: 2155872511,\n    olivedrab: 1804477439,\n    orange: 4289003775,\n    orangered: 4282712319,\n    orchid: 3664828159,\n    palegoldenrod: 4008225535,\n    palegreen: 2566625535,\n    paleturquoise: 2951671551,\n    palevioletred: 3681588223,\n    papayawhip: 4293907967,\n    peachpuff: 4292524543,\n    peru: 3448061951,\n    pink: 4290825215,\n    plum: 3718307327,\n    powderblue: 2967529215,\n    purple: 2147516671,\n    rebeccapurple: 1714657791,\n    red: 4278190335,\n    rosybrown: 3163525119,\n    royalblue: 1097458175,\n    saddlebrown: 2336560127,\n    salmon: 4202722047,\n    sandybrown: 4104413439,\n    seagreen: 780883967,\n    seashell: 4294307583,\n    sienna: 2689740287,\n    silver: 3233857791,\n    skyblue: 2278484991,\n    slateblue: 1784335871,\n    slategray: 1887473919,\n    slategrey: 1887473919,\n    snow: 4294638335,\n    springgreen: 16744447,\n    steelblue: 1182971135,\n    tan: 3535047935,\n    teal: 8421631,\n    thistle: 3636451583,\n    tomato: 4284696575,\n    turquoise: 1088475391,\n    violet: 4001558271,\n    wheat: 4125012991,\n    white: 4294967295,\n    whitesmoke: 4126537215,\n    yellow: 4294902015,\n    yellowgreen: 2597139199\n};\nfunction normalizeColor(color) {\n    const matchers = getMatchers();\n    let match;\n    if (matchers.hex6) {\n        if (match = matchers.hex6.exec(color)) {\n            return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (colorNames[color] !== undefined) {\n        return colorNames[color];\n    }\n    if (matchers.rgb) {\n        if (match = matchers.rgb.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n        }\n    }\n    if (matchers.rgba) {\n        if (match = matchers.rgba.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n        }\n    }\n    if (matchers.hex3) {\n        if (match = matchers.hex3.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (matchers.hex8) {\n        if (match = matchers.hex8.exec(color)) {\n            return Number.parseInt(match[1], 16) >>> 0;\n        }\n    }\n    if (matchers.hex4) {\n        if (match = matchers.hex4.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n        }\n    }\n    if (matchers.hsl) {\n        if (match = matchers.hsl.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n        }\n    }\n    if (matchers.hsla) {\n        if (match = matchers.hsla.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n        }\n    }\n    throw new Error(`invalid color string ${color} provided`);\n}\nvar opacity = (c2)=>{\n    return (c2 >> 24 & 255) / 255;\n};\nvar red = (c2)=>{\n    return c2 >> 16 & 255;\n};\nvar green = (c2)=>{\n    return c2 >> 8 & 255;\n};\nvar blue = (c2)=>{\n    return c2 & 255;\n};\nvar rgbaColor = (r, g, b2, alpha)=>{\n    return `rgba(${r}, ${g}, ${b2}, ${alpha})`;\n};\nfunction processColor(color) {\n    const normalizedColor = normalizeColor(color);\n    return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\nvar interpolateColorsRGB = (value, inputRange, colors)=>{\n    const [r, g, b2, a2] = [\n        red,\n        green,\n        blue,\n        opacity\n    ].map((f)=>{\n        const unrounded = interpolate(value, inputRange, colors.map((c2)=>f(c2)), {\n            extrapolateLeft: \"clamp\",\n            extrapolateRight: \"clamp\"\n        });\n        if (f === opacity) {\n            return Number(unrounded.toFixed(3));\n        }\n        return Math.round(unrounded);\n    });\n    return rgbaColor(r, g, b2, a2);\n};\nvar interpolateColors = (input, inputRange, outputRange)=>{\n    if (typeof input === \"undefined\") {\n        throw new TypeError(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new TypeError(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new TypeError(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new TypeError(\"inputRange (\" + inputRange.length + \" values provided) and outputRange (\" + outputRange.length + \" values provided) must have the same length\");\n    }\n    const processedOutputRange = outputRange.map((c2)=>processColor(c2));\n    return interpolateColorsRGB(input, inputRange, processedOutputRange);\n};\n// src/validate-frame.ts\nvar validateFrame = ({ allowFloats, durationInFrames, frame })=>{\n    if (typeof frame === \"undefined\") {\n        throw new TypeError(`Argument missing for parameter \"frame\"`);\n    }\n    if (typeof frame !== \"number\") {\n        throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n    }\n    if (!Number.isFinite(frame)) {\n        throw new RangeError(`Frame ${frame} is not finite`);\n    }\n    if (frame % 1 !== 0 && !allowFloats) {\n        throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n    }\n    if (frame < 0 && frame < -durationInFrames) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n    }\n    if (frame > durationInFrames - 1) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n    }\n};\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({ src, transparent, currentTime, toneMapped })=>{\n    return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(currentTime)}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n// src/series/index.tsx\n\n// src/series/flatten-children.tsx\n\nvar flattenChildren = (children)=>{\n    const childrenArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);\n    return childrenArray.reduce((flatChildren, child)=>{\n        if (child.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            return flatChildren.concat(flattenChildren(child.props.children));\n        }\n        flatChildren.push(child);\n        return flatChildren;\n    }, []);\n};\n// src/series/is-inside-series.tsx\n\n\nvar IsInsideSeriesContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsInsideSeriesContainer = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n        value: true,\n        children\n    });\n};\nvar IsNotInsideSeriesProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n        value: false,\n        children\n    });\n};\nvar useRequireToBeInsideSeries = ()=>{\n    const isInsideSeries = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsInsideSeriesContext);\n    if (!isInsideSeries) {\n        throw new Error(\"This component must be inside a <Series /> component.\");\n    }\n};\n// src/series/index.tsx\n\nvar SeriesSequenceRefForwardingFunction = ({ children }, _ref)=>{\n    useRequireToBeInsideSeries();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsNotInsideSeriesProvider, {\n        children\n    });\n};\nvar SeriesSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SeriesSequenceRefForwardingFunction);\nvar Series = (props2)=>{\n    const childrenValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let startFrame = 0;\n        const flattenedChildren = flattenChildren(props2.children);\n        return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(flattenedChildren, (child, i)=>{\n            const castedChild = child;\n            if (typeof castedChild === \"string\") {\n                if (castedChild.trim() === \"\") {\n                    return null;\n                }\n                throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but you passed a string \"${castedChild}\"`);\n            }\n            if (castedChild.type !== SeriesSequence) {\n                throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but got ${castedChild} instead`);\n            }\n            const debugInfo = `index = ${i}, duration = ${castedChild.props.durationInFrames}`;\n            if (!castedChild?.props.children) {\n                throw new TypeError(`A <Series.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);\n            }\n            const durationInFramesProp = castedChild.props.durationInFrames;\n            const { durationInFrames, children: _children, from, name, ...passedProps } = castedChild.props;\n            if (i !== flattenedChildren.length - 1 || durationInFramesProp !== Infinity) {\n                validateDurationInFrames(durationInFramesProp, {\n                    component: `of a <Series.Sequence /> component`,\n                    allowFloats: true\n                });\n            }\n            const offset = castedChild.props.offset ?? 0;\n            if (Number.isNaN(offset)) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);\n            }\n            if (!Number.isFinite(offset)) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n            }\n            if (offset % 1 !== 0) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n            }\n            const currentStartFrame = startFrame + offset;\n            startFrame += durationInFramesProp + offset;\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n                name: name || \"<Series.Sequence>\",\n                from: currentStartFrame,\n                durationInFrames: durationInFramesProp,\n                ...passedProps,\n                ref: castedChild.ref,\n                children: child\n            });\n        });\n    }, [\n        props2.children\n    ]);\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n                ...props2,\n                children: childrenValue\n            })\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n        children: childrenValue\n    });\n};\nSeries.Sequence = SeriesSequence;\naddSequenceStackTraces(SeriesSequence);\n// src/validation/validation-spring-duration.ts\nvar validateSpringDuration = (dur)=>{\n    if (typeof dur === \"undefined\") {\n        return;\n    }\n    if (typeof dur !== \"number\") {\n        throw new TypeError(`A \"duration\" of a spring must be a \"number\" but is \"${typeof dur}\"`);\n    }\n    if (Number.isNaN(dur)) {\n        throw new TypeError('A \"duration\" of a spring is NaN, which it must not be');\n    }\n    if (!Number.isFinite(dur)) {\n        throw new TypeError('A \"duration\" of a spring must be finite, but is ' + dur);\n    }\n    if (dur <= 0) {\n        throw new TypeError('A \"duration\" of a spring must be positive, but is ' + dur);\n    }\n};\n// src/spring/spring-utils.ts\nvar defaultSpringConfig = {\n    damping: 10,\n    mass: 1,\n    stiffness: 100,\n    overshootClamping: false\n};\nvar advanceCache = {};\nfunction advance({ animation, now, config }) {\n    const { toValue, lastTimestamp, current, velocity } = animation;\n    const deltaTime = Math.min(now - lastTimestamp, 64);\n    if (config.damping <= 0) {\n        throw new Error(\"Spring damping must be greater than 0, otherwise the spring() animation will never end, causing an infinite loop.\");\n    }\n    const c2 = config.damping;\n    const m = config.mass;\n    const k = config.stiffness;\n    const cacheKey = [\n        toValue,\n        lastTimestamp,\n        current,\n        velocity,\n        c2,\n        m,\n        k,\n        now\n    ].join(\"-\");\n    if (advanceCache[cacheKey]) {\n        return advanceCache[cacheKey];\n    }\n    const v0 = -velocity;\n    const x0 = toValue - current;\n    const zeta = c2 / (2 * Math.sqrt(k * m));\n    const omega0 = Math.sqrt(k / m);\n    const omega1 = omega0 * Math.sqrt(1 - zeta ** 2);\n    const t = deltaTime / 1000;\n    const sin1 = Math.sin(omega1 * t);\n    const cos1 = Math.cos(omega1 * t);\n    const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n    const underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n    const underDampedPosition = toValue - underDampedFrag1;\n    const underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n    const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n    const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n    const criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n    const animationNode = {\n        toValue,\n        prevPosition: current,\n        lastTimestamp: now,\n        current: zeta < 1 ? underDampedPosition : criticallyDampedPosition,\n        velocity: zeta < 1 ? underDampedVelocity : criticallyDampedVelocity\n    };\n    advanceCache[cacheKey] = animationNode;\n    return animationNode;\n}\nvar calculationCache = {};\nfunction springCalculation({ frame, fps, config = {} }) {\n    const from = 0;\n    const to = 1;\n    const cacheKey = [\n        frame,\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness\n    ].join(\"-\");\n    if (calculationCache[cacheKey]) {\n        return calculationCache[cacheKey];\n    }\n    let animation = {\n        lastTimestamp: 0,\n        current: from,\n        toValue: to,\n        velocity: 0,\n        prevPosition: 0\n    };\n    const frameClamped = Math.max(0, frame);\n    const unevenRest = frameClamped % 1;\n    for(let f = 0; f <= Math.floor(frameClamped); f++){\n        if (f === Math.floor(frameClamped)) {\n            f += unevenRest;\n        }\n        const time = f / fps * 1000;\n        animation = advance({\n            animation,\n            now: time,\n            config: {\n                ...defaultSpringConfig,\n                ...config\n            }\n        });\n    }\n    calculationCache[cacheKey] = animation;\n    return animation;\n}\n// src/spring/measure-spring.ts\nvar cache = new Map;\nfunction measureSpring({ fps, config = {}, threshold = 0.005 }) {\n    if (typeof threshold !== \"number\") {\n        throw new TypeError(`threshold must be a number, got ${threshold} of type ${typeof threshold}`);\n    }\n    if (threshold === 0) {\n        return Infinity;\n    }\n    if (threshold === 1) {\n        return 0;\n    }\n    if (isNaN(threshold)) {\n        throw new TypeError(\"Threshold is NaN\");\n    }\n    if (!Number.isFinite(threshold)) {\n        throw new TypeError(\"Threshold is not finite\");\n    }\n    if (threshold < 0) {\n        throw new TypeError(\"Threshold is below 0\");\n    }\n    const cacheKey = [\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness,\n        threshold\n    ].join(\"-\");\n    if (cache.has(cacheKey)) {\n        return cache.get(cacheKey);\n    }\n    validateFps(fps, \"to the measureSpring() function\", false);\n    let frame = 0;\n    let finishedFrame = 0;\n    const calc = ()=>{\n        return springCalculation({\n            fps,\n            frame,\n            config\n        });\n    };\n    let animation = calc();\n    const calcDifference = ()=>{\n        return Math.abs(animation.current - animation.toValue);\n    };\n    let difference = calcDifference();\n    while(difference >= threshold){\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n    }\n    finishedFrame = frame;\n    for(let i = 0; i < 20; i++){\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n        if (difference >= threshold) {\n            i = 0;\n            finishedFrame = frame + 1;\n        }\n    }\n    cache.set(cacheKey, finishedFrame);\n    return finishedFrame;\n}\n// src/spring/index.ts\nfunction spring({ frame: passedFrame, fps, config = {}, from = 0, to = 1, durationInFrames: passedDurationInFrames, durationRestThreshold, delay = 0, reverse = false }) {\n    validateSpringDuration(passedDurationInFrames);\n    validateFrame({\n        frame: passedFrame,\n        durationInFrames: Infinity,\n        allowFloats: true\n    });\n    validateFps(fps, \"to spring()\", false);\n    const needsToCalculateNaturalDuration = reverse || typeof passedDurationInFrames !== \"undefined\";\n    const naturalDuration = needsToCalculateNaturalDuration ? measureSpring({\n        fps,\n        config,\n        threshold: durationRestThreshold\n    }) : undefined;\n    const naturalDurationGetter = needsToCalculateNaturalDuration ? {\n        get: ()=>naturalDuration\n    } : {\n        get: ()=>{\n            throw new Error(\"did not calculate natural duration, this is an error with Remotion. Please report\");\n        }\n    };\n    const reverseProcessed = reverse ? (passedDurationInFrames ?? naturalDurationGetter.get()) - passedFrame : passedFrame;\n    const delayProcessed = reverseProcessed + (reverse ? delay : -delay);\n    const durationProcessed = passedDurationInFrames === undefined ? delayProcessed : delayProcessed / (passedDurationInFrames / naturalDurationGetter.get());\n    if (passedDurationInFrames && delayProcessed > passedDurationInFrames) {\n        return to;\n    }\n    const spr = springCalculation({\n        fps,\n        frame: durationProcessed,\n        config\n    });\n    const inner = config.overshootClamping ? to >= from ? Math.min(spr.current, to) : Math.max(spr.current, to) : spr.current;\n    const interpolated = from === 0 && to === 1 ? inner : interpolate(inner, [\n        0,\n        1\n    ], [\n        from,\n        to\n    ]);\n    return interpolated;\n}\n// src/static-file.ts\nvar problematicCharacters = {\n    \"%3A\": \":\",\n    \"%2F\": \"/\",\n    \"%3F\": \"?\",\n    \"%23\": \"#\",\n    \"%5B\": \"[\",\n    \"%5D\": \"]\",\n    \"%40\": \"@\",\n    \"%21\": \"!\",\n    \"%24\": \"$\",\n    \"%26\": \"&\",\n    \"%27\": \"'\",\n    \"%28\": \"(\",\n    \"%29\": \")\",\n    \"%2A\": \"*\",\n    \"%2B\": \"+\",\n    \"%2C\": \",\",\n    \"%3B\": \";\"\n};\nvar didWarn2 = {};\nvar warnOnce3 = (message)=>{\n    if (didWarn2[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn2[message] = true;\n};\nvar includesHexOfUnsafeChar = (path)=>{\n    for (const key of Object.keys(problematicCharacters)){\n        if (path.includes(key)) {\n            return {\n                containsHex: true,\n                hexCode: key\n            };\n        }\n    }\n    return {\n        containsHex: false\n    };\n};\nvar trimLeadingSlash = (path)=>{\n    if (path.startsWith(\"/\")) {\n        return trimLeadingSlash(path.substring(1));\n    }\n    return path;\n};\nvar inner = (path)=>{\n    if (false) {}\n    return `/${trimLeadingSlash(path)}`;\n};\nvar encodeBySplitting = (path)=>{\n    const splitBySlash = path.split(\"/\");\n    const encodedArray = splitBySlash.map((element)=>{\n        return encodeURIComponent(element);\n    });\n    const merged = encodedArray.join(\"/\");\n    return merged;\n};\nvar staticFile = (path)=>{\n    if (path === null) {\n        throw new TypeError(\"null was passed to staticFile()\");\n    }\n    if (typeof path === \"undefined\") {\n        throw new TypeError(\"undefined was passed to staticFile()\");\n    }\n    if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n        throw new TypeError(`staticFile() does not support remote URLs - got \"${path}\". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);\n    }\n    if (path.startsWith(\"..\") || path.startsWith(\"./\")) {\n        throw new TypeError(`staticFile() does not support relative paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith(\"/Users\") || path.startsWith(\"/home\") || path.startsWith(\"/tmp\") || path.startsWith(\"/etc\") || path.startsWith(\"/opt\") || path.startsWith(\"/var\") || path.startsWith(\"C:\") || path.startsWith(\"D:\") || path.startsWith(\"E:\")) {\n        throw new TypeError(`staticFile() does not support absolute paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith(\"public/\")) {\n        throw new TypeError(`Do not include the public/ prefix when using staticFile() - got \"${path}\". See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    const includesHex = includesHexOfUnsafeChar(path);\n    if (includesHex.containsHex) {\n        warnOnce3(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);\n    }\n    const preprocessed = encodeBySplitting(path);\n    const preparsed = inner(preprocessed);\n    if (!preparsed.startsWith(\"/\")) {\n        return `/${preparsed}`;\n    }\n    return preparsed;\n};\n// src/Still.tsx\n\nvar Still = (props2)=>{\n    const newProps = {\n        ...props2,\n        durationInFrames: 1,\n        fps: 1\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Composition, newProps);\n};\n// src/video/OffthreadVideo.tsx\n\n// src/video/OffthreadVideoForRendering.tsx\n\n\nvar OffthreadVideoForRendering = ({ onError, volume: volumeProp, playbackRate, src, muted, allowAmplificationDuringRender, transparent = false, toneMapped = true, toneFrequency, name, loopVolumeCurveBehavior, delayRenderRetries, delayRenderTimeoutInMilliseconds, onVideoFrame, crossOrigin, ...props2 })=>{\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const videoConfig = useUnsafeVideoConfig();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    if (!src) {\n        throw new TypeError(\"No `src` was passed to <OffthreadVideo>.\");\n    }\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`offthreadvideo-${random(src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [\n        src,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    if (!videoConfig) {\n        throw new Error(\"No video config found\");\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!src) {\n            throw new Error(\"No src passed\");\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        if (muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        registerRenderAsset({\n            type: \"video\",\n            src: getAbsoluteSrc(src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: playbackRate ?? 1,\n            toneFrequency: toneFrequency ?? null,\n            audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n        });\n        return ()=>unregisterRenderAsset(id);\n    }, [\n        muted,\n        src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return getExpectedMediaFrameUncorrected({\n            frame,\n            playbackRate: playbackRate || 1,\n            startFrom: -mediaStartsAt\n        }) / videoConfig.fps;\n    }, [\n        frame,\n        mediaStartsAt,\n        playbackRate,\n        videoConfig.fps\n    ]);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return getOffthreadVideoSource({\n            src,\n            currentTime,\n            transparent,\n            toneMapped\n        });\n    }, [\n        toneMapped,\n        currentTime,\n        src,\n        transparent\n    ]);\n    const [imageSrc, setImageSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!window.remotion_videoEnabled) {\n            return;\n        }\n        const cleanup = [];\n        setImageSrc(null);\n        const controller = new AbortController;\n        const newHandle = delayRender(`Fetching ${actualSrc} from server`, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        });\n        const execute = async ()=>{\n            try {\n                const res = await fetch(actualSrc, {\n                    signal: controller.signal,\n                    cache: \"no-store\"\n                });\n                if (res.status !== 200) {\n                    if (res.status === 500) {\n                        const json = await res.json();\n                        if (json.error) {\n                            const cleanedUpErrorMessage = json.error.replace(/^Error: /, \"\");\n                            throw new Error(cleanedUpErrorMessage);\n                        }\n                    }\n                    throw new Error(`Server returned status ${res.status} while fetching ${actualSrc}`);\n                }\n                const blob = await res.blob();\n                const url = URL.createObjectURL(blob);\n                cleanup.push(()=>URL.revokeObjectURL(url));\n                setImageSrc({\n                    src: url,\n                    handle: newHandle\n                });\n            } catch (err) {\n                if (err.message.includes(\"aborted\")) {\n                    continueRender(newHandle);\n                    return;\n                }\n                if (controller.signal.aborted) {\n                    continueRender(newHandle);\n                    return;\n                }\n                if (err.message.includes(\"Failed to fetch\")) {\n                    err = new Error(`Failed to fetch ${actualSrc}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, {\n                        cause: err\n                    });\n                }\n                if (onError) {\n                    onError(err);\n                } else {\n                    cancelRender(err);\n                }\n            }\n        };\n        execute();\n        cleanup.push(()=>{\n            if (controller.signal.aborted) {\n                return;\n            }\n            controller.abort();\n        });\n        return ()=>{\n            cleanup.forEach((c2)=>c2());\n        };\n    }, [\n        actualSrc,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        onError\n    ]);\n    const onErr = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (onError) {\n            onError?.(new Error(\"Failed to load image with src \" + imageSrc));\n        } else {\n            cancelRender(\"Failed to load image with src \" + imageSrc);\n        }\n    }, [\n        imageSrc,\n        onError\n    ]);\n    const className = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return [\n            OFFTHREAD_VIDEO_CLASS_NAME,\n            props2.className\n        ].filter(truthy).join(\" \");\n    }, [\n        props2.className\n    ]);\n    const onImageFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((img)=>{\n        if (onVideoFrame) {\n            onVideoFrame(img);\n        }\n    }, [\n        onVideoFrame\n    ]);\n    if (!imageSrc || !window.remotion_videoEnabled) {\n        return null;\n    }\n    continueRender(imageSrc.handle);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Img, {\n        src: imageSrc.src,\n        className,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        onImageFrame,\n        ...props2,\n        onError: onErr\n    });\n};\n// src/video/VideoForPreview.tsx\n\n// src/video/emit-video-frame.ts\n\nvar useEmitVideoFrame = ({ ref, onVideoFrame })=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = ref;\n        if (!current) {\n            return;\n        }\n        if (!onVideoFrame) {\n            return;\n        }\n        let handle = 0;\n        const callback = ()=>{\n            if (!ref.current) {\n                return;\n            }\n            onVideoFrame(ref.current);\n            handle = ref.current.requestVideoFrameCallback(callback);\n        };\n        callback();\n        return ()=>{\n            current.cancelVideoFrameCallback(handle);\n        };\n    }, [\n        onVideoFrame,\n        ref\n    ]);\n};\n// src/video/VideoForPreview.tsx\n\nvar VideoForDevelopmentRefForwardingFunction = (props2, ref)=>{\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { volume, muted, playbackRate, onlyWarnForMediaSeekingError, src, onDuration, acceptableTimeShift, acceptableTimeShiftInSeconds, toneFrequency, name, _remotionInternalNativeLoopPassed, _remotionInternalStack, style, pauseWhenBuffering, showInTimeline, loopVolumeCurveBehavior, onError, onAutoPlayError, onVideoFrame, crossOrigin, ...nativeProps } = props2;\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const { fps, durationInFrames } = useVideoConfig();\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(Math.random()));\n    const isSequenceHidden = hidden[timelineId] ?? false;\n    if (typeof acceptableTimeShift !== \"undefined\") {\n        throw new Error(\"acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.\");\n    }\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    const userPreferredVolume = evaluateVolume({\n        frame: volumePropFrame,\n        volume,\n        mediaVolume\n    });\n    useMediaInTimeline({\n        mediaRef: videoRef,\n        volume,\n        mediaVolume,\n        mediaType: \"video\",\n        src,\n        playbackRate: props2.playbackRate ?? 1,\n        displayName: name ?? null,\n        id: timelineId,\n        stack: _remotionInternalStack,\n        showInTimeline,\n        premountDisplay: null,\n        onAutoPlayError: onAutoPlayError ?? null,\n        isPremounting: Boolean(parentSequence?.premounting)\n    });\n    useSyncVolumeWithMediaTag({\n        volumePropFrame,\n        volume,\n        mediaVolume,\n        mediaRef: videoRef\n    });\n    useAmplification({\n        logLevel,\n        mediaRef: videoRef,\n        volume: userPreferredVolume\n    });\n    useMediaPlayback({\n        mediaRef: videoRef,\n        src,\n        mediaType: \"video\",\n        playbackRate: props2.playbackRate ?? 1,\n        onlyWarnForMediaSeekingError,\n        acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,\n        isPremounting: Boolean(parentSequence?.premounting),\n        pauseWhenBuffering,\n        onAutoPlayError: onAutoPlayError ?? null,\n        userPreferredVolume\n    });\n    const actualFrom = parentSequence ? parentSequence.relativeFrom : 0;\n    const duration = parentSequence ? Math.min(parentSequence.durationInFrames, durationInFrames) : durationInFrames;\n    const preloadedSrc = usePreload(src);\n    const actualSrc = useAppendVideoFragment({\n        actualSrc: preloadedSrc,\n        actualFrom,\n        duration,\n        fps\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return videoRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>playbackLogging({\n            logLevel,\n            message: `Mounting video with source = ${actualSrc}, v=${VERSION}, user agent=${typeof navigator === \"undefined\" ? \"server\" : navigator.userAgent}`,\n            tag: \"video\",\n            mountTime\n        }));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        const errorHandler = ()=>{\n            if (current.error) {\n                console.error(\"Error occurred in video\", current?.error);\n                if (onError) {\n                    const err = new Error(`Code ${current.error.code}: ${current.error.message}`);\n                    onError(err);\n                    return;\n                }\n                throw new Error(`The browser threw an error while playing the video ${src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n            } else {\n                if (onError) {\n                    const err = new Error(`The browser threw an error while playing the video ${src}`);\n                    onError(err);\n                    return;\n                }\n                throw new Error(\"The browser threw an error while playing the video\");\n            }\n        };\n        current.addEventListener(\"error\", errorHandler, {\n            once: true\n        });\n        return ()=>{\n            current.removeEventListener(\"error\", errorHandler);\n        };\n    }, [\n        onError,\n        src\n    ]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);\n    currentOnDurationCallback.current = onDuration;\n    useEmitVideoFrame({\n        ref: videoRef,\n        onVideoFrame\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        if (current.duration) {\n            currentOnDurationCallback.current?.(src, current.duration);\n            return;\n        }\n        const onLoadedMetadata = ()=>{\n            currentOnDurationCallback.current?.(src, current.duration);\n        };\n        current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n        return ()=>{\n            current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n        };\n    }, [\n        src\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        if (isIosSafari()) {\n            current.preload = \"metadata\";\n        } else {\n            current.preload = \"auto\";\n        }\n    }, []);\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...style,\n            opacity: isSequenceHidden ? 0 : style?.opacity ?? 1\n        };\n    }, [\n        isSequenceHidden,\n        style\n    ]);\n    const crossOriginValue = crossOrigin ?? (onVideoFrame ? \"anonymous\" : undefined);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n        ref: videoRef,\n        muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n        playsInline: true,\n        src: actualSrc,\n        loop: _remotionInternalNativeLoopPassed,\n        style: actualStyle,\n        disableRemotePlayback: true,\n        crossOrigin: crossOriginValue,\n        ...nativeProps\n    });\n};\nvar VideoForPreview = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForDevelopmentRefForwardingFunction);\n// src/video/OffthreadVideo.tsx\n\nvar OffthreadVideo = (props2)=>{\n    const { startFrom, endAt, name, pauseWhenBuffering, stack, showInTimeline, ...otherProps } = props2;\n    const environment = getRemotionEnvironment();\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return;\n    }, []);\n    if (typeof props2.src !== \"string\") {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n    }\n    if (props2.imageFormat) {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag does no longer accept \\`imageFormat\\`. Use the \\`transparent\\` prop if you want to render a transparent video.`);\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideo, {\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps\n            })\n        });\n    }\n    validateMediaProps(props2, \"Video\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideoForRendering, {\n            ...otherProps\n        });\n    }\n    const { transparent, toneMapped, onAutoPlayError, onVideoFrame, crossOrigin, delayRenderRetries, delayRenderTimeoutInMilliseconds, ...propsForPreview } = otherProps;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n        _remotionInternalStack: stack ?? null,\n        _remotionInternalNativeLoopPassed: false,\n        onDuration,\n        onlyWarnForMediaSeekingError: true,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        showInTimeline: showInTimeline ?? true,\n        onAutoPlayError: onAutoPlayError ?? undefined,\n        onVideoFrame: onVideoFrame ?? null,\n        crossOrigin,\n        ...propsForPreview\n    });\n};\n// src/video/Video.tsx\n\n// src/video/VideoForRendering.tsx\n\n// src/video/seek-until-right.ts\nvar roundTo6Commas = (num)=>{\n    return Math.round(num * 1e5) / 1e5;\n};\nvar seekToTime = ({ element, desiredTime, logLevel, mountTime })=>{\n    if (isApproximatelyTheSame(element.currentTime, desiredTime)) {\n        return {\n            wait: Promise.resolve(desiredTime),\n            cancel: ()=>{}\n        };\n    }\n    seek({\n        logLevel,\n        mediaRef: element,\n        time: desiredTime,\n        why: \"Seeking during rendering\",\n        mountTime\n    });\n    let cancel;\n    let cancelSeeked = null;\n    const prom = new Promise((resolve)=>{\n        cancel = element.requestVideoFrameCallback((now, metadata)=>{\n            const displayIn = metadata.expectedDisplayTime - now;\n            if (displayIn <= 0) {\n                resolve(metadata.mediaTime);\n                return;\n            }\n            setTimeout(()=>{\n                resolve(metadata.mediaTime);\n            }, displayIn + 150);\n        });\n    });\n    const waitForSeekedEvent = new Promise((resolve)=>{\n        const onDone = ()=>{\n            resolve();\n        };\n        element.addEventListener(\"seeked\", onDone, {\n            once: true\n        });\n        cancelSeeked = ()=>{\n            element.removeEventListener(\"seeked\", onDone);\n        };\n    });\n    return {\n        wait: Promise.all([\n            prom,\n            waitForSeekedEvent\n        ]).then(([time])=>time),\n        cancel: ()=>{\n            cancelSeeked?.();\n            element.cancelVideoFrameCallback(cancel);\n        }\n    };\n};\nvar seekToTimeMultipleUntilRight = ({ element, desiredTime, fps, logLevel, mountTime })=>{\n    const threshold = 1 / fps / 2;\n    let currentCancel = ()=>{\n        return;\n    };\n    if (Number.isFinite(element.duration) && element.currentTime >= element.duration && desiredTime >= element.duration) {\n        return {\n            prom: Promise.resolve(),\n            cancel: ()=>{}\n        };\n    }\n    const prom = new Promise((resolve, reject)=>{\n        const firstSeek = seekToTime({\n            element,\n            desiredTime: desiredTime + threshold,\n            logLevel,\n            mountTime\n        });\n        firstSeek.wait.then((seekedTo)=>{\n            const difference = Math.abs(desiredTime - seekedTo);\n            if (difference <= threshold) {\n                return resolve();\n            }\n            const sign = desiredTime > seekedTo ? 1 : -1;\n            const newSeek = seekToTime({\n                element,\n                desiredTime: seekedTo + threshold * sign,\n                logLevel,\n                mountTime\n            });\n            currentCancel = newSeek.cancel;\n            newSeek.wait.then((newTime)=>{\n                const newDifference = Math.abs(desiredTime - newTime);\n                if (roundTo6Commas(newDifference) <= roundTo6Commas(threshold)) {\n                    return resolve();\n                }\n                const thirdSeek = seekToTime({\n                    element,\n                    desiredTime: desiredTime + threshold,\n                    logLevel,\n                    mountTime\n                });\n                currentCancel = thirdSeek.cancel;\n                return thirdSeek.wait.then(()=>{\n                    resolve();\n                }).catch((err)=>{\n                    reject(err);\n                });\n            }).catch((err)=>{\n                reject(err);\n            });\n        });\n        currentCancel = firstSeek.cancel;\n    });\n    return {\n        prom,\n        cancel: ()=>{\n            currentCancel();\n        }\n    };\n};\n// src/video/VideoForRendering.tsx\n\nvar VideoForRenderingForwardFunction = ({ onError, volume: volumeProp, allowAmplificationDuringRender, playbackRate, onDuration, toneFrequency, name, acceptableTimeShiftInSeconds, delayRenderRetries, delayRenderTimeoutInMilliseconds, loopVolumeCurveBehavior, ...props2 }, ref)=>{\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const videoConfig = useUnsafeVideoConfig();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const environment = getRemotionEnvironment();\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`video-${random(props2.src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [\n        props2.src,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    if (!videoConfig) {\n        throw new Error(\"No video config found\");\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!props2.src) {\n            throw new Error(\"No src passed\");\n        }\n        if (props2.muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        registerRenderAsset({\n            type: \"video\",\n            src: getAbsoluteSrc(props2.src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: playbackRate ?? 1,\n            toneFrequency: toneFrequency ?? null,\n            audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n        });\n        return ()=>unregisterRenderAsset(id);\n    }, [\n        props2.muted,\n        props2.src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return videoRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!window.remotion_videoEnabled) {\n            return;\n        }\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        const currentTime = getMediaTime({\n            frame,\n            playbackRate: playbackRate || 1,\n            startFrom: -mediaStartsAt,\n            fps: videoConfig.fps\n        });\n        const handle = delayRender(`Rendering <Video /> with src=\"${props2.src}\" at time ${currentTime}`, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        });\n        if (window.process?.env?.NODE_ENV === \"test\") {\n            continueRender(handle);\n            return;\n        }\n        if (isApproximatelyTheSame(current.currentTime, currentTime)) {\n            if (current.readyState >= 2) {\n                continueRender(handle);\n                return;\n            }\n            const loadedDataHandler = ()=>{\n                continueRender(handle);\n            };\n            current.addEventListener(\"loadeddata\", loadedDataHandler, {\n                once: true\n            });\n            return ()=>{\n                current.removeEventListener(\"loadeddata\", loadedDataHandler);\n            };\n        }\n        const endedHandler = ()=>{\n            continueRender(handle);\n        };\n        const seek2 = seekToTimeMultipleUntilRight({\n            element: current,\n            desiredTime: currentTime,\n            fps: videoConfig.fps,\n            logLevel,\n            mountTime\n        });\n        seek2.prom.then(()=>{\n            continueRender(handle);\n        });\n        current.addEventListener(\"ended\", endedHandler, {\n            once: true\n        });\n        const errorHandler = ()=>{\n            if (current?.error) {\n                console.error(\"Error occurred in video\", current?.error);\n                if (onError) {\n                    return;\n                }\n                throw new Error(`The browser threw an error while playing the video ${props2.src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n            } else {\n                throw new Error(\"The browser threw an error\");\n            }\n        };\n        current.addEventListener(\"error\", errorHandler, {\n            once: true\n        });\n        return ()=>{\n            seek2.cancel();\n            current.removeEventListener(\"ended\", endedHandler);\n            current.removeEventListener(\"error\", errorHandler);\n            continueRender(handle);\n        };\n    }, [\n        volumePropsFrame,\n        props2.src,\n        playbackRate,\n        videoConfig.fps,\n        frame,\n        mediaStartsAt,\n        onError,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        logLevel,\n        mountTime\n    ]);\n    const { src } = props2;\n    if (environment.isRendering) {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n            if (window.process?.env?.NODE_ENV === \"test\") {\n                return;\n            }\n            const newHandle = delayRender(\"Loading <Video> duration with src=\" + src, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            });\n            const { current } = videoRef;\n            const didLoad = ()=>{\n                if (current?.duration) {\n                    onDuration(src, current.duration);\n                }\n                continueRender(newHandle);\n            };\n            if (current?.duration) {\n                onDuration(src, current.duration);\n                continueRender(newHandle);\n            } else {\n                current?.addEventListener(\"loadedmetadata\", didLoad, {\n                    once: true\n                });\n            }\n            return ()=>{\n                current?.removeEventListener(\"loadedmetadata\", didLoad);\n                continueRender(newHandle);\n            };\n        }, [\n            src,\n            onDuration,\n            delayRenderRetries,\n            delayRenderTimeoutInMilliseconds\n        ]);\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n        ref: videoRef,\n        disableRemotePlayback: true,\n        ...props2\n    });\n};\nvar VideoForRendering = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForRenderingForwardFunction);\n// src/video/Video.tsx\n\nvar VideoForwardingFunction = (props2, ref)=>{\n    const { startFrom, endAt, name, pauseWhenBuffering, stack, _remotionInternalNativeLoopPassed, showInTimeline, onAutoPlayError, ...otherProps } = props2;\n    const { loop, ...propsOtherThanLoop } = props2;\n    const { fps } = useVideoConfig();\n    const environment = getRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof ref === \"string\") {\n        throw new Error(\"string refs are not supported\");\n    }\n    if (typeof props2.src !== \"string\") {\n        throw new TypeError(`The \\`<Video>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n    }\n    const preloadedSrc = usePreload(props2.src);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds)=>{\n        setDurations({\n            type: \"got-duration\",\n            durationInSeconds,\n            src\n        });\n    }, [\n        setDurations\n    ]);\n    const onVideoFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{}, []);\n    const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props2.src)];\n    if (loop && durationFetched !== undefined) {\n        if (!Number.isFinite(durationFetched)) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            });\n        }\n        const mediaDuration = durationFetched * fps;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n            durationInFrames: calculateLoopDuration({\n                endAt,\n                mediaDuration,\n                playbackRate: props2.playbackRate ?? 1,\n                startFrom\n            }),\n            layout: \"none\",\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            })\n        });\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps,\n                ref\n            })\n        });\n    }\n    validateMediaProps(props2, \"Video\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForRendering, {\n            onDuration,\n            onVideoFrame: onVideoFrame ?? null,\n            ...otherProps,\n            ref\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n        onlyWarnForMediaSeekingError: false,\n        ...otherProps,\n        ref,\n        onVideoFrame: null,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        onDuration,\n        _remotionInternalStack: stack ?? null,\n        _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,\n        showInTimeline: showInTimeline ?? true,\n        onAutoPlayError: onAutoPlayError ?? undefined\n    });\n};\nvar Video = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForwardingFunction);\naddSequenceStackTraces(Video);\n// src/index.ts\ncheckMultipleRemotionVersions();\nvar Experimental = {\n    Clipper,\n    Null,\n    useIsPlayer\n};\nvar proxyObj = {};\nvar Config = new Proxy(proxyObj, {\n    get (_, prop) {\n        if (prop === \"Bundling\" || prop === \"Rendering\" || prop === \"Log\" || prop === \"Puppeteer\" || prop === \"Output\") {\n            return Config;\n        }\n        return ()=>{\n            console.warn(\"⚠️  The CLI configuration has been extracted from Remotion Core.\");\n            console.warn(\"Update the import from the config file:\");\n            console.warn();\n            console.warn(\"- Delete:\");\n            console.warn('import {Config} from \"remotion\";');\n            console.warn(\"+ Replace:\");\n            console.warn('import {Config} from \"@remotion/cli/config\";');\n            console.warn();\n            console.warn(\"For more information, see https://www.remotion.dev/docs/4-0-migration.\");\n            process.exit(1);\n        };\n    }\n});\naddSequenceStackTraces(Sequence);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmTCxVQUFVSSxRQUFRRSxNQUFNO1FBQ3RCQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFDZEUsWUFBWTtRQUNaQyxjQUFjO1FBQ2RDLEtBQUssQ0FBQ0MsV0FBYU4sR0FBRyxDQUFDQyxLQUFLLEdBQUcsSUFBTUs7SUFDdkM7QUFDSjtBQUVBLG9CQUFvQjtBQUNrQjtBQUN0QyxJQUFJLE9BQU9DLGdEQUFhQSxLQUFLLFlBQVk7SUFDdkMsTUFBTUMsTUFBTTtRQUNWO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsTUFBTSxJQUFJQyxNQUFNRCxJQUFJRSxJQUFJLENBQUMsQ0FBQztBQUM1QixDQUFDO0FBQ0Q7QUFFQSxrQkFBa0I7QUFDbEIsSUFBSUMsVUFBVTtJQUNaLE1BQU0sSUFBSUYsTUFBTTtBQUNsQjtBQUVBLHNDQUFzQztBQUNaO0FBRTFCLGtDQUFrQztBQUNsQyxTQUFTSTtJQUNQLE9BQU87UUFBQztRQUFPO1FBQVE7S0FBSSxDQUFDSCxJQUFJLENBQUM7QUFDbkM7QUFDQSxJQUFJSSxlQUFlO0lBQ2pCLE9BQU87UUFBQztRQUFLO0tBQUssQ0FBQ0osSUFBSSxDQUFDO0FBQzFCO0FBQ0EsSUFBSUsseUJBQXlCO0lBQzNCLE1BQU1DLFdBQVcsTUFBNkIsSUFBSUMsQ0FBd0I7SUFDMUUsTUFBTUUsY0FBYyxNQUFtSCxJQUFLRixDQUFBQSxDQUErTjtJQUMzVyxNQUFNTSxXQUFXLE1BQTZCLElBQUlOLENBQXdCO0lBQzFFLE1BQU1RLG1CQUFtQixNQUE2QixJQUFJUixDQUFn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QUNielQ7UUFDRjtJQUNGO0lBQ0EsT0FBTyxhQUFhLEdBQUc2b0Qsc0RBQUtBLENBQUN4QyxpQkFBaUI7UUFDNUNyeEIsOEJBQThCO1FBQzlCLEdBQUd2aEIsVUFBVTtRQUNielQ7UUFDQXVrRCxjQUFjO1FBQ2Q3MUIsb0JBQW9CQSxzQkFBc0I7UUFDMUNvTjtRQUNBbnFCLHdCQUF3QnBVLFNBQVM7UUFDakMwK0IsbUNBQW1DQSxxQ0FBcUM7UUFDeEV6cUIsZ0JBQWdCQSxrQkFBa0I7UUFDbEN5WSxpQkFBaUJBLG1CQUFtQjNwQjtJQUN0QztBQUNGO0FBQ0EsSUFBSXlvRCxzQkFBUXJDLGlEQUFZQSxDQUFDb0M7QUFDekJyckQsdUJBQXVCc3JEO0FBQ3ZCLGVBQWU7QUFDZnZxRDtBQUNBLElBQUl3cUQsZUFBZTtJQUNqQnZ0RDtJQUNBcUQ7SUFDQVY7QUFDRjtBQUNBLElBQUk2cUQsV0FBVyxDQUFDO0FBQ2hCLElBQUlDLFNBQVMsSUFBSXBzRCxNQUFNbXNELFVBQVU7SUFDL0JqdUQsS0FBSTZNLENBQUMsRUFBRXNoRCxJQUFJO1FBQ1QsSUFBSUEsU0FBUyxjQUFjQSxTQUFTLGVBQWVBLFNBQVMsU0FBU0EsU0FBUyxlQUFlQSxTQUFTLFVBQVU7WUFDOUcsT0FBT0Q7UUFDVDtRQUNBLE9BQU87WUFDTC9nRCxRQUFRQyxJQUFJLENBQUM7WUFDYkQsUUFBUUMsSUFBSSxDQUFDO1lBQ2JELFFBQVFDLElBQUk7WUFDWkQsUUFBUUMsSUFBSSxDQUFDO1lBQ2JELFFBQVFDLElBQUksQ0FBQztZQUNiRCxRQUFRQyxJQUFJLENBQUM7WUFDYkQsUUFBUUMsSUFBSSxDQUFDO1lBQ2JELFFBQVFDLElBQUk7WUFDWkQsUUFBUUMsSUFBSSxDQUFDO1lBQ2JsTSxRQUFRa3RELElBQUksQ0FBQztRQUNmO0lBQ0Y7QUFDRjtBQUNBM3JELHVCQUF1Qm9XO0FBMENyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaXBqcy8uL25vZGVfbW9kdWxlcy9yZW1vdGlvbi9kaXN0L2VzbS9pbmRleC5tanM/N2Q0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIGdldDogYWxsW25hbWVdLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogKG5ld1ZhbHVlKSA9PiBhbGxbbmFtZV0gPSAoKSA9PiBuZXdWYWx1ZVxuICAgIH0pO1xufTtcblxuLy8gc3JjL19jaGVjay1yc2MudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbmlmICh0eXBlb2YgY3JlYXRlQ29udGV4dCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIGNvbnN0IGVyciA9IFtcbiAgICAnUmVtb3Rpb24gcmVxdWlyZXMgUmVhY3QuY3JlYXRlQ29udGV4dCwgYnV0IGl0IGlzIFwidW5kZWZpbmVkXCIuJyxcbiAgICAnSWYgeW91IGFyZSBpbiBhIFJlYWN0IFNlcnZlciBDb21wb25lbnQsIHR1cm4gaXQgaW50byBhIGNsaWVudCBjb21wb25lbnQgYnkgYWRkaW5nIFwidXNlIGNsaWVudFwiIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUuJyxcbiAgICBcIlwiLFxuICAgIFwiQmVmb3JlOlwiLFxuICAgICcgIGltcG9ydCB7dXNlQ3VycmVudEZyYW1lfSBmcm9tIFwicmVtb3Rpb25cIjsnLFxuICAgIFwiXCIsXG4gICAgXCJBZnRlcjpcIixcbiAgICAnICBcInVzZSBjbGllbnRcIjsnLFxuICAgICcgIGltcG9ydCB7dXNlQ3VycmVudEZyYW1lfSBmcm9tIFwicmVtb3Rpb25cIjsnXG4gIF07XG4gIHRocm93IG5ldyBFcnJvcihlcnIuam9pbihgXG5gKSk7XG59XG5cbi8vIHNyYy9DbGlwcGVyLnRzeFxudmFyIENsaXBwZXIgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIjxDbGlwcGVyPiBoYXMgYmVlbiByZW1vdmVkIGFzIG9mIFJlbW90aW9uIHY0LjAuMjI4LiBUaGUgbmF0aXZlIGNsaXBwaW5nIEFQSXMgd2VyZSBleHBlcmltZW50YWwgYW5kIHN1YmplY3QgdG8gcmVtb3ZhbCBhdCBhbnkgdGltZS4gV2UgcmVtb3ZlZCB0aGVtIGJlY2F1c2UgdGhleSB3ZXJlIHNwYXJpbmdseSB1c2VkIGFuZCBtYWRlIHJlbmRlcmluZyBvZnRlbiBzbG93ZXIgcmF0aGVyIHRoYW4gZmFzdGVyLlwiKTtcbn07XG5cbi8vIHNyYy9lbmFibGUtc2VxdWVuY2Utc3RhY2stdHJhY2VzLnRzXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9nZXQtcmVtb3Rpb24tZW52aXJvbm1lbnQudHNcbmZ1bmN0aW9uIGdldE5vZGVFbnZTdHJpbmcoKSB7XG4gIHJldHVybiBbXCJOT0RcIiwgXCJFX0VOXCIsIFwiVlwiXS5qb2luKFwiXCIpO1xufVxudmFyIGdldEVudlN0cmluZyA9ICgpID0+IHtcbiAgcmV0dXJuIFtcImVcIiwgXCJudlwiXS5qb2luKFwiXCIpO1xufTtcbnZhciBnZXRSZW1vdGlvbkVudmlyb25tZW50ID0gKCkgPT4ge1xuICBjb25zdCBpc1BsYXllciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2lzUGxheWVyO1xuICBjb25zdCBpc1JlbmRlcmluZyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5wcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cucHJvY2Vzcy5lbnYgIT09IFwidW5kZWZpbmVkXCIgJiYgKHdpbmRvdy5wcm9jZXNzW2dldEVudlN0cmluZygpXVtnZXROb2RlRW52U3RyaW5nKCldID09PSBcInRlc3RcIiB8fCB3aW5kb3cucHJvY2Vzc1tnZXRFbnZTdHJpbmcoKV1bZ2V0Tm9kZUVudlN0cmluZygpXSA9PT0gXCJwcm9kdWN0aW9uXCIgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnJlbW90aW9uX3B1cHBldGVlclRpbWVvdXQgIT09IFwidW5kZWZpbmVkXCIpO1xuICBjb25zdCBpc1N0dWRpbyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2lzU3R1ZGlvO1xuICBjb25zdCBpc1JlYWRPbmx5U3R1ZGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faXNSZWFkT25seVN0dWRpbztcbiAgcmV0dXJuIHtcbiAgICBpc1N0dWRpbyxcbiAgICBpc1JlbmRlcmluZyxcbiAgICBpc1BsYXllcixcbiAgICBpc1JlYWRPbmx5U3R1ZGlvXG4gIH07XG59O1xuXG4vLyBzcmMvZW5hYmxlLXNlcXVlbmNlLXN0YWNrLXRyYWNlcy50c1xudmFyIG9yaWdpbmFsQ3JlYXRlRWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQ7XG52YXIgY29tcG9uZW50c1RvQWRkU3RhY2tzVG8gPSBbXTtcbnZhciBlbmFibGVTZXF1ZW5jZVN0YWNrVHJhY2VzID0gKCkgPT4ge1xuICBpZiAoIWdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1N0dWRpbykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShvcmlnaW5hbENyZWF0ZUVsZW1lbnQsIHtcbiAgICBhcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ0FycmF5KSB7XG4gICAgICBpZiAoY29tcG9uZW50c1RvQWRkU3RhY2tzVG8uaW5jbHVkZXMoYXJnQXJyYXlbMF0pKSB7XG4gICAgICAgIGNvbnN0IFtmaXJzdCwgcHJvcHMsIC4uLnJlc3RdID0gYXJnQXJyYXk7XG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0ge1xuICAgICAgICAgIC4uLnByb3BzID8/IHt9LFxuICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFja1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIFtmaXJzdCwgbmV3UHJvcHMsIC4uLnJlc3RdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LmNyZWF0ZUVsZW1lbnQgPSBwcm94eTtcbn07XG52YXIgYWRkU2VxdWVuY2VTdGFja1RyYWNlcyA9IChjb21wb25lbnQpID0+IHtcbiAgY29tcG9uZW50c1RvQWRkU3RhY2tzVG8ucHVzaChjb21wb25lbnQpO1xuICBlbmFibGVTZXF1ZW5jZVN0YWNrVHJhY2VzKCk7XG59O1xuXG4vLyBzcmMvaXMtcGxheWVyLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MiwgdXNlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSXNQbGF5ZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDIoZmFsc2UpO1xudmFyIElzUGxheWVyQ29udGV4dFByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW5cbn0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goSXNQbGF5ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHRydWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZUlzUGxheWVyID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChJc1BsYXllckNvbnRleHQpO1xufTtcblxuLy8gc3JjL3RydXRoeS50c1xuZnVuY3Rpb24gdHJ1dGh5KHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbn1cblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBWRVJTSU9OID0gXCI0LjAuMjkwXCI7XG5cbi8vIHNyYy9tdWx0aXBsZS12ZXJzaW9ucy13YXJuaW5nLnRzXG52YXIgY2hlY2tNdWx0aXBsZVJlbW90aW9uVmVyc2lvbnMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZXQgPSAoKSA9PiB7XG4gICAgZ2xvYmFsVGhpcy5yZW1vdGlvbl9pbXBvcnRlZCA9IFZFUlNJT047XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdGlvbl9pbXBvcnRlZCA9IFZFUlNJT047XG4gICAgfVxuICB9O1xuICBjb25zdCBhbHJlYWR5SW1wb3J0ZWQgPSBnbG9iYWxUaGlzLnJlbW90aW9uX2ltcG9ydGVkIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2ltcG9ydGVkO1xuICBpZiAoYWxyZWFkeUltcG9ydGVkKSB7XG4gICAgaWYgKGFscmVhZHlJbXBvcnRlZCA9PT0gVkVSU0lPTikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFscmVhZHlJbXBvcnRlZCA9PT0gXCJzdHJpbmdcIiAmJiBhbHJlYWR5SW1wb3J0ZWQuaW5jbHVkZXMoXCJ3ZWJjb2RlY3NcIikpIHtcbiAgICAgIHNldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcXHVEODNEXFx1REVBOCBNdWx0aXBsZSB2ZXJzaW9ucyBvZiBSZW1vdGlvbiBkZXRlY3RlZDogJHtbXG4gICAgICBWRVJTSU9OLFxuICAgICAgdHlwZW9mIGFscmVhZHlJbXBvcnRlZCA9PT0gXCJzdHJpbmdcIiA/IGFscmVhZHlJbXBvcnRlZCA6IFwiYW4gb2xkZXIgdmVyc2lvblwiXG4gICAgXS5maWx0ZXIodHJ1dGh5KS5qb2luKFwiIGFuZCBcIil9LiBUaGlzIHdpbGwgY2F1c2UgdGhpbmdzIHRvIGJyZWFrIGluIGFuIHVuZXhwZWN0ZWQgd2F5LlxuQ2hlY2sgdGhhdCBhbGwgeW91ciBSZW1vdGlvbiBwYWNrYWdlcyBhcmUgb24gdGhlIHNhbWUgdmVyc2lvbi4gSWYgeW91ciBkZXBlbmRlbmNpZXMgZGVwZW5kIG9uIFJlbW90aW9uLCBtYWtlIHRoZW0gcGVlciBkZXBlbmRlbmNpZXMuIFlvdSBjYW4gYWxzbyBydW4gXFxgbnB4IHJlbW90aW9uIHZlcnNpb25zXFxgIGZyb20geW91ciB0ZXJtaW5hbCB0byBzZWUgd2hpY2ggdmVyc2lvbnMgYXJlIG1pc21hdGNoaW5nLmApO1xuICB9XG4gIHNldCgpO1xufTtcblxuLy8gc3JjL051bGwudHN4XG52YXIgTnVsbCA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiPE51bGw+IGhhcyBiZWVuIHJlbW92ZWQgYXMgb2YgUmVtb3Rpb24gdjQuMC4yMjguIFRoZSBuYXRpdmUgY2xpcHBpbmcgQVBJcyB3ZXJlIGV4cGVyaW1lbnRhbCBhbmQgc3ViamVjdCB0byByZW1vdmFsIGF0IGFueSB0aW1lLiBXZSByZW1vdmVkIHRoZW0gYmVjYXVzZSB0aGV5IHdlcmUgc3BhcmluZ2x5IHVzZWQgYW5kIG1hZGUgcmVuZGVyaW5nIG9mdGVuIHNsb3dlciByYXRoZXIgdGhhbiBmYXN0ZXIuXCIpO1xufTtcblxuLy8gc3JjL1NlcXVlbmNlLnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmMixcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTAsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLFxuICB1c2VNZW1vIGFzIHVzZU1lbW85LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTRcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9BYnNvbHV0ZUZpbGwudHN4XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGhhc1RhaWx3aW5kQ2xhc3NOYW1lID0gKGNsYXNzTmFtZSwgY2xhc3NQcmVmaXgpID0+IHtcbiAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNsYXNzUHJlZml4LnNvbWUoKHByZWZpeCkgPT4ge1xuICAgIHJldHVybiBjbGFzc05hbWUuc3RhcnRzV2l0aChwcmVmaXgpIHx8IGNsYXNzTmFtZS5pbmNsdWRlcyhgICR7cHJlZml4fWApIHx8IGNsYXNzTmFtZS5pbmNsdWRlcyhgOiR7cHJlZml4fWApO1xuICB9KTtcbn07XG52YXIgQWJzb2x1dGVGaWxsUmVmRm9yd2FyZGluZyA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHsgc3R5bGUsIC4uLm90aGVyIH0gPSBwcm9wcztcbiAgY29uc3QgYWN0dWFsU3R5bGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIHRvcDogaGFzVGFpbHdpbmRDbGFzc05hbWUob3RoZXIuY2xhc3NOYW1lLCBbXCJ0b3AtXCIsIFwiaW5zZXQtXCJdKSA/IHVuZGVmaW5lZCA6IDAsXG4gICAgICBsZWZ0OiBoYXNUYWlsd2luZENsYXNzTmFtZShvdGhlci5jbGFzc05hbWUsIFtcImxlZnQtXCIsIFwiaW5zZXQtXCJdKSA/IHVuZGVmaW5lZCA6IDAsXG4gICAgICByaWdodDogaGFzVGFpbHdpbmRDbGFzc05hbWUob3RoZXIuY2xhc3NOYW1lLCBbXCJyaWdodC1cIiwgXCJpbnNldC1cIl0pID8gdW5kZWZpbmVkIDogMCxcbiAgICAgIGJvdHRvbTogaGFzVGFpbHdpbmRDbGFzc05hbWUob3RoZXIuY2xhc3NOYW1lLCBbXCJib3R0b20tXCIsIFwiaW5zZXQtXCJdKSA/IHVuZGVmaW5lZCA6IDAsXG4gICAgICB3aWR0aDogaGFzVGFpbHdpbmRDbGFzc05hbWUob3RoZXIuY2xhc3NOYW1lLCBbXCJ3LVwiXSkgPyB1bmRlZmluZWQgOiBcIjEwMCVcIixcbiAgICAgIGhlaWdodDogaGFzVGFpbHdpbmRDbGFzc05hbWUob3RoZXIuY2xhc3NOYW1lLCBbXCJoLVwiXSkgPyB1bmRlZmluZWQgOiBcIjEwMCVcIixcbiAgICAgIGRpc3BsYXk6IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKG90aGVyLmNsYXNzTmFtZSwgW1xuICAgICAgICBcImJsb2NrXCIsXG4gICAgICAgIFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIFwiaW5saW5lXCIsXG4gICAgICAgIFwiZmxleFwiLFxuICAgICAgICBcImlubGluZS1mbGV4XCIsXG4gICAgICAgIFwiZmxvdy1yb290XCIsXG4gICAgICAgIFwiZ3JpZFwiLFxuICAgICAgICBcImlubGluZS1ncmlkXCIsXG4gICAgICAgIFwiY29udGVudHNcIixcbiAgICAgICAgXCJsaXN0LWl0ZW1cIixcbiAgICAgICAgXCJoaWRkZW5cIlxuICAgICAgXSkgPyB1bmRlZmluZWQgOiBcImZsZXhcIixcbiAgICAgIGZsZXhEaXJlY3Rpb246IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKG90aGVyLmNsYXNzTmFtZSwgW1xuICAgICAgICBcImZsZXgtcm93XCIsXG4gICAgICAgIFwiZmxleC1jb2xcIixcbiAgICAgICAgXCJmbGV4LXJvdy1yZXZlcnNlXCIsXG4gICAgICAgIFwiZmxleC1jb2wtcmV2ZXJzZVwiXG4gICAgICBdKSA/IHVuZGVmaW5lZCA6IFwiY29sdW1uXCIsXG4gICAgICAuLi5zdHlsZVxuICAgIH07XG4gIH0sIFtvdGhlci5jbGFzc05hbWUsIHN0eWxlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MihcImRpdlwiLCB7XG4gICAgcmVmLFxuICAgIHN0eWxlOiBhY3R1YWxTdHlsZSxcbiAgICAuLi5vdGhlclxuICB9KTtcbn07XG52YXIgQWJzb2x1dGVGaWxsID0gZm9yd2FyZFJlZihBYnNvbHV0ZUZpbGxSZWZGb3J3YXJkaW5nKTtcblxuLy8gc3JjL1NlcXVlbmNlQ29udGV4dC50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBTZXF1ZW5jZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MyhudWxsKTtcblxuLy8gc3JjL1NlcXVlbmNlTWFuYWdlci50c3hcbmltcG9ydCBSZWFjdDMsIHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gYXMgdXNlTWVtbzIsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFNlcXVlbmNlTWFuYWdlciA9IFJlYWN0My5jcmVhdGVDb250ZXh0KHtcbiAgcmVnaXN0ZXJTZXF1ZW5jZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlcXVlbmNlTWFuYWdlckNvbnRleHQgbm90IGluaXRpYWxpemVkXCIpO1xuICB9LFxuICB1bnJlZ2lzdGVyU2VxdWVuY2U6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXF1ZW5jZU1hbmFnZXJDb250ZXh0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgfSxcbiAgc2VxdWVuY2VzOiBbXVxufSk7XG52YXIgU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCA9IFJlYWN0My5jcmVhdGVDb250ZXh0KHtcbiAgaGlkZGVuOiB7fSxcbiAgc2V0SGlkZGVuOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgfVxufSk7XG52YXIgU2VxdWVuY2VNYW5hZ2VyUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtzZXF1ZW5jZXMsIHNldFNlcXVlbmNlc10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtoaWRkZW4sIHNldEhpZGRlbl0gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IHJlZ2lzdGVyU2VxdWVuY2UgPSB1c2VDYWxsYmFjaygoc2VxKSA9PiB7XG4gICAgc2V0U2VxdWVuY2VzKChzZXFzKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLnNlcXMsIHNlcV07XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlclNlcXVlbmNlID0gdXNlQ2FsbGJhY2soKHNlcSkgPT4ge1xuICAgIHNldFNlcXVlbmNlcygoc2VxcykgPT4gc2Vxcy5maWx0ZXIoKHMpID0+IHMuaWQgIT09IHNlcSkpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZU1lbW8yKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICAgIHNlcXVlbmNlcyxcbiAgICAgIHVucmVnaXN0ZXJTZXF1ZW5jZVxuICAgIH07XG4gIH0sIFtyZWdpc3RlclNlcXVlbmNlLCBzZXF1ZW5jZXMsIHVucmVnaXN0ZXJTZXF1ZW5jZV0pO1xuICBjb25zdCBoaWRkZW5Db250ZXh0ID0gdXNlTWVtbzIoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBoaWRkZW4sXG4gICAgICBzZXRIaWRkZW5cbiAgICB9O1xuICB9LCBbaGlkZGVuXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MyhTZXF1ZW5jZU1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2VxdWVuY2VDb250ZXh0LFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MyhTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogaGlkZGVuQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvbm9uY2UudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDQsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBOb25jZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0NCh7XG4gIGdldE5vbmNlOiAoKSA9PiAwLFxuICBmYXN0UmVmcmVzaGVzOiAwXG59KTtcbnZhciB1c2VOb25jZSA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQyKE5vbmNlQ29udGV4dCk7XG4gIGNvbnN0IFtub25jZSwgc2V0Tm9uY2VdID0gdXNlU3RhdGUyKCgpID0+IGNvbnRleHQuZ2V0Tm9uY2UoKSk7XG4gIGNvbnN0IGxhc3RDb250ZXh0ID0gdXNlUmVmKGNvbnRleHQpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChsYXN0Q29udGV4dC5jdXJyZW50ID09PSBjb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RDb250ZXh0LmN1cnJlbnQgPSBjb250ZXh0O1xuICAgIHNldE5vbmNlKGNvbnRleHQuZ2V0Tm9uY2UpO1xuICB9LCBbY29udGV4dF0pO1xuICByZXR1cm4gbm9uY2U7XG59O1xuXG4vLyBzcmMvdGltZWxpbmUtcG9zaXRpb24tc3RhdGUudHNcbnZhciBleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlID0ge307XG5fX2V4cG9ydChleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlLCB7XG4gIHVzZVRpbWVsaW5lU2V0RnJhbWU6ICgpID0+IHVzZVRpbWVsaW5lU2V0RnJhbWUsXG4gIHVzZVRpbWVsaW5lUG9zaXRpb246ICgpID0+IHVzZVRpbWVsaW5lUG9zaXRpb24sXG4gIHVzZVBsYXlpbmdTdGF0ZTogKCkgPT4gdXNlUGxheWluZ1N0YXRlLFxuICBwZXJzaXN0Q3VycmVudEZyYW1lOiAoKSA9PiBwZXJzaXN0Q3VycmVudEZyYW1lLFxuICBnZXRJbml0aWFsRnJhbWVTdGF0ZTogKCkgPT4gZ2V0SW5pdGlhbEZyYW1lU3RhdGUsXG4gIGdldEZyYW1lRm9yQ29tcG9zaXRpb246ICgpID0+IGdldEZyYW1lRm9yQ29tcG9zaXRpb24sXG4gIFRpbWVsaW5lQ29udGV4dDogKCkgPT4gVGltZWxpbmVDb250ZXh0LFxuICBTZXRUaW1lbGluZUNvbnRleHQ6ICgpID0+IFNldFRpbWVsaW5lQ29udGV4dFxufSk7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ4LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ1LCB1c2VNZW1vIGFzIHVzZU1lbW82IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91c2UtdmlkZW8udHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDQsIHVzZU1lbW8gYXMgdXNlTWVtbzUgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0NvbXBvc2l0aW9uTWFuYWdlckNvbnRleHQudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ1IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgQ29tcG9zaXRpb25NYW5hZ2VyID0gY3JlYXRlQ29udGV4dDUoe1xuICBjb21wb3NpdGlvbnM6IFtdLFxuICBmb2xkZXJzOiBbXSxcbiAgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGE6IG51bGwsXG4gIGNhbnZhc0NvbnRlbnQ6IG51bGxcbn0pO1xudmFyIENvbXBvc2l0aW9uU2V0dGVycyA9IGNyZWF0ZUNvbnRleHQ1KHtcbiAgcmVnaXN0ZXJDb21wb3NpdGlvbjogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdW5yZWdpc3RlckNvbXBvc2l0aW9uOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICByZWdpc3RlckZvbGRlcjogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdW5yZWdpc3RlckZvbGRlcjogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgc2V0Q2FudmFzQ29udGVudDogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHM6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIG9ubHlSZW5kZXJDb21wb3NpdGlvbjogbnVsbFxufSk7XG5cbi8vIHNyYy9SZXNvbHZlQ29tcG9zaXRpb25Db25maWcudHN4XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ3LFxuICBjcmVhdGVSZWYsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMyxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MyxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTIsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzQsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlM1xufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0VkaXRvclByb3BzLnRzeFxuaW1wb3J0IFJlYWN0NCwge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ2LFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzNcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEVkaXRvclByb3BzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ2KHtcbiAgcHJvcHM6IHt9LFxuICB1cGRhdGVQcm9wczogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfSxcbiAgcmVzZXRVbnNhdmVkOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG59KTtcbnZhciBlZGl0b3JQcm9wc1Byb3ZpZGVyUmVmID0gUmVhY3Q0LmNyZWF0ZVJlZigpO1xudmFyIHRpbWVWYWx1ZVJlZiA9IFJlYWN0NC5jcmVhdGVSZWYoKTtcbnZhciBFZGl0b3JQcm9wc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbcHJvcHMsIHNldFByb3BzXSA9IFJlYWN0NC51c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IHVwZGF0ZVByb3BzID0gdXNlQ2FsbGJhY2syKCh7XG4gICAgZGVmYXVsdFByb3BzLFxuICAgIGlkLFxuICAgIG5ld1Byb3BzXG4gIH0pID0+IHtcbiAgICBzZXRQcm9wcygocHJldikgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2lkXTogdHlwZW9mIG5ld1Byb3BzID09PSBcImZ1bmN0aW9uXCIgPyBuZXdQcm9wcyhwcmV2W2lkXSA/PyBkZWZhdWx0UHJvcHMpIDogbmV3UHJvcHNcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVzZXRVbnNhdmVkID0gdXNlQ2FsbGJhY2syKCgpID0+IHtcbiAgICBzZXRQcm9wcyh7fSk7XG4gIH0sIFtdKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShlZGl0b3JQcm9wc1Byb3ZpZGVyUmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFByb3BzOiAoKSA9PiBwcm9wcyxcbiAgICAgIHNldFByb3BzXG4gICAgfTtcbiAgfSwgW3Byb3BzXSk7XG4gIGNvbnN0IGN0eCA9IHVzZU1lbW8zKCgpID0+IHtcbiAgICByZXR1cm4geyBwcm9wcywgdXBkYXRlUHJvcHMsIHJlc2V0VW5zYXZlZCB9O1xuICB9LCBbcHJvcHMsIHJlc2V0VW5zYXZlZCwgdXBkYXRlUHJvcHNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g0KEVkaXRvclByb3BzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjdHgsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvaW5wdXQtcHJvcHMtc2VyaWFsaXphdGlvbi50c1xudmFyIERBVEVfVE9LRU4gPSBcInJlbW90aW9uLWRhdGU6XCI7XG52YXIgRklMRV9UT0tFTiA9IFwicmVtb3Rpb24tZmlsZTpcIjtcbnZhciBzZXJpYWxpemVKU09OV2l0aERhdGUgPSAoe1xuICBkYXRhLFxuICBpbmRlbnQsXG4gIHN0YXRpY0Jhc2Vcbn0pID0+IHtcbiAgbGV0IGN1c3RvbURhdGVVc2VkID0gZmFsc2U7XG4gIGxldCBjdXN0b21GaWxlVXNlZCA9IGZhbHNlO1xuICBsZXQgbWFwVXNlZCA9IGZhbHNlO1xuICBsZXQgc2V0VXNlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpc1trZXldO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGN1c3RvbURhdGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0RBVEVfVE9LRU59JHtpdGVtLnRvSVNPU3RyaW5nKCl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG1hcFVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBzZXRVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiICYmIHN0YXRpY0Jhc2UgIT09IG51bGwgJiYgaXRlbS5zdGFydHNXaXRoKHN0YXRpY0Jhc2UpKSB7XG4gICAgICAgIGN1c3RvbUZpbGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0ZJTEVfVE9LRU59JHtpdGVtLnJlcGxhY2Uoc3RhdGljQmFzZSArIFwiL1wiLCBcIlwiKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIGluZGVudCk7XG4gICAgcmV0dXJuIHsgc2VyaWFsaXplZFN0cmluZywgY3VzdG9tRGF0ZVVzZWQsIGN1c3RvbUZpbGVVc2VkLCBtYXBVc2VkLCBzZXRVc2VkIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBzZXJpYWxpemUgdGhlIHBhc3NlZCBpbnB1dCBwcm9wcyB0byBKU09OOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgfVxufTtcbnZhciBkZXNlcmlhbGl6ZUpTT05XaXRoQ3VzdG9tRmllbGRzID0gKGRhdGEpID0+IHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSwgKF8sIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKERBVEVfVE9LRU4pKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUucmVwbGFjZShEQVRFX1RPS0VOLCBcIlwiKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChGSUxFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIGAke3dpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlfS8ke3ZhbHVlLnJlcGxhY2UoRklMRV9UT0tFTiwgXCJcIil9YDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn07XG52YXIgc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBkZXNlcmlhbGl6ZUpTT05XaXRoQ3VzdG9tRmllbGRzKHNlcmlhbGl6ZUpTT05XaXRoRGF0ZSh7XG4gICAgZGF0YTogcHJvcHMsXG4gICAgaW5kZW50OiAyLFxuICAgIHN0YXRpY0Jhc2U6IHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlXG4gIH0pLnNlcmlhbGl6ZWRTdHJpbmcpO1xufTtcbnZhciBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyA9IChwcm9wcykgPT4ge1xuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZShwcm9wcyk7XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufTtcblxuLy8gc3JjL2NvbmZpZy9pbnB1dC1wcm9wcy50c1xudmFyIGRpZFdhcm5TU1JJbXBvcnQgPSBmYWxzZTtcbnZhciB3YXJuT25jZVNTUkltcG9ydCA9ICgpID0+IHtcbiAgaWYgKGRpZFdhcm5TU1JJbXBvcnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGlkV2FyblNTUkltcG9ydCA9IHRydWU7XG4gIGNvbnNvbGUud2FybihcIkNhbGxlZCBgZ2V0SW5wdXRQcm9wcygpYCBvbiB0aGUgc2VydmVyLiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBhdmFpbGFibGUgc2VydmVyLXNpZGUgYW5kIGhhcyByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QuXCIpO1xuICBjb25zb2xlLndhcm4oXCJUbyBoaWRlIHRoaXMgd2FybmluZywgZG9uJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBzZXJ2ZXI6XCIpO1xuICBjb25zb2xlLndhcm4oXCIgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8ge30gOiBnZXRJbnB1dFByb3BzKClcIik7XG59O1xudmFyIGdldElucHV0UHJvcHMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2Fybk9uY2VTU1JJbXBvcnQoKTtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1BsYXllcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgY2FsbCBgZ2V0SW5wdXRQcm9wcygpYCBmcm9tIGEgPFBsYXllcj4uIEluc3RlYWQsIHRoZSBwcm9wcyBhcmUgYXZhaWxhYmxlIGFzIFJlYWN0IHByb3BzIGZyb20gY29tcG9uZW50IHRoYXQgeW91IHBhc3NlZCBhcyBgY29tcG9uZW50YCBwcm9wLlwiKTtcbiAgfVxuICBjb25zdCBwYXJhbSA9IHdpbmRvdy5yZW1vdGlvbl9pbnB1dFByb3BzO1xuICBpZiAoIXBhcmFtKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHBhcnNlZCA9IGRlc2VyaWFsaXplSlNPTldpdGhDdXN0b21GaWVsZHMocGFyYW0pO1xuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gc3JjL2NvZGVjLnRzXG52YXIgdmFsaWRDb2RlY3MgPSBbXG4gIFwiaDI2NFwiLFxuICBcImgyNjVcIixcbiAgXCJ2cDhcIixcbiAgXCJ2cDlcIixcbiAgXCJtcDNcIixcbiAgXCJhYWNcIixcbiAgXCJ3YXZcIixcbiAgXCJwcm9yZXNcIixcbiAgXCJoMjY0LW1rdlwiLFxuICBcImgyNjQtdHNcIixcbiAgXCJnaWZcIlxuXTtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZGVmYXVsdC1jb2RlYy50c1xuZnVuY3Rpb24gdmFsaWRhdGVEZWZhdWx0Q29kZWMoZGVmYXVsdENvZGVjLCBsb2NhdGlvbikge1xuICBpZiAodHlwZW9mIGRlZmF1bHRDb2RlYyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmF1bHRDb2RlYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImRlZmF1bHRDb2RlY1wiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhIHN0cmluZywgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGRlZmF1bHRDb2RlY30uYCk7XG4gIH1cbiAgaWYgKCF2YWxpZENvZGVjcy5pbmNsdWRlcyhkZWZhdWx0Q29kZWMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkZWZhdWx0Q29kZWNcIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgb25lIG9mICR7dmFsaWRDb2RlY3Muam9pbihcIiwgXCIpfSwgYnV0IHlvdSBwYXNzZWQgJHtkZWZhdWx0Q29kZWN9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRpbWVuc2lvbnMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRGltZW5zaW9uKGFtb3VudCwgbmFtZU9mUHJvcCwgbG9jYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBhbW91bnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhbW91bnR9YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBpcyBOYU4uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYW1vdW50KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgZmluaXRlLCBidXQgaXMgJHthbW91bnR9LmApO1xuICB9XG4gIGlmIChhbW91bnQgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgaXMgJHthbW91bnR9LmApO1xuICB9XG4gIGlmIChhbW91bnQgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHthbW91bnR9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWR1cmF0aW9uLWluLWZyYW1lcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBhbGxvd0Zsb2F0cywgY29tcG9uZW50IH0gPSBvcHRpb25zO1xuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBpcyBtaXNzaW5nLmApO1xuICB9XG4gIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmIChkdXJhdGlvbkluRnJhbWVzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghYWxsb3dGbG9hdHMgJiYgZHVyYXRpb25JbkZyYW1lcyAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb25JbkZyYW1lcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1mcHMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRnBzKGZwcywgbG9jYXRpb24sIGlzR2lmKSB7XG4gIGlmICh0eXBlb2YgZnBzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgZmluaXRlLCBidXQgeW91IHBhc3NlZCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNOYU4oZnBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBnb3QgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGZwcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJmcHNcIiBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChpc0dpZiAmJiBmcHMgPiA1MCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBGUFMgZm9yIGEgR0lGIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiA1MC4gVXNlIHRoZSAtLWV2ZXJ5LW50aC1mcmFtZSBvcHRpb24gdG8gbG93ZXIgdGhlIEZQUzogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9yZW5kZXItYXMtZ2lmYCk7XG4gIH1cbn1cblxuLy8gc3JjL3Jlc29sdmUtdmlkZW8tY29uZmlnLnRzXG52YXIgdmFsaWRhdGVDYWxjdWxhdGVkID0gKHtcbiAgY2FsY3VsYXRlZCxcbiAgY29tcG9zaXRpb25JZCxcbiAgY29tcG9zaXRpb25GcHMsXG4gIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICBjb21wb3NpdGlvbldpZHRoLFxuICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXNcbn0pID0+IHtcbiAgY29uc3QgY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uID0gYGNhbGN1bGF0ZWQgYnkgY2FsY3VsYXRlTWV0YWRhdGEoKSBmb3IgdGhlIGNvbXBvc2l0aW9uIFwiJHtjb21wb3NpdGlvbklkfVwiYDtcbiAgY29uc3QgZGVmYXVsdEVycm9yTG9jYXRpb24gPSBgb2YgdGhlIFwiPENvbXBvc2l0aW9uIC8+XCIgY29tcG9uZW50IHdpdGggdGhlIGlkIFwiJHtjb21wb3NpdGlvbklkfVwiYDtcbiAgY29uc3Qgd2lkdGggPSBjYWxjdWxhdGVkPy53aWR0aCA/PyBjb21wb3NpdGlvbldpZHRoID8/IHVuZGVmaW5lZDtcbiAgdmFsaWRhdGVEaW1lbnNpb24od2lkdGgsIFwid2lkdGhcIiwgY2FsY3VsYXRlZD8ud2lkdGggPyBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24gOiBkZWZhdWx0RXJyb3JMb2NhdGlvbik7XG4gIGNvbnN0IGhlaWdodCA9IGNhbGN1bGF0ZWQ/LmhlaWdodCA/PyBjb21wb3NpdGlvbkhlaWdodCA/PyB1bmRlZmluZWQ7XG4gIHZhbGlkYXRlRGltZW5zaW9uKGhlaWdodCwgXCJoZWlnaHRcIiwgY2FsY3VsYXRlZD8uaGVpZ2h0ID8gY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIDogZGVmYXVsdEVycm9yTG9jYXRpb24pO1xuICBjb25zdCBmcHMgPSBjYWxjdWxhdGVkPy5mcHMgPz8gY29tcG9zaXRpb25GcHMgPz8gbnVsbDtcbiAgdmFsaWRhdGVGcHMoZnBzLCBjYWxjdWxhdGVkPy5mcHMgPyBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24gOiBkZWZhdWx0RXJyb3JMb2NhdGlvbiwgZmFsc2UpO1xuICBjb25zdCBkdXJhdGlvbkluRnJhbWVzID0gY2FsY3VsYXRlZD8uZHVyYXRpb25JbkZyYW1lcyA/PyBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbDtcbiAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIHtcbiAgICBhbGxvd0Zsb2F0czogZmFsc2UsXG4gICAgY29tcG9uZW50OiBgb2YgdGhlIFwiPENvbXBvc2l0aW9uIC8+XCIgY29tcG9uZW50IHdpdGggdGhlIGlkIFwiJHtjb21wb3NpdGlvbklkfVwiYFxuICB9KTtcbiAgY29uc3QgZGVmYXVsdENvZGVjID0gY2FsY3VsYXRlZD8uZGVmYXVsdENvZGVjO1xuICB2YWxpZGF0ZURlZmF1bHRDb2RlYyhkZWZhdWx0Q29kZWMsIGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbik7XG4gIGNvbnN0IGRlZmF1bHRPdXROYW1lID0gY2FsY3VsYXRlZD8uZGVmYXVsdE91dE5hbWU7XG4gIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIGZwcywgZHVyYXRpb25JbkZyYW1lcywgZGVmYXVsdENvZGVjLCBkZWZhdWx0T3V0TmFtZSB9O1xufTtcbnZhciByZXNvbHZlVmlkZW9Db25maWcgPSAoe1xuICBjYWxjdWxhdGVNZXRhZGF0YSxcbiAgc2lnbmFsLFxuICBkZWZhdWx0UHJvcHMsXG4gIG9yaWdpbmFsUHJvcHMsXG4gIGNvbXBvc2l0aW9uSWQsXG4gIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgY29tcG9zaXRpb25GcHMsXG4gIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICBjb21wb3NpdGlvbldpZHRoXG59KSA9PiB7XG4gIGNvbnN0IGNhbGN1bGF0ZWRQcm9tID0gY2FsY3VsYXRlTWV0YWRhdGEgPyBjYWxjdWxhdGVNZXRhZGF0YSh7XG4gICAgZGVmYXVsdFByb3BzLFxuICAgIHByb3BzOiBvcmlnaW5hbFByb3BzLFxuICAgIGFib3J0U2lnbmFsOiBzaWduYWwsXG4gICAgY29tcG9zaXRpb25JZFxuICB9KSA6IG51bGw7XG4gIGlmIChjYWxjdWxhdGVkUHJvbSAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlZFByb20gPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gY2FsY3VsYXRlZFByb20pIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlZFByb20udGhlbigoYykgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICBmcHMsXG4gICAgICAgIGRlZmF1bHRDb2RlYyxcbiAgICAgICAgZGVmYXVsdE91dE5hbWVcbiAgICAgIH0gPSB2YWxpZGF0ZUNhbGN1bGF0ZWQoe1xuICAgICAgICBjYWxjdWxhdGVkOiBjLFxuICAgICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGNvbXBvc2l0aW9uRnBzLFxuICAgICAgICBjb21wb3NpdGlvbkhlaWdodCxcbiAgICAgICAgY29tcG9zaXRpb25XaWR0aCxcbiAgICAgICAgY29tcG9zaXRpb25JZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBmcHMsXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGlkOiBjb21wb3NpdGlvbklkLFxuICAgICAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyksXG4gICAgICAgIHByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhjLnByb3BzID8/IG9yaWdpbmFsUHJvcHMpLFxuICAgICAgICBkZWZhdWx0Q29kZWM6IGRlZmF1bHRDb2RlYyA/PyBudWxsLFxuICAgICAgICBkZWZhdWx0T3V0TmFtZTogZGVmYXVsdE91dE5hbWUgPz8gbnVsbFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBkYXRhID0gdmFsaWRhdGVDYWxjdWxhdGVkKHtcbiAgICBjYWxjdWxhdGVkOiBjYWxjdWxhdGVkUHJvbSxcbiAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgY29tcG9zaXRpb25GcHMsXG4gICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgY29tcG9zaXRpb25XaWR0aCxcbiAgICBjb21wb3NpdGlvbklkXG4gIH0pO1xuICBpZiAoY2FsY3VsYXRlZFByb20gPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGlkOiBjb21wb3NpdGlvbklkLFxuICAgICAgZGVmYXVsdFByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhkZWZhdWx0UHJvcHMgPz8ge30pLFxuICAgICAgcHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKG9yaWdpbmFsUHJvcHMpLFxuICAgICAgZGVmYXVsdENvZGVjOiBudWxsLFxuICAgICAgZGVmYXVsdE91dE5hbWU6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBpZDogY29tcG9zaXRpb25JZCxcbiAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyA/PyB7fSksXG4gICAgcHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGNhbGN1bGF0ZWRQcm9tLnByb3BzID8/IG9yaWdpbmFsUHJvcHMpLFxuICAgIGRlZmF1bHRDb2RlYzogY2FsY3VsYXRlZFByb20uZGVmYXVsdENvZGVjID8/IG51bGwsXG4gICAgZGVmYXVsdE91dE5hbWU6IGNhbGN1bGF0ZWRQcm9tLmRlZmF1bHRPdXROYW1lID8/IG51bGxcbiAgfTtcbn07XG52YXIgcmVzb2x2ZVZpZGVvQ29uZmlnT3JDYXRjaCA9IChwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9taXNlT3JSZXR1cm5WYWx1ZSA9IHJlc29sdmVWaWRlb0NvbmZpZyhwYXJhbXMpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgIHJlc3VsdDogcHJvbWlzZU9yUmV0dXJuVmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgZXJyb3I6IGVyclxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9SZXNvbHZlQ29tcG9zaXRpb25Db25maWcudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0NyhudWxsKTtcbnZhciByZXNvbHZlQ29tcG9zaXRpb25zUmVmID0gY3JlYXRlUmVmKCk7XG52YXIgbmVlZHNSZXNvbHV0aW9uID0gKGNvbXBvc2l0aW9uKSA9PiB7XG4gIHJldHVybiBCb29sZWFuKGNvbXBvc2l0aW9uLmNhbGN1bGF0ZU1ldGFkYXRhKTtcbn07XG52YXIgUFJPUFNfVVBEQVRFRF9FWFRFUk5BTExZID0gXCJyZW1vdGlvbi5wcm9wc1VwZGF0ZWRFeHRlcm5hbGx5XCI7XG52YXIgUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbY3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24sIHNldEN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uXSA9IHVzZVN0YXRlMyhudWxsKTtcbiAgY29uc3QgeyBjb21wb3NpdGlvbnMsIGNhbnZhc0NvbnRlbnQsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIH0gPSB1c2VDb250ZXh0MyhDb21wb3NpdGlvbk1hbmFnZXIpO1xuICBjb25zdCB7IGZhc3RSZWZyZXNoZXMgfSA9IHVzZUNvbnRleHQzKE5vbmNlQ29udGV4dCk7XG4gIGNvbnN0IHNlbGVjdGVkQ29tcG9zaXRpb24gPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9ucy5maW5kKChjKSA9PiBjYW52YXNDb250ZW50ICYmIGNhbnZhc0NvbnRlbnQudHlwZSA9PT0gXCJjb21wb3NpdGlvblwiICYmIGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZCA9PT0gYy5pZCk7XG4gIH0sIFtjYW52YXNDb250ZW50LCBjb21wb3NpdGlvbnNdKTtcbiAgY29uc3QgcmVuZGVyTW9kYWxDb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9ucy5maW5kKChjKSA9PiBjLmlkID09PSBjdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbik7XG4gIGNvbnN0IHsgcHJvcHM6IGFsbEVkaXRvclByb3BzIH0gPSB1c2VDb250ZXh0MyhFZGl0b3JQcm9wc0NvbnRleHQpO1xuICBjb25zdCBpbnB1dFByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1BsYXllciA/IHt9IDogZ2V0SW5wdXRQcm9wcygpID8/IHt9O1xuICB9LCBbXSk7XG4gIGNvbnN0IFtyZXNvbHZlZENvbmZpZ3MsIHNldFJlc29sdmVkQ29uZmlnc10gPSB1c2VTdGF0ZTMoe30pO1xuICBjb25zdCBzZWxlY3RlZEVkaXRvclByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiBzZWxlY3RlZENvbXBvc2l0aW9uID8gYWxsRWRpdG9yUHJvcHNbc2VsZWN0ZWRDb21wb3NpdGlvbi5pZF0gPz8ge30gOiB7fTtcbiAgfSwgW2FsbEVkaXRvclByb3BzLCBzZWxlY3RlZENvbXBvc2l0aW9uXSk7XG4gIGNvbnN0IHJlbmRlck1vZGFsUHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHJlbmRlck1vZGFsQ29tcG9zaXRpb24gPyBhbGxFZGl0b3JQcm9wc1tyZW5kZXJNb2RhbENvbXBvc2l0aW9uLmlkXSA/PyB7fSA6IHt9O1xuICB9LCBbYWxsRWRpdG9yUHJvcHMsIHJlbmRlck1vZGFsQ29tcG9zaXRpb25dKTtcbiAgY29uc3QgaGFzUmVzb2x1dGlvbiA9IEJvb2xlYW4oY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEpO1xuICBjb25zdCBkb1Jlc29sdXRpb24gPSB1c2VDYWxsYmFjazMoKHtcbiAgICBjYWxjdWxhdGVNZXRhZGF0YSxcbiAgICBjb21iaW5lZFByb3BzLFxuICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgICBjb21wb3NpdGlvbkZwcyxcbiAgICBjb21wb3NpdGlvbkhlaWdodCxcbiAgICBjb21wb3NpdGlvbklkLFxuICAgIGNvbXBvc2l0aW9uV2lkdGgsXG4gICAgZGVmYXVsdFByb3BzXG4gIH0pID0+IHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgICBpZiAoaGFzUmVzb2x1dGlvbikge1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBjb250cm9sbGVyO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJlc29sdmVWaWRlb0NvbmZpZ09yQ2F0Y2goe1xuICAgICAgY29tcG9zaXRpb25JZCxcbiAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgb3JpZ2luYWxQcm9wczogY29tYmluZWRQcm9wcyxcbiAgICAgIHNpZ25hbCxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGNvbXBvc2l0aW9uRnBzLFxuICAgICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgICBjb21wb3NpdGlvbldpZHRoXG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4gKHtcbiAgICAgICAgLi4ucixcbiAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgIGVycm9yOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGNvbnN0IHByb21Pck5vdCA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgaWYgKHR5cGVvZiBwcm9tT3JOb3QgPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gcHJvbU9yTm90KSB7XG4gICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+IHtcbiAgICAgICAgY29uc3QgcHJldiA9IHJbY29tcG9zaXRpb25JZF07XG4gICAgICAgIGlmIChwcmV2Py50eXBlID09PSBcInN1Y2Nlc3NcIiB8fCBwcmV2Py50eXBlID09PSBcInN1Y2Nlc3MtYW5kLXJlZnJlc2hpbmdcIikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yLFxuICAgICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzcy1hbmQtcmVmcmVzaGluZ1wiLFxuICAgICAgICAgICAgICByZXN1bHQ6IHByZXYucmVzdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICB0eXBlOiBcImxvYWRpbmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcHJvbU9yTm90LnRoZW4oKGMpID0+IHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiAoe1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIHJlc3VsdDogY1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgICAgLi4ucixcbiAgICAgICAgICBbY29tcG9zaXRpb25JZF06IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgIC4uLnIsXG4gICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIHJlc3VsdDogcHJvbU9yTm90XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gIH0sIFtoYXNSZXNvbHV0aW9uXSk7XG4gIGNvbnN0IGN1cnJlbnRDb21wb3NpdGlvbiA9IGNhbnZhc0NvbnRlbnQ/LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiA/IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZCA6IG51bGw7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUyKHJlc29sdmVDb21wb3NpdGlvbnNSZWYsICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb246IChpZCkgPT4ge1xuICAgICAgICBzZXRDdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbihpZCk7XG4gICAgICB9LFxuICAgICAgcmVsb2FkQ3VycmVudGx5U2VsZWN0ZWRDb21wb3NpdGlvbjogKCkgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9ucy5maW5kKChjKSA9PiBjLmlkID09PSBjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgICBpZiAoIWNvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBjb21wb3NpdGlvbiB3aXRoIGlkICR7Y3VycmVudENvbXBvc2l0aW9ufWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkaXRvclByb3BzID0gYWxsRWRpdG9yUHJvcHNbY3VycmVudENvbXBvc2l0aW9uXSA/PyB7fTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgIC4uLmNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgICAuLi5lZGl0b3JQcm9wcyA/PyB7fVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgLi4uaW5wdXRQcm9wcyA/PyB7fVxuICAgICAgICB9O1xuICAgICAgICBkb1Jlc29sdXRpb24oe1xuICAgICAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogY29tcG9zaXRpb24uY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgICAgICAgY29tYmluZWRQcm9wczogcHJvcHMsXG4gICAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzOiBjb21wb3NpdGlvbi5kdXJhdGlvbkluRnJhbWVzID8/IG51bGwsXG4gICAgICAgICAgY29tcG9zaXRpb25GcHM6IGNvbXBvc2l0aW9uLmZwcyA/PyBudWxsLFxuICAgICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiBjb21wb3NpdGlvbi5oZWlnaHQgPz8gbnVsbCxcbiAgICAgICAgICBjb21wb3NpdGlvbldpZHRoOiBjb21wb3NpdGlvbi53aWR0aCA/PyBudWxsLFxuICAgICAgICAgIGNvbXBvc2l0aW9uSWQ6IGNvbXBvc2l0aW9uLmlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtcbiAgICBhbGxFZGl0b3JQcm9wcyxcbiAgICBjb21wb3NpdGlvbnMsXG4gICAgY3VycmVudENvbXBvc2l0aW9uLFxuICAgIGRvUmVzb2x1dGlvbixcbiAgICBpbnB1dFByb3BzXG4gIF0pO1xuICBjb25zdCBpc1RoZVNhbWUgPSBzZWxlY3RlZENvbXBvc2l0aW9uPy5pZCA9PT0gcmVuZGVyTW9kYWxDb21wb3NpdGlvbj8uaWQ7XG4gIGNvbnN0IGN1cnJlbnREZWZhdWx0UHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNlbGVjdGVkQ29tcG9zaXRpb24/LmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgIC4uLnNlbGVjdGVkRWRpdG9yUHJvcHMgPz8ge31cbiAgICB9O1xuICB9LCBbc2VsZWN0ZWRDb21wb3NpdGlvbj8uZGVmYXVsdFByb3BzLCBzZWxlY3RlZEVkaXRvclByb3BzXSk7XG4gIGNvbnN0IG9yaWdpbmFsUHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmN1cnJlbnREZWZhdWx0UHJvcHMsXG4gICAgICAuLi5pbnB1dFByb3BzID8/IHt9XG4gICAgfTtcbiAgfSwgW2N1cnJlbnREZWZhdWx0UHJvcHMsIGlucHV0UHJvcHNdKTtcbiAgY29uc3QgY2FuUmVzb2x2ZSA9IHNlbGVjdGVkQ29tcG9zaXRpb24gJiYgbmVlZHNSZXNvbHV0aW9uKHNlbGVjdGVkQ29tcG9zaXRpb24pO1xuICBjb25zdCBzaG91bGRJZ25vcmVVcGRhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pZ25vcmVGYXN0UmVmcmVzaFVwZGF0ZSAmJiBmYXN0UmVmcmVzaGVzIDw9IHdpbmRvdy5yZW1vdGlvbl9pZ25vcmVGYXN0UmVmcmVzaFVwZGF0ZTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHNob3VsZElnbm9yZVVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FuUmVzb2x2ZSkge1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGRvUmVzb2x1dGlvbih7XG4gICAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhOiBzZWxlY3RlZENvbXBvc2l0aW9uLmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgICBjb21iaW5lZFByb3BzOiBvcmlnaW5hbFByb3BzLFxuICAgICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXM6IHNlbGVjdGVkQ29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcyA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbkZwczogc2VsZWN0ZWRDb21wb3NpdGlvbi5mcHMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25IZWlnaHQ6IHNlbGVjdGVkQ29tcG9zaXRpb24uaGVpZ2h0ID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uV2lkdGg6IHNlbGVjdGVkQ29tcG9zaXRpb24ud2lkdGggPz8gbnVsbCxcbiAgICAgICAgZGVmYXVsdFByb3BzOiBjdXJyZW50RGVmYXVsdFByb3BzLFxuICAgICAgICBjb21wb3NpdGlvbklkOiBzZWxlY3RlZENvbXBvc2l0aW9uLmlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXG4gICAgY2FuUmVzb2x2ZSxcbiAgICBjdXJyZW50RGVmYXVsdFByb3BzLFxuICAgIGRvUmVzb2x1dGlvbixcbiAgICBvcmlnaW5hbFByb3BzLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmR1cmF0aW9uSW5GcmFtZXMsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8uZnBzLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmhlaWdodCxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5pZCxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy53aWR0aCxcbiAgICBzaG91bGRJZ25vcmVVcGRhdGVcbiAgXSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGlmIChzaG91bGRJZ25vcmVVcGRhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFBST1BTX1VQREFURURfRVhURVJOQUxMWSwge1xuICAgICAgZGV0YWlsOiB7XG4gICAgICAgIHJlc2V0VW5zYXZlZDogdHJ1ZVxuICAgICAgfVxuICAgIH0pKTtcbiAgfSwgW2Zhc3RSZWZyZXNoZXNdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHJlbmRlck1vZGFsQ29tcG9zaXRpb24gJiYgIWlzVGhlU2FtZSkge1xuICAgICAgY29uc3QgY29tYmluZWRQcm9wcyA9IHtcbiAgICAgICAgLi4ucmVuZGVyTW9kYWxDb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgIC4uLnJlbmRlck1vZGFsUHJvcHMgPz8ge30sXG4gICAgICAgIC4uLmlucHV0UHJvcHMgPz8ge31cbiAgICAgIH07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gZG9SZXNvbHV0aW9uKHtcbiAgICAgICAgY2FsY3VsYXRlTWV0YWRhdGE6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lczogcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5kdXJhdGlvbkluRnJhbWVzID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uRnBzOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmZwcyA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbkhlaWdodDogcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5oZWlnaHQgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25JZDogcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5pZCxcbiAgICAgICAgY29tcG9zaXRpb25XaWR0aDogcmVuZGVyTW9kYWxDb21wb3NpdGlvbi53aWR0aCA/PyBudWxsLFxuICAgICAgICBkZWZhdWx0UHJvcHM6IGN1cnJlbnREZWZhdWx0UHJvcHMsXG4gICAgICAgIGNvbWJpbmVkUHJvcHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtcbiAgICBjdXJyZW50RGVmYXVsdFByb3BzLFxuICAgIGRvUmVzb2x1dGlvbixcbiAgICBpbnB1dFByb3BzLFxuICAgIGlzVGhlU2FtZSxcbiAgICByZW5kZXJNb2RhbENvbXBvc2l0aW9uLFxuICAgIHJlbmRlck1vZGFsUHJvcHNcbiAgXSk7XG4gIGNvbnN0IHJlc29sdmVkQ29uZmlnc0luY2x1ZGluZ1N0YXRpY09uZXMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGljQ29tcHMgPSBjb21wb3NpdGlvbnMuZmlsdGVyKChjKSA9PiB7XG4gICAgICByZXR1cm4gYy5jYWxjdWxhdGVNZXRhZGF0YSA9PT0gbnVsbDtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzb2x2ZWRDb25maWdzLFxuICAgICAgLi4uc3RhdGljQ29tcHMucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgW2N1cnIuaWRdOiB7XG4gICAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIHJlc3VsdDogeyAuLi5jdXJyLCBkZWZhdWx0UHJvcHM6IGN1cnIuZGVmYXVsdFByb3BzID8/IHt9IH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LCB7fSlcbiAgICB9O1xuICB9LCBbY29tcG9zaXRpb25zLCByZXNvbHZlZENvbmZpZ3NdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g1KFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcmVzb2x2ZWRDb25maWdzSW5jbHVkaW5nU3RhdGljT25lcyxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgdXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyA9IChwcmVmZXJyZWRDb21wb3NpdGlvbklkKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MyhSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0KTtcbiAgY29uc3QgeyBwcm9wczogYWxsRWRpdG9yUHJvcHMgfSA9IHVzZUNvbnRleHQzKEVkaXRvclByb3BzQ29udGV4dCk7XG4gIGNvbnN0IHsgY29tcG9zaXRpb25zLCBjYW52YXNDb250ZW50LCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSB9ID0gdXNlQ29udGV4dDMoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgY29uc3QgY3VycmVudENvbXBvc2l0aW9uID0gY2FudmFzQ29udGVudD8udHlwZSA9PT0gXCJjb21wb3NpdGlvblwiID8gY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkIDogbnVsbDtcbiAgY29uc3QgY29tcG9zaXRpb25JZCA9IHByZWZlcnJlZENvbXBvc2l0aW9uSWQgPz8gY3VycmVudENvbXBvc2l0aW9uO1xuICBjb25zdCBjb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9ucy5maW5kKChjKSA9PiBjLmlkID09PSBjb21wb3NpdGlvbklkKTtcbiAgY29uc3Qgc2VsZWN0ZWRFZGl0b3JQcm9wcyA9IHVzZU1lbW80KCgpID0+IHtcbiAgICByZXR1cm4gY29tcG9zaXRpb24gPyBhbGxFZGl0b3JQcm9wc1tjb21wb3NpdGlvbi5pZF0gPz8ge30gOiB7fTtcbiAgfSwgW2FsbEVkaXRvclByb3BzLCBjb21wb3NpdGlvbl0pO1xuICByZXR1cm4gdXNlTWVtbzQoKCkgPT4ge1xuICAgIGlmICghY29tcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAuLi5jdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICAgICAgICBpZDogY29tcG9zaXRpb24uaWQsXG4gICAgICAgICAgZGVmYXVsdFByb3BzOiBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge31cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFuZWVkc1Jlc29sdXRpb24oY29tcG9zaXRpb24pKSB7XG4gICAgICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoY29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcywge1xuICAgICAgICBhbGxvd0Zsb2F0czogZmFsc2UsXG4gICAgICAgIGNvbXBvbmVudDogYGluIDxDb21wb3NpdGlvbiBpZD1cIiR7Y29tcG9zaXRpb24uaWR9XCI+YFxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZUZwcyhjb21wb3NpdGlvbi5mcHMsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmAsIGZhbHNlKTtcbiAgICAgIHZhbGlkYXRlRGltZW5zaW9uKGNvbXBvc2l0aW9uLndpZHRoLCBcIndpZHRoXCIsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmApO1xuICAgICAgdmFsaWRhdGVEaW1lbnNpb24oY29tcG9zaXRpb24uaGVpZ2h0LCBcImhlaWdodFwiLCBgaW4gPENvbXBvc2l0aW9uIGlkPVwiJHtjb21wb3NpdGlvbi5pZH1cIj5gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICB3aWR0aDogY29tcG9zaXRpb24ud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjb21wb3NpdGlvbi5oZWlnaHQsXG4gICAgICAgICAgZnBzOiBjb21wb3NpdGlvbi5mcHMsXG4gICAgICAgICAgaWQ6IGNvbXBvc2l0aW9uLmlkLFxuICAgICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGNvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgICAgZGVmYXVsdFByb3BzOiBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIC4uLmNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgICAgIC4uLnNlbGVjdGVkRWRpdG9yUHJvcHMgPz8ge30sXG4gICAgICAgICAgICAuLi50eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1BsYXllciA/IHt9IDogZ2V0SW5wdXRQcm9wcygpID8/IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0Q29kZWM6IG51bGwsXG4gICAgICAgICAgZGVmYXVsdE91dE5hbWU6IG51bGxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFjb250ZXh0W2NvbXBvc2l0aW9uLmlkXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0W2NvbXBvc2l0aW9uLmlkXTtcbiAgfSwgW2NvbXBvc2l0aW9uLCBjb250ZXh0LCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgc2VsZWN0ZWRFZGl0b3JQcm9wc10pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby50c1xudmFyIHVzZVZpZGVvID0gKCkgPT4ge1xuICBjb25zdCB7IGNhbnZhc0NvbnRlbnQsIGNvbXBvc2l0aW9ucywgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgfSA9IHVzZUNvbnRleHQ0KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHNlbGVjdGVkID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IHtcbiAgICByZXR1cm4gY2FudmFzQ29udGVudD8udHlwZSA9PT0gXCJjb21wb3NpdGlvblwiICYmIGMuaWQgPT09IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZDtcbiAgfSk7XG4gIGNvbnN0IHJlc29sdmVkID0gdXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyhzZWxlY3RlZD8uaWQgPz8gbnVsbCk7XG4gIHJldHVybiB1c2VNZW1vNSgoKSA9PiB7XG4gICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZWQudHlwZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc29sdmVkLnJlc3VsdCxcbiAgICAgIGRlZmF1bHRQcm9wczogc2VsZWN0ZWQuZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgaWQ6IHNlbGVjdGVkLmlkLFxuICAgICAgLi4uY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgPz8ge30sXG4gICAgICBjb21wb25lbnQ6IHNlbGVjdGVkLmNvbXBvbmVudFxuICAgIH07XG4gIH0sIFtjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgcmVzb2x2ZWQsIHNlbGVjdGVkXSk7XG59O1xuXG4vLyBzcmMvdGltZWxpbmUtcG9zaXRpb24tc3RhdGUudHNcbnZhciBUaW1lbGluZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0OCh7XG4gIGZyYW1lOiB7fSxcbiAgcGxheWluZzogZmFsc2UsXG4gIHBsYXliYWNrUmF0ZTogMSxcbiAgcm9vdElkOiBcIlwiLFxuICBpbXBlcmF0aXZlUGxheWluZzoge1xuICAgIGN1cnJlbnQ6IGZhbHNlXG4gIH0sXG4gIHNldFBsYXliYWNrUmF0ZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRlZmF1bHRcIik7XG4gIH0sXG4gIGF1ZGlvQW5kVmlkZW9UYWdzOiB7IGN1cnJlbnQ6IFtdIH1cbn0pO1xudmFyIFNldFRpbWVsaW5lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ4KHtcbiAgc2V0RnJhbWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9LFxuICBzZXRQbGF5aW5nOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfVxufSk7XG52YXIgbWFrZUtleSA9ICgpID0+IHtcbiAgcmV0dXJuIGByZW1vdGlvbi50aW1lLWFsbGA7XG59O1xudmFyIHBlcnNpc3RDdXJyZW50RnJhbWUgPSAodGltZSkgPT4ge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtYWtlS2V5KCksIEpTT04uc3RyaW5naWZ5KHRpbWUpKTtcbn07XG52YXIgZ2V0SW5pdGlhbEZyYW1lU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShtYWtlS2V5KCkpID8/IFwie31cIjtcbiAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgcmV0dXJuIG9iajtcbn07XG52YXIgZ2V0RnJhbWVGb3JDb21wb3NpdGlvbiA9IChjb21wb3NpdGlvbikgPT4ge1xuICBjb25zdCBpdGVtID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obWFrZUtleSgpKSA/PyBcInt9XCI7XG4gIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoaXRlbSk7XG4gIGlmIChvYmpbY29tcG9zaXRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gTnVtYmVyKG9ialtjb21wb3NpdGlvbl0pO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWUgPz8gMDtcbn07XG52YXIgdXNlVGltZWxpbmVQb3NpdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlbygpO1xuICBjb25zdCBzdGF0ZSA9IHVzZUNvbnRleHQ1KFRpbWVsaW5lQ29udGV4dCk7XG4gIGlmICghdmlkZW9Db25maWcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IDAgOiB3aW5kb3cucmVtb3Rpb25faW5pdGlhbEZyYW1lID8/IDA7XG4gIH1cbiAgY29uc3QgdW5jbGFtcGVkID0gc3RhdGUuZnJhbWVbdmlkZW9Db25maWcuaWRdID8/IChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIgPyAwIDogZ2V0RnJhbWVGb3JDb21wb3NpdGlvbih2aWRlb0NvbmZpZy5pZCkpO1xuICByZXR1cm4gTWF0aC5taW4odmlkZW9Db25maWcuZHVyYXRpb25JbkZyYW1lcyAtIDEsIHVuY2xhbXBlZCk7XG59O1xudmFyIHVzZVRpbWVsaW5lU2V0RnJhbWUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgc2V0RnJhbWUgfSA9IHVzZUNvbnRleHQ1KFNldFRpbWVsaW5lQ29udGV4dCk7XG4gIHJldHVybiBzZXRGcmFtZTtcbn07XG52YXIgdXNlUGxheWluZ1N0YXRlID0gKCkgPT4ge1xuICBjb25zdCB7IHBsYXlpbmcsIGltcGVyYXRpdmVQbGF5aW5nIH0gPSB1c2VDb250ZXh0NShUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCB7IHNldFBsYXlpbmcgfSA9IHVzZUNvbnRleHQ1KFNldFRpbWVsaW5lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vNigoKSA9PiBbcGxheWluZywgc2V0UGxheWluZywgaW1wZXJhdGl2ZVBsYXlpbmddLCBbaW1wZXJhdGl2ZVBsYXlpbmcsIHBsYXlpbmcsIHNldFBsYXlpbmddKTtcbn07XG5cbi8vIHNyYy91c2UtdmlkZW8tY29uZmlnLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ3IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9DYW5Vc2VSZW1vdGlvbkhvb2tzLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0OSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDYgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBDYW5Vc2VSZW1vdGlvbkhvb2tzID0gY3JlYXRlQ29udGV4dDkoZmFsc2UpO1xudmFyIENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g2KENhblVzZVJlbW90aW9uSG9va3MuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy91c2UtdW5zYWZlLXZpZGVvLWNvbmZpZy50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NiwgdXNlTWVtbyBhcyB1c2VNZW1vNyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZVVuc2FmZVZpZGVvQ29uZmlnID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDYoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgY3R4V2lkdGggPSBjb250ZXh0Py53aWR0aCA/PyBudWxsO1xuICBjb25zdCBjdHhIZWlnaHQgPSBjb250ZXh0Py5oZWlnaHQgPz8gbnVsbDtcbiAgY29uc3QgY3R4RHVyYXRpb24gPSBjb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzID8/IG51bGw7XG4gIGNvbnN0IHZpZGVvID0gdXNlVmlkZW8oKTtcbiAgcmV0dXJuIHVzZU1lbW83KCgpID0+IHtcbiAgICBpZiAoIXZpZGVvKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgZnBzLFxuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGgsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlZmF1bHRDb2RlYyxcbiAgICAgIGRlZmF1bHRPdXROYW1lXG4gICAgfSA9IHZpZGVvO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHdpZHRoOiBjdHhXaWR0aCA/PyB3aWR0aCxcbiAgICAgIGhlaWdodDogY3R4SGVpZ2h0ID8/IGhlaWdodCxcbiAgICAgIGZwcyxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGN0eER1cmF0aW9uID8/IGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlZmF1bHRDb2RlYyxcbiAgICAgIGRlZmF1bHRPdXROYW1lXG4gICAgfTtcbiAgfSwgW2N0eER1cmF0aW9uLCBjdHhIZWlnaHQsIGN0eFdpZHRoLCB2aWRlb10pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby1jb25maWcudHNcbnZhciB1c2VWaWRlb0NvbmZpZyA9ICgpID0+IHtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDcoQ2FuVXNlUmVtb3Rpb25Ib29rcyk7XG4gIGNvbnN0IGlzUGxheWVyID0gdXNlSXNQbGF5ZXIoKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllciB8fCBpc1BsYXllcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgXCJObyB2aWRlbyBjb25maWcgZm91bmQuIExpa2VseSByZWFzb25zOlwiLFxuICAgICAgICBcIi0gWW91IGFyZSBwcm9iYWJseSBjYWxsaW5nIHVzZVZpZGVvQ29uZmlnKCkgZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQgcGFzc2VkIHRvIDxQbGF5ZXIgLz4uIFNlZSBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvZXhhbXBsZXMgZm9yIGhvdyB0byBzZXQgdXAgdGhlIFBsYXllciBjb3JyZWN0bHkuXCIsXG4gICAgICAgIFwiLSBZb3UgaGF2ZSBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBSZW1vdGlvbiBpbnN0YWxsZWQgd2hpY2ggY2F1c2VzIHRoZSBSZWFjdCBjb250ZXh0IHRvIGdldCBsb3N0LlwiXG4gICAgICBdLmpvaW4oXCItXCIpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmlkZW8gY29uZmlnIGZvdW5kLiBZb3UgYXJlIHByb2JhYmx5IGNhbGxpbmcgdXNlVmlkZW9Db25maWcoKSBmcm9tIGEgY29tcG9uZW50IHdoaWNoIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIGFzIGEgPENvbXBvc2l0aW9uIC8+LiBTZWUgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvdGhlLWZ1bmRhbWVudGFscyNkZWZpbmluZy1jb21wb3NpdGlvbnMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpO1xuICB9XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCB1c2VWaWRlb0NvbmZpZygpIG91dHNpZGUgYSBSZW1vdGlvbiBjb21wb3NpdGlvbi5cIik7XG4gIH1cbiAgcmV0dXJuIHZpZGVvQ29uZmlnO1xufTtcblxuLy8gc3JjL2ZyZWV6ZS50c3hcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDksIHVzZU1lbW8gYXMgdXNlTWVtbzggfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3VzZS1jdXJyZW50LWZyYW1lLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ4IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlQ3VycmVudEZyYW1lID0gKCkgPT4ge1xuICBjb25zdCBjYW5Vc2VSZW1vdGlvbkhvb2tzID0gdXNlQ29udGV4dDgoQ2FuVXNlUmVtb3Rpb25Ib29rcyk7XG4gIGlmICghY2FuVXNlUmVtb3Rpb25Ib29rcykge1xuICAgIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdXNlQ3VycmVudEZyYW1lIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgYSBjb21wb25lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIDxQbGF5ZXI+LiBTZWU6IGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3BsYXllci9leGFtcGxlc2ApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVzZUN1cnJlbnRGcmFtZSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgYSBjb21wb25lbnQgdGhhdCB3YXMgcmVnaXN0ZXJlZCBhcyBhIGNvbXBvc2l0aW9uLiBTZWUgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvdGhlLWZ1bmRhbWVudGFscyNkZWZpbmluZy1jb21wb3NpdGlvbnNgKTtcbiAgfVxuICBjb25zdCBmcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQ4KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IGNvbnRleHRPZmZzZXQgPSBjb250ZXh0ID8gY29udGV4dC5jdW11bGF0ZWRGcm9tICsgY29udGV4dC5yZWxhdGl2ZUZyb20gOiAwO1xuICByZXR1cm4gZnJhbWUgLSBjb250ZXh0T2Zmc2V0O1xufTtcblxuLy8gc3JjL2ZyZWV6ZS50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRnJlZXplID0gKHtcbiAgZnJhbWU6IGZyYW1lVG9GcmVlemUsXG4gIGNoaWxkcmVuLFxuICBhY3RpdmUgPSB0cnVlXG59KSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVmlkZW9Db25maWcoKTtcbiAgaWYgKHR5cGVvZiBmcmFtZVRvRnJlZXplID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgPEZyZWV6ZSAvPiBjb21wb25lbnQgcmVxdWlyZXMgYSAnZnJhbWUnIHByb3AsIGJ1dCBub25lIHdhcyBwYXNzZWQuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcmFtZVRvRnJlZXplICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2ZyYW1lJyBwcm9wIG9mIDxGcmVlemUgLz4gbXVzdCBiZSBhIG51bWJlciwgYnV0IGlzIG9mIHR5cGUgJHt0eXBlb2YgZnJhbWVUb0ZyZWV6ZX1gKTtcbiAgfVxuICBpZiAoTnVtYmVyLmlzTmFOKGZyYW1lVG9GcmVlemUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2ZyYW1lJyBwcm9wIG9mIDxGcmVlemUgLz4gbXVzdCBiZSBhIHJlYWwgbnVtYmVyLCBidXQgaXQgaXMgTmFOLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYW1lVG9GcmVlemUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2ZyYW1lJyBwcm9wIG9mIDxGcmVlemUgLz4gbXVzdCBiZSBhIGZpbml0ZSBudW1iZXIsIGJ1dCBpdCBpcyAke2ZyYW1lVG9GcmVlemV9LmApO1xuICB9XG4gIGNvbnN0IGlzQWN0aXZlID0gdXNlTWVtbzgoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgYWN0aXZlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIGFjdGl2ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhY3RpdmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFjdGl2ZShmcmFtZSk7XG4gICAgfVxuICB9LCBbYWN0aXZlLCBmcmFtZV0pO1xuICBjb25zdCB0aW1lbGluZUNvbnRleHQgPSB1c2VDb250ZXh0OShUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0OShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCByZWxhdGl2ZUZyb20gPSBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSA/PyAwO1xuICBjb25zdCB0aW1lbGluZVZhbHVlID0gdXNlTWVtbzgoKCkgPT4ge1xuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiB0aW1lbGluZUNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi50aW1lbGluZUNvbnRleHQsXG4gICAgICBwbGF5aW5nOiBmYWxzZSxcbiAgICAgIGltcGVyYXRpdmVQbGF5aW5nOiB7XG4gICAgICAgIGN1cnJlbnQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZnJhbWU6IHtcbiAgICAgICAgW3ZpZGVvQ29uZmlnLmlkXTogZnJhbWVUb0ZyZWV6ZSArIHJlbGF0aXZlRnJvbVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtpc0FjdGl2ZSwgdGltZWxpbmVDb250ZXh0LCB2aWRlb0NvbmZpZy5pZCwgZnJhbWVUb0ZyZWV6ZSwgcmVsYXRpdmVGcm9tXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NyhUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdGltZWxpbmVWYWx1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9TZXF1ZW5jZS50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVndWxhclNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHtcbiAgZnJvbSA9IDAsXG4gIGR1cmF0aW9uSW5GcmFtZXMgPSBJbmZpbml0eSxcbiAgY2hpbGRyZW4sXG4gIG5hbWUsXG4gIGhlaWdodCxcbiAgd2lkdGgsXG4gIHNob3dJblRpbWVsaW5lID0gdHJ1ZSxcbiAgX3JlbW90aW9uSW50ZXJuYWxMb29wRGlzcGxheTogbG9vcERpc3BsYXksXG4gIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrLFxuICBfcmVtb3Rpb25JbnRlcm5hbFByZW1vdW50RGlzcGxheTogcHJlbW91bnREaXNwbGF5LFxuICAuLi5vdGhlclxufSwgcmVmKSA9PiB7XG4gIGNvbnN0IHsgbGF5b3V0ID0gXCJhYnNvbHV0ZS1maWxsXCIgfSA9IG90aGVyO1xuICBjb25zdCBbaWRdID0gdXNlU3RhdGU0KCgpID0+IFN0cmluZyhNYXRoLnJhbmRvbSgpKSk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlID0gdXNlQ29udGV4dDEwKFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHsgcm9vdElkIH0gPSB1c2VDb250ZXh0MTAoVGltZWxpbmVDb250ZXh0KTtcbiAgY29uc3QgY3VtdWxhdGVkRnJvbSA9IHBhcmVudFNlcXVlbmNlID8gcGFyZW50U2VxdWVuY2UuY3VtdWxhdGVkRnJvbSArIHBhcmVudFNlcXVlbmNlLnJlbGF0aXZlRnJvbSA6IDA7XG4gIGNvbnN0IG5vbmNlID0gdXNlTm9uY2UoKTtcbiAgaWYgKGxheW91dCAhPT0gXCJhYnNvbHV0ZS1maWxsXCIgJiYgbGF5b3V0ICE9PSBcIm5vbmVcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBsYXlvdXQgcHJvcCBvZiA8U2VxdWVuY2UgLz4gZXhwZWN0cyBlaXRoZXIgXCJhYnNvbHV0ZS1maWxsXCIgb3IgXCJub25lXCIsIGJ1dCB5b3UgcGFzc2VkOiAke2xheW91dH1gKTtcbiAgfVxuICBpZiAobGF5b3V0ID09PSBcIm5vbmVcIiAmJiB0eXBlb2Ygb3RoZXIuc3R5bGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJZiBsYXlvdXQ9XCJub25lXCIsIHlvdSBtYXkgbm90IHBhc3MgYSBzdHlsZS4nKTtcbiAgfVxuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgcGFzc2VkIHRvIGR1cmF0aW9uSW5GcmFtZXMgYW4gYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkluRnJhbWVzfSwgYnV0IGl0IG11c3QgYmUgYSBudW1iZXIuYCk7XG4gIH1cbiAgaWYgKGR1cmF0aW9uSW5GcmFtZXMgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGR1cmF0aW9uSW5GcmFtZXMgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9YCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcm9tICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byB0aGUgXCJmcm9tXCIgcHJvcHMgb2YgeW91ciA8U2VxdWVuY2U+IGFuIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgZnJvbX0sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZyb20pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZnJvbVwiIHByb3Agb2YgYSBzZXF1ZW5jZSBtdXN0IGJlIGZpbml0ZSwgYnV0IGdvdCAke2Zyb219LmApO1xuICB9XG4gIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgcGFyZW50U2VxdWVuY2VEdXJhdGlvbiA9IHBhcmVudFNlcXVlbmNlID8gTWF0aC5taW4ocGFyZW50U2VxdWVuY2UuZHVyYXRpb25JbkZyYW1lcyAtIGZyb20sIGR1cmF0aW9uSW5GcmFtZXMpIDogZHVyYXRpb25JbkZyYW1lcztcbiAgY29uc3QgYWN0dWFsRHVyYXRpb25JbkZyYW1lcyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZpZGVvQ29uZmlnLmR1cmF0aW9uSW5GcmFtZXMgLSBmcm9tLCBwYXJlbnRTZXF1ZW5jZUR1cmF0aW9uKSk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJTZXF1ZW5jZSwgdW5yZWdpc3RlclNlcXVlbmNlIH0gPSB1c2VDb250ZXh0MTAoU2VxdWVuY2VNYW5hZ2VyKTtcbiAgY29uc3QgeyBoaWRkZW4gfSA9IHVzZUNvbnRleHQxMChTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0KTtcbiAgY29uc3QgcHJlbW91bnRpbmcgPSB1c2VNZW1vOSgoKSA9PiB7XG4gICAgcmV0dXJuIHBhcmVudFNlcXVlbmNlPy5wcmVtb3VudGluZyB8fCBCb29sZWFuKG90aGVyLl9yZW1vdGlvbkludGVybmFsSXNQcmVtb3VudGluZyk7XG4gIH0sIFtvdGhlci5fcmVtb3Rpb25JbnRlcm5hbElzUHJlbW91bnRpbmcsIHBhcmVudFNlcXVlbmNlPy5wcmVtb3VudGluZ10pO1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vOSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1bXVsYXRlZEZyb20sXG4gICAgICByZWxhdGl2ZUZyb206IGZyb20sXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgICAgcGFyZW50RnJvbTogcGFyZW50U2VxdWVuY2U/LnJlbGF0aXZlRnJvbSA/PyAwLFxuICAgICAgaWQsXG4gICAgICBoZWlnaHQ6IGhlaWdodCA/PyBwYXJlbnRTZXF1ZW5jZT8uaGVpZ2h0ID8/IG51bGwsXG4gICAgICB3aWR0aDogd2lkdGggPz8gcGFyZW50U2VxdWVuY2U/LndpZHRoID8/IG51bGwsXG4gICAgICBwcmVtb3VudGluZ1xuICAgIH07XG4gIH0sIFtcbiAgICBjdW11bGF0ZWRGcm9tLFxuICAgIGZyb20sXG4gICAgYWN0dWFsRHVyYXRpb25JbkZyYW1lcyxcbiAgICBwYXJlbnRTZXF1ZW5jZSxcbiAgICBpZCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgcHJlbW91bnRpbmdcbiAgXSk7XG4gIGNvbnN0IHRpbWVsaW5lQ2xpcE5hbWUgPSB1c2VNZW1vOSgoKSA9PiB7XG4gICAgcmV0dXJuIG5hbWUgPz8gXCJcIjtcbiAgfSwgW25hbWVdKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKCFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnaXN0ZXJTZXF1ZW5jZSh7XG4gICAgICBmcm9tLFxuICAgICAgZHVyYXRpb246IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBpZCxcbiAgICAgIGRpc3BsYXlOYW1lOiB0aW1lbGluZUNsaXBOYW1lLFxuICAgICAgcGFyZW50OiBwYXJlbnRTZXF1ZW5jZT8uaWQgPz8gbnVsbCxcbiAgICAgIHR5cGU6IFwic2VxdWVuY2VcIixcbiAgICAgIHJvb3RJZCxcbiAgICAgIHNob3dJblRpbWVsaW5lLFxuICAgICAgbm9uY2UsXG4gICAgICBsb29wRGlzcGxheSxcbiAgICAgIHN0YWNrOiBzdGFjayA/PyBudWxsLFxuICAgICAgcHJlbW91bnREaXNwbGF5OiBwcmVtb3VudERpc3BsYXkgPz8gbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyU2VxdWVuY2UoaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgIGlkLFxuICAgIG5hbWUsXG4gICAgcmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICB0aW1lbGluZUNsaXBOYW1lLFxuICAgIHVucmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICBwYXJlbnRTZXF1ZW5jZT8uaWQsXG4gICAgYWN0dWFsRHVyYXRpb25JbkZyYW1lcyxcbiAgICByb290SWQsXG4gICAgZnJvbSxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBub25jZSxcbiAgICBsb29wRGlzcGxheSxcbiAgICBzdGFjayxcbiAgICBwcmVtb3VudERpc3BsYXlcbiAgXSk7XG4gIGNvbnN0IGVuZFRocmVzaG9sZCA9IE1hdGguY2VpbChjdW11bGF0ZWRGcm9tICsgZnJvbSArIGR1cmF0aW9uSW5GcmFtZXMgLSAxKTtcbiAgY29uc3QgY29udGVudCA9IGFic29sdXRlRnJhbWUgPCBjdW11bGF0ZWRGcm9tICsgZnJvbSA/IG51bGwgOiBhYnNvbHV0ZUZyYW1lID4gZW5kVGhyZXNob2xkID8gbnVsbCA6IGNoaWxkcmVuO1xuICBjb25zdCBzdHlsZUlmVGhlcmUgPSBvdGhlci5sYXlvdXQgPT09IFwibm9uZVwiID8gdW5kZWZpbmVkIDogb3RoZXIuc3R5bGU7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZmxleERpcmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgLi4ud2lkdGggPyB7IHdpZHRoIH0gOiB7fSxcbiAgICAgIC4uLmhlaWdodCA/IHsgaGVpZ2h0IH0gOiB7fSxcbiAgICAgIC4uLnN0eWxlSWZUaGVyZSA/PyB7fVxuICAgIH07XG4gIH0sIFtoZWlnaHQsIHN0eWxlSWZUaGVyZSwgd2lkdGhdKTtcbiAgaWYgKHJlZiAhPT0gbnVsbCAmJiBsYXlvdXQgPT09IFwibm9uZVwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXQgaXMgbm90IHN1cHBvcnRlZCB0byBwYXNzIGJvdGggYSBgcmVmYCBhbmQgYGxheW91dD1cIm5vbmVcImAgdG8gPFNlcXVlbmNlIC8+LicpO1xuICB9XG4gIGNvbnN0IGlzU2VxdWVuY2VIaWRkZW4gPSBoaWRkZW5baWRdID8/IGZhbHNlO1xuICBpZiAoaXNTZXF1ZW5jZUhpZGRlbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OChTZXF1ZW5jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIGNoaWxkcmVuOiBjb250ZW50ID09PSBudWxsID8gbnVsbCA6IG90aGVyLmxheW91dCA9PT0gXCJub25lXCIgPyBjb250ZW50IDogLyogQF9fUFVSRV9fICovIGpzeDgoQWJzb2x1dGVGaWxsLCB7XG4gICAgICByZWYsXG4gICAgICBzdHlsZTogZGVmYXVsdFN0eWxlLFxuICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbjogY29udGVudFxuICAgIH0pXG4gIH0pO1xufTtcbnZhciBSZWd1bGFyU2VxdWVuY2UgPSBmb3J3YXJkUmVmMihSZWd1bGFyU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xudmFyIFByZW1vdW50ZWRTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGlmIChwcm9wcy5sYXlvdXQgPT09IFwibm9uZVwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgPFNlcXVlbmNlPmAgd2l0aCBgcHJlbW91bnRGb3JgIHByb3AgZG9lcyBub3Qgc3VwcG9ydCBsYXlvdXQ9XCJub25lXCInKTtcbiAgfVxuICBjb25zdCB7XG4gICAgc3R5bGU6IHBhc3NlZFN0eWxlLFxuICAgIGZyb20gPSAwLFxuICAgIHByZW1vdW50Rm9yID0gMCxcbiAgICBzdHlsZVdoaWxlUHJlbW91bnRlZCxcbiAgICAuLi5vdGhlclByb3BzXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcHJlbW91bnRpbmdBY3RpdmUgPSBmcmFtZSA8IGZyb20gJiYgZnJhbWUgPj0gZnJvbSAtIHByZW1vdW50Rm9yO1xuICBjb25zdCBzdHlsZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFzc2VkU3R5bGUsXG4gICAgICBvcGFjaXR5OiBwcmVtb3VudGluZ0FjdGl2ZSA/IDAgOiAxLFxuICAgICAgcG9pbnRlckV2ZW50czogcHJlbW91bnRpbmdBY3RpdmUgPyBcIm5vbmVcIiA6IHBhc3NlZFN0eWxlPy5wb2ludGVyRXZlbnRzID8/IHVuZGVmaW5lZCxcbiAgICAgIC4uLnByZW1vdW50aW5nQWN0aXZlID8gc3R5bGVXaGlsZVByZW1vdW50ZWQgOiB7fVxuICAgIH07XG4gIH0sIFtwYXNzZWRTdHlsZSwgcHJlbW91bnRpbmdBY3RpdmUsIHN0eWxlV2hpbGVQcmVtb3VudGVkXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OChGcmVlemUsIHtcbiAgICBmcmFtZTogZnJvbSxcbiAgICBhY3RpdmU6IHByZW1vdW50aW5nQWN0aXZlLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4OChTZXF1ZW5jZSwge1xuICAgICAgcmVmLFxuICAgICAgZnJvbSxcbiAgICAgIHN0eWxlLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxQcmVtb3VudERpc3BsYXk6IHByZW1vdW50Rm9yLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxJc1ByZW1vdW50aW5nOiBwcmVtb3VudGluZ0FjdGl2ZSxcbiAgICAgIC4uLm90aGVyUHJvcHNcbiAgICB9KVxuICB9KTtcbn07XG52YXIgUHJlbW91bnRlZFNlcXVlbmNlID0gZm9yd2FyZFJlZjIoUHJlbW91bnRlZFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcbnZhciBTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGlmIChwcm9wcy5sYXlvdXQgIT09IFwibm9uZVwiICYmIHByb3BzLnByZW1vdW50Rm9yICYmICFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDgoUHJlbW91bnRlZFNlcXVlbmNlLCB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHJlZlxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OChSZWd1bGFyU2VxdWVuY2UsIHtcbiAgICAuLi5wcm9wcyxcbiAgICByZWZcbiAgfSk7XG59O1xudmFyIFNlcXVlbmNlID0gZm9yd2FyZFJlZjIoU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuLy8gc3JjL2FuaW1hdGVkLWltYWdlL0FuaW1hdGVkSW1hZ2UudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYzLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNCxcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VSZWYgYXMgdXNlUmVmMyxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGU1XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY2FuY2VsLXJlbmRlci50c1xudmFyIGlzRXJyb3JMaWtlID0gKGVycikgPT4ge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghKFwic3RhY2tcIiBpbiBlcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyLnN0YWNrICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghKFwibWVzc2FnZVwiIGluIGVycikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIubWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBjYW5jZWxSZW5kZXIoZXJyKSB7XG4gIGxldCBlcnJvcjtcbiAgaWYgKGlzRXJyb3JMaWtlKGVycikpIHtcbiAgICBlcnJvciA9IGVycjtcbiAgICBpZiAoIWVycm9yLnN0YWNrKSB7XG4gICAgICBlcnJvci5zdGFjayA9IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKS5zdGFjaztcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVyciA9PT0gXCJzdHJpbmdcIikge1xuICAgIGVycm9yID0gRXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvciA9IEVycm9yKFwiUmVuZGVyaW5nIHdhcyBjYW5jZWxsZWRcIik7XG4gIH1cbiAgd2luZG93LnJlbW90aW9uX2NhbmNlbGxlZEVycm9yID0gZXJyb3Iuc3RhY2s7XG4gIHRocm93IGVycm9yO1xufVxuXG4vLyBzcmMvbG9nLnRzXG52YXIgbG9nTGV2ZWxzID0gW1widHJhY2VcIiwgXCJ2ZXJib3NlXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiXTtcbnZhciBnZXROdW1iZXJGb3JMb2dMZXZlbCA9IChsZXZlbCkgPT4ge1xuICByZXR1cm4gbG9nTGV2ZWxzLmluZGV4T2YobGV2ZWwpO1xufTtcbnZhciBpc0VxdWFsT3JCZWxvd0xvZ0xldmVsID0gKGN1cnJlbnRMZXZlbCwgbGV2ZWwpID0+IHtcbiAgcmV0dXJuIGdldE51bWJlckZvckxvZ0xldmVsKGN1cnJlbnRMZXZlbCkgPD0gZ2V0TnVtYmVyRm9yTG9nTGV2ZWwobGV2ZWwpO1xufTtcbnZhciBMb2cgPSB7XG4gIHRyYWNlOiAobG9nTGV2ZWwsIC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoaXNFcXVhbE9yQmVsb3dMb2dMZXZlbChsb2dMZXZlbCwgXCJ0cmFjZVwiKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgIH1cbiAgfSxcbiAgdmVyYm9zZTogKGxvZ0xldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgaWYgKGlzRXF1YWxPckJlbG93TG9nTGV2ZWwobG9nTGV2ZWwsIFwidmVyYm9zZVwiKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgIH1cbiAgfSxcbiAgaW5mbzogKGxvZ0xldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgaWYgKGlzRXF1YWxPckJlbG93TG9nTGV2ZWwobG9nTGV2ZWwsIFwiaW5mb1wiKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgIH1cbiAgfSxcbiAgd2FybjogKGxvZ0xldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgaWYgKGlzRXF1YWxPckJlbG93TG9nTGV2ZWwobG9nTGV2ZWwsIFwid2FyblwiKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybiguLi5hcmdzKTtcbiAgICB9XG4gIH0sXG4gIGVycm9yOiAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICB9XG59O1xuXG4vLyBzcmMvZGVsYXktcmVuZGVyLnRzXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSBmYWxzZTtcbn1cbnZhciBoYW5kbGVzID0gW107XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0cyA9IHt9O1xufVxudmFyIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4gPSBcIlRoZSBkZWxheVJlbmRlciB3YXMgY2FsbGVkOlwiO1xudmFyIERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgPSBcIlJldHJpZXMgbGVmdDogXCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOID0gXCItIFJlbmRlcmluZyB0aGUgZnJhbWUgd2lsbCBiZSByZXRyaWVkLlwiO1xudmFyIERFTEFZX1JFTkRFUl9DTEVBUl9UT0tFTiA9IFwiaGFuZGxlIHdhcyBjbGVhcmVkIGFmdGVyXCI7XG52YXIgZGVmYXVsdFRpbWVvdXQgPSAzMDAwMDtcbnZhciBkZWxheVJlbmRlciA9IChsYWJlbCwgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIGxhYmVsICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBsYWJlbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsYWJlbCBwYXJhbWV0ZXIgb2YgZGVsYXlSZW5kZXIoKSBtdXN0IGJlIGEgc3RyaW5nIG9yIHVuZGVmaW5lZCwgZ290OiBcIiArIEpTT04uc3RyaW5naWZ5KGxhYmVsKSk7XG4gIH1cbiAgY29uc3QgaGFuZGxlID0gTWF0aC5yYW5kb20oKTtcbiAgaGFuZGxlcy5wdXNoKGhhbmRsZSk7XG4gIGNvbnN0IGNhbGxlZCA9IEVycm9yKCkuc3RhY2s/LnJlcGxhY2UoL15FcnJvci9nLCBcIlwiKSA/PyBcIlwiO1xuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgY29uc3QgdGltZW91dFRvVXNlID0gKG9wdGlvbnM/LnRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IGRlZmF1bHRUaW1lb3V0IDogd2luZG93LnJlbW90aW9uX3B1cHBldGVlclRpbWVvdXQgPz8gZGVmYXVsdFRpbWVvdXQpKSAtIDIwMDA7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnN0IHJldHJpZXNMZWZ0ID0gKG9wdGlvbnM/LnJldHJpZXMgPz8gMCkgLSAod2luZG93LnJlbW90aW9uX2F0dGVtcHQgLSAxKTtcbiAgICAgIHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzW2hhbmRsZV0gPSB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCA/PyBudWxsLFxuICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgIHRpbWVvdXQ6IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICBgQSBkZWxheVJlbmRlcigpYCxcbiAgICAgICAgICAgIGxhYmVsID8gYFwiJHtsYWJlbH1cImAgOiBudWxsLFxuICAgICAgICAgICAgYHdhcyBjYWxsZWQgYnV0IG5vdCBjbGVhcmVkIGFmdGVyICR7dGltZW91dFRvVXNlfW1zLiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy90aW1lb3V0IGZvciBoZWxwLmAsXG4gICAgICAgICAgICByZXRyaWVzTGVmdCA+IDAgPyBERUxBWV9SRU5ERVJfUkVUUklFU19MRUZUICsgcmV0cmllc0xlZnQgOiBudWxsLFxuICAgICAgICAgICAgcmV0cmllc0xlZnQgPiAwID8gREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOIDogbnVsbCxcbiAgICAgICAgICAgIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4sXG4gICAgICAgICAgICBjYWxsZWRcbiAgICAgICAgICBdLmZpbHRlcih0cnV0aHkpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIGNhbmNlbFJlbmRlcihFcnJvcihtZXNzYWdlKSk7XG4gICAgICAgIH0sIHRpbWVvdXRUb1VzZSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luZG93LnJlbW90aW9uX3JlbmRlclJlYWR5ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZTtcbn07XG52YXIgY29udGludWVSZW5kZXIgPSAoaGFuZGxlKSA9PiB7XG4gIGlmICh0eXBlb2YgaGFuZGxlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBjb250aW51ZVJlbmRlcigpIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgcGFyYW1ldGVyIHRoYXQgaXMgdGhlIHJldHVybiB2YWx1ZSBvZiBkZWxheVJlbmRlcigpLiBObyB2YWx1ZSB3YXMgcGFzc2VkLlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgcGFyYW1ldGVyIHBhc3NlZCBpbnRvIGNvbnRpbnVlUmVuZGVyKCkgbXVzdCBiZSB0aGUgcmV0dXJuIHZhbHVlIG9mIGRlbGF5UmVuZGVyKCkgd2hpY2ggaXMgYSBudW1iZXIuIEdvdDogXCIgKyBKU09OLnN0cmluZ2lmeShoYW5kbGUpKTtcbiAgfVxuICBoYW5kbGVzID0gaGFuZGxlcy5maWx0ZXIoKGgpID0+IHtcbiAgICBpZiAoaCA9PT0gaGFuZGxlKSB7XG4gICAgICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIGlmICghd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHNbaGFuZGxlXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxhYmVsLCBzdGFydFRpbWUsIHRpbWVvdXQgfSA9IHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzW2hhbmRsZV07XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICBsYWJlbCA/IGBkZWxheVJlbmRlcigpIFwiJHtsYWJlbH1cImAgOiBcIkEgZGVsYXlSZW5kZXIoKVwiLFxuICAgICAgICAgIERFTEFZX1JFTkRFUl9DTEVBUl9UT0tFTixcbiAgICAgICAgICBgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYFxuICAgICAgICBdLmZpbHRlcih0cnV0aHkpLmpvaW4oXCIgXCIpO1xuICAgICAgICBMb2cudmVyYm9zZSh3aW5kb3cucmVtb3Rpb25fbG9nTGV2ZWwsIG1lc3NhZ2UpO1xuICAgICAgICBkZWxldGUgd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHNbaGFuZGxlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICBpZiAoaGFuZGxlcy5sZW5ndGggPT09IDAgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5yZW1vdGlvbl9yZW5kZXJSZWFkeSA9IHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9jYW52YXMudHN4XG5pbXBvcnQgUmVhY3Q4LCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlMywgdXNlUmVmIGFzIHVzZVJlZjIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3g5IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgY2FsY0FyZ3MgPSAoZml0LCBmcmFtZVNpemUsIGNhbnZhc1NpemUpID0+IHtcbiAgc3dpdGNoIChmaXQpIHtcbiAgICBjYXNlIFwiZmlsbFwiOiB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBmcmFtZVNpemUud2lkdGgsXG4gICAgICAgIGZyYW1lU2l6ZS5oZWlnaHQsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgIGNhbnZhc1NpemUuaGVpZ2h0XG4gICAgICBdO1xuICAgIH1cbiAgICBjYXNlIFwiY29udGFpblwiOiB7XG4gICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKGNhbnZhc1NpemUud2lkdGggLyBmcmFtZVNpemUud2lkdGgsIGNhbnZhc1NpemUuaGVpZ2h0IC8gZnJhbWVTaXplLmhlaWdodCk7XG4gICAgICBjb25zdCBjZW50ZXJYID0gKGNhbnZhc1NpemUud2lkdGggLSBmcmFtZVNpemUud2lkdGggKiByYXRpbykgLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IChjYW52YXNTaXplLmhlaWdodCAtIGZyYW1lU2l6ZS5oZWlnaHQgKiByYXRpbykgLyAyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZnJhbWVTaXplLndpZHRoLFxuICAgICAgICBmcmFtZVNpemUuaGVpZ2h0LFxuICAgICAgICBjZW50ZXJYLFxuICAgICAgICBjZW50ZXJZLFxuICAgICAgICBmcmFtZVNpemUud2lkdGggKiByYXRpbyxcbiAgICAgICAgZnJhbWVTaXplLmhlaWdodCAqIHJhdGlvXG4gICAgICBdO1xuICAgIH1cbiAgICBjYXNlIFwiY292ZXJcIjoge1xuICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1heChjYW52YXNTaXplLndpZHRoIC8gZnJhbWVTaXplLndpZHRoLCBjYW52YXNTaXplLmhlaWdodCAvIGZyYW1lU2l6ZS5oZWlnaHQpO1xuICAgICAgY29uc3QgY2VudGVyWCA9IChjYW52YXNTaXplLndpZHRoIC0gZnJhbWVTaXplLndpZHRoICogcmF0aW8pIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSAoY2FudmFzU2l6ZS5oZWlnaHQgLSBmcmFtZVNpemUuaGVpZ2h0ICogcmF0aW8pIC8gMjtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGZyYW1lU2l6ZS53aWR0aCxcbiAgICAgICAgZnJhbWVTaXplLmhlaWdodCxcbiAgICAgICAgY2VudGVyWCxcbiAgICAgICAgY2VudGVyWSxcbiAgICAgICAgZnJhbWVTaXplLndpZHRoICogcmF0aW8sXG4gICAgICAgIGZyYW1lU2l6ZS5oZWlnaHQgKiByYXRpb1xuICAgICAgXTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZml0OiBcIiArIGZpdCk7XG4gIH1cbn07XG52YXIgQ2FudmFzUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHsgd2lkdGgsIGhlaWdodCwgZml0LCBjbGFzc05hbWUsIHN0eWxlIH0sIHJlZikgPT4ge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWYyKG51bGwpO1xuICBjb25zdCBkcmF3ID0gdXNlQ2FsbGJhY2s0KChpbWFnZURhdGEpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IHdpZHRoID8/IGltYWdlRGF0YS5kaXNwbGF5V2lkdGg7XG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ID8/IGltYWdlRGF0YS5kaXNwbGF5SGVpZ2h0O1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgcmVmIGlzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IGNhbnZhc1JlZi5jdXJyZW50Py5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgMmQgY29udGV4dFwiKTtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlRGF0YSwgLi4uY2FsY0FyZ3MoZml0LCB7XG4gICAgICBoZWlnaHQ6IGltYWdlRGF0YS5kaXNwbGF5SGVpZ2h0LFxuICAgICAgd2lkdGg6IGltYWdlRGF0YS5kaXNwbGF5V2lkdGhcbiAgICB9LCB7XG4gICAgICB3aWR0aDogY2FudmFzV2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodFxuICAgIH0pKTtcbiAgfSwgW2ZpdCwgaGVpZ2h0LCB3aWR0aF0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlMyhyZWYsICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZHJhdyxcbiAgICAgIGdldENhbnZhczogKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIHJlZiBpcyBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgIH0sXG4gICAgICBjbGVhcjogKCkgPT4ge1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXNSZWYuY3VycmVudD8uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgMmQgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1JlZi5jdXJyZW50LndpZHRoLCBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtkcmF3XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OShcImNhbnZhc1wiLCB7XG4gICAgcmVmOiBjYW52YXNSZWYsXG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlXG4gIH0pO1xufTtcbnZhciBDYW52YXMgPSBSZWFjdDguZm9yd2FyZFJlZihDYW52YXNSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuXG4vLyBzcmMvYW5pbWF0ZWQtaW1hZ2UvZGVjb2RlLWltYWdlLnRzXG52YXIgQ0FDSEVfU0laRSA9IDU7XG52YXIgZ2V0QWN0dWFsVGltZSA9ICh7XG4gIGxvb3BCZWhhdmlvcixcbiAgZHVyYXRpb25Gb3VuZCxcbiAgdGltZUluU2VjXG59KSA9PiB7XG4gIHJldHVybiBsb29wQmVoYXZpb3IgPT09IFwibG9vcFwiID8gZHVyYXRpb25Gb3VuZCA/IHRpbWVJblNlYyAlIGR1cmF0aW9uRm91bmQgOiB0aW1lSW5TZWMgOiBNYXRoLm1pbih0aW1lSW5TZWMsIGR1cmF0aW9uRm91bmQgfHwgSW5maW5pdHkpO1xufTtcbnZhciBkZWNvZGVJbWFnZSA9IGFzeW5jICh7XG4gIHJlc29sdmVkU3JjLFxuICBzaWduYWwsXG4gIGN1cnJlbnRUaW1lLFxuICBpbml0aWFsTG9vcEJlaGF2aW9yXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgSW1hZ2VEZWNvZGVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIFdlYkNvZGVjcyBJbWFnZURlY29kZXIgQVBJLlwiKTtcbiAgfVxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChyZXNvbHZlZFNyYywgeyBzaWduYWwgfSk7XG4gIGNvbnN0IHsgYm9keSB9ID0gcmVzO1xuICBpZiAoIWJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJHb3Qgbm8gYm9keVwiKTtcbiAgfVxuICBjb25zdCBkZWNvZGVyID0gbmV3IEltYWdlRGVjb2Rlcih7XG4gICAgZGF0YTogYm9keSxcbiAgICB0eXBlOiByZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikgfHwgXCJpbWFnZS9naWZcIlxuICB9KTtcbiAgYXdhaXQgZGVjb2Rlci5jb21wbGV0ZWQ7XG4gIGNvbnN0IHsgc2VsZWN0ZWRUcmFjayB9ID0gZGVjb2Rlci50cmFja3M7XG4gIGlmICghc2VsZWN0ZWRUcmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNlbGVjdGVkIHRyYWNrXCIpO1xuICB9XG4gIGNvbnN0IGNhY2hlID0gW107XG4gIGxldCBkdXJhdGlvbkZvdW5kID0gbnVsbDtcbiAgY29uc3QgZ2V0RnJhbWVCeUluZGV4ID0gYXN5bmMgKGZyYW1lSW5kZXgpID0+IHtcbiAgICBjb25zdCBmb3VuZEluQ2FjaGUgPSBjYWNoZS5maW5kKChjKSA9PiBjLmZyYW1lSW5kZXggPT09IGZyYW1lSW5kZXgpO1xuICAgIGlmIChmb3VuZEluQ2FjaGUgJiYgZm91bmRJbkNhY2hlLmZyYW1lKSB7XG4gICAgICByZXR1cm4gZm91bmRJbkNhY2hlO1xuICAgIH1cbiAgICBjb25zdCBmcmFtZSA9IGF3YWl0IGRlY29kZXIuZGVjb2RlKHtcbiAgICAgIGZyYW1lSW5kZXgsXG4gICAgICBjb21wbGV0ZUZyYW1lc09ubHk6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoZm91bmRJbkNhY2hlKSB7XG4gICAgICBmb3VuZEluQ2FjaGUuZnJhbWUgPSBmcmFtZS5pbWFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCh7XG4gICAgICAgIGZyYW1lOiBmcmFtZS5pbWFnZSxcbiAgICAgICAgZnJhbWVJbmRleCxcbiAgICAgICAgdGltZUluU2Vjb25kczogZnJhbWUuaW1hZ2UudGltZXN0YW1wIC8gMWU2XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYW1lOiBmcmFtZS5pbWFnZSxcbiAgICAgIGZyYW1lSW5kZXgsXG4gICAgICB0aW1lSW5TZWNvbmRzOiBmcmFtZS5pbWFnZS50aW1lc3RhbXAgLyAxZTZcbiAgICB9O1xuICB9O1xuICBjb25zdCBjbGVhckNhY2hlID0gKGNsb3NlVG9UaW1lSW5TZWMpID0+IHtcbiAgICBjb25zdCBpdGVtc0luQ2FjaGUgPSBjYWNoZS5maWx0ZXIoKGMpID0+IGMuZnJhbWUpO1xuICAgIGNvbnN0IHNvcnRCeUNsb3Nlc3RUb0N1cnJlbnRUaW1lID0gaXRlbXNJbkNhY2hlLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFEaWZmID0gTWF0aC5hYnMoYS50aW1lSW5TZWNvbmRzIC0gY2xvc2VUb1RpbWVJblNlYyk7XG4gICAgICBjb25zdCBiRGlmZiA9IE1hdGguYWJzKGIudGltZUluU2Vjb25kcyAtIGNsb3NlVG9UaW1lSW5TZWMpO1xuICAgICAgcmV0dXJuIGFEaWZmIC0gYkRpZmY7XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7aSA8IHNvcnRCeUNsb3Nlc3RUb0N1cnJlbnRUaW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA8IENBQ0hFX1NJWkUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtID0gc29ydEJ5Q2xvc2VzdFRvQ3VycmVudFRpbWVbaV07XG4gICAgICBpdGVtLmZyYW1lID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIgPSBhc3luYyAoe1xuICAgIHRpbWVJblNlYyxcbiAgICBsb29wQmVoYXZpb3JcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGFjdHVhbFRpbWVJblNlYyA9IGdldEFjdHVhbFRpbWUoe1xuICAgICAgZHVyYXRpb25Gb3VuZCxcbiAgICAgIGxvb3BCZWhhdmlvcixcbiAgICAgIHRpbWVJblNlY1xuICAgIH0pO1xuICAgIGNvbnN0IGZyYW1lc0JlZm9yZSA9IGNhY2hlLmZpbHRlcigoYykgPT4gYy50aW1lSW5TZWNvbmRzIDw9IGFjdHVhbFRpbWVJblNlYyk7XG4gICAgY29uc3QgYmlnZ2VzdEluZGV4ID0gZnJhbWVzQmVmb3JlLm1hcCgoYykgPT4gYy5mcmFtZUluZGV4KS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpLCAwKTtcbiAgICBsZXQgaSA9IGJpZ2dlc3RJbmRleDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgZiA9IGF3YWl0IGdldEZyYW1lQnlJbmRleChpKTtcbiAgICAgIGkrKztcbiAgICAgIGlmICghZi5mcmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmcmFtZSBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghZi5mcmFtZS5kdXJhdGlvbikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBzZWxlY3RlZFRyYWNrLmZyYW1lQ291bnQgJiYgZHVyYXRpb25Gb3VuZCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IChmLmZyYW1lLnRpbWVzdGFtcCArIGYuZnJhbWUuZHVyYXRpb24pIC8gMWU2O1xuICAgICAgICBkdXJhdGlvbkZvdW5kID0gZHVyYXRpb247XG4gICAgICB9XG4gICAgICBpZiAoZi50aW1lSW5TZWNvbmRzID4gYWN0dWFsVGltZUluU2VjIHx8IGkgPT09IHNlbGVjdGVkVHJhY2suZnJhbWVDb3VudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGVkVHJhY2suZnJhbWVDb3VudCAtIGJpZ2dlc3RJbmRleCA8IDMgJiYgbG9vcEJlaGF2aW9yID09PSBcImxvb3BcIikge1xuICAgICAgYXdhaXQgZ2V0RnJhbWVCeUluZGV4KDApO1xuICAgIH1cbiAgICBjbGVhckNhY2hlKGFjdHVhbFRpbWVJblNlYyk7XG4gIH07XG4gIGF3YWl0IGVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIoe1xuICAgIHRpbWVJblNlYzogY3VycmVudFRpbWUsXG4gICAgbG9vcEJlaGF2aW9yOiBpbml0aWFsTG9vcEJlaGF2aW9yXG4gIH0pO1xuICBhd2FpdCBlbnN1cmVGcmFtZUJlZm9yZUFuZEFmdGVyKHtcbiAgICB0aW1lSW5TZWM6IGN1cnJlbnRUaW1lLFxuICAgIGxvb3BCZWhhdmlvcjogaW5pdGlhbExvb3BCZWhhdmlvclxuICB9KTtcbiAgY29uc3QgZ2V0RnJhbWUgPSBhc3luYyAodGltZUluU2VjLCBsb29wQmVoYXZpb3IpID0+IHtcbiAgICBpZiAoZHVyYXRpb25Gb3VuZCAhPT0gbnVsbCAmJiB0aW1lSW5TZWMgPiBkdXJhdGlvbkZvdW5kICYmIGxvb3BCZWhhdmlvciA9PT0gXCJjbGVhci1hZnRlci1maW5pc2hcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFjdHVhbFRpbWVJblNlYyA9IGdldEFjdHVhbFRpbWUoe1xuICAgICAgbG9vcEJlaGF2aW9yLFxuICAgICAgZHVyYXRpb25Gb3VuZCxcbiAgICAgIHRpbWVJblNlY1xuICAgIH0pO1xuICAgIGF3YWl0IGVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIoeyB0aW1lSW5TZWM6IGFjdHVhbFRpbWVJblNlYywgbG9vcEJlaGF2aW9yIH0pO1xuICAgIGNvbnN0IGl0ZW1zSW5DYWNoZSA9IGNhY2hlLmZpbHRlcigoYykgPT4gYy5mcmFtZSk7XG4gICAgY29uc3QgY2xvc2VzdCA9IGl0ZW1zSW5DYWNoZS5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFEaWZmID0gTWF0aC5hYnMoYS50aW1lSW5TZWNvbmRzIC0gYWN0dWFsVGltZUluU2VjKTtcbiAgICAgIGNvbnN0IGJEaWZmID0gTWF0aC5hYnMoYi50aW1lSW5TZWNvbmRzIC0gYWN0dWFsVGltZUluU2VjKTtcbiAgICAgIHJldHVybiBhRGlmZiA8IGJEaWZmID8gYSA6IGI7XG4gICAgfSk7XG4gICAgaWYgKCFjbG9zZXN0LmZyYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmcmFtZSBmb3VuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3Q7XG4gIH07XG4gIHJldHVybiB7XG4gICAgZ2V0RnJhbWUsXG4gICAgZnJhbWVDb3VudDogc2VsZWN0ZWRUcmFjay5mcmFtZUNvdW50XG4gIH07XG59O1xuXG4vLyBzcmMvYW5pbWF0ZWQtaW1hZ2UvcmVzb2x2ZS1pbWFnZS1zb3VyY2UudHN4XG52YXIgcmVzb2x2ZUFuaW1hdGVkSW1hZ2VTb3VyY2UgPSAoc3JjKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHNyYztcbiAgfVxuICByZXR1cm4gbmV3IFVSTChzcmMsIHdpbmRvdy5vcmlnaW4pLmhyZWY7XG59O1xuXG4vLyBzcmMvYW5pbWF0ZWQtaW1hZ2UvQW5pbWF0ZWRJbWFnZS50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gxMCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEFuaW1hdGVkSW1hZ2UgPSBmb3J3YXJkUmVmMygoe1xuICBzcmMsXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIG9uRXJyb3IsXG4gIGxvb3BCZWhhdmlvciA9IFwibG9vcFwiLFxuICBwbGF5YmFja1JhdGUgPSAxLFxuICBmaXQgPSBcImZpbGxcIixcbiAgLi4ucHJvcHNcbn0sIGNhbnZhc1JlZikgPT4ge1xuICBjb25zdCBtb3VudFN0YXRlID0gdXNlUmVmMyh7IGlzTW91bnRlZDogdHJ1ZSB9KTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBtb3VudFN0YXRlO1xuICAgIGN1cnJlbnQuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlc29sdmVkU3JjID0gcmVzb2x2ZUFuaW1hdGVkSW1hZ2VTb3VyY2Uoc3JjKTtcbiAgY29uc3QgW2ltYWdlRGVjb2Rlciwgc2V0SW1hZ2VEZWNvZGVyXSA9IHVzZVN0YXRlNShudWxsKTtcbiAgY29uc3QgW2RlY29kZUhhbmRsZV0gPSB1c2VTdGF0ZTUoKCkgPT4gZGVsYXlSZW5kZXIoYFJlbmRlcmluZyA8QW5pbWF0ZWRJbWFnZS8+IHdpdGggc3JjPVwiJHtyZXNvbHZlZFNyY31cImApKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gZnJhbWUgLyBwbGF5YmFja1JhdGUgLyBmcHM7XG4gIGNvbnN0IGN1cnJlbnRUaW1lUmVmID0gdXNlUmVmMyhjdXJyZW50VGltZSk7XG4gIGN1cnJlbnRUaW1lUmVmLmN1cnJlbnQgPSBjdXJyZW50VGltZTtcbiAgY29uc3QgcmVmID0gdXNlUmVmMyhudWxsKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTQoY2FudmFzUmVmLCAoKSA9PiB7XG4gICAgY29uc3QgYyA9IHJlZi5jdXJyZW50Py5nZXRDYW52YXMoKTtcbiAgICBpZiAoIWMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyByZWYgaXMgbm90IHNldFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH0sIFtdKTtcbiAgY29uc3QgW2luaXRpYWxMb29wQmVoYXZpb3JdID0gdXNlU3RhdGU1KCgpID0+IGxvb3BCZWhhdmlvcik7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyO1xuICAgIGRlY29kZUltYWdlKHtcbiAgICAgIHJlc29sdmVkU3JjLFxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIGN1cnJlbnRUaW1lOiBjdXJyZW50VGltZVJlZi5jdXJyZW50LFxuICAgICAgaW5pdGlhbExvb3BCZWhhdmlvclxuICAgIH0pLnRoZW4oKGQpID0+IHtcbiAgICAgIHNldEltYWdlRGVjb2RlcihkKTtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKGRlY29kZUhhbmRsZSk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICBjb250aW51ZVJlbmRlcihkZWNvZGVIYW5kbGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yPy4oZXJyKTtcbiAgICAgICAgY29udGludWVSZW5kZXIoZGVjb2RlSGFuZGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmNlbFJlbmRlcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfTtcbiAgfSwgW3Jlc29sdmVkU3JjLCBkZWNvZGVIYW5kbGUsIG9uRXJyb3IsIGluaXRpYWxMb29wQmVoYXZpb3JdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWltYWdlRGVjb2Rlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWxheSA9IGRlbGF5UmVuZGVyKGBSZW5kZXJpbmcgZnJhbWUgYXQgJHtjdXJyZW50VGltZX0gb2YgPEFuaW1hdGVkSW1hZ2Ugc3JjPVwiJHtzcmN9XCIvPmApO1xuICAgIGltYWdlRGVjb2Rlci5nZXRGcmFtZShjdXJyZW50VGltZSwgbG9vcEJlaGF2aW9yKS50aGVuKCh2aWRlb0ZyYW1lKSA9PiB7XG4gICAgICBpZiAobW91bnRTdGF0ZS5jdXJyZW50LmlzTW91bnRlZCkge1xuICAgICAgICBpZiAodmlkZW9GcmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50Py5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZi5jdXJyZW50Py5kcmF3KHZpZGVvRnJhbWUuZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250aW51ZVJlbmRlcihkZWxheSk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICBjb250aW51ZVJlbmRlcihkZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW5jZWxSZW5kZXIoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2N1cnJlbnRUaW1lLCBpbWFnZURlY29kZXIsIGxvb3BCZWhhdmlvciwgb25FcnJvciwgc3JjXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTAoQ2FudmFzLCB7XG4gICAgcmVmLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBmaXQsXG4gICAgLi4ucHJvcHNcbiAgfSk7XG59KTtcbi8vIHNyYy9BcnRpZmFjdC50c3hcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDExLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NSwgdXNlU3RhdGUgYXMgdXNlU3RhdGU3IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9SZW5kZXJBc3NldE1hbmFnZXIudHN4XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxMCxcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s1LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0MixcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMTAsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlNlxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtYXJ0aWZhY3QudHNcbnZhciB2YWxpZGF0ZUFydGlmYWN0RmlsZW5hbWUgPSAoZmlsZW5hbWUpID0+IHtcbiAgaWYgKHR5cGVvZiBmaWxlbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImZpbGVuYW1lXCIgbXVzdCBiZSBhIHN0cmluZywgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGZpbGVuYW1lfWApO1xuICB9XG4gIGlmIChmaWxlbmFtZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGZpbGVuYW1lYCBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgfVxuICBpZiAoIWZpbGVuYW1lLm1hdGNoKC9eKFswLTlhLXpBLVotIV8uKicoKS86JiRAPTsrLD9dKykvZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgZmlsZW5hbWVgIG11c3QgbWF0Y2ggXCIvXihbMC05YS16QS1aLSFfLipcXCcoKS86JiRAPTsrLD9dKykvZ1wiLiBVc2UgZm9yd2FyZCBzbGFzaGVzIG9ubHksIGV2ZW4gb24gV2luZG93cy4nKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZUNvbnRlbnQgPSAoY29udGVudCkgPT4ge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgIT09IFwic3RyaW5nXCIgJiYgIShjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJjb250ZW50XCIgbXVzdCBiZSBhIHN0cmluZyBvciBVaW50OEFycmF5LCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgY29udGVudH1gKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIgJiYgY29udGVudC50cmltKCkgPT09IFwiXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGNvbnRlbnRgIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICB9XG59O1xudmFyIHZhbGlkYXRlUmVuZGVyQXNzZXQgPSAoYXJ0aWZhY3QpID0+IHtcbiAgaWYgKGFydGlmYWN0LnR5cGUgIT09IFwiYXJ0aWZhY3RcIikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YWxpZGF0ZUFydGlmYWN0RmlsZW5hbWUoYXJ0aWZhY3QuZmlsZW5hbWUpO1xuICBpZiAoYXJ0aWZhY3QuY29udGVudFR5cGUgPT09IFwidGh1bWJuYWlsXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFsaWRhdGVDb250ZW50KGFydGlmYWN0LmNvbnRlbnQpO1xufTtcblxuLy8gc3JjL1JlbmRlckFzc2V0TWFuYWdlci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gxMSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlbmRlckFzc2V0TWFuYWdlciA9IGNyZWF0ZUNvbnRleHQxMCh7XG4gIHJlZ2lzdGVyUmVuZGVyQXNzZXQ6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHVucmVnaXN0ZXJSZW5kZXJBc3NldDogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVuZGVyQXNzZXRzOiBbXVxufSk7XG52YXIgUmVuZGVyQXNzZXRNYW5hZ2VyUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtyZW5kZXJBc3NldHMsIHNldFJlbmRlckFzc2V0c10gPSB1c2VTdGF0ZTYoW10pO1xuICBjb25zdCByZWdpc3RlclJlbmRlckFzc2V0ID0gdXNlQ2FsbGJhY2s1KChyZW5kZXJBc3NldCkgPT4ge1xuICAgIHZhbGlkYXRlUmVuZGVyQXNzZXQocmVuZGVyQXNzZXQpO1xuICAgIHNldFJlbmRlckFzc2V0cygoYXNzZXRzKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLmFzc2V0cywgcmVuZGVyQXNzZXRdO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJSZW5kZXJBc3NldCA9IHVzZUNhbGxiYWNrNSgoaWQpID0+IHtcbiAgICBzZXRSZW5kZXJBc3NldHMoKGFzc3RzKSA9PiB7XG4gICAgICByZXR1cm4gYXNzdHMuZmlsdGVyKChhKSA9PiBhLmlkICE9PSBpZCk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdXNlTGF5b3V0RWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdGlvbl9jb2xsZWN0QXNzZXRzID0gKCkgPT4ge1xuICAgICAgICBzZXRSZW5kZXJBc3NldHMoW10pO1xuICAgICAgICByZXR1cm4gcmVuZGVyQXNzZXRzO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtyZW5kZXJBc3NldHNdKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbzEwKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICAgIHJlbmRlckFzc2V0c1xuICAgIH07XG4gIH0sIFtyZW5kZXJBc3NldHMsIHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDExKFJlbmRlckFzc2V0TWFuYWdlci5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvQXJ0aWZhY3QudHN4XG52YXIgQXJ0aWZhY3RUaHVtYm5haWwgPSBTeW1ib2woXCJUaHVtYm5haWxcIik7XG52YXIgQXJ0aWZhY3QgPSAoeyBmaWxlbmFtZSwgY29udGVudCB9KSA9PiB7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MTEoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3QgW2Vudl0gPSB1c2VTdGF0ZTcoKCkgPT4gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgW2lkXSA9IHVzZVN0YXRlNygoKSA9PiB7XG4gICAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgfSk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGlmICghZW52LmlzUmVuZGVyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICAgIHR5cGU6IFwiYXJ0aWZhY3RcIixcbiAgICAgICAgaWQsXG4gICAgICAgIGNvbnRlbnQ6IGJ0b2EobmV3IFRleHREZWNvZGVyKFwidXRmOFwiKS5kZWNvZGUoY29udGVudCkpLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImJpbmFyeVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRlbnQgPT09IEFydGlmYWN0VGh1bWJuYWlsKSB7XG4gICAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgICAgdHlwZTogXCJhcnRpZmFjdFwiLFxuICAgICAgICBpZCxcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGZyYW1lLFxuICAgICAgICBjb250ZW50VHlwZTogXCJ0aHVtYm5haWxcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgICB0eXBlOiBcImFydGlmYWN0XCIsXG4gICAgICAgIGlkLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXR1cm4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgICB9O1xuICB9LCBbXG4gICAgY29udGVudCxcbiAgICBlbnYuaXNSZW5kZXJpbmcsXG4gICAgZmlsZW5hbWUsXG4gICAgZnJhbWUsXG4gICAgaWQsXG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXRcbiAgXSk7XG4gIHJldHVybiBudWxsO1xufTtcbkFydGlmYWN0LlRodW1ibmFpbCA9IEFydGlmYWN0VGh1bWJuYWlsO1xuLy8gc3JjL2F1ZGlvL0F1ZGlvLnRzeFxuaW1wb3J0IHsgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNiwgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMSwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjMgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2Fic29sdXRlLXNyYy50c1xudmFyIGdldEFic29sdXRlU3JjID0gKHJlbGF0aXZlU3JjKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlU3JjO1xuICB9XG4gIHJldHVybiBuZXcgVVJMKHJlbGF0aXZlU3JjLCB3aW5kb3cub3JpZ2luKS5ocmVmO1xufTtcblxuLy8gc3JjL2NhbGN1bGF0ZS1sb29wLnRzXG52YXIgY2FsY3VsYXRlTG9vcER1cmF0aW9uID0gKHtcbiAgZW5kQXQsXG4gIG1lZGlhRHVyYXRpb24sXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIGxldCBkdXJhdGlvbiA9IG1lZGlhRHVyYXRpb247XG4gIGlmICh0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkdXJhdGlvbiA9IGVuZEF0O1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhcnRGcm9tICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZHVyYXRpb24gLT0gc3RhcnRGcm9tO1xuICB9XG4gIGNvbnN0IGFjdHVhbER1cmF0aW9uID0gZHVyYXRpb24gLyBwbGF5YmFja1JhdGU7XG4gIHJldHVybiBNYXRoLmZsb29yKGFjdHVhbER1cmF0aW9uKTtcbn07XG5cbi8vIHNyYy9sb29wL2luZGV4LnRzeFxuaW1wb3J0IFJlYWN0OSwgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxMSwgdXNlTWVtbyBhcyB1c2VNZW1vMTEgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIExvb3BDb250ZXh0ID0gY3JlYXRlQ29udGV4dDExKG51bGwpO1xudmFyIHVzZUxvb3AgPSAoKSA9PiB7XG4gIHJldHVybiBSZWFjdDkudXNlQ29udGV4dChMb29wQ29udGV4dCk7XG59O1xudmFyIExvb3AgPSAoeyBkdXJhdGlvbkluRnJhbWVzLCB0aW1lcyA9IEluZmluaXR5LCBjaGlsZHJlbiwgbmFtZSwgLi4ucHJvcHMgfSkgPT4ge1xuICBjb25zdCBjdXJyZW50RnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgeyBkdXJhdGlvbkluRnJhbWVzOiBjb21wRHVyYXRpb24gfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCB7XG4gICAgY29tcG9uZW50OiBcIm9mIHRoZSA8TG9vcCAvPiBjb21wb25lbnRcIixcbiAgICBhbGxvd0Zsb2F0czogdHJ1ZVxuICB9KTtcbiAgaWYgKHR5cGVvZiB0aW1lcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgdG8gXCJ0aW1lc1wiIGFuIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgdGltZXN9LCBidXQgaXQgbXVzdCBiZSBhIG51bWJlci5gKTtcbiAgfVxuICBpZiAodGltZXMgIT09IEluZmluaXR5ICYmIHRpbWVzICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInRpbWVzXCIgcHJvcCBvZiBhIGxvb3AgbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7dGltZXN9LmApO1xuICB9XG4gIGlmICh0aW1lcyA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJ0aW1lc1wiIHByb3Agb2YgYSBsb29wIG11c3QgYmUgYXQgbGVhc3QgMCwgYnV0IGdvdCAke3RpbWVzfWApO1xuICB9XG4gIGNvbnN0IG1heFRpbWVzID0gTWF0aC5jZWlsKGNvbXBEdXJhdGlvbiAvIGR1cmF0aW9uSW5GcmFtZXMpO1xuICBjb25zdCBhY3R1YWxUaW1lcyA9IE1hdGgubWluKG1heFRpbWVzLCB0aW1lcyk7XG4gIGNvbnN0IHN0eWxlID0gcHJvcHMubGF5b3V0ID09PSBcIm5vbmVcIiA/IHVuZGVmaW5lZCA6IHByb3BzLnN0eWxlO1xuICBjb25zdCBtYXhGcmFtZSA9IGR1cmF0aW9uSW5GcmFtZXMgKiAoYWN0dWFsVGltZXMgLSAxKTtcbiAgY29uc3QgaXRlcmF0aW9uID0gTWF0aC5mbG9vcihjdXJyZW50RnJhbWUgLyBkdXJhdGlvbkluRnJhbWVzKTtcbiAgY29uc3Qgc3RhcnQgPSBpdGVyYXRpb24gKiBkdXJhdGlvbkluRnJhbWVzO1xuICBjb25zdCBmcm9tID0gTWF0aC5taW4oc3RhcnQsIG1heEZyYW1lKTtcbiAgY29uc3QgbG9vcERpc3BsYXkgPSB1c2VNZW1vMTEoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBudW1iZXJPZlRpbWVzOiBhY3R1YWxUaW1lcyxcbiAgICAgIHN0YXJ0T2Zmc2V0OiAtZnJvbSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXNcbiAgICB9O1xuICB9LCBbYWN0dWFsVGltZXMsIGR1cmF0aW9uSW5GcmFtZXMsIGZyb21dKTtcbiAgY29uc3QgbG9vcENvbnRleHQgPSB1c2VNZW1vMTEoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVyYXRpb246IE1hdGguZmxvb3IoY3VycmVudEZyYW1lIC8gZHVyYXRpb25JbkZyYW1lcyksXG4gICAgICBkdXJhdGlvbkluRnJhbWVzXG4gICAgfTtcbiAgfSwgW2N1cnJlbnRGcmFtZSwgZHVyYXRpb25JbkZyYW1lc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDEyKExvb3BDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGxvb3BDb250ZXh0LFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MTIoU2VxdWVuY2UsIHtcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBmcm9tLFxuICAgICAgbmFtZTogbmFtZSA/PyBcIjxMb29wPlwiLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxMb29wRGlzcGxheTogbG9vcERpc3BsYXksXG4gICAgICBsYXlvdXQ6IHByb3BzLmxheW91dCxcbiAgICAgIHN0eWxlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9KTtcbn07XG5Mb29wLnVzZUxvb3AgPSB1c2VMb29wO1xuXG4vLyBzcmMvcHJlZmV0Y2gudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDEyIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9wbGF5YmFjay1sb2dnaW5nLnRzXG52YXIgcGxheWJhY2tMb2dnaW5nID0gKHtcbiAgbG9nTGV2ZWwsXG4gIHRhZyxcbiAgbWVzc2FnZSxcbiAgbW91bnRUaW1lXG59KSA9PiB7XG4gIGNvbnN0IHRhZ3MgPSBbbW91bnRUaW1lID8gRGF0ZS5ub3coKSAtIG1vdW50VGltZSArIFwibXMgXCIgOiBudWxsLCB0YWddLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgTG9nLnRyYWNlKGxvZ0xldmVsLCBgWyR7dGFnc31dYCwgbWVzc2FnZSk7XG59O1xuXG4vLyBzcmMvcHJlZmV0Y2gtc3RhdGUudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlOCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDEzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUHJlbG9hZENvbnRleHQgPSBjcmVhdGVDb250ZXh0MTIoe30pO1xudmFyIHByZWxvYWRzID0ge307XG52YXIgdXBkYXRlcnMgPSBbXTtcbnZhciBzZXRQcmVsb2FkcyA9ICh1cGRhdGVyKSA9PiB7XG4gIHByZWxvYWRzID0gdXBkYXRlcihwcmVsb2Fkcyk7XG4gIHVwZGF0ZXJzLmZvckVhY2goKHUpID0+IHUoKSk7XG59O1xudmFyIFByZWZldGNoUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtfcHJlbG9hZHMsIF9zZXRQcmVsb2Fkc10gPSB1c2VTdGF0ZTgoKCkgPT4gcHJlbG9hZHMpO1xuICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVyRnVuY3Rpb24gPSAoKSA9PiB7XG4gICAgICBfc2V0UHJlbG9hZHMocHJlbG9hZHMpO1xuICAgIH07XG4gICAgdXBkYXRlcnMucHVzaCh1cGRhdGVyRnVuY3Rpb24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1cGRhdGVycyA9IHVwZGF0ZXJzLmZpbHRlcigodSkgPT4gdSAhPT0gdXBkYXRlckZ1bmN0aW9uKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTMoUHJlbG9hZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogX3ByZWxvYWRzLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL3ByZWZldGNoLnRzXG52YXIgcmVtb3ZlQW5kR2V0SGFzaEZyYWdtZW50ID0gKHNyYykgPT4ge1xuICBjb25zdCBoYXNoSW5kZXggPSBzcmMuaW5kZXhPZihcIiNcIik7XG4gIGlmIChoYXNoSW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhc2hJbmRleDtcbn07XG52YXIgZ2V0U3JjV2l0aG91dEhhc2ggPSAoc3JjKSA9PiB7XG4gIGNvbnN0IGhhc2hJbmRleCA9IHJlbW92ZUFuZEdldEhhc2hGcmFnbWVudChzcmMpO1xuICBpZiAoaGFzaEluZGV4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHNyYztcbiAgfVxuICByZXR1cm4gc3JjLnNsaWNlKDAsIGhhc2hJbmRleCk7XG59O1xudmFyIHVzZVByZWxvYWQgPSAoc3JjKSA9PiB7XG4gIGNvbnN0IHByZWxvYWRzMiA9IHVzZUNvbnRleHQxMihQcmVsb2FkQ29udGV4dCk7XG4gIGNvbnN0IGhhc2hGcmFnbWVudEluZGV4ID0gcmVtb3ZlQW5kR2V0SGFzaEZyYWdtZW50KHNyYyk7XG4gIGNvbnN0IHdpdGhvdXRIYXNoRnJhZ21lbnQgPSBnZXRTcmNXaXRob3V0SGFzaChzcmMpO1xuICBpZiAoIXByZWxvYWRzMlt3aXRob3V0SGFzaEZyYWdtZW50XSkge1xuICAgIHJldHVybiBzcmM7XG4gIH1cbiAgaWYgKGhhc2hGcmFnbWVudEluZGV4ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByZWxvYWRzMlt3aXRob3V0SGFzaEZyYWdtZW50XSArIHNyYy5zbGljZShoYXNoRnJhZ21lbnRJbmRleCk7XG4gIH1cbiAgcmV0dXJuIHByZWxvYWRzMlt3aXRob3V0SGFzaEZyYWdtZW50XTtcbn07XG52YXIgYmxvYlRvQmFzZTY0ID0gZnVuY3Rpb24oYmxvYikge1xuICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBkYXRhVXJsID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgIHJlc29sdmUoZGF0YVVybCk7XG4gICAgfTtcbiAgICByZWFkZXIub25lcnJvciA9IChlcnIpID0+IHtcbiAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICB9O1xuICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICB9KTtcbn07XG52YXIgZ2V0QmxvYkZyb21SZWFkZXIgPSBhc3luYyAoe1xuICByZWFkZXIsXG4gIGNvbnRlbnRUeXBlLFxuICBjb250ZW50TGVuZ3RoLFxuICBvblByb2dyZXNzXG59KSA9PiB7XG4gIGxldCByZWNlaXZlZExlbmd0aCA9IDA7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgcmVjZWl2ZWRMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICBvblByb2dyZXNzKHsgbG9hZGVkQnl0ZXM6IHJlY2VpdmVkTGVuZ3RoLCB0b3RhbEJ5dGVzOiBjb250ZW50TGVuZ3RoIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBjaHVua3NBbGwgPSBuZXcgVWludDhBcnJheShyZWNlaXZlZExlbmd0aCk7XG4gIGxldCBwb3NpdGlvbiA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgY2h1bmtzQWxsLnNldChjaHVuaywgcG9zaXRpb24pO1xuICAgIHBvc2l0aW9uICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gbmV3IEJsb2IoW2NodW5rc0FsbF0sIHtcbiAgICB0eXBlOiBjb250ZW50VHlwZSA/PyB1bmRlZmluZWRcbiAgfSk7XG59O1xudmFyIHByZWZldGNoID0gKHNyYywgb3B0aW9ucykgPT4ge1xuICBjb25zdCBtZXRob2QgPSBvcHRpb25zPy5tZXRob2QgPz8gXCJibG9iLXVybFwiO1xuICBjb25zdCBsb2dMZXZlbCA9IG9wdGlvbnM/LmxvZ0xldmVsID8/IFwiaW5mb1wiO1xuICBjb25zdCBzcmNXaXRob3V0SGFzaCA9IGdldFNyY1dpdGhvdXRIYXNoKHNyYyk7XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJlZTogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgICB9LFxuICAgICAgd2FpdFVudGlsRG9uZTogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHNyY1dpdGhvdXRIYXNoKVxuICAgIH07XG4gIH1cbiAgTG9nLnZlcmJvc2UobG9nTGV2ZWwsIGBbcHJlZmV0Y2hdIFN0YXJ0aW5nIHByZWZldGNoICR7c3JjV2l0aG91dEhhc2h9YCk7XG4gIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICBsZXQgb2JqZWN0VXJsID0gbnVsbDtcbiAgbGV0IHJlc29sdmUgPSAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBsZXQgcmVqZWN0ID0gKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfTtcbiAgY29uc3Qgd2FpdFVudGlsRG9uZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXI7XG4gIGxldCBjYW5CZUFib3J0ZWQgPSB0cnVlO1xuICBmZXRjaChzcmNXaXRob3V0SGFzaCwge1xuICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgY3JlZGVudGlhbHM6IG9wdGlvbnM/LmNyZWRlbnRpYWxzID8/IHVuZGVmaW5lZFxuICB9KS50aGVuKChyZXMpID0+IHtcbiAgICBjYW5CZUFib3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yLCBzdGF0dXMgPSAke3Jlcy5zdGF0dXN9YCk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlckNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gb3B0aW9ucz8uY29udGVudFR5cGUgPz8gaGVhZGVyQ29udGVudFR5cGU7XG4gICAgY29uc3QgaGFzUHJvcGVyQ29udGVudFR5cGUgPSBjb250ZW50VHlwZSAmJiAoY29udGVudFR5cGUuc3RhcnRzV2l0aChcInZpZGVvL1wiKSB8fCBjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiYXVkaW8vXCIpIHx8IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpO1xuICAgIGlmICghaGFzUHJvcGVyQ29udGVudFR5cGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ2FsbGVkIHByZWZldGNoKCkgb24gJHtzcmNXaXRob3V0SGFzaH0gd2hpY2ggcmV0dXJuZWQgYSBcIkNvbnRlbnQtVHlwZVwiIG9mICR7aGVhZGVyQ29udGVudFR5cGV9LiBQcmVmZXRjaGVkIGNvbnRlbnQgc2hvdWxkIGhhdmUgYSBwcm9wZXIgY29udGVudCB0eXBlICh2aWRlby8uLi4gb3IgYXVkaW8vLi4uKSBvciBhIGNvbnRlbnRUeXBlIHBhc3NlZCB0aGUgb3B0aW9ucyBvZiBwcmVmZXRjaCgpLiBPdGhlcndpc2UsIHByZWZldGNoaW5nIHdpbGwgbm90IHdvcmsgcHJvcGVybHkgaW4gYWxsIGJyb3dzZXJzLmApO1xuICAgIH1cbiAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgcmVzcG9uc2Ugb2YgJHtzcmNXaXRob3V0SGFzaH0gaGFzIG5vIGJvZHlgKTtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gcmVzLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgcmV0dXJuIGdldEJsb2JGcm9tUmVhZGVyKHtcbiAgICAgIHJlYWRlcixcbiAgICAgIGNvbnRlbnRUeXBlOiBvcHRpb25zPy5jb250ZW50VHlwZSA/PyBoZWFkZXJDb250ZW50VHlwZSA/PyBudWxsLFxuICAgICAgY29udGVudExlbmd0aDogcmVzLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikgPyBwYXJzZUludChyZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApIDogbnVsbCxcbiAgICAgIG9uUHJvZ3Jlc3M6IG9wdGlvbnM/Lm9uUHJvZ3Jlc3NcbiAgICB9KTtcbiAgfSkudGhlbigoYnVmKSA9PiB7XG4gICAgaWYgKCFidWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0dWFsQmxvYiA9IG9wdGlvbnM/LmNvbnRlbnRUeXBlID8gbmV3IEJsb2IoW2J1Zl0sIHsgdHlwZTogb3B0aW9ucy5jb250ZW50VHlwZSB9KSA6IGJ1ZjtcbiAgICBpZiAobWV0aG9kID09PSBcImJhc2U2NFwiKSB7XG4gICAgICByZXR1cm4gYmxvYlRvQmFzZTY0KGFjdHVhbEJsb2IpO1xuICAgIH1cbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChhY3R1YWxCbG9iKTtcbiAgfSkudGhlbigodXJsKSA9PiB7XG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICBsb2dMZXZlbCxcbiAgICAgIHRhZzogXCJwcmVmZXRjaFwiLFxuICAgICAgbWVzc2FnZTogYEZpbmlzaGVkIHByZWZldGNoICR7c3JjV2l0aG91dEhhc2h9IHdpdGggbWV0aG9kICR7bWV0aG9kfWAsXG4gICAgICBtb3VudFRpbWU6IG51bGxcbiAgICB9KTtcbiAgICBvYmplY3RVcmwgPSB1cmw7XG4gICAgc2V0UHJlbG9hZHMoKHApID0+ICh7XG4gICAgICAuLi5wLFxuICAgICAgW3NyY1dpdGhvdXRIYXNoXTogb2JqZWN0VXJsXG4gICAgfSkpO1xuICAgIHJlc29sdmUob2JqZWN0VXJsKTtcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChlcnI/Lm1lc3NhZ2UuaW5jbHVkZXMoXCJmcmVlKCkgY2FsbGVkXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlamVjdChlcnIpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBmcmVlOiAoKSA9PiB7XG4gICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgdGFnOiBcInByZWZldGNoXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBGcmVlaW5nICR7c3JjV2l0aG91dEhhc2h9YCxcbiAgICAgICAgbW91bnRUaW1lOiBudWxsXG4gICAgICB9KTtcbiAgICAgIGlmIChvYmplY3RVcmwpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJibG9iLXVybFwiKSB7XG4gICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xuICAgICAgICB9XG4gICAgICAgIHNldFByZWxvYWRzKChwKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29weSA9IHsgLi4ucCB9O1xuICAgICAgICAgIGRlbGV0ZSBjb3B5W3NyY1dpdGhvdXRIYXNoXTtcbiAgICAgICAgICByZXR1cm4gY29weTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIGlmIChjYW5CZUFib3J0ZWQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoXCJmcmVlKCkgY2FsbGVkXCIpKTtcbiAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHdhaXRVbnRpbERvbmU6ICgpID0+IHtcbiAgICAgIHJldHVybiB3YWl0VW50aWxEb25lO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy92YWxpZGF0ZS1tZWRpYS1wcm9wcy50c1xudmFyIHZhbGlkYXRlTWVkaWFQcm9wcyA9IChwcm9wcywgY29tcG9uZW50KSA9PiB7XG4gIGlmICh0eXBlb2YgcHJvcHMudm9sdW1lICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiBwcm9wcy52b2x1bWUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcHJvcHMudm9sdW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgdm9sdW1lIG9mIHR5cGUgJHt0eXBlb2YgcHJvcHMudm9sdW1lfSB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBWb2x1bWUgbXVzdCBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uIHdpdGggdGhlIHNpZ25hdHVyZSAnKGZyYW1lOiBudW1iZXIpID0+IG51bWJlcicgdW5kZWZpbmVkLmApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHMudm9sdW1lID09PSBcIm51bWJlclwiICYmIHByb3BzLnZvbHVtZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgaGF2ZSBwYXNzZWQgYSB2b2x1bWUgYmVsb3cgMCB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBWb2x1bWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFgKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZSAhPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcHJvcHMucGxheWJhY2tSYXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgcGxheWJhY2tSYXRlIG9mIHR5cGUgJHt0eXBlb2YgcHJvcHMucGxheWJhY2tSYXRlfSB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBQbGF5YmFjayByYXRlIG11c3QgYSByZWFsIG51bWJlciBvciB1bmRlZmluZWQuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGUgPT09IFwibnVtYmVyXCIgJiYgKGlzTmFOKHByb3BzLnBsYXliYWNrUmF0ZSkgfHwgIU51bWJlci5pc0Zpbml0ZShwcm9wcy5wbGF5YmFja1JhdGUpIHx8IHByb3BzLnBsYXliYWNrUmF0ZSA8PSAwKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHBsYXliYWNrUmF0ZSBvZiAke3Byb3BzLnBsYXliYWNrUmF0ZX0gdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gUGxheWJhY2sgcmF0ZSBtdXN0IGJlIGEgcmVhbCBudW1iZXIgYWJvdmUgMC5gKTtcbiAgfVxufTtcblxuLy8gc3JjL3ZhbGlkYXRlLXN0YXJ0LWZyb20tcHJvcHMudHNcbnZhciB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzID0gKHN0YXJ0RnJvbSwgZW5kQXQpID0+IHtcbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZSBvZiBzdGFydEZyb20gcHJvcCBtdXN0IGJlIGEgbnVtYmVyLCBpbnN0ZWFkIGdvdCB0eXBlICR7dHlwZW9mIHN0YXJ0RnJvbX0uYCk7XG4gICAgfVxuICAgIGlmIChpc05hTihzdGFydEZyb20pIHx8IHN0YXJ0RnJvbSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzdGFydEZyb20gcHJvcCBjYW4gbm90IGJlIE5hTiBvciBJbmZpbml0eS5cIik7XG4gICAgfVxuICAgIGlmIChzdGFydEZyb20gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGFydEZyb20gbXVzdCBiZSBncmVhdGVyIHRoYW4gZXF1YWwgdG8gMCBpbnN0ZWFkIGdvdCAke3N0YXJ0RnJvbX0uYCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIGVuZEF0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlIG9mIGVuZEF0IHByb3AgbXVzdCBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgdHlwZSAke3R5cGVvZiBlbmRBdH0uYCk7XG4gICAgfVxuICAgIGlmIChpc05hTihlbmRBdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmRBdCBwcm9wIGNhbiBub3QgYmUgTmFOLlwiKTtcbiAgICB9XG4gICAgaWYgKGVuZEF0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGVuZEF0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIsIGluc3RlYWQgZ290ICR7ZW5kQXR9LmApO1xuICAgIH1cbiAgfVxuICBpZiAoZW5kQXQgPCBzdGFydEZyb20pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5kQXQgcHJvcCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFydEZyb20gcHJvcC5cIik7XG4gIH1cbn07XG5cbi8vIHNyYy92aWRlby9kdXJhdGlvbi1zdGF0ZS50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDEzLCB1c2VNZW1vIGFzIHVzZU1lbW8xMiwgdXNlUmVkdWNlciB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDE0IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgZHVyYXRpb25SZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJnb3QtZHVyYXRpb25cIjoge1xuICAgICAgY29uc3QgYWJzb2x1dGVTcmMgPSBnZXRBYnNvbHV0ZVNyYyhhY3Rpb24uc3JjKTtcbiAgICAgIGlmIChzdGF0ZVthYnNvbHV0ZVNyY10gPT09IGFjdGlvbi5kdXJhdGlvbkluU2Vjb25kcykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW2Fic29sdXRlU3JjXTogYWN0aW9uLmR1cmF0aW9uSW5TZWNvbmRzXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xudmFyIER1cmF0aW9uc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0MTMoe1xuICBkdXJhdGlvbnM6IHt9LFxuICBzZXREdXJhdGlvbnM6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb250ZXh0IG1pc3NpbmdcIik7XG4gIH1cbn0pO1xudmFyIER1cmF0aW9uc0NvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW2R1cmF0aW9ucywgc2V0RHVyYXRpb25zXSA9IHVzZVJlZHVjZXIoZHVyYXRpb25SZWR1Y2VyLCB7fSk7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzEyKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZHVyYXRpb25zLFxuICAgICAgc2V0RHVyYXRpb25zXG4gICAgfTtcbiAgfSwgW2R1cmF0aW9uc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE0KER1cmF0aW9uc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9hdWRpby9BdWRpb0ZvclByZXZpZXcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY0LFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU1LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8xOSxcbiAgdXNlUmVmIGFzIHVzZVJlZjExLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTEzXG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvbG9nLWxldmVsLWNvbnRleHQudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QxMiBmcm9tIFwicmVhY3RcIjtcbnZhciBMb2dMZXZlbENvbnRleHQgPSBjcmVhdGVDb250ZXh0MTQoe1xuICBsb2dMZXZlbDogXCJpbmZvXCIsXG4gIG1vdW50VGltZTogMFxufSk7XG52YXIgdXNlTG9nTGV2ZWwgPSAoKSA9PiB7XG4gIGNvbnN0IHsgbG9nTGV2ZWwgfSA9IFJlYWN0MTIudXNlQ29udGV4dChMb2dMZXZlbENvbnRleHQpO1xuICBpZiAobG9nTGV2ZWwgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VMb2dMZXZlbCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgTG9nTGV2ZWxQcm92aWRlclwiKTtcbiAgfVxuICByZXR1cm4gbG9nTGV2ZWw7XG59O1xudmFyIHVzZU1vdW50VGltZSA9ICgpID0+IHtcbiAgY29uc3QgeyBtb3VudFRpbWUgfSA9IFJlYWN0MTIudXNlQ29udGV4dChMb2dMZXZlbENvbnRleHQpO1xuICBpZiAobW91bnRUaW1lID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlTW91bnRUaW1lIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBMb2dMZXZlbFByb3ZpZGVyXCIpO1xuICB9XG4gIHJldHVybiBtb3VudFRpbWU7XG59O1xuXG4vLyBzcmMvcmFuZG9tLnRzXG5mdW5jdGlvbiBtdWxiZXJyeTMyKGEpIHtcbiAgbGV0IHQgPSBhICsgMTgzMTU2NTgxMztcbiAgdCA9IE1hdGguaW11bCh0IF4gdCA+Pj4gMTUsIHQgfCAxKTtcbiAgdCBePSB0ICsgTWF0aC5pbXVsKHQgXiB0ID4+PiA3LCB0IHwgNjEpO1xuICByZXR1cm4gKCh0IF4gdCA+Pj4gMTQpID4+PiAwKSAvIDQyOTQ5NjcyOTY7XG59XG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgY2hyID0gMDtcbiAgbGV0IGhhc2ggPSAwO1xuICBmb3IgKGkgPSAwO2kgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgIGhhc2ggfD0gMDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cbnZhciByYW5kb20gPSAoc2VlZCwgZHVtbXkpID0+IHtcbiAgaWYgKGR1bW15ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmFuZG9tKCkgdGFrZXMgb25seSBvbmUgYXJndW1lbnRcIik7XG4gIH1cbiAgaWYgKHNlZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihoYXNoQ29kZShzZWVkKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG11bGJlcnJ5MzIoc2VlZCAqIDEwMDAwMDAwMDAwKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb20oKSBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpO1xufTtcblxuLy8gc3JjL3VzZS1hbXBsaWZpY2F0aW9uLnRzXG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0MywgdXNlUmVmIGFzIHVzZVJlZjQgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB3YXJuZWQgPSBmYWxzZTtcbnZhciB3YXJuT25jZSA9IChsb2dMZXZlbCkgPT4ge1xuICBpZiAod2FybmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5lZCA9IHRydWU7XG4gIExvZy53YXJuKGxvZ0xldmVsLCBcIkF1ZGlvQ29udGV4dCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbn07XG52YXIgZ2V0U2hvdWxkQW1wbGlmeSA9ICh2b2x1bWUpID0+IHtcbiAgcmV0dXJuIHZvbHVtZSA+IDE7XG59O1xudmFyIHVzZUFtcGxpZmljYXRpb24gPSAoe1xuICBtZWRpYVJlZixcbiAgdm9sdW1lLFxuICBsb2dMZXZlbFxufSkgPT4ge1xuICBjb25zdCBzaG91bGRBbXBsaWZ5ID0gZ2V0U2hvdWxkQW1wbGlmeSh2b2x1bWUpO1xuICBjb25zdCBhdWRpb1N0dWZmUmVmID0gdXNlUmVmNChudWxsKTtcbiAgY29uc3QgY3VycmVudFZvbHVtZVJlZiA9IHVzZVJlZjQodm9sdW1lKTtcbiAgY3VycmVudFZvbHVtZVJlZi5jdXJyZW50ID0gdm9sdW1lO1xuICB1c2VMYXlvdXRFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAoIXNob3VsZEFtcGxpZnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBdWRpb0NvbnRleHQpIHtcbiAgICAgIHdhcm5PbmNlKGxvZ0xldmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhdWRpb1N0dWZmUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCh7XG4gICAgICBsYXRlbmN5SGludDogXCJpbnRlcmFjdGl2ZVwiXG4gICAgfSk7XG4gICAgY29uc3Qgc291cmNlID0gbmV3IE1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZShhdWRpb0NvbnRleHQsIHtcbiAgICAgIG1lZGlhRWxlbWVudDogbWVkaWFSZWYuY3VycmVudFxuICAgIH0pO1xuICAgIGNvbnN0IGdhaW5Ob2RlID0gbmV3IEdhaW5Ob2RlKGF1ZGlvQ29udGV4dCwge1xuICAgICAgZ2FpbjogTWF0aC5tYXgoY3VycmVudFZvbHVtZVJlZi5jdXJyZW50LCAxKVxuICAgIH0pO1xuICAgIGF1ZGlvU3R1ZmZSZWYuY3VycmVudCA9IHtcbiAgICAgIGdhaW5Ob2RlLFxuICAgICAgc291cmNlLFxuICAgICAgYXVkaW9Db250ZXh0XG4gICAgfTtcbiAgICBzb3VyY2UuY29ubmVjdChnYWluTm9kZSk7XG4gICAgZ2Fpbk5vZGUuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgIExvZy50cmFjZShsb2dMZXZlbCwgYFN0YXJ0aW5nIHRvIGFtcGxpZnkgJHttZWRpYVJlZi5jdXJyZW50Py5zcmN9LiBHYWluID0gJHtjdXJyZW50Vm9sdW1lUmVmLmN1cnJlbnR9YCk7XG4gIH0sIFtsb2dMZXZlbCwgbWVkaWFSZWYsIHNob3VsZEFtcGxpZnldKTtcbiAgaWYgKGF1ZGlvU3R1ZmZSZWYuY3VycmVudCkge1xuICAgIGNvbnN0IHZhbHVlVG9TZXQgPSBNYXRoLm1heCh2b2x1bWUsIDEpO1xuICAgIGlmIChhdWRpb1N0dWZmUmVmLmN1cnJlbnQuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSAhPT0gdmFsdWVUb1NldCkge1xuICAgICAgYXVkaW9TdHVmZlJlZi5jdXJyZW50LmdhaW5Ob2RlLmdhaW4udmFsdWUgPSB2YWx1ZVRvU2V0O1xuICAgICAgTG9nLnRyYWNlKGxvZ0xldmVsLCBgU2V0dGluZyBnYWluIHRvICR7dmFsdWVUb1NldH0gZm9yICR7bWVkaWFSZWYuY3VycmVudD8uc3JjfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXVkaW9TdHVmZlJlZjtcbn07XG5cbi8vIHNyYy91c2UtbWVkaWEtaW4tdGltZWxpbmUudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDE1LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NywgdXNlTWVtbyBhcyB1c2VNZW1vMTMsIHVzZVN0YXRlIGFzIHVzZVN0YXRlOSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYXVkaW8vdXNlLWF1ZGlvLWZyYW1lLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxNCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhU3RhcnRzQXQgPSAoKSA9PiB7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlID0gdXNlQ29udGV4dDE0KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHN0YXJ0c0F0ID0gTWF0aC5taW4oMCwgcGFyZW50U2VxdWVuY2U/LnJlbGF0aXZlRnJvbSA/PyAwKTtcbiAgcmV0dXJuIHN0YXJ0c0F0O1xufTtcbnZhciB1c2VGcmFtZUZvclZvbHVtZVByb3AgPSAoYmVoYXZpb3IpID0+IHtcbiAgY29uc3QgbG9vcCA9IExvb3AudXNlTG9vcCgpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCBzdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgaWYgKGJlaGF2aW9yID09PSBcInJlcGVhdFwiIHx8IGxvb3AgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZnJhbWUgKyBzdGFydHNBdDtcbiAgfVxuICByZXR1cm4gZnJhbWUgKyBzdGFydHNBdCArIGxvb3AuZHVyYXRpb25JbkZyYW1lcyAqIGxvb3AuaXRlcmF0aW9uO1xufTtcblxuLy8gc3JjL2dldC1hc3NldC1maWxlLW5hbWUudHNcbnZhciBnZXRBc3NldERpc3BsYXlOYW1lID0gKGZpbGVuYW1lKSA9PiB7XG4gIGlmICgvZGF0YTp8YmxvYjovLnRlc3QoZmlsZW5hbWUuc3Vic3RyaW5nKDAsIDUpKSkge1xuICAgIHJldHVybiBcIkRhdGEgVVJMXCI7XG4gIH1cbiAgY29uc3Qgc3BsaXR0ZWQgPSBmaWxlbmFtZS5zcGxpdChcIi9cIikubWFwKChzKSA9PiBzLnNwbGl0KFwiXFxcXFwiKSkuZmxhdCgxKTtcbiAgcmV0dXJuIHNwbGl0dGVkW3NwbGl0dGVkLmxlbmd0aCAtIDFdO1xufTtcblxuLy8gc3JjL3BsYXktYW5kLWhhbmRsZS1ub3QtYWxsb3dlZC1lcnJvci50c1xudmFyIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3IgPSAoe1xuICBtZWRpYVJlZixcbiAgbWVkaWFUeXBlLFxuICBvbkF1dG9QbGF5RXJyb3IsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWUsXG4gIHJlYXNvblxufSkgPT4ge1xuICBjb25zdCB7IGN1cnJlbnQgfSA9IG1lZGlhUmVmO1xuICBpZiAoIWN1cnJlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICBsb2dMZXZlbCxcbiAgICB0YWc6IFwicGxheVwiLFxuICAgIG1lc3NhZ2U6IGBBdHRlbXB0aW5nIHRvIHBsYXkgJHtjdXJyZW50LnNyY30uIFJlYXNvbjogJHtyZWFzb259YCxcbiAgICBtb3VudFRpbWVcbiAgfSk7XG4gIGNvbnN0IHByb20gPSBjdXJyZW50LnBsYXkoKTtcbiAgaWYgKCFwcm9tLmNhdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb20uY2F0Y2goKGVycikgPT4ge1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJyZXF1ZXN0IHdhcyBpbnRlcnJ1cHRlZCBieSBhIGNhbGwgdG8gcGF1c2VcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwiVGhlIGZldGNoaW5nIHByb2Nlc3MgZm9yIHRoZSBtZWRpYSByZXNvdXJjZSB3YXMgYWJvcnRlZCBieSB0aGUgdXNlciBhZ2VudFwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJyZXF1ZXN0IHdhcyBpbnRlcnJ1cHRlZCBieSBhIG5ldyBsb2FkIHJlcXVlc3RcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwiYmVjYXVzZSB0aGUgbWVkaWEgd2FzIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnRcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwidXNlciBkaWRuJ3QgaW50ZXJhY3Qgd2l0aCB0aGUgZG9jdW1lbnRcIikgJiYgY3VycmVudC5tdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhgQ291bGQgbm90IHBsYXkgJHttZWRpYVR5cGV9IGR1ZSB0byBmb2xsb3dpbmcgZXJyb3I6IGAsIGVycik7XG4gICAgaWYgKCFjdXJyZW50Lm11dGVkKSB7XG4gICAgICBpZiAob25BdXRvUGxheUVycm9yKSB7XG4gICAgICAgIG9uQXV0b1BsYXlFcnJvcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgVGhlIHZpZGVvIHdpbGwgYmUgbXV0ZWQgYW5kIHdlJ2xsIHJldHJ5IHBsYXlpbmcgaXQuYCk7XG4gICAgICBpZiAobWVkaWFUeXBlID09PSBcInZpZGVvXCIgJiYgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUGxheWVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVXNlIG9uQXV0b1BsYXlFcnJvcigpIHRvIGhhbmRsZSB0aGlzIGVycm9yIHlvdXJzZWxmLlwiKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgY3VycmVudC5wbGF5KCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIHNyYy92b2x1bWUtcHJvcC50c1xudmFyIGV2YWx1YXRlVm9sdW1lID0gKHtcbiAgZnJhbWUsXG4gIHZvbHVtZSxcbiAgbWVkaWFWb2x1bWUgPSAxXG59KSA9PiB7XG4gIGlmICh0eXBlb2Ygdm9sdW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZvbHVtZSAqIG1lZGlhVm9sdW1lO1xuICB9XG4gIGlmICh0eXBlb2Ygdm9sdW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIE51bWJlcihtZWRpYVZvbHVtZSk7XG4gIH1cbiAgY29uc3QgZXZhbHVhdGVkID0gdm9sdW1lKGZyYW1lKSAqIG1lZGlhVm9sdW1lO1xuICBpZiAodHlwZW9mIGV2YWx1YXRlZCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgaW4gYSBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgZGlkIG5vdCByZXR1cm4gYSBudW1iZXIgYnV0IGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBldmFsdWF0ZWR9IGZvciBmcmFtZSAke2ZyYW1lfWApO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZXZhbHVhdGVkKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgaW4gYSBmdW5jdGlvbiB0byB0aGUgdm9sdW1lIHByb3AgYnV0IGl0IHJldHVybmVkIE5hTiBmb3IgZnJhbWUgJHtmcmFtZX0uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZXZhbHVhdGVkKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgaW4gYSBmdW5jdGlvbiB0byB0aGUgdm9sdW1lIHByb3AgYnV0IGl0IHJldHVybmVkIGEgbm9uLWZpbml0ZSBudW1iZXIgZm9yIGZyYW1lICR7ZnJhbWV9LmApO1xuICB9XG4gIHJldHVybiBNYXRoLm1heCgwLCBldmFsdWF0ZWQpO1xufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1pbi10aW1lbGluZS50c1xudmFyIGRpZFdhcm4gPSB7fTtcbnZhciB3YXJuT25jZTIgPSAobWVzc2FnZSkgPT4ge1xuICBpZiAoZGlkV2FyblttZXNzYWdlXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIGRpZFdhcm5bbWVzc2FnZV0gPSB0cnVlO1xufTtcbnZhciB1c2VNZWRpYUluVGltZWxpbmUgPSAoe1xuICB2b2x1bWUsXG4gIG1lZGlhVm9sdW1lLFxuICBtZWRpYVJlZixcbiAgc3JjLFxuICBtZWRpYVR5cGUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgZGlzcGxheU5hbWUsXG4gIGlkLFxuICBzdGFjayxcbiAgc2hvd0luVGltZWxpbmUsXG4gIHByZW1vdW50RGlzcGxheSxcbiAgb25BdXRvUGxheUVycm9yLFxuICBpc1ByZW1vdW50aW5nXG59KSA9PiB7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgeyByb290SWQsIGF1ZGlvQW5kVmlkZW9UYWdzIH0gPSB1c2VDb250ZXh0MTUoVGltZWxpbmVDb250ZXh0KTtcbiAgY29uc3QgcGFyZW50U2VxdWVuY2UgPSB1c2VDb250ZXh0MTUoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgYWN0dWFsRnJvbSA9IHBhcmVudFNlcXVlbmNlID8gcGFyZW50U2VxdWVuY2UucmVsYXRpdmVGcm9tICsgcGFyZW50U2VxdWVuY2UuY3VtdWxhdGVkRnJvbSA6IDA7XG4gIGNvbnN0IHsgaW1wZXJhdGl2ZVBsYXlpbmcgfSA9IHVzZUNvbnRleHQxNShUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgY29uc3QgeyByZWdpc3RlclNlcXVlbmNlLCB1bnJlZ2lzdGVyU2VxdWVuY2UgfSA9IHVzZUNvbnRleHQxNShTZXF1ZW5jZU1hbmFnZXIpO1xuICBjb25zdCBbaW5pdGlhbFZvbHVtZV0gPSB1c2VTdGF0ZTkoKCkgPT4gdm9sdW1lKTtcbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCBtb3VudFRpbWUgPSB1c2VNb3VudFRpbWUoKTtcbiAgY29uc3Qgbm9uY2UgPSB1c2VOb25jZSgpO1xuICBjb25zdCBkdXJhdGlvbiA9IHBhcmVudFNlcXVlbmNlID8gTWF0aC5taW4ocGFyZW50U2VxdWVuY2UuZHVyYXRpb25JbkZyYW1lcywgdmlkZW9Db25maWcuZHVyYXRpb25JbkZyYW1lcykgOiB2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzO1xuICBjb25zdCBkb2VzVm9sdW1lQ2hhbmdlID0gdHlwZW9mIHZvbHVtZSA9PT0gXCJmdW5jdGlvblwiO1xuICBjb25zdCB2b2x1bWVzID0gdXNlTWVtbzEzKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZvbHVtZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHZvbHVtZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheShNYXRoLmZsb29yKE1hdGgubWF4KDAsIGR1cmF0aW9uICsgc3RhcnRzQXQpKSkuZmlsbCh0cnVlKS5tYXAoKF8sIGkpID0+IHtcbiAgICAgIHJldHVybiBldmFsdWF0ZVZvbHVtZSh7XG4gICAgICAgIGZyYW1lOiBpICsgc3RhcnRzQXQsXG4gICAgICAgIHZvbHVtZSxcbiAgICAgICAgbWVkaWFWb2x1bWVcbiAgICAgIH0pO1xuICAgIH0pLmpvaW4oXCIsXCIpO1xuICB9LCBbZHVyYXRpb24sIHN0YXJ0c0F0LCB2b2x1bWUsIG1lZGlhVm9sdW1lXSk7XG4gIHVzZUVmZmVjdDcoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygdm9sdW1lID09PSBcIm51bWJlclwiICYmIHZvbHVtZSAhPT0gaW5pdGlhbFZvbHVtZSkge1xuICAgICAgd2Fybk9uY2UyKGBSZW1vdGlvbjogVGhlICR7bWVkaWFUeXBlfSB3aXRoIHNyYyAke3NyY30gaGFzIGNoYW5nZWQgaXQncyB2b2x1bWUuIFByZWZlciB0aGUgY2FsbGJhY2sgc3ludGF4IGZvciBzZXR0aW5nIHZvbHVtZSB0byBnZXQgYmV0dGVyIHRpbWVsaW5lIGRpc3BsYXk6IGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL2F1ZGlvL3ZvbHVtZWApO1xuICAgIH1cbiAgfSwgW2luaXRpYWxWb2x1bWUsIG1lZGlhVHlwZSwgc3JjLCB2b2x1bWVdKTtcbiAgdXNlRWZmZWN0NygoKSA9PiB7XG4gICAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICAgIH1cbiAgICBpZiAoIWdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1N0dWRpbyAmJiB3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzaG93SW5UaW1lbGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclNlcXVlbmNlKHtcbiAgICAgIHR5cGU6IG1lZGlhVHlwZSxcbiAgICAgIHNyYyxcbiAgICAgIGlkLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBmcm9tOiAwLFxuICAgICAgcGFyZW50OiBwYXJlbnRTZXF1ZW5jZT8uaWQgPz8gbnVsbCxcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSA/PyBnZXRBc3NldERpc3BsYXlOYW1lKHNyYyksXG4gICAgICByb290SWQsXG4gICAgICB2b2x1bWU6IHZvbHVtZXMsXG4gICAgICBzaG93SW5UaW1lbGluZTogdHJ1ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgc3RhcnRNZWRpYUZyb206IDAgLSBzdGFydHNBdCxcbiAgICAgIGRvZXNWb2x1bWVDaGFuZ2UsXG4gICAgICBsb29wRGlzcGxheTogdW5kZWZpbmVkLFxuICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgc3RhY2ssXG4gICAgICBwcmVtb3VudERpc3BsYXlcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5yZWdpc3RlclNlcXVlbmNlKGlkKTtcbiAgICB9O1xuICB9LCBbXG4gICAgYWN0dWFsRnJvbSxcbiAgICBkdXJhdGlvbixcbiAgICBpZCxcbiAgICBwYXJlbnRTZXF1ZW5jZSxcbiAgICBzcmMsXG4gICAgcmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICByb290SWQsXG4gICAgdW5yZWdpc3RlclNlcXVlbmNlLFxuICAgIHZpZGVvQ29uZmlnLFxuICAgIHZvbHVtZXMsXG4gICAgZG9lc1ZvbHVtZUNoYW5nZSxcbiAgICBub25jZSxcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgc3RhcnRzQXQsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIGRpc3BsYXlOYW1lLFxuICAgIHN0YWNrLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIHByZW1vdW50RGlzcGxheVxuICBdKTtcbiAgdXNlRWZmZWN0NygoKSA9PiB7XG4gICAgY29uc3QgdGFnID0ge1xuICAgICAgaWQsXG4gICAgICBwbGF5OiAocmVhc29uKSA9PiB7XG4gICAgICAgIGlmICghaW1wZXJhdGl2ZVBsYXlpbmcuY3VycmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVtb3VudGluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgICAgbWVkaWFSZWYsXG4gICAgICAgICAgbWVkaWFUeXBlLFxuICAgICAgICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgICBtb3VudFRpbWUsXG4gICAgICAgICAgcmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgYXVkaW9BbmRWaWRlb1RhZ3MuY3VycmVudC5wdXNoKHRhZyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzLmN1cnJlbnQgPSBhdWRpb0FuZFZpZGVvVGFncy5jdXJyZW50LmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBhdWRpb0FuZFZpZGVvVGFncyxcbiAgICBpZCxcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIGltcGVyYXRpdmVQbGF5aW5nLFxuICAgIGlzUHJlbW91bnRpbmcsXG4gICAgbG9nTGV2ZWwsXG4gICAgbW91bnRUaW1lXG4gIF0pO1xufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1wbGF5YmFjay50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s4LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxOCwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDExLCB1c2VSZWYgYXMgdXNlUmVmOSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYnVmZmVyLXVudGlsLWZpcnN0LWZyYW1lLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazcsIHVzZU1lbW8gYXMgdXNlTWVtbzE2LCB1c2VSZWYgYXMgdXNlUmVmNiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXNlLWJ1ZmZlci1zdGF0ZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTcsIHVzZU1lbW8gYXMgdXNlTWVtbzE1IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9idWZmZXJpbmcudHN4XG5pbXBvcnQgUmVhY3QxMywge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazYsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDE2LFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0OCxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDQsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzE0LFxuICB1c2VSZWYgYXMgdXNlUmVmNSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxNSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHVzZUJ1ZmZlck1hbmFnZXIgPSAobG9nTGV2ZWwsIG1vdW50VGltZSkgPT4ge1xuICBjb25zdCBbYmxvY2tzLCBzZXRCbG9ja3NdID0gdXNlU3RhdGUxMChbXSk7XG4gIGNvbnN0IFtvbkJ1ZmZlcmluZ0NhbGxiYWNrcywgc2V0T25CdWZmZXJpbmdDYWxsYmFja3NdID0gdXNlU3RhdGUxMChbXSk7XG4gIGNvbnN0IFtvblJlc3VtZUNhbGxiYWNrcywgc2V0T25SZXN1bWVDYWxsYmFja3NdID0gdXNlU3RhdGUxMChbXSk7XG4gIGNvbnN0IGJ1ZmZlcmluZyA9IHVzZVJlZjUoZmFsc2UpO1xuICBjb25zdCBhZGRCbG9jayA9IHVzZUNhbGxiYWNrNigoYmxvY2spID0+IHtcbiAgICBzZXRCbG9ja3MoKGIpID0+IFsuLi5iLCBibG9ja10pO1xuICAgIHJldHVybiB7XG4gICAgICB1bmJsb2NrOiAoKSA9PiB7XG4gICAgICAgIHNldEJsb2NrcygoYikgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld0FyciA9IGIuZmlsdGVyKChieCkgPT4gYnggIT09IGJsb2NrKTtcbiAgICAgICAgICBpZiAobmV3QXJyLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3QXJyO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IGxpc3RlbkZvckJ1ZmZlcmluZyA9IHVzZUNhbGxiYWNrNigoY2FsbGJhY2spID0+IHtcbiAgICBzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrcygoYykgPT4gWy4uLmMsIGNhbGxiYWNrXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZTogKCkgPT4ge1xuICAgICAgICBzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrcygoYykgPT4gYy5maWx0ZXIoKGNiKSA9PiBjYiAhPT0gY2FsbGJhY2spKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IGxpc3RlbkZvclJlc3VtZSA9IHVzZUNhbGxiYWNrNigoY2FsbGJhY2spID0+IHtcbiAgICBzZXRPblJlc3VtZUNhbGxiYWNrcygoYykgPT4gWy4uLmMsIGNhbGxiYWNrXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZTogKCkgPT4ge1xuICAgICAgICBzZXRPblJlc3VtZUNhbGxiYWNrcygoYykgPT4gYy5maWx0ZXIoKGNiKSA9PiBjYiAhPT0gY2FsbGJhY2spKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDgoKCkgPT4ge1xuICAgIGlmIChibG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgb25CdWZmZXJpbmdDYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gYygpKTtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlOiBcIlBsYXllciBpcyBlbnRlcmluZyBidWZmZXIgc3RhdGVcIixcbiAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICB0YWc6IFwicGxheWVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2Jsb2Nrc10pO1xuICB1c2VMYXlvdXRFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgb25SZXN1bWVDYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gYygpKTtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlOiBcIlBsYXllciBpcyBleGl0aW5nIGJ1ZmZlciBzdGF0ZVwiLFxuICAgICAgICBtb3VudFRpbWUsXG4gICAgICAgIHRhZzogXCJwbGF5ZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbYmxvY2tzXSk7XG4gIHJldHVybiB1c2VNZW1vMTQoKCkgPT4ge1xuICAgIHJldHVybiB7IGFkZEJsb2NrLCBsaXN0ZW5Gb3JCdWZmZXJpbmcsIGxpc3RlbkZvclJlc3VtZSwgYnVmZmVyaW5nIH07XG4gIH0sIFthZGRCbG9jaywgYnVmZmVyaW5nLCBsaXN0ZW5Gb3JCdWZmZXJpbmcsIGxpc3RlbkZvclJlc3VtZV0pO1xufTtcbnZhciBCdWZmZXJpbmdDb250ZXh0UmVhY3QgPSBSZWFjdDEzLmNyZWF0ZUNvbnRleHQobnVsbCk7XG52YXIgQnVmZmVyaW5nUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IHsgbG9nTGV2ZWwsIG1vdW50VGltZSB9ID0gdXNlQ29udGV4dDE2KExvZ0xldmVsQ29udGV4dCk7XG4gIGNvbnN0IGJ1ZmZlck1hbmFnZXIgPSB1c2VCdWZmZXJNYW5hZ2VyKGxvZ0xldmVsID8/IFwiaW5mb1wiLCBtb3VudFRpbWUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE1KEJ1ZmZlcmluZ0NvbnRleHRSZWFjdC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBidWZmZXJNYW5hZ2VyLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciB1c2VJc1BsYXllckJ1ZmZlcmluZyA9IChidWZmZXJNYW5hZ2VyKSA9PiB7XG4gIGNvbnN0IFtpc0J1ZmZlcmluZywgc2V0SXNCdWZmZXJpbmddID0gdXNlU3RhdGUxMChidWZmZXJNYW5hZ2VyLmJ1ZmZlcmluZy5jdXJyZW50KTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgY29uc3Qgb25CdWZmZXIgPSAoKSA9PiB7XG4gICAgICBzZXRJc0J1ZmZlcmluZyh0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUmVzdW1lID0gKCkgPT4ge1xuICAgICAgc2V0SXNCdWZmZXJpbmcoZmFsc2UpO1xuICAgIH07XG4gICAgYnVmZmVyTWFuYWdlci5saXN0ZW5Gb3JCdWZmZXJpbmcob25CdWZmZXIpO1xuICAgIGJ1ZmZlck1hbmFnZXIubGlzdGVuRm9yUmVzdW1lKG9uUmVzdW1lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYnVmZmVyTWFuYWdlci5saXN0ZW5Gb3JCdWZmZXJpbmcoKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgICB9KTtcbiAgICAgIGJ1ZmZlck1hbmFnZXIubGlzdGVuRm9yUmVzdW1lKCgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2J1ZmZlck1hbmFnZXJdKTtcbiAgcmV0dXJuIGlzQnVmZmVyaW5nO1xufTtcblxuLy8gc3JjL3VzZS1idWZmZXItc3RhdGUudHNcbnZhciB1c2VCdWZmZXJTdGF0ZSA9ICgpID0+IHtcbiAgY29uc3QgYnVmZmVyID0gdXNlQ29udGV4dDE3KEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCk7XG4gIGNvbnN0IGFkZEJsb2NrID0gYnVmZmVyID8gYnVmZmVyLmFkZEJsb2NrIDogbnVsbDtcbiAgcmV0dXJuIHVzZU1lbW8xNSgoKSA9PiAoe1xuICAgIGRlbGF5UGxheWJhY2s6ICgpID0+IHtcbiAgICAgIGlmICghYWRkQmxvY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gZW5hYmxlIHRoZSBidWZmZXJpbmcgc3RhdGUsIGJ1dCBhIFJlbW90aW9uIGNvbnRleHQgd2FzIG5vdCBmb3VuZC4gVGhpcyBBUEkgY2FuIG9ubHkgYmUgY2FsbGVkIGluIGEgY29tcG9uZW50IHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgUmVtb3Rpb24gUGxheWVyIG9yIGEgPENvbXBvc2l0aW9uPi4gT3IgeW91IG1pZ2h0IGhhdmUgZXhwZXJpZW5jZWQgYSB2ZXJzaW9uIG1pc21hdGNoIC0gcnVuIGBucHggcmVtb3Rpb24gdmVyc2lvbnNgIGFuZCBlbnN1cmUgYWxsIHBhY2thZ2VzIGhhdmUgdGhlIHNhbWUgdmVyc2lvbi4gVGhpcyBlcnJvciBpcyB0aHJvd24gYnkgdGhlIGJ1ZmZlciBzdGF0ZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3BsYXllci9idWZmZXItc3RhdGVcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHVuYmxvY2sgfSA9IGFkZEJsb2NrKHtcbiAgICAgICAgaWQ6IFN0cmluZyhNYXRoLnJhbmRvbSgpKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyB1bmJsb2NrIH07XG4gICAgfVxuICB9KSwgW2FkZEJsb2NrXSk7XG59O1xuXG4vLyBzcmMvYnVmZmVyLXVudGlsLWZpcnN0LWZyYW1lLnRzXG52YXIgaXNTYWZhcmlXZWJraXQgPSAoKSA9PiB7XG4gIGNvbnN0IGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHJldHVybiBpc1NhZmFyaTtcbn07XG52YXIgdXNlQnVmZmVyVW50aWxGaXJzdEZyYW1lID0gKHtcbiAgbWVkaWFSZWYsXG4gIG1lZGlhVHlwZSxcbiAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQsXG4gIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgbG9nTGV2ZWwsXG4gIG1vdW50VGltZVxufSkgPT4ge1xuICBjb25zdCBidWZmZXJpbmdSZWYgPSB1c2VSZWY2KGZhbHNlKTtcbiAgY29uc3QgeyBkZWxheVBsYXliYWNrIH0gPSB1c2VCdWZmZXJTdGF0ZSgpO1xuICBjb25zdCBidWZmZXJVbnRpbEZpcnN0RnJhbWUgPSB1c2VDYWxsYmFjazcoKHJlcXVlc3RlZFRpbWUpID0+IHtcbiAgICBpZiAobWVkaWFUeXBlICE9PSBcInZpZGVvXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwYXVzZVdoZW5CdWZmZXJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IG1lZGlhUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPj0gY3VycmVudC5IQVZFX0VOT1VHSF9EQVRBICYmICFpc1NhZmFyaVdlYmtpdCgpKSB7XG4gICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbWVzc2FnZTogYE5vdCB1c2luZyBidWZmZXIgdW50aWwgZmlyc3QgZnJhbWUsIGJlY2F1c2UgcmVhZHlTdGF0ZSBpcyAke2N1cnJlbnQucmVhZHlTdGF0ZX0gYW5kIGlzIG5vdCBTYWZhcmlgLFxuICAgICAgICBtb3VudFRpbWUsXG4gICAgICAgIHRhZzogXCJidWZmZXJcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3VycmVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKSB7XG4gICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbWVzc2FnZTogYE5vdCB1c2luZyBidWZmZXIgdW50aWwgZmlyc3QgZnJhbWUsIGJlY2F1c2UgcmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayBpcyBub3Qgc3VwcG9ydGVkYCxcbiAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICB0YWc6IFwiYnVmZmVyXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBidWZmZXJpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgIGxvZ0xldmVsLFxuICAgICAgbWVzc2FnZTogYEJ1ZmZlcmluZyAke21lZGlhUmVmLmN1cnJlbnQ/LnNyY30gdW50aWwgdGhlIGZpcnN0IGZyYW1lIGlzIHJlY2VpdmVkYCxcbiAgICAgIG1vdW50VGltZSxcbiAgICAgIHRhZzogXCJidWZmZXJcIlxuICAgIH0pO1xuICAgIGNvbnN0IHBsYXliYWNrID0gZGVsYXlQbGF5YmFjaygpO1xuICAgIGNvbnN0IHVuYmxvY2sgPSAoKSA9PiB7XG4gICAgICBwbGF5YmFjay51bmJsb2NrKCk7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLCB1bmJsb2NrLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgdW5ibG9jaywge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGJ1ZmZlcmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSA9ICgpID0+IHtcbiAgICAgIHVuYmxvY2soKTtcbiAgICB9O1xuICAgIGN1cnJlbnQucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaygoXywgaW5mbykgPT4ge1xuICAgICAgY29uc3QgZGlmZmVyZW5jZUZyb21SZXF1ZXN0ZWQgPSBNYXRoLmFicyhpbmZvLm1lZGlhVGltZSAtIHJlcXVlc3RlZFRpbWUpO1xuICAgICAgaWYgKGRpZmZlcmVuY2VGcm9tUmVxdWVzdGVkID4gMC41KSB7XG4gICAgICAgIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkKCk7XG4gICAgICB9XG4gICAgICB1bmJsb2NrKCk7XG4gICAgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgb25FbmRlZE9yUGF1c2VPckNhblBsYXksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLCBvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgb25FbmRlZE9yUGF1c2VPckNhblBsYXksIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgfSwgW1xuICAgIGRlbGF5UGxheWJhY2ssXG4gICAgbG9nTGV2ZWwsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG1vdW50VGltZSxcbiAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmdcbiAgXSk7XG4gIHJldHVybiB1c2VNZW1vMTYoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBpc0J1ZmZlcmluZzogKCkgPT4gYnVmZmVyaW5nUmVmLmN1cnJlbnQsXG4gICAgICBidWZmZXJVbnRpbEZpcnN0RnJhbWVcbiAgICB9O1xuICB9LCBbYnVmZmVyVW50aWxGaXJzdEZyYW1lXSk7XG59O1xuXG4vLyBzcmMvdmlkZW8vdmlkZW8tZnJhZ21lbnQudHNcbmltcG9ydCB7IHVzZVJlZiBhcyB1c2VSZWY3IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdG9TZWNvbmRzID0gKHRpbWUsIGZwcykgPT4ge1xuICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lIC8gZnBzICogMTAwKSAvIDEwMDtcbn07XG52YXIgaXNJb3NTYWZhcmkgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlzSXBhZElQb2RJUGhvbmUgPSAvaVAoYWR8b2R8aG9uZSkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgY29uc3QgaXNBcHBsZVdlYktpdCA9IC9BcHBsZVdlYktpdC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHJldHVybiBpc0lwYWRJUG9kSVBob25lICYmIGlzQXBwbGVXZWJLaXQ7XG59O1xudmFyIGlzSU9TU2FmYXJpQW5kQmxvYiA9IChhY3R1YWxTcmMpID0+IHtcbiAgcmV0dXJuIGlzSW9zU2FmYXJpKCkgJiYgYWN0dWFsU3JjLnN0YXJ0c1dpdGgoXCJibG9iOlwiKTtcbn07XG52YXIgZ2V0VmlkZW9GcmFnbWVudFN0YXJ0ID0gKHtcbiAgYWN0dWFsRnJvbSxcbiAgZnBzXG59KSA9PiB7XG4gIHJldHVybiB0b1NlY29uZHMoTWF0aC5tYXgoMCwgLWFjdHVhbEZyb20pLCBmcHMpO1xufTtcbnZhciBnZXRWaWRlb0ZyYWdtZW50RW5kID0gKHtcbiAgZHVyYXRpb24sXG4gIGZwc1xufSkgPT4ge1xuICByZXR1cm4gdG9TZWNvbmRzKGR1cmF0aW9uLCBmcHMpO1xufTtcbnZhciBhcHBlbmRWaWRlb0ZyYWdtZW50ID0gKHtcbiAgYWN0dWFsU3JjLFxuICBhY3R1YWxGcm9tLFxuICBkdXJhdGlvbixcbiAgZnBzXG59KSA9PiB7XG4gIGlmIChpc0lPU1NhZmFyaUFuZEJsb2IoYWN0dWFsU3JjKSkge1xuICAgIHJldHVybiBhY3R1YWxTcmM7XG4gIH1cbiAgaWYgKGFjdHVhbFNyYy5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nSGFzaCA9IEJvb2xlYW4obmV3IFVSTChhY3R1YWxTcmMsICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSA/PyBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiKS5oYXNoKTtcbiAgaWYgKGV4aXN0aW5nSGFzaCkge1xuICAgIHJldHVybiBhY3R1YWxTcmM7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYWN0dWFsRnJvbSkpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IHdpdGhTdGFydEhhc2ggPSBgJHthY3R1YWxTcmN9I3Q9JHtnZXRWaWRlb0ZyYWdtZW50U3RhcnQoeyBhY3R1YWxGcm9tLCBmcHMgfSl9YDtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pKSB7XG4gICAgcmV0dXJuIHdpdGhTdGFydEhhc2g7XG4gIH1cbiAgcmV0dXJuIGAke3dpdGhTdGFydEhhc2h9LCR7Z2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uLCBmcHMgfSl9YDtcbn07XG52YXIgaXNTdWJzZXRPZkR1cmF0aW9uID0gKHtcbiAgcHJldlN0YXJ0RnJvbSxcbiAgbmV3U3RhcnRGcm9tLFxuICBwcmV2RHVyYXRpb24sXG4gIG5ld0R1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgY29uc3QgcHJldmlvdXNGcm9tID0gZ2V0VmlkZW9GcmFnbWVudFN0YXJ0KHsgYWN0dWFsRnJvbTogcHJldlN0YXJ0RnJvbSwgZnBzIH0pO1xuICBjb25zdCBuZXdGcm9tID0gZ2V0VmlkZW9GcmFnbWVudFN0YXJ0KHsgYWN0dWFsRnJvbTogbmV3U3RhcnRGcm9tLCBmcHMgfSk7XG4gIGNvbnN0IHByZXZpb3VzRW5kID0gZ2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uOiBwcmV2RHVyYXRpb24sIGZwcyB9KTtcbiAgY29uc3QgbmV3RW5kID0gZ2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uOiBuZXdEdXJhdGlvbiwgZnBzIH0pO1xuICBpZiAobmV3RnJvbSA8IHByZXZpb3VzRnJvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmV3RW5kID4gcHJldmlvdXNFbmQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHVzZUFwcGVuZFZpZGVvRnJhZ21lbnQgPSAoe1xuICBhY3R1YWxTcmM6IGluaXRpYWxBY3R1YWxTcmMsXG4gIGFjdHVhbEZyb206IGluaXRpYWxBY3R1YWxGcm9tLFxuICBkdXJhdGlvbjogaW5pdGlhbER1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgY29uc3QgYWN0dWFsRnJvbVJlZiA9IHVzZVJlZjcoaW5pdGlhbEFjdHVhbEZyb20pO1xuICBjb25zdCBhY3R1YWxEdXJhdGlvbiA9IHVzZVJlZjcoaW5pdGlhbER1cmF0aW9uKTtcbiAgY29uc3QgYWN0dWFsU3JjID0gdXNlUmVmNyhpbml0aWFsQWN0dWFsU3JjKTtcbiAgaWYgKCFpc1N1YnNldE9mRHVyYXRpb24oe1xuICAgIHByZXZTdGFydEZyb206IGFjdHVhbEZyb21SZWYuY3VycmVudCxcbiAgICBuZXdTdGFydEZyb206IGluaXRpYWxBY3R1YWxGcm9tLFxuICAgIHByZXZEdXJhdGlvbjogYWN0dWFsRHVyYXRpb24uY3VycmVudCxcbiAgICBuZXdEdXJhdGlvbjogaW5pdGlhbER1cmF0aW9uLFxuICAgIGZwc1xuICB9KSB8fCBpbml0aWFsQWN0dWFsU3JjICE9PSBhY3R1YWxTcmMuY3VycmVudCkge1xuICAgIGFjdHVhbEZyb21SZWYuY3VycmVudCA9IGluaXRpYWxBY3R1YWxGcm9tO1xuICAgIGFjdHVhbER1cmF0aW9uLmN1cnJlbnQgPSBpbml0aWFsRHVyYXRpb247XG4gICAgYWN0dWFsU3JjLmN1cnJlbnQgPSBpbml0aWFsQWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IGFwcGVuZGVkID0gYXBwZW5kVmlkZW9GcmFnbWVudCh7XG4gICAgYWN0dWFsU3JjOiBhY3R1YWxTcmMuY3VycmVudCxcbiAgICBhY3R1YWxGcm9tOiBhY3R1YWxGcm9tUmVmLmN1cnJlbnQsXG4gICAgZHVyYXRpb246IGFjdHVhbER1cmF0aW9uLmN1cnJlbnQsXG4gICAgZnBzXG4gIH0pO1xuICByZXR1cm4gYXBwZW5kZWQ7XG59O1xuXG4vLyBzcmMvc2Vlay50c1xudmFyIHNlZWsgPSAoe1xuICBtZWRpYVJlZixcbiAgdGltZSxcbiAgbG9nTGV2ZWwsXG4gIHdoeSxcbiAgbW91bnRUaW1lXG59KSA9PiB7XG4gIGNvbnN0IHRpbWVUb1NldCA9IGlzSW9zU2FmYXJpKCkgPyBOdW1iZXIodGltZS50b0ZpeGVkKDEpKSA6IHRpbWU7XG4gIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgbG9nTGV2ZWwsXG4gICAgdGFnOiBcInNlZWtcIixcbiAgICBtZXNzYWdlOiBgU2Vla2luZyBmcm9tICR7bWVkaWFSZWYuY3VycmVudFRpbWV9IHRvICR7dGltZVRvU2V0fS4gc3JjPSAke21lZGlhUmVmLnNyY30gUmVhc29uOiAke3doeX1gLFxuICAgIG1vdW50VGltZVxuICB9KTtcbiAgbWVkaWFSZWYuY3VycmVudFRpbWUgPSB0aW1lVG9TZXQ7XG4gIHJldHVybiB0aW1lVG9TZXQ7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLWJ1ZmZlcmluZy50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDksIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTEgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VNZWRpYUJ1ZmZlcmluZyA9ICh7XG4gIGVsZW1lbnQsXG4gIHNob3VsZEJ1ZmZlcixcbiAgaXNQcmVtb3VudGluZyxcbiAgbG9nTGV2ZWwsXG4gIG1vdW50VGltZVxufSkgPT4ge1xuICBjb25zdCBidWZmZXIgPSB1c2VCdWZmZXJTdGF0ZSgpO1xuICBjb25zdCBbaXNCdWZmZXJpbmcsIHNldElzQnVmZmVyaW5nXSA9IHVzZVN0YXRlMTEoZmFsc2UpO1xuICB1c2VFZmZlY3Q5KCgpID0+IHtcbiAgICBsZXQgY2xlYW51cEZucyA9IFtdO1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gZWxlbWVudDtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzaG91bGRCdWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUHJlbW91bnRpbmcpIHtcbiAgICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPCBjdXJyZW50LkhBVkVfRlVUVVJFX0RBVEEpIHtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveC9cIikpIHtcbiAgICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgICBtZXNzYWdlOiBgQ2FsbGluZyAubG9hZCgpIG9uICR7Y3VycmVudC5zcmN9IGJlY2F1c2UgcmVhZHlTdGF0ZSBpcyAke2N1cnJlbnQucmVhZHlTdGF0ZX0gYW5kIGl0IGlzIG5vdCBGaXJlZm94LiBFbGVtZW50IGlzIHByZW1vdW50ZWRgLFxuICAgICAgICAgICAgdGFnOiBcImxvYWRcIixcbiAgICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnQubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsZWFudXAgPSAocmVhc29uKSA9PiB7XG4gICAgICBsZXQgZGlkRG9Tb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgIGNsZWFudXBGbnMuZm9yRWFjaCgoZm4pID0+IHtcbiAgICAgICAgZm4ocmVhc29uKTtcbiAgICAgICAgZGlkRG9Tb21ldGhpbmcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBjbGVhbnVwRm5zID0gW107XG4gICAgICBzZXRJc0J1ZmZlcmluZygocHJldmlvdXMpID0+IHtcbiAgICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgICAgZGlkRG9Tb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGRpZERvU29tZXRoaW5nKSB7XG4gICAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgbWVzc2FnZTogYFVubWFya2luZyBhcyBidWZmZXJpbmc6ICR7Y3VycmVudC5zcmN9LiBSZWFzb246ICR7cmVhc29ufWAsXG4gICAgICAgICAgdGFnOiBcImJ1ZmZlclwiLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJsb2NrTWVkaWEgPSAocmVhc29uKSA9PiB7XG4gICAgICBzZXRJc0J1ZmZlcmluZyh0cnVlKTtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlOiBgTWFya2luZyBhcyBidWZmZXJpbmc6ICR7Y3VycmVudC5zcmN9LiBSZWFzb246ICR7cmVhc29ufWAsXG4gICAgICAgIHRhZzogXCJidWZmZXJcIixcbiAgICAgICAgbW91bnRUaW1lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHsgdW5ibG9jayB9ID0gYnVmZmVyLmRlbGF5UGxheWJhY2soKTtcbiAgICAgIGNvbnN0IG9uQ2FuUGxheSA9ICgpID0+IHtcbiAgICAgICAgY2xlYW51cCgnXCJjYW5wbGF5XCIgd2FzIGZpcmVkJyk7XG4gICAgICAgIGluaXQoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBvbkVycm9yID0gKCkgPT4ge1xuICAgICAgICBjbGVhbnVwKCdcImVycm9yXCIgZXZlbnQgd2FzIG9jY3VycmVkJyk7XG4gICAgICAgIGluaXQoKTtcbiAgICAgIH07XG4gICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIG9uQ2FuUGxheSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNsZWFudXBGbnMucHVzaCgoKSA9PiB7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgb25DYW5QbGF5KTtcbiAgICAgIH0pO1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvciwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNsZWFudXBGbnMucHVzaCgoKSA9PiB7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgfSk7XG4gICAgICBjbGVhbnVwRm5zLnB1c2goKGNsZWFudXBSZWFzb24pID0+IHtcbiAgICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5ibG9ja2luZyAke2N1cnJlbnQuc3JjfSBmcm9tIGJ1ZmZlci4gUmVhc29uOiAke2NsZWFudXBSZWFzb259YCxcbiAgICAgICAgICB0YWc6IFwiYnVmZmVyXCIsXG4gICAgICAgICAgbW91bnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgICB1bmJsb2NrKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXQgPSAoKSA9PiB7XG4gICAgICBpZiAoY3VycmVudC5yZWFkeVN0YXRlIDwgY3VycmVudC5IQVZFX0ZVVFVSRV9EQVRBKSB7XG4gICAgICAgIGJsb2NrTWVkaWEoYHJlYWR5U3RhdGUgaXMgJHtjdXJyZW50LnJlYWR5U3RhdGV9LCB3aGljaCBpcyBsZXNzIHRoYW4gSEFWRV9GVVRVUkVfREFUQWApO1xuICAgICAgICBpZiAoIW5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJGaXJlZm94L1wiKSkge1xuICAgICAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBDYWxsaW5nIC5sb2FkKCkgb24gJHtjdXJyZW50LnNyY30gYmVjYXVzZSByZWFkeVN0YXRlIGlzICR7Y3VycmVudC5yZWFkeVN0YXRlfSBhbmQgaXQgaXMgbm90IEZpcmVmb3guYCxcbiAgICAgICAgICAgIHRhZzogXCJsb2FkXCIsXG4gICAgICAgICAgICBtb3VudFRpbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50LmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25XYWl0aW5nID0gKCkgPT4ge1xuICAgICAgICAgIGJsb2NrTWVkaWEoJ1wid2FpdGluZ1wiIGV2ZW50IHdhcyBmaXJlZCcpO1xuICAgICAgICB9O1xuICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3YWl0aW5nXCIsIG9uV2FpdGluZyk7XG4gICAgICAgIGNsZWFudXBGbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2FpdGluZ1wiLCBvbldhaXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGluaXQoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cChcImVsZW1lbnQgd2FzIHVubW91bnRlZCBvciBwcm9wIGNoYW5nZWRcIik7XG4gICAgfTtcbiAgfSwgW2J1ZmZlciwgZWxlbWVudCwgaXNQcmVtb3VudGluZywgbG9nTGV2ZWwsIHNob3VsZEJ1ZmZlciwgbW91bnRUaW1lXSk7XG4gIHJldHVybiBpc0J1ZmZlcmluZztcbn07XG5cbi8vIHNyYy91c2UtcmVxdWVzdC12aWRlby1jYWxsYmFjay10aW1lLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTAsIHVzZVJlZiBhcyB1c2VSZWY4IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlUmVxdWVzdFZpZGVvQ2FsbGJhY2tUaW1lID0gKHtcbiAgbWVkaWFSZWYsXG4gIG1lZGlhVHlwZSxcbiAgbGFzdFNlZWssXG4gIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkXG59KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gdXNlUmVmOChudWxsKTtcbiAgdXNlRWZmZWN0MTAoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gbWVkaWFSZWY7XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnRUaW1lLmN1cnJlbnQgPSBjdXJyZW50LmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJ2aWRlb1wiKSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9UYWcgPSBjdXJyZW50O1xuICAgIGlmICghdmlkZW9UYWcucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgY29uc3QgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgIGlmICghdmlkZW9UYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2IgPSB2aWRlb1RhZy5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChfLCBpbmZvKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50VGltZS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IE1hdGguYWJzKGN1cnJlbnRUaW1lLmN1cnJlbnQgLSBpbmZvLm1lZGlhVGltZSk7XG4gICAgICAgICAgY29uc3QgZGlmZmVyZW5jZVRvTGFzdFNlZWsgPSBNYXRoLmFicyhsYXN0U2Vlay5jdXJyZW50ID09PSBudWxsID8gSW5maW5pdHkgOiBpbmZvLm1lZGlhVGltZSAtIGxhc3RTZWVrLmN1cnJlbnQpO1xuICAgICAgICAgIGlmIChkaWZmZXJlbmNlID4gMC41ICYmIGRpZmZlcmVuY2VUb0xhc3RTZWVrID4gMC41ICYmIGluZm8ubWVkaWFUaW1lID4gY3VycmVudFRpbWUuY3VycmVudCkge1xuICAgICAgICAgICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRpbWUuY3VycmVudCA9IGluZm8ubWVkaWFUaW1lO1xuICAgICAgICByZXF1ZXN0KCk7XG4gICAgICB9KTtcbiAgICAgIGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgdmlkZW9UYWcuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKGNiKTtcbiAgICAgICAgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXF1ZXN0KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH07XG4gIH0sIFtsYXN0U2VlaywgbWVkaWFSZWYsIG1lZGlhVHlwZSwgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWRdKTtcbiAgcmV0dXJuIGN1cnJlbnRUaW1lO1xufTtcblxuLy8gc3JjL2ludGVycG9sYXRlLnRzXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgZWFzaW5nIH0gPSBvcHRpb25zO1xuICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG4gIGNvbnN0IFtpbnB1dE1pbiwgaW5wdXRNYXhdID0gaW5wdXRSYW5nZTtcbiAgY29uc3QgW291dHB1dE1pbiwgb3V0cHV0TWF4XSA9IG91dHB1dFJhbmdlO1xuICBpZiAocmVzdWx0IDwgaW5wdXRNaW4pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiY2xhbXBcIikge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJleHRlbmRcIikge31cbiAgfVxuICBpZiAocmVzdWx0ID4gaW5wdXRNYXgpIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1heDtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiZXh0ZW5kXCIpIHt9XG4gIH1cbiAgaWYgKG91dHB1dE1pbiA9PT0gb3V0cHV0TWF4KSB7XG4gICAgcmV0dXJuIG91dHB1dE1pbjtcbiAgfVxuICByZXN1bHQgPSAocmVzdWx0IC0gaW5wdXRNaW4pIC8gKGlucHV0TWF4IC0gaW5wdXRNaW4pO1xuICByZXN1bHQgPSBlYXNpbmcocmVzdWx0KTtcbiAgcmVzdWx0ID0gcmVzdWx0ICogKG91dHB1dE1heCAtIG91dHB1dE1pbikgKyBvdXRwdXRNaW47XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpIHtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7aSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgaWYgKGlucHV0UmFuZ2VbaV0gPj0gaW5wdXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaSAtIDE7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkSW5wdXRSYW5nZShhcnIpIHtcbiAgZm9yIChsZXQgaSA9IDE7aSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmICghKGFycltpXSA+IGFycltpIC0gMV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0UmFuZ2UgbXVzdCBiZSBzdHJpY3RseSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbmZpbml0ZVJhbmdlKG5hbWUsIGFycikge1xuICBpZiAoYXJyLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGVsZW1lbnRzXCIpO1xuICB9XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBhcnIpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzYCk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBjb250YWluIG9ubHkgZmluaXRlIG51bWJlcnMsIGJ1dCBnb3QgWyR7YXJyLmpvaW4oXCIsXCIpfV1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG91dHB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIChcIiArIGlucHV0UmFuZ2UubGVuZ3RoICsgXCIpIGFuZCBvdXRwdXRSYW5nZSAoXCIgKyBvdXRwdXRSYW5nZS5sZW5ndGggKyBcIikgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjaGVja0luZmluaXRlUmFuZ2UoXCJpbnB1dFJhbmdlXCIsIGlucHV0UmFuZ2UpO1xuICBjaGVja0luZmluaXRlUmFuZ2UoXCJvdXRwdXRSYW5nZVwiLCBvdXRwdXRSYW5nZSk7XG4gIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGlucHV0UmFuZ2UpO1xuICBjb25zdCBlYXNpbmcgPSBvcHRpb25zPy5lYXNpbmcgPz8gKChudW0pID0+IG51bSk7XG4gIGxldCBleHRyYXBvbGF0ZUxlZnQgPSBcImV4dGVuZFwiO1xuICBpZiAob3B0aW9ucz8uZXh0cmFwb2xhdGVMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZUxlZnQgPSBvcHRpb25zLmV4dHJhcG9sYXRlTGVmdDtcbiAgfVxuICBsZXQgZXh0cmFwb2xhdGVSaWdodCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZVJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZVJpZ2h0ID0gb3B0aW9ucy5leHRyYXBvbGF0ZVJpZ2h0O1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGludGVycG9sYXRlIGFuIGlucHV0IHdoaWNoIGlzIG5vdCBhIG51bWJlclwiKTtcbiAgfVxuICBjb25zdCByYW5nZSA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBbaW5wdXRSYW5nZVtyYW5nZV0sIGlucHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIFtvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV1dLCB7XG4gICAgZWFzaW5nLFxuICAgIGV4dHJhcG9sYXRlTGVmdCxcbiAgICBleHRyYXBvbGF0ZVJpZ2h0XG4gIH0pO1xufVxuXG4vLyBzcmMvdmlkZW8vZ2V0LWN1cnJlbnQtdGltZS50c1xudmFyIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkID0gKHtcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIHJldHVybiBpbnRlcnBvbGF0ZShmcmFtZSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIDFdLCBbLTEsIHN0YXJ0RnJvbSwgc3RhcnRGcm9tICsgcGxheWJhY2tSYXRlXSk7XG59O1xudmFyIGdldE1lZGlhVGltZSA9ICh7XG4gIGZwcyxcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIGNvbnN0IGV4cGVjdGVkRnJhbWUgPSBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCh7XG4gICAgZnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHN0YXJ0RnJvbVxuICB9KTtcbiAgY29uc3QgbXNQZXJGcmFtZSA9IDEwMDAgLyBmcHM7XG4gIHJldHVybiBleHBlY3RlZEZyYW1lICogbXNQZXJGcmFtZSAvIDEwMDA7XG59O1xuXG4vLyBzcmMvd2Fybi1hYm91dC1ub24tc2Vla2FibGUtbWVkaWEudHNcbnZhciBhbHJlYWR5V2FybmVkID0ge307XG52YXIgd2FybkFib3V0Tm9uU2Vla2FibGVNZWRpYSA9IChyZWYsIHR5cGUpID0+IHtcbiAgaWYgKHJlZiA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGFscmVhZHlXYXJuZWRbcmVmLnNyY10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0OiByZWYuc2Vla2FibGUuc3RhcnQoMCksIGVuZDogcmVmLnNlZWthYmxlLmVuZCgwKSB9O1xuICBpZiAocmFuZ2Uuc3RhcnQgPT09IDAgJiYgcmFuZ2UuZW5kID09PSAwKSB7XG4gICAgY29uc3QgbXNnID0gW1xuICAgICAgYFRoZSBtZWRpYSAke3JlZi5zcmN9IGNhbm5vdCBiZSBzZWVrZWQuIFRoaXMgY291bGQgYmUgb25lIG9mIGZldyByZWFzb25zOmAsXG4gICAgICBcIjEpIFRoZSBtZWRpYSByZXNvdXJjZSB3YXMgcmVwbGFjZWQgd2hpbGUgdGhlIHZpZGVvIGlzIHBsYXlpbmcgYnV0IGl0IHdhcyBub3QgbG9hZGVkIHlldC5cIixcbiAgICAgIFwiMikgVGhlIG1lZGlhIGRvZXMgbm90IHN1cHBvcnQgc2Vla2luZy5cIixcbiAgICAgIFwiMykgVGhlIG1lZGlhIHdhcyBsb2FkZWQgd2l0aCBzZWN1cml0eSBoZWFkZXJzIHBydmVudGluZyBpdCBmcm9tIGJlaW5nIGluY2x1ZGVkLlwiLFxuICAgICAgXCJQbGVhc2Ugc2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvbm9uLXNlZWthYmxlLW1lZGlhIGZvciBhc3Npc3RhbmNlLlwiXG4gICAgXS5qb2luKGBcbmApO1xuICAgIGlmICh0eXBlID09PSBcImNvbnNvbGUtZXJyb3JcIikge1xuICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb25zb2xlLXdhcm5pbmdcIikge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgbWVkaWEgJHtyZWYuc3JjfSBkb2VzIG5vdCBzdXBwb3J0IHNlZWtpbmcuIFRoZSB2aWRlbyB3aWxsIHJlbmRlciBmaW5lLCBidXQgbWF5IG5vdCBwbGF5IGNvcnJlY3RseSBpbiB0aGUgUmVtb3Rpb24gU3R1ZGlvIGFuZCBpbiB0aGUgPFBsYXllcj4uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL25vbi1zZWVrYWJsZS1tZWRpYSBmb3IgYW4gZXhwbGFuYXRpb24uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICBhbHJlYWR5V2FybmVkW3JlZi5zcmNdID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1wbGF5YmFjay50c1xudmFyIHVzZU1lZGlhUGxheWJhY2sgPSAoe1xuICBtZWRpYVJlZixcbiAgc3JjLFxuICBtZWRpYVR5cGUsXG4gIHBsYXliYWNrUmF0ZTogbG9jYWxQbGF5YmFja1JhdGUsXG4gIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gIGFjY2VwdGFibGVUaW1lc2hpZnQsXG4gIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgaXNQcmVtb3VudGluZyxcbiAgb25BdXRvUGxheUVycm9yLFxuICB1c2VyUHJlZmVycmVkVm9sdW1lXG59KSA9PiB7XG4gIGNvbnN0IHsgcGxheWJhY2tSYXRlOiBnbG9iYWxQbGF5YmFja1JhdGUgfSA9IHVzZUNvbnRleHQxOChUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCBbcGxheWluZ10gPSB1c2VQbGF5aW5nU3RhdGUoKTtcbiAgY29uc3QgYnVmZmVyaW5nID0gdXNlQ29udGV4dDE4KEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCk7XG4gIGNvbnN0IHsgZnBzIH0gPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCBtZWRpYVN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCBsYXN0U2Vla0R1ZVRvU2hpZnQgPSB1c2VSZWY5KG51bGwpO1xuICBjb25zdCBsYXN0U2VlayA9IHVzZVJlZjkobnVsbCk7XG4gIGNvbnN0IGxvZ0xldmVsID0gdXNlTG9nTGV2ZWwoKTtcbiAgY29uc3QgbW91bnRUaW1lID0gdXNlTW91bnRUaW1lKCk7XG4gIGlmICghYnVmZmVyaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlTWVkaWFQbGF5YmFjayBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgPEJ1ZmZlcmluZ0NvbnRleHQ+XCIpO1xuICB9XG4gIGNvbnN0IGlzVmFyaWFibGVGcHNWaWRlb01hcCA9IHVzZVJlZjkoe30pO1xuICBjb25zdCBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCA9IHVzZUNhbGxiYWNrOCgoKSA9PiB7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgTG9nLnZlcmJvc2UobG9nTGV2ZWwsIGBEZXRlY3RlZCAke3NyY30gYXMgYSB2YXJpYWJsZSBGUFMgdmlkZW8uIERpc2FibGluZyBidWZmZXJpbmcgd2hpbGUgc2Vla2luZy5gKTtcbiAgICBpc1ZhcmlhYmxlRnBzVmlkZW9NYXAuY3VycmVudFtzcmNdID0gdHJ1ZTtcbiAgfSwgW2xvZ0xldmVsLCBzcmNdKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSB1c2VSZXF1ZXN0VmlkZW9DYWxsYmFja1RpbWUoe1xuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBsYXN0U2VlayxcbiAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZFxuICB9KTtcbiAgY29uc3QgZGVzaXJlZFVuY2xhbXBlZFRpbWUgPSBnZXRNZWRpYVRpbWUoe1xuICAgIGZyYW1lLFxuICAgIHBsYXliYWNrUmF0ZTogbG9jYWxQbGF5YmFja1JhdGUsXG4gICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdCxcbiAgICBmcHNcbiAgfSk7XG4gIGNvbnN0IGlzTWVkaWFUYWdCdWZmZXJpbmcgPSB1c2VNZWRpYUJ1ZmZlcmluZyh7XG4gICAgZWxlbWVudDogbWVkaWFSZWYsXG4gICAgc2hvdWxkQnVmZmVyOiBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgaXNQcmVtb3VudGluZyxcbiAgICBsb2dMZXZlbCxcbiAgICBtb3VudFRpbWVcbiAgfSk7XG4gIGNvbnN0IHsgYnVmZmVyVW50aWxGaXJzdEZyYW1lLCBpc0J1ZmZlcmluZyB9ID0gdXNlQnVmZmVyVW50aWxGaXJzdEZyYW1lKHtcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIG1vdW50VGltZVxuICB9KTtcbiAgY29uc3QgcGxheWJhY2tSYXRlID0gbG9jYWxQbGF5YmFja1JhdGUgKiBnbG9iYWxQbGF5YmFja1JhdGU7XG4gIGNvbnN0IGFjY2VwdGFibGVUaW1lU2hpZnRCdXRMZXNzVGhhbkR1cmF0aW9uID0gKCgpID0+IHtcbiAgICBjb25zdCBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfTk9STUFMX1BMQVlCQUNLID0gMC40NTtcbiAgICBjb25zdCBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfQU1QTElGSUNBVElPTiA9IERFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlRfV0lUSF9OT1JNQUxfUExBWUJBQ0sgKyAwLjI7XG4gICAgY29uc3QgZGVmYXVsdEFjY2VwdGFibGVUaW1lc2hpZnQgPSBnZXRTaG91bGRBbXBsaWZ5KHVzZXJQcmVmZXJyZWRWb2x1bWUpID8gREVGQVVMVF9BQ0NFUFRBQkxFX1RJTUVTSElGVF9XSVRIX0FNUExJRklDQVRJT04gOiBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfTk9STUFMX1BMQVlCQUNLO1xuICAgIGlmIChtZWRpYVJlZi5jdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWluKG1lZGlhUmVmLmN1cnJlbnQuZHVyYXRpb24sIGFjY2VwdGFibGVUaW1lc2hpZnQgPz8gZGVmYXVsdEFjY2VwdGFibGVUaW1lc2hpZnQpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjZXB0YWJsZVRpbWVzaGlmdCA/PyBkZWZhdWx0QWNjZXB0YWJsZVRpbWVzaGlmdDtcbiAgfSkoKTtcbiAgY29uc3QgaXNQbGF5ZXJCdWZmZXJpbmcgPSB1c2VJc1BsYXllckJ1ZmZlcmluZyhidWZmZXJpbmcpO1xuICB1c2VFZmZlY3QxMSgoKSA9PiB7XG4gICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQ/LnBhdXNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXBsYXlpbmcpIHtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICB0YWc6IFwicGF1c2VcIixcbiAgICAgICAgbWVzc2FnZTogYFBhdXNpbmcgJHttZWRpYVJlZi5jdXJyZW50Py5zcmN9IGJlY2F1c2UgJHtpc1ByZW1vdW50aW5nID8gXCJtZWRpYSBpcyBwcmVtb3VudGluZ1wiIDogXCJQbGF5ZXIgaXMgbm90IHBsYXlpbmdcIn1gLFxuICAgICAgICBtb3VudFRpbWVcbiAgICAgIH0pO1xuICAgICAgbWVkaWFSZWYuY3VycmVudD8ucGF1c2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZCA9IGlzTWVkaWFUYWdCdWZmZXJpbmcgfHwgaXNCdWZmZXJpbmcoKTtcbiAgICBjb25zdCBwbGF5ZXJCdWZmZXJpbmdOb3RTdGF0ZUJ1dExpdmUgPSBidWZmZXJpbmcuYnVmZmVyaW5nLmN1cnJlbnQ7XG4gICAgaWYgKHBsYXllckJ1ZmZlcmluZ05vdFN0YXRlQnV0TGl2ZSAmJiAhaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZCkge1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIHRhZzogXCJwYXVzZVwiLFxuICAgICAgICBtZXNzYWdlOiBgUGF1c2luZyAke21lZGlhUmVmLmN1cnJlbnQ/LnNyY30gYmVjYXVzZSBwbGF5ZXIgaXMgYnVmZmVyaW5nIGJ1dCBtZWRpYSB0YWcgaXMgbm90YCxcbiAgICAgICAgbW91bnRUaW1lXG4gICAgICB9KTtcbiAgICAgIG1lZGlhUmVmLmN1cnJlbnQ/LnBhdXNlKCk7XG4gICAgfVxuICB9LCBbXG4gICAgaXNCdWZmZXJpbmcsXG4gICAgaXNNZWRpYVRhZ0J1ZmZlcmluZyxcbiAgICBidWZmZXJpbmcsXG4gICAgaXNQbGF5ZXJCdWZmZXJpbmcsXG4gICAgaXNQcmVtb3VudGluZyxcbiAgICBsb2dMZXZlbCxcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgbW91bnRUaW1lLFxuICAgIHBsYXlpbmdcbiAgXSk7XG4gIHVzZUVmZmVjdDExKCgpID0+IHtcbiAgICBjb25zdCB0YWdOYW1lID0gbWVkaWFUeXBlID09PSBcImF1ZGlvXCIgPyBcIjxBdWRpbz5cIiA6IFwiPFZpZGVvPlwiO1xuICAgIGlmICghbWVkaWFSZWYuY3VycmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyAke21lZGlhVHlwZX0gcmVmIGZvdW5kYCk7XG4gICAgfVxuICAgIGlmICghc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vICdzcmMnIGF0dHJpYnV0ZSB3YXMgcGFzc2VkIHRvIHRoZSAke3RhZ05hbWV9IGVsZW1lbnQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHBsYXliYWNrUmF0ZVRvU2V0ID0gTWF0aC5tYXgoMCwgcGxheWJhY2tSYXRlKTtcbiAgICBpZiAobWVkaWFSZWYuY3VycmVudC5wbGF5YmFja1JhdGUgIT09IHBsYXliYWNrUmF0ZVRvU2V0KSB7XG4gICAgICBtZWRpYVJlZi5jdXJyZW50LnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZVRvU2V0O1xuICAgIH1cbiAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSBtZWRpYVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHNob3VsZEJlVGltZSA9ICFOdW1iZXIuaXNOYU4oZHVyYXRpb24pICYmIE51bWJlci5pc0Zpbml0ZShkdXJhdGlvbikgPyBNYXRoLm1pbihkdXJhdGlvbiwgZGVzaXJlZFVuY2xhbXBlZFRpbWUpIDogZGVzaXJlZFVuY2xhbXBlZFRpbWU7XG4gICAgY29uc3QgbWVkaWFUYWdUaW1lID0gbWVkaWFSZWYuY3VycmVudC5jdXJyZW50VGltZTtcbiAgICBjb25zdCBydmNUaW1lID0gY3VycmVudFRpbWUuY3VycmVudCA/PyBudWxsO1xuICAgIGNvbnN0IGlzVmFyaWFibGVGcHNWaWRlbyA9IGlzVmFyaWFibGVGcHNWaWRlb01hcC5jdXJyZW50W3NyY107XG4gICAgY29uc3QgdGltZVNoaWZ0TWVkaWFUYWcgPSBNYXRoLmFicyhzaG91bGRCZVRpbWUgLSBtZWRpYVRhZ1RpbWUpO1xuICAgIGNvbnN0IHRpbWVTaGlmdFJ2Y1RhZyA9IHJ2Y1RpbWUgPyBNYXRoLmFicyhzaG91bGRCZVRpbWUgLSBydmNUaW1lKSA6IG51bGw7XG4gICAgY29uc3QgdGltZVNoaWZ0ID0gdGltZVNoaWZ0UnZjVGFnICYmICFpc1ZhcmlhYmxlRnBzVmlkZW8gPyB0aW1lU2hpZnRSdmNUYWcgOiB0aW1lU2hpZnRNZWRpYVRhZztcbiAgICBpZiAodGltZVNoaWZ0ID4gYWNjZXB0YWJsZVRpbWVTaGlmdEJ1dExlc3NUaGFuRHVyYXRpb24gJiYgbGFzdFNlZWtEdWVUb1NoaWZ0LmN1cnJlbnQgIT09IHNob3VsZEJlVGltZSkge1xuICAgICAgbGFzdFNlZWsuY3VycmVudCA9IHNlZWsoe1xuICAgICAgICBtZWRpYVJlZjogbWVkaWFSZWYuY3VycmVudCxcbiAgICAgICAgdGltZTogc2hvdWxkQmVUaW1lLFxuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgd2h5OiBgYmVjYXVzZSB0aW1lIHNoaWZ0IGlzIHRvbyBiaWcuIHNob3VsZEJlVGltZSA9ICR7c2hvdWxkQmVUaW1lfSwgaXNUaW1lID0gJHttZWRpYVRhZ1RpbWV9LCByZXF1ZXN0VmlkZW9DYWxsYmFja1RpbWUgPSAke3J2Y1RpbWV9LCB0aW1lU2hpZnQgPSAke3RpbWVTaGlmdH0ke2lzVmFyaWFibGVGcHNWaWRlbyA/IFwiLCBpc1ZhcmlhYmxlRnBzVmlkZW8gPSB0cnVlXCIgOiBcIlwifSwgaXNQcmVtb3VudGluZyA9ICR7aXNQcmVtb3VudGluZ30sIHBhdXNlV2hlbkJ1ZmZlcmluZyA9ICR7cGF1c2VXaGVuQnVmZmVyaW5nfWAsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBsYXN0U2Vla0R1ZVRvU2hpZnQuY3VycmVudCA9IGxhc3RTZWVrLmN1cnJlbnQ7XG4gICAgICBpZiAocGxheWluZykge1xuICAgICAgICBpZiAocGxheWJhY2tSYXRlID4gMCkge1xuICAgICAgICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZShzaG91bGRCZVRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWRpYVJlZi5jdXJyZW50LnBhdXNlZCkge1xuICAgICAgICAgIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3Ioe1xuICAgICAgICAgICAgbWVkaWFSZWYsXG4gICAgICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgICAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgICAgIHJlYXNvbjogXCJwbGF5ZXIgaXMgcGxheWluZyBidXQgbWVkaWEgdGFnIGlzIHBhdXNlZCwgYW5kIGp1c3Qgc2Vla2VkXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yKSB7XG4gICAgICAgIHdhcm5BYm91dE5vblNlZWthYmxlTWVkaWEobWVkaWFSZWYuY3VycmVudCwgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvciA/IFwiY29uc29sZS13YXJuaW5nXCIgOiBcImNvbnNvbGUtZXJyb3JcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlZWtUaHJlc2hvbGQgPSBwbGF5aW5nID8gMC4xNSA6IDAuMDE7XG4gICAgY29uc3QgbWFrZXNTZW5zZVRvU2VlayA9IE1hdGguYWJzKG1lZGlhUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgLSBzaG91bGRCZVRpbWUpID4gc2Vla1RocmVzaG9sZDtcbiAgICBjb25zdCBpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkID0gaXNNZWRpYVRhZ0J1ZmZlcmluZyB8fCBpc0J1ZmZlcmluZygpO1xuICAgIGNvbnN0IGlzU29tZXRoaW5nRWxzZUJ1ZmZlcmluZyA9IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudCAmJiAhaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZDtcbiAgICBpZiAoIXBsYXlpbmcgfHwgaXNTb21ldGhpbmdFbHNlQnVmZmVyaW5nKSB7XG4gICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgICAgbWVkaWFSZWY6IG1lZGlhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgdGltZTogc2hvdWxkQmVUaW1lLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIHdoeTogYG5vdCBwbGF5aW5nIG9yIHNvbWV0aGluZyBlbHNlIGlzIGJ1ZmZlcmluZy4gdGltZSBvZmZzZXQgaXMgb3ZlciBzZWVrIHRocmVzaG9sZCAoJHtzZWVrVGhyZXNob2xkfSlgLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwbGF5aW5nIHx8IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXVzZWRDb25kaXRpb24gPSBtZWRpYVJlZi5jdXJyZW50LnBhdXNlZCAmJiAhbWVkaWFSZWYuY3VycmVudC5lbmRlZDtcbiAgICBjb25zdCBmaXJzdEZyYW1lQ29uZGl0aW9uID0gYWJzb2x1dGVGcmFtZSA9PT0gMDtcbiAgICBpZiAocGF1c2VkQ29uZGl0aW9uIHx8IGZpcnN0RnJhbWVDb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IHJlYXNvbiA9IHBhdXNlZENvbmRpdGlvbiA/IFwibWVkaWEgdGFnIGlzIHBhdXNlZFwiIDogXCJhYnNvbHV0ZSBmcmFtZSBpcyAwXCI7XG4gICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgICAgbWVkaWFSZWY6IG1lZGlhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgdGltZTogc2hvdWxkQmVUaW1lLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIHdoeTogYGlzIG92ZXIgdGltZXNoaWZ0IHRocmVzaG9sZCAodGhyZXNob2xkID0gJHtzZWVrVGhyZXNob2xkfSkgYW5kICR7cmVhc29ufWAsXG4gICAgICAgICAgbW91bnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgIG1lZGlhUmVmLFxuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgcmVhc29uOiBgcGxheWVyIGlzIHBsYXlpbmcgYW5kICR7cmVhc29ufWBcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc1ZhcmlhYmxlRnBzVmlkZW8gJiYgcGxheWJhY2tSYXRlID4gMCkge1xuICAgICAgICBidWZmZXJVbnRpbEZpcnN0RnJhbWUoc2hvdWxkQmVUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRCdXRMZXNzVGhhbkR1cmF0aW9uLFxuICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZSxcbiAgICBidWZmZXJpbmcuYnVmZmVyaW5nLFxuICAgIGN1cnJlbnRUaW1lLFxuICAgIGxvZ0xldmVsLFxuICAgIGRlc2lyZWRVbmNsYW1wZWRUaW1lLFxuICAgIGlzQnVmZmVyaW5nLFxuICAgIGlzTWVkaWFUYWdCdWZmZXJpbmcsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHBsYXlpbmcsXG4gICAgc3JjLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBtb3VudFRpbWVcbiAgXSk7XG59O1xuXG4vLyBzcmMvdXNlLXN5bmMtdm9sdW1lLXdpdGgtbWVkaWEtdGFnLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazksIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvaXMtYXBwcm94aW1hdGVseS10aGUtc2FtZS50c1xudmFyIEZMT0FUSU5HX1BPSU5UX0VSUk9SX1RIUkVTSE9MRCA9IDAuMDAwMDE7XG52YXIgaXNBcHByb3hpbWF0ZWx5VGhlU2FtZSA9IChudW0xLCBudW0yKSA9PiB7XG4gIHJldHVybiBNYXRoLmFicyhudW0xIC0gbnVtMikgPCBGTE9BVElOR19QT0lOVF9FUlJPUl9USFJFU0hPTEQ7XG59O1xuXG4vLyBzcmMvdXNlLXN5bmMtdm9sdW1lLXdpdGgtbWVkaWEtdGFnLnRzXG52YXIgdXNlU3luY1ZvbHVtZVdpdGhNZWRpYVRhZyA9ICh7XG4gIHZvbHVtZVByb3BGcmFtZSxcbiAgdm9sdW1lLFxuICBtZWRpYVZvbHVtZSxcbiAgbWVkaWFSZWZcbn0pID0+IHtcbiAgY29uc3QgYWRqdXN0Vm9sdW1lID0gdXNlQ2FsbGJhY2s5KCgpID0+IHtcbiAgICBpZiAoIW1lZGlhUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXNlclByZWZlcnJlZFZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgICB2b2x1bWUsXG4gICAgICBtZWRpYVZvbHVtZVxuICAgIH0pO1xuICAgIGlmICghaXNBcHByb3hpbWF0ZWx5VGhlU2FtZSh1c2VyUHJlZmVycmVkVm9sdW1lLCBtZWRpYVJlZi5jdXJyZW50LnZvbHVtZSkpIHtcbiAgICAgIG1lZGlhUmVmLmN1cnJlbnQudm9sdW1lID0gTWF0aC5taW4odXNlclByZWZlcnJlZFZvbHVtZSwgMSk7XG4gICAgfVxuICB9LCBbbWVkaWFSZWYsIG1lZGlhVm9sdW1lLCB2b2x1bWUsIHZvbHVtZVByb3BGcmFtZV0pO1xuICB1c2VFZmZlY3QxMigoKSA9PiB7XG4gICAgYWRqdXN0Vm9sdW1lKCk7XG4gIH0sIFthZGp1c3RWb2x1bWVdKTtcbiAgdXNlRWZmZWN0MTIoKCkgPT4ge1xuICAgIGNvbnN0IG1lZGlhID0gbWVkaWFSZWYuY3VycmVudDtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVZvbHVtZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGFkanVzdFZvbHVtZSgpO1xuICAgIH07XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcihcInZvbHVtZWNoYW5nZVwiLCBoYW5kbGVWb2x1bWVDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKFwidm9sdW1lY2hhbmdlXCIsIGhhbmRsZVZvbHVtZUNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2FkanVzdFZvbHVtZSwgbWVkaWFSZWZdKTtcbn07XG5cbi8vIHNyYy92b2x1bWUtcG9zaXRpb24tc3RhdGUudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE1LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxOSwgdXNlTWVtbyBhcyB1c2VNZW1vMTcgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBNZWRpYVZvbHVtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTUoe1xuICBtZWRpYU11dGVkOiBmYWxzZSxcbiAgbWVkaWFWb2x1bWU6IDFcbn0pO1xudmFyIFNldE1lZGlhVm9sdW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxNSh7XG4gIHNldE1lZGlhTXV0ZWQ6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9LFxuICBzZXRNZWRpYVZvbHVtZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRlZmF1bHRcIik7XG4gIH1cbn0pO1xudmFyIHVzZU1lZGlhVm9sdW1lU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgbWVkaWFWb2x1bWUgfSA9IHVzZUNvbnRleHQxOShNZWRpYVZvbHVtZUNvbnRleHQpO1xuICBjb25zdCB7IHNldE1lZGlhVm9sdW1lIH0gPSB1c2VDb250ZXh0MTkoU2V0TWVkaWFWb2x1bWVDb250ZXh0KTtcbiAgcmV0dXJuIHVzZU1lbW8xNygoKSA9PiB7XG4gICAgcmV0dXJuIFttZWRpYVZvbHVtZSwgc2V0TWVkaWFWb2x1bWVdO1xuICB9LCBbbWVkaWFWb2x1bWUsIHNldE1lZGlhVm9sdW1lXSk7XG59O1xudmFyIHVzZU1lZGlhTXV0ZWRTdGF0ZSA9ICgpID0+IHtcbiAgY29uc3QgeyBtZWRpYU11dGVkIH0gPSB1c2VDb250ZXh0MTkoTWVkaWFWb2x1bWVDb250ZXh0KTtcbiAgY29uc3QgeyBzZXRNZWRpYU11dGVkIH0gPSB1c2VDb250ZXh0MTkoU2V0TWVkaWFWb2x1bWVDb250ZXh0KTtcbiAgcmV0dXJuIHVzZU1lbW8xNygoKSA9PiB7XG4gICAgcmV0dXJuIFttZWRpYU11dGVkLCBzZXRNZWRpYU11dGVkXTtcbiAgfSwgW21lZGlhTXV0ZWQsIHNldE1lZGlhTXV0ZWRdKTtcbn07XG5cbi8vIHNyYy9hdWRpby9zaGFyZWQtYXVkaW8tdGFncy50c3hcbmltcG9ydCBSZWFjdDE0LCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE2LFxuICBjcmVhdGVSZWYgYXMgY3JlYXRlUmVmMixcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMCxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjAsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMyxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMTgsXG4gIHVzZVJlZiBhcyB1c2VSZWYxMCxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMlxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxNiwganN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEVNUFRZX0FVRElPID0gXCJkYXRhOmF1ZGlvL21wMztiYXNlNjQsLytNWXhBQUpjQVY4QUFnQUFCbi8vLy8vLysvZ1E1QkFNQStENFBnK0JBUUJBRUF3RDRQZytENEVCQUVBUURBUGcrK2hZQkgvLy9oVUZRVkJVRlJFRFFOSG1mLy8vLy8vLytNWXhCVUdrQUdJTUFBQUFQLzI5WHQ2bFV4QlRVVXpMakV3TUZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWLytNWXhEVUFBQU5JQUFBQUFGVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWXCI7XG52YXIgY29tcGFyZVByb3BzID0gKG9iajEsIG9iajIpID0+IHtcbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmoxKS5zb3J0KCk7XG4gIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMob2JqMikuc29ydCgpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7aSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGtleXNBW2ldICE9PSBrZXlzQltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob2JqMVtrZXlzQVtpXV0gIT09IG9iajJba2V5c0JbaV1dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBkaWRQcm9wQ2hhbmdlID0gKGtleSwgbmV3UHJvcCwgcHJldlByb3ApID0+IHtcbiAgaWYgKGtleSA9PT0gXCJzcmNcIiAmJiAhcHJldlByb3Auc3RhcnRzV2l0aChcImRhdGE6XCIpICYmICFuZXdQcm9wLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgIHJldHVybiBuZXcgVVJMKHByZXZQcm9wLCB3aW5kb3cub3JpZ2luKS50b1N0cmluZygpICE9PSBuZXcgVVJMKG5ld1Byb3AsIHdpbmRvdy5vcmlnaW4pLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHByZXZQcm9wID09PSBuZXdQcm9wKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBTaGFyZWRBdWRpb0NvbnRleHQgPSBjcmVhdGVDb250ZXh0MTYobnVsbCk7XG52YXIgU2hhcmVkQXVkaW9Db250ZXh0UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgbnVtYmVyT2ZBdWRpb1RhZ3MsIGNvbXBvbmVudCB9KSA9PiB7XG4gIGNvbnN0IGF1ZGlvcyA9IHVzZVJlZjEwKFtdKTtcbiAgY29uc3QgW2luaXRpYWxOdW1iZXJPZkF1ZGlvVGFnc10gPSB1c2VTdGF0ZTEyKG51bWJlck9mQXVkaW9UYWdzKTtcbiAgaWYgKG51bWJlck9mQXVkaW9UYWdzICE9PSBpbml0aWFsTnVtYmVyT2ZBdWRpb1RhZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHNoYXJlZCBhdWRpbyB0YWdzIGhhcyBjaGFuZ2VkIGR5bmFtaWNhbGx5LiBPbmNlIHlvdSBoYXZlIHNldCB0aGlzIHByb3BlcnR5LCB5b3UgY2Fubm90IGNoYW5nZSBpdCBhZnRlcndhcmRzLlwiKTtcbiAgfVxuICBjb25zdCByZWZzID0gdXNlTWVtbzE4KCgpID0+IHtcbiAgICByZXR1cm4gbmV3IEFycmF5KG51bWJlck9mQXVkaW9UYWdzKS5maWxsKHRydWUpLm1hcCgoKSA9PiB7XG4gICAgICByZXR1cm4geyBpZDogTWF0aC5yYW5kb20oKSwgcmVmOiBjcmVhdGVSZWYyKCkgfTtcbiAgICB9KTtcbiAgfSwgW251bWJlck9mQXVkaW9UYWdzXSk7XG4gIGNvbnN0IHRha2VuQXVkaW9zID0gdXNlUmVmMTAobmV3IEFycmF5KG51bWJlck9mQXVkaW9UYWdzKS5maWxsKGZhbHNlKSk7XG4gIGNvbnN0IHJlcmVuZGVyQXVkaW9zID0gdXNlQ2FsbGJhY2sxMCgoKSA9PiB7XG4gICAgcmVmcy5mb3JFYWNoKCh7IHJlZiwgaWQgfSkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGF1ZGlvcy5jdXJyZW50Py5maW5kKChhKSA9PiBhLmlkID09PSBpZCk7XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHJlZjtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN1cnJlbnQuc3JjID0gRU1QVFlfQVVESU87XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYXVkaW8gZGF0YSB0byBiZSB0aGVyZVwiKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKGRhdGEucHJvcHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoZGlkUHJvcENoYW5nZShrZXksIGRhdGEucHJvcHNba2V5XSwgY3VycmVudFtrZXldKSkge1xuICAgICAgICAgIGN1cnJlbnRba2V5XSA9IGRhdGEucHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtyZWZzXSk7XG4gIGNvbnN0IHJlZ2lzdGVyQXVkaW8gPSB1c2VDYWxsYmFjazEwKChhdWQsIGF1ZGlvSWQpID0+IHtcbiAgICBjb25zdCBmb3VuZCA9IGF1ZGlvcy5jdXJyZW50Py5maW5kKChhKSA9PiBhLmF1ZGlvSWQgPT09IGF1ZGlvSWQpO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdEZyZWVBdWRpbyA9IHRha2VuQXVkaW9zLmN1cnJlbnQuZmluZEluZGV4KChhKSA9PiBhID09PSBmYWxzZSk7XG4gICAgaWYgKGZpcnN0RnJlZUF1ZGlvID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmllZCB0byBzaW11bHRhbmVvdXNseSBtb3VudCAke251bWJlck9mQXVkaW9UYWdzICsgMX0gPEF1ZGlvIC8+IHRhZ3MgYXQgdGhlIHNhbWUgdGltZS4gV2l0aCB0aGUgY3VycmVudCBzZXR0aW5ncywgdGhlIG1heGltdW0gYW1vdW50IG9mIDxBdWRpbyAvPiB0YWdzIGlzIGxpbWl0ZWQgdG8gJHtudW1iZXJPZkF1ZGlvVGFnc30gYXQgdGhlIHNhbWUgdGltZS4gUmVtb3Rpb24gcHJlLW1vdW50cyBzaWxlbnQgYXVkaW8gdGFncyB0byBoZWxwIGF2b2lkIGJyb3dzZXIgYXV0b3BsYXkgcmVzdHJpY3Rpb25zLiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvYXV0b3BsYXkjdXNpbmctdGhlLW51bWJlcm9mc2hhcmVkYXVkaW90YWdzLXByb3AgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIGluY3JlYXNlIHRoaXMgbGltaXQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHJlZiB9ID0gcmVmc1tmaXJzdEZyZWVBdWRpb107XG4gICAgY29uc3QgY2xvbmVkID0gWy4uLnRha2VuQXVkaW9zLmN1cnJlbnRdO1xuICAgIGNsb25lZFtmaXJzdEZyZWVBdWRpb10gPSBpZDtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgIGNvbnN0IG5ld0VsZW0gPSB7XG4gICAgICBwcm9wczogYXVkLFxuICAgICAgaWQsXG4gICAgICBlbDogcmVmLFxuICAgICAgYXVkaW9JZFxuICAgIH07XG4gICAgYXVkaW9zLmN1cnJlbnQ/LnB1c2gobmV3RWxlbSk7XG4gICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgICByZXR1cm4gbmV3RWxlbTtcbiAgfSwgW251bWJlck9mQXVkaW9UYWdzLCByZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCB1bnJlZ2lzdGVyQXVkaW8gPSB1c2VDYWxsYmFjazEwKChpZCkgPT4ge1xuICAgIGNvbnN0IGNsb25lZCA9IFsuLi50YWtlbkF1ZGlvcy5jdXJyZW50XTtcbiAgICBjb25zdCBpbmRleCA9IHJlZnMuZmluZEluZGV4KChyKSA9PiByLmlkID09PSBpZCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkVycm9yIG9jY3VyZWQgaW4gXCIpO1xuICAgIH1cbiAgICBjbG9uZWRbaW5kZXhdID0gZmFsc2U7XG4gICAgdGFrZW5BdWRpb3MuY3VycmVudCA9IGNsb25lZDtcbiAgICBhdWRpb3MuY3VycmVudCA9IGF1ZGlvcy5jdXJyZW50Py5maWx0ZXIoKGEpID0+IGEuaWQgIT09IGlkKTtcbiAgICByZXJlbmRlckF1ZGlvcygpO1xuICB9LCBbcmVmcywgcmVyZW5kZXJBdWRpb3NdKTtcbiAgY29uc3QgdXBkYXRlQXVkaW8gPSB1c2VDYWxsYmFjazEwKCh7XG4gICAgYXVkLFxuICAgIGF1ZGlvSWQsXG4gICAgaWRcbiAgfSkgPT4ge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgYXVkaW9zLmN1cnJlbnQgPSBhdWRpb3MuY3VycmVudD8ubWFwKChwcmV2QSkgPT4ge1xuICAgICAgaWYgKHByZXZBLmlkID09PSBpZCkge1xuICAgICAgICBjb25zdCBpc1RoZVNhbWUgPSBjb21wYXJlUHJvcHMoYXVkLCBwcmV2QS5wcm9wcyk7XG4gICAgICAgIGlmIChpc1RoZVNhbWUpIHtcbiAgICAgICAgICByZXR1cm4gcHJldkE7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ucHJldkEsXG4gICAgICAgICAgcHJvcHM6IGF1ZCxcbiAgICAgICAgICBhdWRpb0lkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldkE7XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gICAgfVxuICB9LCBbcmVyZW5kZXJBdWRpb3NdKTtcbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCBtb3VudFRpbWUgPSB1c2VNb3VudFRpbWUoKTtcbiAgY29uc3QgcGxheUFsbEF1ZGlvcyA9IHVzZUNhbGxiYWNrMTAoKCkgPT4ge1xuICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yKHtcbiAgICAgICAgbWVkaWFSZWY6IHJlZi5yZWYsXG4gICAgICAgIG1lZGlhVHlwZTogXCJhdWRpb1wiLFxuICAgICAgICBvbkF1dG9QbGF5RXJyb3I6IG51bGwsXG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICBtb3VudFRpbWUsXG4gICAgICAgIHJlYXNvbjogXCJwbGF5aW5nIGFsbCBhdWRpb3NcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtsb2dMZXZlbCwgbW91bnRUaW1lLCByZWZzXSk7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzE4KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJBdWRpbyxcbiAgICAgIHVucmVnaXN0ZXJBdWRpbyxcbiAgICAgIHVwZGF0ZUF1ZGlvLFxuICAgICAgcGxheUFsbEF1ZGlvcyxcbiAgICAgIG51bWJlck9mQXVkaW9UYWdzXG4gICAgfTtcbiAgfSwgW1xuICAgIG51bWJlck9mQXVkaW9UYWdzLFxuICAgIHBsYXlBbGxBdWRpb3MsXG4gICAgcmVnaXN0ZXJBdWRpbyxcbiAgICB1bnJlZ2lzdGVyQXVkaW8sXG4gICAgdXBkYXRlQXVkaW9cbiAgXSk7XG4gIGNvbnN0IHJlc2V0QXVkaW8gPSB1c2VDYWxsYmFjazEwKCgpID0+IHtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gbmV3IEFycmF5KG51bWJlck9mQXVkaW9UYWdzKS5maWxsKGZhbHNlKTtcbiAgICBhdWRpb3MuY3VycmVudCA9IFtdO1xuICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gIH0sIFtudW1iZXJPZkF1ZGlvVGFncywgcmVyZW5kZXJBdWRpb3NdKTtcbiAgdXNlRWZmZWN0MTMoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXNldEF1ZGlvKCk7XG4gICAgfTtcbiAgfSwgW2NvbXBvbmVudCwgcmVzZXRBdWRpb10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoU2hhcmVkQXVkaW9Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWUsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIHJlZnMubWFwKCh7IGlkLCByZWYgfSkgPT4ge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE2KFwiYXVkaW9cIiwge1xuICAgICAgICAgIHJlZixcbiAgICAgICAgICBwcmVsb2FkOiBcIm1ldGFkYXRhXCIsXG4gICAgICAgICAgc3JjOiBFTVBUWV9BVURJT1xuICAgICAgICB9LCBpZCk7XG4gICAgICB9KSxcbiAgICAgIGNoaWxkcmVuXG4gICAgXVxuICB9KTtcbn07XG52YXIgdXNlU2hhcmVkQXVkaW8gPSAoYXVkLCBhdWRpb0lkKSA9PiB7XG4gIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQyMChTaGFyZWRBdWRpb0NvbnRleHQpO1xuICBjb25zdCBbZWxlbV0gPSB1c2VTdGF0ZTEyKCgpID0+IHtcbiAgICBpZiAoY3R4ICYmIGN0eC5udW1iZXJPZkF1ZGlvVGFncyA+IDApIHtcbiAgICAgIHJldHVybiBjdHgucmVnaXN0ZXJBdWRpbyhhdWQsIGF1ZGlvSWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWw6IFJlYWN0MTQuY3JlYXRlUmVmKCksXG4gICAgICBpZDogTWF0aC5yYW5kb20oKSxcbiAgICAgIHByb3BzOiBhdWQsXG4gICAgICBhdWRpb0lkXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IGVmZmVjdFRvVXNlID0gUmVhY3QxNC51c2VJbnNlcnRpb25FZmZlY3QgPz8gUmVhY3QxNC51c2VMYXlvdXRFZmZlY3Q7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBlZmZlY3RUb1VzZSgoKSA9PiB7XG4gICAgICBpZiAoY3R4ICYmIGN0eC5udW1iZXJPZkF1ZGlvVGFncyA+IDApIHtcbiAgICAgICAgY3R4LnVwZGF0ZUF1ZGlvKHsgaWQ6IGVsZW0uaWQsIGF1ZCwgYXVkaW9JZCB9KTtcbiAgICAgIH1cbiAgICB9LCBbYXVkLCBjdHgsIGVsZW0uaWQsIGF1ZGlvSWRdKTtcbiAgICBlZmZlY3RUb1VzZSgoKSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoY3R4ICYmIGN0eC5udW1iZXJPZkF1ZGlvVGFncyA+IDApIHtcbiAgICAgICAgICBjdHgudW5yZWdpc3RlckF1ZGlvKGVsZW0uaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtjdHgsIGVsZW0uaWRdKTtcbiAgfVxuICByZXR1cm4gZWxlbTtcbn07XG5cbi8vIHNyYy9hdWRpby9BdWRpb0ZvclByZXZpZXcudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTcgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBdWRpb0ZvckRldmVsb3BtZW50Rm9yd2FyZFJlZkZ1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgW2luaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHNdID0gdXNlU3RhdGUxMyhwcm9wcy5zaG91bGRQcmVNb3VudEF1ZGlvVGFncyk7XG4gIGlmIChwcm9wcy5zaG91bGRQcmVNb3VudEF1ZGlvVGFncyAhPT0gaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjaGFuZ2UgdGhlIGJlaGF2aW9yIGZvciBwcmUtbW91bnRpbmcgYXVkaW8gdGFncyBkeW5hbWljYWxseS5cIik7XG4gIH1cbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCB7XG4gICAgdm9sdW1lLFxuICAgIG11dGVkLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBzaG91bGRQcmVNb3VudEF1ZGlvVGFncyxcbiAgICBzcmMsXG4gICAgb25EdXJhdGlvbixcbiAgICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrLFxuICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgICBuYW1lLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgICBzdGFjayxcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFttZWRpYVZvbHVtZV0gPSB1c2VNZWRpYVZvbHVtZVN0YXRlKCk7XG4gIGNvbnN0IFttZWRpYU11dGVkXSA9IHVzZU1lZGlhTXV0ZWRTdGF0ZSgpO1xuICBjb25zdCB2b2x1bWVQcm9wRnJhbWUgPSB1c2VGcmFtZUZvclZvbHVtZVByb3AobG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IgPz8gXCJyZXBlYXRcIik7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSB1c2VDb250ZXh0MjEoU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCk7XG4gIGlmICghc3JjKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vICdzcmMnIHdhcyBwYXNzZWQgdG8gPEF1ZGlvPi5cIik7XG4gIH1cbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChzcmMpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjEoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgW3RpbWVsaW5lSWRdID0gdXNlU3RhdGUxMygoKSA9PiBTdHJpbmcoTWF0aC5yYW5kb20oKSkpO1xuICBjb25zdCBpc1NlcXVlbmNlSGlkZGVuID0gaGlkZGVuW3RpbWVsaW5lSWRdID8/IGZhbHNlO1xuICBjb25zdCB1c2VyUHJlZmVycmVkVm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lXG4gIH0pO1xuICBjb25zdCBwcm9wc1RvUGFzcyA9IHVzZU1lbW8xOSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG11dGVkOiBtdXRlZCB8fCBtZWRpYU11dGVkIHx8IGlzU2VxdWVuY2VIaWRkZW4gfHwgdXNlclByZWZlcnJlZFZvbHVtZSA8PSAwLFxuICAgICAgc3JjOiBwcmVsb2FkZWRTcmMsXG4gICAgICBsb29wOiBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgICAuLi5uYXRpdmVQcm9wc1xuICAgIH07XG4gIH0sIFtcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgaXNTZXF1ZW5jZUhpZGRlbixcbiAgICBtZWRpYU11dGVkLFxuICAgIG11dGVkLFxuICAgIG5hdGl2ZVByb3BzLFxuICAgIHByZWxvYWRlZFNyYyxcbiAgICB1c2VyUHJlZmVycmVkVm9sdW1lXG4gIF0pO1xuICBjb25zdCBpZCA9IHVzZU1lbW8xOSgoKSA9PiBgYXVkaW8tJHtyYW5kb20oc3JjID8/IFwiXCIpfS0ke3NlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9LW11dGVkOiR7cHJvcHMubXV0ZWR9LWxvb3A6JHtwcm9wcy5sb29wfWAsIFtcbiAgICBzcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lcyxcbiAgICBwcm9wcy5tdXRlZCxcbiAgICBwcm9wcy5sb29wXG4gIF0pO1xuICBjb25zdCBhdWRpb1JlZiA9IHVzZVNoYXJlZEF1ZGlvKHByb3BzVG9QYXNzLCBpZCkuZWw7XG4gIHVzZVN5bmNWb2x1bWVXaXRoTWVkaWFUYWcoe1xuICAgIHZvbHVtZVByb3BGcmFtZSxcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWUsXG4gICAgbWVkaWFSZWY6IGF1ZGlvUmVmXG4gIH0pO1xuICB1c2VNZWRpYUluVGltZWxpbmUoe1xuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZSxcbiAgICBtZWRpYVJlZjogYXVkaW9SZWYsXG4gICAgc3JjLFxuICAgIG1lZGlhVHlwZTogXCJhdWRpb1wiLFxuICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlID8/IDEsXG4gICAgZGlzcGxheU5hbWU6IG5hbWUgPz8gbnVsbCxcbiAgICBpZDogdGltZWxpbmVJZCxcbiAgICBzdGFjazogX3JlbW90aW9uSW50ZXJuYWxTdGFjayxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBwcmVtb3VudERpc3BsYXk6IG51bGwsXG4gICAgb25BdXRvUGxheUVycm9yOiBudWxsLFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZylcbiAgfSk7XG4gIHVzZUFtcGxpZmljYXRpb24oe1xuICAgIGxvZ0xldmVsLFxuICAgIG1lZGlhUmVmOiBhdWRpb1JlZixcbiAgICB2b2x1bWU6IHVzZXJQcmVmZXJyZWRWb2x1bWVcbiAgfSk7XG4gIHVzZU1lZGlhUGxheWJhY2soe1xuICAgIG1lZGlhUmVmOiBhdWRpb1JlZixcbiAgICBzcmMsXG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvXCIsXG4gICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgPz8gMSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yOiBmYWxzZSxcbiAgICBhY2NlcHRhYmxlVGltZXNoaWZ0OiBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzID8/IG51bGwsXG4gICAgaXNQcmVtb3VudGluZzogQm9vbGVhbihzZXF1ZW5jZUNvbnRleHQ/LnByZW1vdW50aW5nKSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgb25BdXRvUGxheUVycm9yOiBudWxsLFxuICAgIHVzZXJQcmVmZXJyZWRWb2x1bWVcbiAgfSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU1KHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiBhdWRpb1JlZi5jdXJyZW50O1xuICB9LCBbYXVkaW9SZWZdKTtcbiAgY29uc3QgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjayA9IHVzZVJlZjExKG9uRHVyYXRpb24pO1xuICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQgPSBvbkR1cmF0aW9uO1xuICB1c2VFZmZlY3QxNCgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBhdWRpb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQuZHVyYXRpb24pIHtcbiAgICAgIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudD8uKGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25Mb2FkZWRNZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudD8uKGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICB9O1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBvbkxvYWRlZE1ldGFkYXRhKTtcbiAgICB9O1xuICB9LCBbYXVkaW9SZWYsIHNyY10pO1xuICBpZiAoaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTcoXCJhdWRpb1wiLCB7XG4gICAgcmVmOiBhdWRpb1JlZixcbiAgICBwcmVsb2FkOiBcIm1ldGFkYXRhXCIsXG4gICAgLi4ucHJvcHNUb1Bhc3NcbiAgfSk7XG59O1xudmFyIEF1ZGlvRm9yUHJldmlldyA9IGZvcndhcmRSZWY0KEF1ZGlvRm9yRGV2ZWxvcG1lbnRGb3J3YXJkUmVmRnVuY3Rpb24pO1xuXG4vLyBzcmMvYXVkaW8vQXVkaW9Gb3JSZW5kZXJpbmcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY1LFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMixcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE1LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU2LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0NSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjAsXG4gIHVzZVJlZiBhcyB1c2VSZWYxMlxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxOCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEF1ZGlvRm9yUmVuZGVyaW5nUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgYXVkaW9SZWYgPSB1c2VSZWYxMihudWxsKTtcbiAgY29uc3Qge1xuICAgIHZvbHVtZTogdm9sdW1lUHJvcCxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICAgIG9uRHVyYXRpb24sXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbixcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyxcbiAgICBuYW1lLFxuICAgIG9uRXJyb3IsXG4gICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICAgIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlQ29udGV4dDIyKFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MjIoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3QgaWQgPSB1c2VNZW1vMjAoKCkgPT4gYGF1ZGlvLSR7cmFuZG9tKHByb3BzLnNyYyA/PyBcIlwiKX0tJHtzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzfWAsIFtcbiAgICBwcm9wcy5zcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc1xuICBdKTtcbiAgY29uc3Qgdm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgIHZvbHVtZTogdm9sdW1lUHJvcCxcbiAgICBmcmFtZTogdm9sdW1lUHJvcEZyYW1lLFxuICAgIG1lZGlhVm9sdW1lOiAxXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlNihyZWYsICgpID0+IHtcbiAgICByZXR1cm4gYXVkaW9SZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QxNSgoKSA9PiB7XG4gICAgaWYgKCFwcm9wcy5zcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvcHMubXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgdHlwZTogXCJhdWRpb1wiLFxuICAgICAgc3JjOiBnZXRBYnNvbHV0ZVNyYyhwcm9wcy5zcmMpLFxuICAgICAgaWQsXG4gICAgICBmcmFtZTogYWJzb2x1dGVGcmFtZSxcbiAgICAgIHZvbHVtZSxcbiAgICAgIG1lZGlhRnJhbWU6IGZyYW1lLFxuICAgICAgcGxheWJhY2tSYXRlOiBwcm9wcy5wbGF5YmFja1JhdGUgPz8gMSxcbiAgICAgIHRvbmVGcmVxdWVuY3k6IHRvbmVGcmVxdWVuY3kgPz8gbnVsbCxcbiAgICAgIGF1ZGlvU3RhcnRGcmFtZTogTWF0aC5tYXgoMCwgLShzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSA/PyAwKSlcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgfSwgW1xuICAgIHByb3BzLm11dGVkLFxuICAgIHByb3BzLnNyYyxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIGFic29sdXRlRnJhbWUsXG4gICAgaWQsXG4gICAgdW5yZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHZvbHVtZSxcbiAgICB2b2x1bWVQcm9wRnJhbWUsXG4gICAgZnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHByb3BzLnBsYXliYWNrUmF0ZSxcbiAgICB0b25lRnJlcXVlbmN5LFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tXG4gIF0pO1xuICBjb25zdCB7IHNyYyB9ID0gcHJvcHM7XG4gIGNvbnN0IG5lZWRzVG9SZW5kZXJBdWRpb1RhZyA9IHJlZiB8fCBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbjtcbiAgdXNlTGF5b3V0RWZmZWN0NSgoKSA9PiB7XG4gICAgaWYgKHdpbmRvdy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5lZWRzVG9SZW5kZXJBdWRpb1RhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcihcIkxvYWRpbmcgPEF1ZGlvPiBkdXJhdGlvbiB3aXRoIHNyYz1cIiArIHNyYywge1xuICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBhdWRpb1JlZjtcbiAgICBjb25zdCBkaWRMb2FkID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICAgIG9uRHVyYXRpb24oY3VycmVudC5zcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICB9O1xuICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgb25EdXJhdGlvbihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Py5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZGlkTG9hZCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGRpZExvYWQpO1xuICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICB9O1xuICB9LCBbXG4gICAgc3JjLFxuICAgIG9uRHVyYXRpb24sXG4gICAgbmVlZHNUb1JlbmRlckF1ZGlvVGFnLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kc1xuICBdKTtcbiAgaWYgKCFuZWVkc1RvUmVuZGVyQXVkaW9UYWcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE4KFwiYXVkaW9cIiwge1xuICAgIHJlZjogYXVkaW9SZWYsXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSk7XG59O1xudmFyIEF1ZGlvRm9yUmVuZGVyaW5nID0gZm9yd2FyZFJlZjUoQXVkaW9Gb3JSZW5kZXJpbmdSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuXG4vLyBzcmMvYXVkaW8vQXVkaW8udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTkgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBdWRpb1JlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHVzZUNvbnRleHQyMyhTaGFyZWRBdWRpb0NvbnRleHQpO1xuICBjb25zdCB7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIG5hbWUsXG4gICAgc3RhY2ssXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIC4uLm90aGVyUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7IGxvb3AsIC4uLnByb3BzT3RoZXJUaGFuTG9vcCB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgZnBzIH0gPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgeyBkdXJhdGlvbnMsIHNldER1cmF0aW9ucyB9ID0gdXNlQ29udGV4dDIzKER1cmF0aW9uc0NvbnRleHQpO1xuICBpZiAodHlwZW9mIHByb3BzLnNyYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8QXVkaW8+XFxgIHRhZyByZXF1aXJlcyBhIHN0cmluZyBmb3IgXFxgc3JjXFxgLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkocHJvcHMuc3JjKX0gaW5zdGVhZC5gKTtcbiAgfVxuICBjb25zdCBwcmVsb2FkZWRTcmMgPSB1c2VQcmVsb2FkKHByb3BzLnNyYyk7XG4gIGNvbnN0IG9uRXJyb3IgPSB1c2VDYWxsYmFjazExKChlKSA9PiB7XG4gICAgY29uc29sZS5sb2coZS5jdXJyZW50VGFyZ2V0LmVycm9yKTtcbiAgICBjb25zdCBlcnJNZXNzYWdlID0gYENvdWxkIG5vdCBwbGF5IGF1ZGlvIHdpdGggc3JjICR7cHJlbG9hZGVkU3JjfTogJHtlLmN1cnJlbnRUYXJnZXQuZXJyb3J9LiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9tZWRpYS1wbGF5YmFjay1lcnJvciBmb3IgaGVscC5gO1xuICAgIGlmIChsb29wKSB7XG4gICAgICBjYW5jZWxSZW5kZXIobmV3IEVycm9yKGVyck1lc3NhZ2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGVyck1lc3NhZ2UpO1xuICAgIH1cbiAgfSwgW2xvb3AsIHByZWxvYWRlZFNyY10pO1xuICBjb25zdCBvbkR1cmF0aW9uID0gdXNlQ2FsbGJhY2sxMSgoc3JjLCBkdXJhdGlvbkluU2Vjb25kcykgPT4ge1xuICAgIHNldER1cmF0aW9ucyh7IHR5cGU6IFwiZ290LWR1cmF0aW9uXCIsIGR1cmF0aW9uSW5TZWNvbmRzLCBzcmMgfSk7XG4gIH0sIFtzZXREdXJhdGlvbnNdKTtcbiAgY29uc3QgZHVyYXRpb25GZXRjaGVkID0gZHVyYXRpb25zW2dldEFic29sdXRlU3JjKHByZWxvYWRlZFNyYyldID8/IGR1cmF0aW9uc1tnZXRBYnNvbHV0ZVNyYyhwcm9wcy5zcmMpXTtcbiAgaWYgKGxvb3AgJiYgZHVyYXRpb25GZXRjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbkZldGNoZWQpKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE5KEF1ZGlvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9IGR1cmF0aW9uRmV0Y2hlZCAqIGZwcztcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE5KExvb3AsIHtcbiAgICAgIGxheW91dDogXCJub25lXCIsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBjYWxjdWxhdGVMb29wRHVyYXRpb24oe1xuICAgICAgICBlbmRBdCxcbiAgICAgICAgbWVkaWFEdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHN0YXJ0RnJvbVxuICAgICAgfSksXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDE5KEF1ZGlvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGVuZEF0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFsaWRhdGVTdGFydEZyb21Qcm9wcyhzdGFydEZyb20sIGVuZEF0KTtcbiAgICBjb25zdCBzdGFydEZyb21GcmFtZU5vID0gc3RhcnRGcm9tID8/IDA7XG4gICAgY29uc3QgZW5kQXRGcmFtZU5vID0gZW5kQXQgPz8gSW5maW5pdHk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxOShTZXF1ZW5jZSwge1xuICAgICAgbGF5b3V0OiBcIm5vbmVcIixcbiAgICAgIGZyb206IDAgLSBzdGFydEZyb21GcmFtZU5vLFxuICAgICAgc2hvd0luVGltZWxpbmU6IGZhbHNlLFxuICAgICAgZHVyYXRpb25JbkZyYW1lczogZW5kQXRGcmFtZU5vLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MTkoQXVkaW8sIHtcbiAgICAgICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcCksXG4gICAgICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgICByZWZcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgdmFsaWRhdGVNZWRpYVByb3BzKHByb3BzLCBcIkF1ZGlvXCIpO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE5KEF1ZGlvRm9yUmVuZGVyaW5nLCB7XG4gICAgICBvbkR1cmF0aW9uLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWYsXG4gICAgICBvbkVycm9yLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcClcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE5KEF1ZGlvRm9yUHJldmlldywge1xuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogcHJvcHMuX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkID8/IGZhbHNlLFxuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgc2hvdWxkUHJlTW91bnRBdWRpb1RhZ3M6IGF1ZGlvQ29udGV4dCAhPT0gbnVsbCAmJiBhdWRpb0NvbnRleHQubnVtYmVyT2ZBdWRpb1RhZ3MgPiAwLFxuICAgIC4uLnByb3BzLFxuICAgIHJlZixcbiAgICBvbkVycm9yLFxuICAgIG9uRHVyYXRpb24sXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcCksXG4gICAgc2hvd0luVGltZWxpbmU6IHNob3dJblRpbWVsaW5lID8/IHRydWVcbiAgfSk7XG59O1xudmFyIEF1ZGlvID0gZm9yd2FyZFJlZjYoQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhBdWRpbyk7XG4vLyBzcmMvQ29tcG9zaXRpb24udHN4XG5pbXBvcnQgeyBTdXNwZW5zZSwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjUsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuXG4vLyBzcmMvRm9sZGVyLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTcsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI0LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTYsIHVzZU1lbW8gYXMgdXNlTWVtbzIxIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWZvbGRlci1uYW1lLnRzXG52YXIgZ2V0UmVnZXggPSAoKSA9PiAvXihbYS16QS1aMC05LVxcdTRFMDAtXFx1OUZGRl0pKyQvZztcbnZhciBpc0ZvbGRlck5hbWVWYWxpZCA9IChuYW1lKSA9PiBuYW1lLm1hdGNoKGdldFJlZ2V4KCkpO1xudmFyIHZhbGlkYXRlRm9sZGVyTmFtZSA9IChuYW1lKSA9PiB7XG4gIGlmIChuYW1lID09PSB1bmRlZmluZWQgfHwgbmFtZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgbmFtZSB0byBhIDxGb2xkZXIgLz4uXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIm5hbWVcIiB5b3UgcGFzcyBpbnRvIDxGb2xkZXIgLz4gbXVzdCBiZSBhIHN0cmluZy4gR290OiAke3R5cGVvZiBuYW1lfWApO1xuICB9XG4gIGlmICghaXNGb2xkZXJOYW1lVmFsaWQobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZvbGRlciBuYW1lIGNhbiBvbmx5IGNvbnRhaW4gYS16LCBBLVosIDAtOSBhbmQgLS4gWW91IHBhc3NlZCAke25hbWV9YCk7XG4gIH1cbn07XG52YXIgaW52YWxpZEZvbGRlck5hbWVFcnJvck1lc3NhZ2UgPSBgRm9sZGVyIG5hbWUgbXVzdCBtYXRjaCAke1N0cmluZyhnZXRSZWdleCgpKX1gO1xuXG4vLyBzcmMvRm9sZGVyLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIwIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRm9sZGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxNyh7XG4gIGZvbGRlck5hbWU6IG51bGwsXG4gIHBhcmVudE5hbWU6IG51bGxcbn0pO1xudmFyIEZvbGRlciA9ICh7IG5hbWUsIGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgcGFyZW50ID0gdXNlQ29udGV4dDI0KEZvbGRlckNvbnRleHQpO1xuICBjb25zdCB7IHJlZ2lzdGVyRm9sZGVyLCB1bnJlZ2lzdGVyRm9sZGVyIH0gPSB1c2VDb250ZXh0MjQoQ29tcG9zaXRpb25TZXR0ZXJzKTtcbiAgdmFsaWRhdGVGb2xkZXJOYW1lKG5hbWUpO1xuICBjb25zdCBwYXJlbnROYW1lQXJyID0gW3BhcmVudC5wYXJlbnROYW1lLCBwYXJlbnQuZm9sZGVyTmFtZV0uZmlsdGVyKHRydXRoeSk7XG4gIGNvbnN0IHBhcmVudE5hbWUgPSBwYXJlbnROYW1lQXJyLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBwYXJlbnROYW1lQXJyLmpvaW4oXCIvXCIpO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8yMSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbGRlck5hbWU6IG5hbWUsXG4gICAgICBwYXJlbnROYW1lXG4gICAgfTtcbiAgfSwgW25hbWUsIHBhcmVudE5hbWVdKTtcbiAgdXNlRWZmZWN0MTYoKCkgPT4ge1xuICAgIHJlZ2lzdGVyRm9sZGVyKG5hbWUsIHBhcmVudE5hbWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyRm9sZGVyKG5hbWUsIHBhcmVudE5hbWUpO1xuICAgIH07XG4gIH0sIFtuYW1lLCBwYXJlbnQuZm9sZGVyTmFtZSwgcGFyZW50TmFtZSwgcmVnaXN0ZXJGb2xkZXIsIHVucmVnaXN0ZXJGb2xkZXJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyMChGb2xkZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvbG9hZGluZy1pbmRpY2F0b3IudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjEsIGpzeHMgYXMganN4czIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciByb3RhdGUgPSB7XG4gIHRyYW5zZm9ybTogYHJvdGF0ZSg5MGRlZylgXG59O1xudmFyIElDT05fU0laRSA9IDQwO1xudmFyIGxhYmVsID0ge1xuICBjb2xvcjogXCJ3aGl0ZVwiLFxuICBmb250U2l6ZTogMTQsXG4gIGZvbnRGYW1pbHk6IFwic2Fucy1zZXJpZlwiXG59O1xudmFyIGNvbnRhaW5lciA9IHtcbiAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gIGFsaWduSXRlbXM6IFwiY2VudGVyXCJcbn07XG52YXIgTG9hZGluZyA9ICgpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihBYnNvbHV0ZUZpbGwsIHtcbiAgICBzdHlsZTogY29udGFpbmVyLFxuICAgIGlkOiBcInJlbW90aW9uLWNvbXAtbG9hZGluZ1wiLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MjEoXCJzdHlsZVwiLCB7XG4gICAgICAgIHR5cGU6IFwidGV4dC9jc3NcIixcbiAgICAgICAgY2hpbGRyZW46IGBcblx0XHRcdFx0QGtleWZyYW1lcyBhbmltIHtcblx0XHRcdFx0XHRmcm9tIHtcblx0XHRcdFx0XHRcdG9wYWNpdHk6IDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG8ge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTogMVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQjcmVtb3Rpb24tY29tcC1sb2FkaW5nIHtcblx0XHRcdFx0XHRhbmltYXRpb246IGFuaW0gMnM7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLWZpbGwtbW9kZTogZm9yd2FyZHM7XG5cdFx0XHRcdH1cblx0XHRcdGBcbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIxKFwic3ZnXCIsIHtcbiAgICAgICAgd2lkdGg6IElDT05fU0laRSxcbiAgICAgICAgaGVpZ2h0OiBJQ09OX1NJWkUsXG4gICAgICAgIHZpZXdCb3g6IFwiLTEwMCAtMTAwIDQwMCA0MDBcIixcbiAgICAgICAgc3R5bGU6IHJvdGF0ZSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMShcInBhdGhcIiwge1xuICAgICAgICAgIGZpbGw6IFwiIzU1NVwiLFxuICAgICAgICAgIHN0cm9rZTogXCIjNTU1XCIsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMTAwXCIsXG4gICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgICAgICBkOiBcIk0gMiAxNzIgYSAxOTYgMTAwIDAgMCAwIDE5NSA1IEEgMTk2IDI0MCAwIDAgMCAxMDAgMi4yNTkgQSAxOTYgMjQwIDAgMCAwIDIgMTcyIHpcIlxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4czIoXCJwXCIsIHtcbiAgICAgICAgc3R5bGU6IGxhYmVsLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIFwiUmVzb2x2aW5nIFwiLFxuICAgICAgICAgIFwiPFN1c3BlbnNlPlwiLFxuICAgICAgICAgIFwiLi4uXCJcbiAgICAgICAgXVxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufTtcblxuLy8gc3JjL3BvcnRhbC1ub2RlLnRzXG52YXIgX3BvcnRhbE5vZGUgPSBudWxsO1xudmFyIHBvcnRhbE5vZGUgPSAoKSA9PiB7XG4gIGlmICghX3BvcnRhbE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBjYWxsIGFuIEFQSSB0aGF0IG9ubHkgd29ya3MgaW4gdGhlIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHRoZSBicm93c2VyXCIpO1xuICAgIH1cbiAgICBfcG9ydGFsTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5yaWdodCA9IFwiMHB4XCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJjb2x1bW5cIjtcbiAgICBjb25zdCBjb250YWluZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb250YWluZXJOb2RlLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIGNvbnRhaW5lck5vZGUuc3R5bGUudG9wID0gLTk5OTk5OSArIFwicHhcIjtcbiAgICBjb250YWluZXJOb2RlLmFwcGVuZENoaWxkKF9wb3J0YWxOb2RlKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lck5vZGUpO1xuICB9XG4gIHJldHVybiBfcG9ydGFsTm9kZTtcbn07XG5cbi8vIHNyYy91c2UtbGF6eS1jb21wb25lbnQudHNcbmltcG9ydCBSZWFjdDE4LCB7IHVzZU1lbW8gYXMgdXNlTWVtbzIyIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlTGF6eUNvbXBvbmVudCA9ICh7XG4gIGNvbXBQcm9wcyxcbiAgY29tcG9uZW50TmFtZSxcbiAgbm9TdXNwZW5zZVxufSkgPT4ge1xuICBjb25zdCBsYXp5ID0gdXNlTWVtbzIyKCgpID0+IHtcbiAgICBpZiAoXCJjb21wb25lbnRcIiBpbiBjb21wUHJvcHMpIHtcbiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgfHwgbm9TdXNwZW5zZSkge1xuICAgICAgICByZXR1cm4gY29tcFByb3BzLmNvbXBvbmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29tcFByb3BzLmNvbXBvbmVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgdmFsdWUgb2YgXFxgdW5kZWZpbmVkXFxgIHdhcyBwYXNzZWQgdG8gdGhlIFxcYGNvbXBvbmVudFxcYCBwcm9wLiBDaGVjayB0aGUgdmFsdWUgeW91IGFyZSBwYXNzaW5nIHRvIHRoZSA8JHtjb21wb25lbnROYW1lfS8+IGNvbXBvbmVudC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdDE4LmxhenkoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZGVmYXVsdDogY29tcFByb3BzLmNvbXBvbmVudCB9KSk7XG4gICAgfVxuICAgIGlmIChcImxhenlDb21wb25lbnRcIiBpbiBjb21wUHJvcHMgJiYgdHlwZW9mIGNvbXBQcm9wcy5sYXp5Q29tcG9uZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbXBQcm9wcy5sYXp5Q29tcG9uZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQSB2YWx1ZSBvZiBcXGB1bmRlZmluZWRcXGAgd2FzIHBhc3NlZCB0byB0aGUgXFxgbGF6eUNvbXBvbmVudFxcYCBwcm9wLiBDaGVjayB0aGUgdmFsdWUgeW91IGFyZSBwYXNzaW5nIHRvIHRoZSA8JHtjb21wb25lbnROYW1lfS8+IGNvbXBvbmVudC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdDE4LmxhenkoY29tcFByb3BzLmxhenlDb21wb25lbnQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGVpdGhlciAnY29tcG9uZW50JyBvciAnbGF6eUNvbXBvbmVudCdcIik7XG4gIH0sIFtjb21wUHJvcHMuY29tcG9uZW50LCBjb21wUHJvcHMubGF6eUNvbXBvbmVudF0pO1xuICByZXR1cm4gbGF6eTtcbn07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWNvbXBvc2l0aW9uLWlkLnRzXG52YXIgZ2V0UmVnZXgyID0gKCkgPT4gL14oW2EtekEtWjAtOS1cXHU0RTAwLVxcdTlGRkZdKSskL2c7XG52YXIgaXNDb21wb3NpdGlvbklkVmFsaWQgPSAoaWQpID0+IGlkLm1hdGNoKGdldFJlZ2V4MigpKTtcbnZhciB2YWxpZGF0ZUNvbXBvc2l0aW9uSWQgPSAoaWQpID0+IHtcbiAgaWYgKCFpc0NvbXBvc2l0aW9uSWRWYWxpZChpZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvc2l0aW9uIGlkIGNhbiBvbmx5IGNvbnRhaW4gYS16LCBBLVosIDAtOSwgQ0pLIGNoYXJhY3RlcnMgYW5kIC0uIFlvdSBwYXNzZWQgJHtpZH1gKTtcbiAgfVxufTtcbnZhciBpbnZhbGlkQ29tcG9zaXRpb25FcnJvck1lc3NhZ2UgPSBgQ29tcG9zaXRpb24gSUQgbXVzdCBtYXRjaCAke1N0cmluZyhnZXRSZWdleDIoKSl9YDtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZGVmYXVsdC1wcm9wcy50c1xudmFyIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMgPSAoZGVmYXVsdFByb3BzLCBuYW1lLCBjb21wb3NpdGlvbklkKSA9PiB7XG4gIGlmICghZGVmYXVsdFByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZGVmYXVsdFByb3BzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGRlZmF1bHRQcm9wc31gKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0UHJvcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGFuIG9iamVjdCwgYW4gYXJyYXkgd2FzIHBhc3NlZCAke2NvbXBvc2l0aW9uSWQgPyBgZm9yIGNvbXBvc2l0aW9uIFwiJHtjb21wb3NpdGlvbklkfVwiYCA6IFwiXCJ9YCk7XG4gIH1cbn07XG5cbi8vIHNyYy9Db21wb3NpdGlvbi50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEZhbGxiYWNrID0gKCkgPT4ge1xuICB1c2VFZmZlY3QxNygoKSA9PiB7XG4gICAgY29uc3QgZmFsbGJhY2sgPSBkZWxheVJlbmRlcihcIldhaXRpbmcgZm9yIFJvb3QgY29tcG9uZW50IHRvIHVuc3VzcGVuZFwiKTtcbiAgICByZXR1cm4gKCkgPT4gY29udGludWVSZW5kZXIoZmFsbGJhY2spO1xuICB9LCBbXSk7XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBJbm5lckNvbXBvc2l0aW9uID0gKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgZnBzLFxuICBkdXJhdGlvbkluRnJhbWVzLFxuICBpZCxcbiAgZGVmYXVsdFByb3BzLFxuICBzY2hlbWEsXG4gIC4uLmNvbXBQcm9wc1xufSkgPT4ge1xuICBjb25zdCBjb21wTWFuYWdlciA9IHVzZUNvbnRleHQyNShDb21wb3NpdGlvblNldHRlcnMpO1xuICBjb25zdCB7IHJlZ2lzdGVyQ29tcG9zaXRpb24sIHVucmVnaXN0ZXJDb21wb3NpdGlvbiB9ID0gY29tcE1hbmFnZXI7XG4gIGNvbnN0IHZpZGVvID0gdXNlVmlkZW8oKTtcbiAgY29uc3QgbGF6eSA9IHVzZUxhenlDb21wb25lbnQoe1xuICAgIGNvbXBQcm9wcyxcbiAgICBjb21wb25lbnROYW1lOiBcIkNvbXBvc2l0aW9uXCIsXG4gICAgbm9TdXNwZW5zZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IG5vbmNlID0gdXNlTm9uY2UoKTtcbiAgY29uc3QgaXNQbGF5ZXIgPSB1c2VJc1BsYXllcigpO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgY2FuVXNlQ29tcG9zaXRpb24gPSB1c2VDb250ZXh0MjUoQ2FuVXNlUmVtb3Rpb25Ib29rcyk7XG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbikge1xuICAgIGlmIChpc1BsYXllcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiPENvbXBvc2l0aW9uPiB3YXMgbW91bnRlZCBpbnNpZGUgdGhlIGBjb21wb25lbnRgIHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgPFBsYXllcj4uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3dyb25nLWNvbXBvc2l0aW9uLW1vdW50IGZvciBoZWxwLlwiKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiPENvbXBvc2l0aW9uPiBtb3VudGVkIGluc2lkZSBhbm90aGVyIGNvbXBvc2l0aW9uLiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy93cm9uZy1jb21wb3NpdGlvbi1tb3VudCBmb3IgaGVscC5cIik7XG4gIH1cbiAgY29uc3QgeyBmb2xkZXJOYW1lLCBwYXJlbnROYW1lIH0gPSB1c2VDb250ZXh0MjUoRm9sZGVyQ29udGV4dCk7XG4gIHVzZUVmZmVjdDE3KCgpID0+IHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBpZCBmb3IgY29tcG9zaXRpb24gcGFzc2VkLlwiKTtcbiAgICB9XG4gICAgdmFsaWRhdGVDb21wb3NpdGlvbklkKGlkKTtcbiAgICB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzKGRlZmF1bHRQcm9wcywgXCJkZWZhdWx0UHJvcHNcIiwgaWQpO1xuICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24oe1xuICAgICAgZHVyYXRpb25JbkZyYW1lczogZHVyYXRpb25JbkZyYW1lcyA/PyB1bmRlZmluZWQsXG4gICAgICBmcHM6IGZwcyA/PyB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6IGhlaWdodCA/PyB1bmRlZmluZWQsXG4gICAgICB3aWR0aDogd2lkdGggPz8gdW5kZWZpbmVkLFxuICAgICAgaWQsXG4gICAgICBmb2xkZXJOYW1lLFxuICAgICAgY29tcG9uZW50OiBsYXp5LFxuICAgICAgZGVmYXVsdFByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhkZWZhdWx0UHJvcHMgPz8ge30pLFxuICAgICAgbm9uY2UsXG4gICAgICBwYXJlbnRGb2xkZXJOYW1lOiBwYXJlbnROYW1lLFxuICAgICAgc2NoZW1hOiBzY2hlbWEgPz8gbnVsbCxcbiAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhOiBjb21wUHJvcHMuY2FsY3VsYXRlTWV0YWRhdGEgPz8gbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyQ29tcG9zaXRpb24oaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgIGZwcyxcbiAgICBoZWlnaHQsXG4gICAgbGF6eSxcbiAgICBpZCxcbiAgICBmb2xkZXJOYW1lLFxuICAgIGRlZmF1bHRQcm9wcyxcbiAgICB3aWR0aCxcbiAgICBub25jZSxcbiAgICBwYXJlbnROYW1lLFxuICAgIHNjaGVtYSxcbiAgICBjb21wUHJvcHMuY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgcmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICB1bnJlZ2lzdGVyQ29tcG9zaXRpb25cbiAgXSk7XG4gIGNvbnN0IHJlc29sdmVkID0gdXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyhpZCk7XG4gIGlmIChlbnZpcm9ubWVudC5pc1N0dWRpbyAmJiB2aWRlbyAmJiB2aWRlby5jb21wb25lbnQgPT09IGxhenkpIHtcbiAgICBjb25zdCBDb21wID0gbGF6eTtcbiAgICBpZiAocmVzb2x2ZWQgPT09IG51bGwgfHwgcmVzb2x2ZWQudHlwZSAhPT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKC8qIEBfX1BVUkVfXyAqLyBqc3gyMihDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIsIHtcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjIoU3VzcGVuc2UsIHtcbiAgICAgICAgZmFsbGJhY2s6IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihMb2FkaW5nLCB7fSksXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjIoQ29tcCwge1xuICAgICAgICAgIC4uLnJlc29sdmVkLnJlc3VsdC5wcm9wcyA/PyB7fVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KSwgcG9ydGFsTm9kZSgpKTtcbiAgfVxuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcgJiYgdmlkZW8gJiYgdmlkZW8uY29tcG9uZW50ID09PSBsYXp5KSB7XG4gICAgY29uc3QgQ29tcCA9IGxhenk7XG4gICAgaWYgKHJlc29sdmVkID09PSBudWxsIHx8IHJlc29sdmVkLnR5cGUgIT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbCgvKiBAX19QVVJFX18gKi8ganN4MjIoQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyLCB7XG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIyKFN1c3BlbnNlLCB7XG4gICAgICAgIGZhbGxiYWNrOiAvKiBAX19QVVJFX18gKi8ganN4MjIoRmFsbGJhY2ssIHt9KSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihDb21wLCB7XG4gICAgICAgICAgLi4ucmVzb2x2ZWQucmVzdWx0LnByb3BzID8/IHt9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pLCBwb3J0YWxOb2RlKCkpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBDb21wb3NpdGlvbiA9IChwcm9wczIpID0+IHtcbiAgY29uc3QgeyBvbmx5UmVuZGVyQ29tcG9zaXRpb24gfSA9IHVzZUNvbnRleHQyNShDb21wb3NpdGlvblNldHRlcnMpO1xuICBpZiAob25seVJlbmRlckNvbXBvc2l0aW9uICYmIG9ubHlSZW5kZXJDb21wb3NpdGlvbiAhPT0gcHJvcHMyLmlkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyMihJbm5lckNvbXBvc2l0aW9uLCB7XG4gICAgLi4ucHJvcHMyXG4gIH0pO1xufTtcbi8vIHNyYy9iZXppZXIudHNcbnZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG52YXIgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xudmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcbnZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xudmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbnZhciBrU2FtcGxlU3RlcFNpemUgPSAxIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxKTtcbnZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSBcImZ1bmN0aW9uXCI7XG5mdW5jdGlvbiBhKGFBMSwgYUEyKSB7XG4gIHJldHVybiAxIC0gMyAqIGFBMiArIDMgKiBhQTE7XG59XG5mdW5jdGlvbiBiKGFBMSwgYUEyKSB7XG4gIHJldHVybiAzICogYUEyIC0gNiAqIGFBMTtcbn1cbmZ1bmN0aW9uIGMoYUExKSB7XG4gIHJldHVybiAzICogYUExO1xufVxuZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcbiAgcmV0dXJuICgoYShhQTEsIGFBMikgKiBhVCArIGIoYUExLCBhQTIpKSAqIGFUICsgYyhhQTEpKSAqIGFUO1xufVxuZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7XG4gIHJldHVybiAzICogYShhQTEsIGFBMikgKiBhVCAqIGFUICsgMiAqIGIoYUExLCBhQTIpICogYVQgKyBjKGFBMSk7XG59XG5mdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoe1xuICBhWCxcbiAgX2FBLFxuICBfYUIsXG4gIG1YMSxcbiAgbVgyXG59KSB7XG4gIGxldCBjdXJyZW50WDtcbiAgbGV0IGN1cnJlbnRUO1xuICBsZXQgaSA9IDA7XG4gIGxldCBhQSA9IF9hQTtcbiAgbGV0IGFCID0gX2FCO1xuICBkbyB7XG4gICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDI7XG4gICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICBpZiAoY3VycmVudFggPiAwKSB7XG4gICAgICBhQiA9IGN1cnJlbnRUO1xuICAgIH0gZWxzZSB7XG4gICAgICBhQSA9IGN1cnJlbnRUO1xuICAgIH1cbiAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKTtcbiAgcmV0dXJuIGN1cnJlbnRUO1xufVxuZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIF9hR3Vlc3NULCBtWDEsIG1YMikge1xuICBsZXQgYUd1ZXNzVCA9IF9hR3Vlc3NUO1xuICBmb3IgKGxldCBpID0gMDtpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuICAgIGNvbnN0IGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgICBpZiAoY3VycmVudFNsb3BlID09PSAwKSB7XG4gICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gIH1cbiAgcmV0dXJuIGFHdWVzc1Q7XG59XG5mdW5jdGlvbiBiZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIGlmICghKG1YMSA+PSAwICYmIG1YMSA8PSAxICYmIG1YMiA+PSAwICYmIG1YMiA8PSAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImJlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZVwiKTtcbiAgfVxuICBjb25zdCBzYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICBmb3IgKGxldCBpID0gMDtpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XG4gICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICBsZXQgaW50ZXJ2YWxTdGFydCA9IDA7XG4gICAgbGV0IGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcbiAgICBmb3IgKDtjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICB9XG4gICAgLS1jdXJyZW50U2FtcGxlO1xuICAgIGNvbnN0IGRpc3QgPSAoYVggLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgIGNvbnN0IGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xuICAgIGNvbnN0IGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICB9XG4gICAgaWYgKGluaXRpYWxTbG9wZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICB9XG4gICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZSh7XG4gICAgICBhWCxcbiAgICAgIF9hQTogaW50ZXJ2YWxTdGFydCxcbiAgICAgIF9hQjogaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSxcbiAgICAgIG1YMSxcbiAgICAgIG1YMlxuICAgIH0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoeCA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gIH07XG59XG5cbi8vIHNyYy9lYXNpbmcudHNcbmNsYXNzIEVhc2luZyB7XG4gIHN0YXRpYyBzdGVwMChuKSB7XG4gICAgcmV0dXJuIG4gPiAwID8gMSA6IDA7XG4gIH1cbiAgc3RhdGljIHN0ZXAxKG4pIHtcbiAgICByZXR1cm4gbiA+PSAxID8gMSA6IDA7XG4gIH1cbiAgc3RhdGljIGxpbmVhcih0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgc3RhdGljIGVhc2UodCkge1xuICAgIHJldHVybiBFYXNpbmcuYmV6aWVyKDAuNDIsIDAsIDEsIDEpKHQpO1xuICB9XG4gIHN0YXRpYyBxdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH1cbiAgc3RhdGljIGN1YmljKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xuICB9XG4gIHN0YXRpYyBwb2x5KG4pIHtcbiAgICByZXR1cm4gKHQpID0+IHQgKiogbjtcbiAgfVxuICBzdGF0aWMgc2luKHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMik7XG4gIH1cbiAgc3RhdGljIGNpcmNsZSh0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTtcbiAgfVxuICBzdGF0aWMgZXhwKHQpIHtcbiAgICByZXR1cm4gMiAqKiAoMTAgKiAodCAtIDEpKTtcbiAgfVxuICBzdGF0aWMgZWxhc3RpYyhib3VuY2luZXNzID0gMSkge1xuICAgIGNvbnN0IHAgPSBib3VuY2luZXNzICogTWF0aC5QSTtcbiAgICByZXR1cm4gKHQpID0+IDEgLSBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpICoqIDMgKiBNYXRoLmNvcyh0ICogcCk7XG4gIH1cbiAgc3RhdGljIGJhY2socyA9IDEuNzAxNTgpIHtcbiAgICByZXR1cm4gKHQpID0+IHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH1cbiAgc3RhdGljIGJvdW5jZSh0KSB7XG4gICAgaWYgKHQgPCAxIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8IDIgLyAyLjc1KSB7XG4gICAgICBjb25zdCB0Ml8gPSB0IC0gMS41IC8gMi43NTtcbiAgICAgIHJldHVybiA3LjU2MjUgKiB0Ml8gKiB0Ml8gKyAwLjc1O1xuICAgIH1cbiAgICBpZiAodCA8IDIuNSAvIDIuNzUpIHtcbiAgICAgIGNvbnN0IHQyXyA9IHQgLSAyLjI1IC8gMi43NTtcbiAgICAgIHJldHVybiA3LjU2MjUgKiB0Ml8gKiB0Ml8gKyAwLjkzNzU7XG4gICAgfVxuICAgIGNvbnN0IHQyID0gdCAtIDIuNjI1IC8gMi43NTtcbiAgICByZXR1cm4gNy41NjI1ICogdDIgKiB0MiArIDAuOTg0Mzc1O1xuICB9XG4gIHN0YXRpYyBiZXppZXIoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gYmV6aWVyKHgxLCB5MSwgeDIsIHkyKTtcbiAgfVxuICBzdGF0aWMgaW4oZWFzaW5nKSB7XG4gICAgcmV0dXJuIGVhc2luZztcbiAgfVxuICBzdGF0aWMgb3V0KGVhc2luZykge1xuICAgIHJldHVybiAodCkgPT4gMSAtIGVhc2luZygxIC0gdCk7XG4gIH1cbiAgc3RhdGljIGluT3V0KGVhc2luZykge1xuICAgIHJldHVybiAodCkgPT4ge1xuICAgICAgaWYgKHQgPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIGVhc2luZyh0ICogMikgLyAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDEgLSBlYXNpbmcoKDEgLSB0KSAqIDIpIC8gMjtcbiAgICB9O1xuICB9XG59XG4vLyBzcmMvdjUtZmxhZy50c1xudmFyIEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTID0gZmFsc2U7XG5cbi8vIHNyYy9nZXQtc3RhdGljLWZpbGVzLnRzXG52YXIgd2FybmVkU2VydmVyID0gZmFsc2U7XG52YXIgd2FybmVkUGxheWVyID0gZmFsc2U7XG52YXIgd2FyblNlcnZlck9uY2UgPSAoKSA9PiB7XG4gIGlmICh3YXJuZWRTZXJ2ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybmVkU2VydmVyID0gdHJ1ZTtcbiAgY29uc29sZS53YXJuKFwiQ2FsbGVkIGdldFN0YXRpY0ZpbGVzKCkgb24gdGhlIHNlcnZlci4gVGhlIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3Nlci4gQW4gZW1wdHkgYXJyYXkgd2FzIHJldHVybmVkLlwiKTtcbn07XG52YXIgd2FyblBsYXllck9uY2UgPSAoKSA9PiB7XG4gIGlmICh3YXJuZWRQbGF5ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybmVkUGxheWVyID0gdHJ1ZTtcbiAgY29uc29sZS53YXJuKFwiQ2FsbGVkIGdldFN0YXRpY0ZpbGVzKCkgd2hpbGUgdXNpbmcgdGhlIFJlbW90aW9uIFBsYXllci4gVGhlIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSB3aGlsZSB1c2luZyB0aGUgUmVtb3Rpb24gU3R1ZGlvLiBBbiBlbXB0eSBhcnJheSB3YXMgcmV0dXJuZWQuXCIpO1xufTtcbnZhciBnZXRTdGF0aWNGaWxlcyA9ICgpID0+IHtcbiAgaWYgKEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0U3RhdGljRmlsZXMoKSBoYXMgbW92ZWQgaW50byB0aGUgYEByZW1vdGlvbi9zdHVkaW9gIHBhY2thZ2UuIFVwZGF0ZSB5b3VyIGltcG9ydHMuXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3YXJuU2VydmVyT25jZSgpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAod2luZG93LnJlbW90aW9uX2lzUGxheWVyKSB7XG4gICAgd2FyblBsYXllck9uY2UoKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNGaWxlcztcbn07XG4vLyBzcmMvSUZyYW1lLnRzeFxuaW1wb3J0IHsgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNywgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMiwgdXNlU3RhdGUgYXMgdXNlU3RhdGUxNCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDIzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSUZyYW1lUmVmRm9yd2FyZGluZyA9ICh7XG4gIG9uTG9hZCxcbiAgb25FcnJvcixcbiAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgLi4ucHJvcHMyXG59LCByZWYpID0+IHtcbiAgY29uc3QgW2hhbmRsZV0gPSB1c2VTdGF0ZTE0KCgpID0+IGRlbGF5UmVuZGVyKGBMb2FkaW5nIDxJRnJhbWU+IHdpdGggc291cmNlICR7cHJvcHMyLnNyY31gLCB7XG4gICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICB9KSk7XG4gIGNvbnN0IGRpZExvYWQgPSB1c2VDYWxsYmFjazEyKChlKSA9PiB7XG4gICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICBvbkxvYWQ/LihlKTtcbiAgfSwgW2hhbmRsZSwgb25Mb2FkXSk7XG4gIGNvbnN0IGRpZEdldEVycm9yID0gdXNlQ2FsbGJhY2sxMigoZSkgPT4ge1xuICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGlmcmFtZTpcIiwgZSwgXCJIYW5kbGUgdGhlIGV2ZW50IHVzaW5nIHRoZSBvbkVycm9yKCkgcHJvcCB0byBtYWtlIHRoaXMgbWVzc2FnZSBkaXNhcHBlYXIuXCIpO1xuICAgIH1cbiAgfSwgW2hhbmRsZSwgb25FcnJvcl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIzKFwiaWZyYW1lXCIsIHtcbiAgICAuLi5wcm9wczIsXG4gICAgcmVmLFxuICAgIG9uRXJyb3I6IGRpZEdldEVycm9yLFxuICAgIG9uTG9hZDogZGlkTG9hZFxuICB9KTtcbn07XG52YXIgSUZyYW1lID0gZm9yd2FyZFJlZjcoSUZyYW1lUmVmRm9yd2FyZGluZyk7XG4vLyBzcmMvSW1nLnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmOCxcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMyxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjYsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTcsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q2LFxuICB1c2VSZWYgYXMgdXNlUmVmMTNcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MjQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIGV4cG9uZW50aWFsQmFja29mZihlcnJvckNvdW50KSB7XG4gIHJldHVybiAxMDAwICogMiAqKiAoZXJyb3JDb3VudCAtIDEpO1xufVxudmFyIEltZ1JlZkZvcndhcmRpbmcgPSAoe1xuICBvbkVycm9yLFxuICBtYXhSZXRyaWVzID0gMixcbiAgc3JjLFxuICBwYXVzZVdoZW5Mb2FkaW5nLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBvbkltYWdlRnJhbWUsXG4gIC4uLnByb3BzMlxufSwgcmVmKSA9PiB7XG4gIGNvbnN0IGltYWdlUmVmID0gdXNlUmVmMTMobnVsbCk7XG4gIGNvbnN0IGVycm9ycyA9IHVzZVJlZjEzKHt9KTtcbiAgY29uc3QgeyBkZWxheVBsYXliYWNrIH0gPSB1c2VCdWZmZXJTdGF0ZSgpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjYoU2VxdWVuY2VDb250ZXh0KTtcbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwic3JjXCIgcHJvcCB3YXMgcGFzc2VkIHRvIDxJbWc+LicpO1xuICB9XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU3KHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiBpbWFnZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIGNvbnN0IGFjdHVhbFNyYyA9IHVzZVByZWxvYWQoc3JjKTtcbiAgY29uc3QgcmV0cnlJbiA9IHVzZUNhbGxiYWNrMTMoKHRpbWVvdXQpID0+IHtcbiAgICBpZiAoIWltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFNyYyA9IGltYWdlUmVmLmN1cnJlbnQuc3JjO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFpbWFnZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld1NyYyA9IGltYWdlUmVmLmN1cnJlbnQ/LnNyYztcbiAgICAgIGlmIChuZXdTcmMgIT09IGN1cnJlbnRTcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW1hZ2VSZWYuY3VycmVudC5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICBpbWFnZVJlZi5jdXJyZW50LnNldEF0dHJpYnV0ZShcInNyY1wiLCBuZXdTcmMpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9LCBbXSk7XG4gIGNvbnN0IGRpZEdldEVycm9yID0gdXNlQ2FsbGJhY2sxMygoZSkgPT4ge1xuICAgIGlmICghZXJyb3JzLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA9IChlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdID8/IDApICsgMTtcbiAgICBpZiAob25FcnJvciAmJiAoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA+IG1heFJldHJpZXMpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA8PSBtYXhSZXRyaWVzKSB7XG4gICAgICBjb25zdCBiYWNrb2ZmID0gZXhwb25lbnRpYWxCYWNrb2ZmKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCk7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBsb2FkIGltYWdlIHdpdGggc291cmNlICR7aW1hZ2VSZWYuY3VycmVudD8uc3JjfSwgcmV0cnlpbmcgYWdhaW4gaW4gJHtiYWNrb2ZmfW1zYCk7XG4gICAgICByZXRyeUluKGJhY2tvZmYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYW5jZWxSZW5kZXIoXCJFcnJvciBsb2FkaW5nIGltYWdlIHdpdGggc3JjOiBcIiArIGltYWdlUmVmLmN1cnJlbnQ/LnNyYyk7XG4gIH0sIFttYXhSZXRyaWVzLCBvbkVycm9yLCByZXRyeUluXSk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgaXNQcmVtb3VudGluZyA9IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZyk7XG4gICAgdXNlTGF5b3V0RWZmZWN0NigoKSA9PiB7XG4gICAgICBpZiAod2luZG93LnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09IFwidGVzdFwiKSB7XG4gICAgICAgIGlmIChpbWFnZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaW1hZ2VSZWYuY3VycmVudC5zcmMgPSBhY3R1YWxTcmM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSBpbWFnZVJlZjtcbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcihcIkxvYWRpbmcgPEltZz4gd2l0aCBzcmM9XCIgKyBhY3R1YWxTcmMsIHtcbiAgICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdW5ibG9jayA9IHBhdXNlV2hlbkxvYWRpbmcgJiYgIWlzUHJlbW91bnRpbmcgPyBkZWxheVBsYXliYWNrKCkudW5ibG9jayA6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfTtcbiAgICAgIGxldCB1bm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG9uQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh1bm1vdW50ZWQpIHtcbiAgICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCkgPiAwKSB7XG4gICAgICAgICAgZGVsZXRlIGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY107XG4gICAgICAgICAgY29uc29sZS5pbmZvKGBSZXRyeSBzdWNjZXNzZnVsIC0gJHtpbWFnZVJlZi5jdXJyZW50Py5zcmN9IGlzIG5vdyBsb2FkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgIG9uSW1hZ2VGcmFtZT8uKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICAgIH07XG4gICAgICBpZiAoIWltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50LnNyYyA9IGFjdHVhbFNyYztcbiAgICAgIGlmIChjdXJyZW50LmNvbXBsZXRlKSB7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQuZGVjb2RlKCkudGhlbihvbkNvbXBsZXRlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgICAgICAgaWYgKGN1cnJlbnQuY29tcGxldGUpIHtcbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkNvbXBsZXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkNvbXBsZXRlKTtcbiAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICB9LCBbXG4gICAgICBhY3R1YWxTcmMsXG4gICAgICBkZWxheVBsYXliYWNrLFxuICAgICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgICBwYXVzZVdoZW5Mb2FkaW5nLFxuICAgICAgaXNQcmVtb3VudGluZyxcbiAgICAgIG9uSW1hZ2VGcmFtZVxuICAgIF0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjQoXCJpbWdcIiwge1xuICAgIC4uLnByb3BzMixcbiAgICByZWY6IGltYWdlUmVmLFxuICAgIG9uRXJyb3I6IGRpZEdldEVycm9yXG4gIH0pO1xufTtcbnZhciBJbWcgPSBmb3J3YXJkUmVmOChJbWdSZWZGb3J3YXJkaW5nKTtcbi8vIHNyYy9pbnRlcm5hbHMudHNcbmltcG9ydCB7IGNyZWF0ZVJlZiBhcyBjcmVhdGVSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9Db21wb3NpdGlvbk1hbmFnZXIudHN4XG5pbXBvcnQgUmVhY3QyMiwge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazE0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU4LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yMyxcbiAgdXNlUmVmIGFzIHVzZVJlZjE0LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE1XG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgY29tcG9zaXRpb25zUmVmID0gUmVhY3QyMi5jcmVhdGVSZWYoKTtcbnZhciBDb21wb3NpdGlvbk1hbmFnZXJQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgb25seVJlbmRlckNvbXBvc2l0aW9uLFxuICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YVxufSkgPT4ge1xuICBjb25zdCBbY29tcG9zaXRpb25zLCBzZXRDb21wb3NpdGlvbnNdID0gdXNlU3RhdGUxNShbXSk7XG4gIGNvbnN0IGN1cnJlbnRjb21wb3NpdGlvbnNSZWYgPSB1c2VSZWYxNChjb21wb3NpdGlvbnMpO1xuICBjb25zdCBbZm9sZGVycywgc2V0Rm9sZGVyc10gPSB1c2VTdGF0ZTE1KFtdKTtcbiAgY29uc3QgW2NhbnZhc0NvbnRlbnQsIHNldENhbnZhc0NvbnRlbnRdID0gdXNlU3RhdGUxNShudWxsKTtcbiAgY29uc3QgdXBkYXRlQ29tcG9zaXRpb25zID0gdXNlQ2FsbGJhY2sxNCgodXBkYXRlQ29tcHMpID0+IHtcbiAgICBzZXRDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkID0gdXBkYXRlQ29tcHMoY29tcHMpO1xuICAgICAgY3VycmVudGNvbXBvc2l0aW9uc1JlZi5jdXJyZW50ID0gdXBkYXRlZDtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZ2lzdGVyQ29tcG9zaXRpb24gPSB1c2VDYWxsYmFjazE0KChjb21wKSA9PiB7XG4gICAgdXBkYXRlQ29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgaWYgKGNvbXBzLmZpbmQoKGMyKSA9PiBjMi5pZCA9PT0gY29tcC5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBjb21wb3NpdGlvbiB3aXRoIGlkICR7Y29tcC5pZH0gYXJlIHJlZ2lzdGVyZWQuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IFsuLi5jb21wcywgY29tcF0uc2xpY2UoKS5zb3J0KChhMiwgYjIpID0+IGEyLm5vbmNlIC0gYjIubm9uY2UpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9LCBbdXBkYXRlQ29tcG9zaXRpb25zXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJDb21wb3NpdGlvbiA9IHVzZUNhbGxiYWNrMTQoKGlkKSA9PiB7XG4gICAgc2V0Q29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgcmV0dXJuIGNvbXBzLmZpbHRlcigoYzIpID0+IGMyLmlkICE9PSBpZCk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJGb2xkZXIgPSB1c2VDYWxsYmFjazE0KChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4ucHJldkZvbGRlcnMsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBhcmVudFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJGb2xkZXIgPSB1c2VDYWxsYmFjazE0KChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgcmV0dXJuIHByZXZGb2xkZXJzLmZpbHRlcigocCkgPT4gIShwLm5hbWUgPT09IG5hbWUgJiYgcC5wYXJlbnQgPT09IHBhcmVudCkpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU4KGNvbXBvc2l0aW9uc1JlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRDb21wb3NpdGlvbnM6ICgpID0+IGN1cnJlbnRjb21wb3NpdGlvbnNSZWYuY3VycmVudFxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYzIpID0+IGNhbnZhc0NvbnRlbnQ/LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiA/IGMyLmlkID09PSBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgOiBudWxsKTtcbiAgY29uc3QgdXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHMgPSB1c2VDYWxsYmFjazE0KChpZCwgbmV3RGVmYXVsdFByb3BzKSA9PiB7XG4gICAgc2V0Q29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IGNvbXBzLm1hcCgoYzIpID0+IHtcbiAgICAgICAgaWYgKGMyLmlkID09PSBpZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jMixcbiAgICAgICAgICAgIGRlZmF1bHRQcm9wczogbmV3RGVmYXVsdFByb3BzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yMygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvc2l0aW9ucyxcbiAgICAgIGZvbGRlcnMsXG4gICAgICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICAgIGNhbnZhc0NvbnRlbnRcbiAgICB9O1xuICB9LCBbY29tcG9zaXRpb25zLCBmb2xkZXJzLCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgY2FudmFzQ29udGVudF0pO1xuICBjb25zdCBzZXR0ZXJzID0gdXNlTWVtbzIzKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICAgIHJlZ2lzdGVyRm9sZGVyLFxuICAgICAgdW5yZWdpc3RlckZvbGRlcixcbiAgICAgIHNldENhbnZhc0NvbnRlbnQsXG4gICAgICB1cGRhdGVDb21wb3NpdGlvbkRlZmF1bHRQcm9wcyxcbiAgICAgIG9ubHlSZW5kZXJDb21wb3NpdGlvblxuICAgIH07XG4gIH0sIFtcbiAgICByZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIHJlZ2lzdGVyRm9sZGVyLFxuICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICB1bnJlZ2lzdGVyRm9sZGVyLFxuICAgIHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzLFxuICAgIG9ubHlSZW5kZXJDb21wb3NpdGlvblxuICBdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNShDb21wb3NpdGlvbk1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoQ29tcG9zaXRpb25TZXR0ZXJzLlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogc2V0dGVycyxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoU2VxdWVuY2VNYW5hZ2VyUHJvdmlkZXIsIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShSZW5kZXJBc3NldE1hbmFnZXJQcm92aWRlciwge1xuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI1KFNoYXJlZEF1ZGlvQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIG51bWJlck9mQXVkaW9UYWdzLFxuICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvc2l0aW9uPy5jb21wb25lbnQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvZGVmYXVsdC1jc3MudHNcbnZhciBleHBvcnRzX2RlZmF1bHRfY3NzID0ge307XG5fX2V4cG9ydChleHBvcnRzX2RlZmF1bHRfY3NzLCB7XG4gIG1ha2VEZWZhdWx0UHJldmlld0NTUzogKCkgPT4gbWFrZURlZmF1bHRQcmV2aWV3Q1NTLFxuICBpbmplY3RDU1M6ICgpID0+IGluamVjdENTUyxcbiAgT0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUU6ICgpID0+IE9GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FXG59KTtcbnZhciBpbmplY3RlZCA9IHt9O1xudmFyIGluamVjdENTUyA9IChjc3MpID0+IHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5qZWN0ZWRbY3NzXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgaGVhZC5wcmVwZW5kKHN0eWxlKTtcbiAgaW5qZWN0ZWRbY3NzXSA9IHRydWU7XG59O1xudmFyIE9GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FID0gXCJfX3JlbW90aW9uX29mZnRocmVhZHZpZGVvXCI7XG52YXIgbWFrZURlZmF1bHRQcmV2aWV3Q1NTID0gKHNjb3BlLCBiYWNrZ3JvdW5kQ29sb3IpID0+IHtcbiAgaWYgKCFzY29wZSkge1xuICAgIHJldHVybiBgXG4gICAgKiB7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICBib2R5IHtcbiAgICAgIG1hcmdpbjogMDtcblx0ICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yfTtcbiAgICB9XG4gICAgLiR7T0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUV9IHtcbiAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gICAgfVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICAke3Njb3BlfSAqIHtcbiAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuICAgICR7c2NvcGV9ICo6LXdlYmtpdC1mdWxsLXNjcmVlbiB7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG4gICAgJHtzY29wZX0gLiR7T0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUV9IHtcbiAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gICAgfVxuICBgO1xufTtcblxuLy8gc3JjL2dldC1wcmV2aWV3LWRvbS1lbGVtZW50LnRzXG52YXIgUkVNT1RJT05fU1RVRElPX0NPTlRBSU5FUl9FTEVNRU5UID0gXCJfX3JlbW90aW9uLXN0dWRpby1jb250YWluZXJcIjtcbnZhciBnZXRQcmV2aWV3RG9tRWxlbWVudCA9ICgpID0+IHtcbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCk7XG59O1xuXG4vLyBzcmMvcmVnaXN0ZXItcm9vdC50c1xudmFyIFJvb3QgPSBudWxsO1xudmFyIGxpc3RlbmVycyA9IFtdO1xudmFyIHJlZ2lzdGVyUm9vdCA9IChjb21wKSA9PiB7XG4gIGlmICghY29tcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIFJlYWN0IGNvbXBvbmVudCB0byByZWdpc3RlclJvb3QoKSwgYnV0ICR7SlNPTi5zdHJpbmdpZnkoY29tcCl9IHdhcyBwYXNzZWQuYCk7XG4gIH1cbiAgaWYgKFJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWdpc3RlclJvb3QoKSB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlwiKTtcbiAgfVxuICBSb290ID0gY29tcDtcbiAgbGlzdGVuZXJzLmZvckVhY2goKGwpID0+IHtcbiAgICBsKGNvbXApO1xuICB9KTtcbn07XG52YXIgZ2V0Um9vdCA9ICgpID0+IHtcbiAgcmV0dXJuIFJvb3Q7XG59O1xudmFyIHdhaXRGb3JSb290ID0gKGZuKSA9PiB7XG4gIGlmIChSb290KSB7XG4gICAgZm4oUm9vdCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG4gIGxpc3RlbmVycy5wdXNoKGZuKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKChsKSA9PiBsICE9PSBmbik7XG4gIH07XG59O1xuXG4vLyBzcmMvUmVtb3Rpb25Sb290LnRzeFxuaW1wb3J0IHtcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE4LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0NyxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjQsXG4gIHVzZVJlZiBhcyB1c2VSZWYxNSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxNlxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyNiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlbW90aW9uUm9vdCA9ICh7XG4gIGNoaWxkcmVuLFxuICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgbG9nTGV2ZWwsXG4gIG9ubHlSZW5kZXJDb21wb3NpdGlvbixcbiAgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGFcbn0pID0+IHtcbiAgY29uc3QgW3JlbW90aW9uUm9vdElkXSA9IHVzZVN0YXRlMTYoKCkgPT4gU3RyaW5nKHJhbmRvbShudWxsKSkpO1xuICBjb25zdCBbZnJhbWUsIHNldEZyYW1lXSA9IHVzZVN0YXRlMTYoKCkgPT4gZ2V0SW5pdGlhbEZyYW1lU3RhdGUoKSk7XG4gIGNvbnN0IFtwbGF5aW5nLCBzZXRQbGF5aW5nXSA9IHVzZVN0YXRlMTYoZmFsc2UpO1xuICBjb25zdCBpbXBlcmF0aXZlUGxheWluZyA9IHVzZVJlZjE1KGZhbHNlKTtcbiAgY29uc3QgW2Zhc3RSZWZyZXNoZXMsIHNldEZhc3RSZWZyZXNoZXNdID0gdXNlU3RhdGUxNigwKTtcbiAgY29uc3QgW3BsYXliYWNrUmF0ZSwgc2V0UGxheWJhY2tSYXRlXSA9IHVzZVN0YXRlMTYoMSk7XG4gIGNvbnN0IGF1ZGlvQW5kVmlkZW9UYWdzID0gdXNlUmVmMTUoW10pO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHVzZUxheW91dEVmZmVjdDcoKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW90aW9uX3NldEZyYW1lID0gKGYsIGNvbXBvc2l0aW9uLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdGlvbl9hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICAgICAgY29uc3QgaWQgPSBkZWxheVJlbmRlcihgU2V0dGluZyB0aGUgY3VycmVudCBmcmFtZSB0byAke2Z9YCk7XG4gICAgICAgIGxldCBhc3luY1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHNldEZyYW1lKChzKSA9PiB7XG4gICAgICAgICAgY29uc3QgY3VycmVudEZyYW1lID0gc1tjb21wb3NpdGlvbl0gPz8gd2luZG93LnJlbW90aW9uX2luaXRpYWxGcmFtZTtcbiAgICAgICAgICBpZiAoY3VycmVudEZyYW1lID09PSBmKSB7XG4gICAgICAgICAgICBhc3luY1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zLFxuICAgICAgICAgICAgW2NvbXBvc2l0aW9uXTogZlxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXN5bmNVcGRhdGUpIHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gY29udGludWVSZW5kZXIoaWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250aW51ZVJlbmRlcihpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIgPSBmYWxzZTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgY29uc3QgdGltZWxpbmVDb250ZXh0VmFsdWUgPSB1c2VNZW1vMjQoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmcmFtZSxcbiAgICAgIHBsYXlpbmcsXG4gICAgICBpbXBlcmF0aXZlUGxheWluZyxcbiAgICAgIHJvb3RJZDogcmVtb3Rpb25Sb290SWQsXG4gICAgICBwbGF5YmFja1JhdGUsXG4gICAgICBzZXRQbGF5YmFja1JhdGUsXG4gICAgICBhdWRpb0FuZFZpZGVvVGFnc1xuICAgIH07XG4gIH0sIFtmcmFtZSwgcGxheWJhY2tSYXRlLCBwbGF5aW5nLCByZW1vdGlvblJvb3RJZF0pO1xuICBjb25zdCBzZXRUaW1lbGluZUNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEZyYW1lLFxuICAgICAgc2V0UGxheWluZ1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3Qgbm9uY2VDb250ZXh0ID0gdXNlTWVtbzI0KCgpID0+IHtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldE5vbmNlOiAoKSA9PiBjb3VudGVyKyssXG4gICAgICBmYXN0UmVmcmVzaGVzXG4gICAgfTtcbiAgfSwgW2Zhc3RSZWZyZXNoZXNdKTtcbiAgdXNlRWZmZWN0MTgoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgX193ZWJwYWNrX21vZHVsZV9fICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX193ZWJwYWNrX21vZHVsZV9fLmhvdCkge1xuICAgICAgICBfX3dlYnBhY2tfbW9kdWxlX18uaG90LmFkZFN0YXR1c0hhbmRsZXIoKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgICAgICBzZXRGYXN0UmVmcmVzaGVzKChpKSA9PiBpICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgbG9nZ2luZyA9IHVzZU1lbW8yNCgoKSA9PiB7XG4gICAgcmV0dXJuIHsgbG9nTGV2ZWwsIG1vdW50VGltZTogRGF0ZS5ub3coKSB9O1xuICB9LCBbbG9nTGV2ZWxdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNihMb2dMZXZlbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbG9nZ2luZyxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KE5vbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IG5vbmNlQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoVGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB0aW1lbGluZUNvbnRleHRWYWx1ZSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihTZXRUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICB2YWx1ZTogc2V0VGltZWxpbmVDb250ZXh0VmFsdWUsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihFZGl0b3JQcm9wc1Byb3ZpZGVyLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KFByZWZldGNoUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihDb21wb3NpdGlvbk1hbmFnZXJQcm92aWRlciwge1xuICAgICAgICAgICAgICAgIG51bWJlck9mQXVkaW9UYWdzLFxuICAgICAgICAgICAgICAgIG9ubHlSZW5kZXJDb21wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KER1cmF0aW9uc0NvbnRleHRQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihCdWZmZXJpbmdQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9zZXR1cC1lbnYtdmFyaWFibGVzLnRzXG52YXIgZ2V0RW52VmFyaWFibGVzID0gKCkgPT4ge1xuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgY29uc3QgcGFyYW0gPSB3aW5kb3cucmVtb3Rpb25fZW52VmFyaWFibGVzO1xuICAgIGlmICghcGFyYW0pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uSlNPTi5wYXJzZShwYXJhbSksIE5PREVfRU5WOiBcInByb2R1Y3Rpb25cIiB9O1xuICB9XG4gIGlmIChmYWxzZSkge31cbiAgcmV0dXJuIHtcbiAgICBOT0RFX0VOVjogXCJwcm9kdWN0aW9uXCJcbiAgfTtcbn07XG52YXIgc2V0dXBFbnZWYXJpYWJsZXMgPSAoKSA9PiB7XG4gIGNvbnN0IGVudiA9IGdldEVudlZhcmlhYmxlcygpO1xuICBpZiAoIXdpbmRvdy5wcm9jZXNzKSB7XG4gICAgd2luZG93LnByb2Nlc3MgPSB7fTtcbiAgfVxuICBpZiAoIXdpbmRvdy5wcm9jZXNzLmVudikge1xuICAgIHdpbmRvdy5wcm9jZXNzLmVudiA9IHt9O1xuICB9XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgd2luZG93LnByb2Nlc3MuZW52W2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvdXNlLWN1cnJlbnQtc2NhbGUudHNcbmltcG9ydCBSZWFjdDI0LCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE4IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgQ3VycmVudFNjYWxlQ29udGV4dCA9IFJlYWN0MjQuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBQcmV2aWV3U2l6ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTgoe1xuICBzZXRTaXplOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICBzaXplOiB7IHNpemU6IFwiYXV0b1wiLCB0cmFuc2xhdGlvbjogeyB4OiAwLCB5OiAwIH0gfVxufSk7XG52YXIgY2FsY3VsYXRlU2NhbGUgPSAoe1xuICBjYW52YXNTaXplLFxuICBjb21wb3NpdGlvbkhlaWdodCxcbiAgY29tcG9zaXRpb25XaWR0aCxcbiAgcHJldmlld1NpemVcbn0pID0+IHtcbiAgY29uc3QgaGVpZ2h0UmF0aW8gPSBjYW52YXNTaXplLmhlaWdodCAvIGNvbXBvc2l0aW9uSGVpZ2h0O1xuICBjb25zdCB3aWR0aFJhdGlvID0gY2FudmFzU2l6ZS53aWR0aCAvIGNvbXBvc2l0aW9uV2lkdGg7XG4gIGNvbnN0IHJhdGlvID0gTWF0aC5taW4oaGVpZ2h0UmF0aW8sIHdpZHRoUmF0aW8pO1xuICByZXR1cm4gcHJldmlld1NpemUgPT09IFwiYXV0b1wiID8gcmF0aW8gOiBOdW1iZXIocHJldmlld1NpemUpO1xufTtcbnZhciB1c2VDdXJyZW50U2NhbGUgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBoYXNDb250ZXh0ID0gUmVhY3QyNC51c2VDb250ZXh0KEN1cnJlbnRTY2FsZUNvbnRleHQpO1xuICBjb25zdCB6b29tQ29udGV4dCA9IFJlYWN0MjQudXNlQ29udGV4dChQcmV2aWV3U2l6ZUNvbnRleHQpO1xuICBjb25zdCBjb25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICBpZiAoaGFzQ29udGV4dCA9PT0gbnVsbCB8fCBjb25maWcgPT09IG51bGwgfHwgem9vbUNvbnRleHQgPT09IG51bGwpIHtcbiAgICBpZiAob3B0aW9ucz8uZG9udFRocm93SWZPdXRzaWRlT2ZSZW1vdGlvbikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgXCJ1c2VDdXJyZW50U2NhbGUoKSB3YXMgY2FsbGVkIG91dHNpZGUgb2YgYSBSZW1vdGlvbiBjb250ZXh0LlwiLFxuICAgICAgXCJUaGlzIGhvb2sgY2FuIG9ubHkgYmUgY2FsbGVkIGluIGEgY29tcG9uZW50IHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQgYnkgUmVtb3Rpb24uXCIsXG4gICAgICBcIklmIHlvdSB3YW50IHRvIHRoaXMgaG9vayB0byByZXR1cm4gMSBvdXRzaWRlIG9mIFJlbW90aW9uLCBwYXNzIHtkb250VGhyb3dJZk91dHNpZGVPZlJlbW90aW9uOiB0cnVlfSBhcyBhbiBvcHRpb24uXCIsXG4gICAgICBcIklmIHlvdSB0aGluayB5b3UgY2FsbGVkIHRoaXMgaG9vayBpbiBhIFJlbW90aW9uIGNvbXBvbmVudCwgbWFrZSBzdXJlIGFsbCB2ZXJzaW9ucyBvZiBSZW1vdGlvbiBhcmUgYWxpZ25lZC5cIlxuICAgIF0uam9pbihgXG5gKSk7XG4gIH1cbiAgaWYgKGhhc0NvbnRleHQudHlwZSA9PT0gXCJzY2FsZVwiKSB7XG4gICAgcmV0dXJuIGhhc0NvbnRleHQuc2NhbGU7XG4gIH1cbiAgcmV0dXJuIGNhbGN1bGF0ZVNjYWxlKHtcbiAgICBjYW52YXNTaXplOiBoYXNDb250ZXh0LmNhbnZhc1NpemUsXG4gICAgY29tcG9zaXRpb25IZWlnaHQ6IGNvbmZpZy5oZWlnaHQsXG4gICAgY29tcG9zaXRpb25XaWR0aDogY29uZmlnLndpZHRoLFxuICAgIHByZXZpZXdTaXplOiB6b29tQ29udGV4dC5zaXplLnNpemVcbiAgfSk7XG59O1xuXG4vLyBzcmMvd2F0Y2gtc3RhdGljLWZpbGUudHNcbnZhciBXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMgPSBcInJlbW90aW9uX3N0YXRpY0ZpbGVzQ2hhbmdlZFwiO1xudmFyIHdhdGNoU3RhdGljRmlsZSA9IChmaWxlTmFtZSwgY2FsbGJhY2spID0+IHtcbiAgaWYgKEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwid2F0Y2hTdGF0aWNGaWxlKCkgaGFzIG1vdmVkIGludG8gdGhlIGBAcmVtb3Rpb24vc3R1ZGlvYCBwYWNrYWdlLiBVcGRhdGUgeW91ciBpbXBvcnRzLlwiKTtcbiAgfVxuICBpZiAoIWdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1N0dWRpbykge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSB3YXRjaFN0YXRpY0ZpbGUoKSBBUEkgaXMgb25seSBhdmFpbGFibGUgd2hpbGUgdXNpbmcgdGhlIFJlbW90aW9uIFN0dWRpby5cIik7XG4gICAgcmV0dXJuIHsgY2FuY2VsOiAoKSA9PiB7XG4gICAgICByZXR1cm47XG4gICAgfSB9O1xuICB9XG4gIGNvbnN0IHdpdGhvdXRTdGF0aWNCYXNlID0gZmlsZU5hbWUuc3RhcnRzV2l0aCh3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSkgPyBmaWxlTmFtZS5yZXBsYWNlKHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlLCBcIlwiKSA6IGZpbGVOYW1lO1xuICBjb25zdCB3aXRob3V0TGVhZGluZ1NsYXNoID0gd2l0aG91dFN0YXRpY0Jhc2Uuc3RhcnRzV2l0aChcIi9cIikgPyB3aXRob3V0U3RhdGljQmFzZS5zbGljZSgxKSA6IHdpdGhvdXRTdGF0aWNCYXNlO1xuICBsZXQgcHJldkZpbGVEYXRhID0gd2luZG93LnJlbW90aW9uX3N0YXRpY0ZpbGVzLmZpbmQoKGZpbGUpID0+IGZpbGUubmFtZSA9PT0gd2l0aG91dExlYWRpbmdTbGFzaCk7XG4gIGNvbnN0IGNoZWNrRmlsZSA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IHN0YXRpY0ZpbGVzID0gZXZlbnQuZGV0YWlsLmZpbGVzO1xuICAgIGNvbnN0IG5ld0ZpbGVEYXRhID0gc3RhdGljRmlsZXMuZmluZCgoZmlsZSkgPT4gZmlsZS5uYW1lID09PSB3aXRob3V0TGVhZGluZ1NsYXNoKTtcbiAgICBpZiAoIW5ld0ZpbGVEYXRhKSB7XG4gICAgICBpZiAocHJldkZpbGVEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICB9XG4gICAgICBwcmV2RmlsZURhdGEgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcmV2RmlsZURhdGEgPT09IHVuZGVmaW5lZCB8fCBwcmV2RmlsZURhdGEubGFzdE1vZGlmaWVkICE9PSBuZXdGaWxlRGF0YS5sYXN0TW9kaWZpZWQpIHtcbiAgICAgIGNhbGxiYWNrKG5ld0ZpbGVEYXRhKTtcbiAgICAgIHByZXZGaWxlRGF0YSA9IG5ld0ZpbGVEYXRhO1xuICAgIH1cbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTLCBjaGVja0ZpbGUpO1xuICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFdBVENIX1JFTU9USU9OX1NUQVRJQ19GSUxFUywgY2hlY2tGaWxlKTtcbiAgfTtcbiAgcmV0dXJuIHsgY2FuY2VsIH07XG59O1xuXG4vLyBzcmMvd3JhcC1yZW1vdGlvbi1jb250ZXh0LnRzeFxuaW1wb3J0IFJlYWN0MjUsIHsgdXNlTWVtbyBhcyB1c2VNZW1vMjUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyNyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gdXNlUmVtb3Rpb25Db250ZXh0cygpIHtcbiAgY29uc3QgY29tcG9zaXRpb25NYW5hZ2VyQ3R4ID0gUmVhY3QyNS51c2VDb250ZXh0KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHRpbWVsaW5lQ29udGV4dCA9IFJlYWN0MjUudXNlQ29udGV4dChUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzZXRUaW1lbGluZUNvbnRleHQgPSBSZWFjdDI1LnVzZUNvbnRleHQoU2V0VGltZWxpbmVDb250ZXh0KTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gUmVhY3QyNS51c2VDb250ZXh0KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IG5vbmNlQ29udGV4dCA9IFJlYWN0MjUudXNlQ29udGV4dChOb25jZUNvbnRleHQpO1xuICBjb25zdCBjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCA9IFJlYWN0MjUudXNlQ29udGV4dChDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgY29uc3QgcHJlbG9hZENvbnRleHQgPSBSZWFjdDI1LnVzZUNvbnRleHQoUHJlbG9hZENvbnRleHQpO1xuICBjb25zdCByZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0ID0gUmVhY3QyNS51c2VDb250ZXh0KFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQpO1xuICBjb25zdCByZW5kZXJBc3NldE1hbmFnZXJDb250ZXh0ID0gUmVhY3QyNS51c2VDb250ZXh0KFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGNvbnN0IHNlcXVlbmNlTWFuYWdlckNvbnRleHQgPSBSZWFjdDI1LnVzZUNvbnRleHQoU2VxdWVuY2VNYW5hZ2VyKTtcbiAgY29uc3QgYnVmZmVyTWFuYWdlckNvbnRleHQgPSBSZWFjdDI1LnVzZUNvbnRleHQoQnVmZmVyaW5nQ29udGV4dFJlYWN0KTtcbiAgY29uc3QgbG9nTGV2ZWxDb250ZXh0ID0gUmVhY3QyNS51c2VDb250ZXh0KExvZ0xldmVsQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMjUoKCkgPT4gKHtcbiAgICBjb21wb3NpdGlvbk1hbmFnZXJDdHgsXG4gICAgdGltZWxpbmVDb250ZXh0LFxuICAgIHNldFRpbWVsaW5lQ29udGV4dCxcbiAgICBzZXF1ZW5jZUNvbnRleHQsXG4gICAgbm9uY2VDb250ZXh0LFxuICAgIGNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0LFxuICAgIHByZWxvYWRDb250ZXh0LFxuICAgIHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCxcbiAgICBzZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgIGJ1ZmZlck1hbmFnZXJDb250ZXh0LFxuICAgIGxvZ0xldmVsQ29udGV4dFxuICB9KSwgW1xuICAgIGNvbXBvc2l0aW9uTWFuYWdlckN0eCxcbiAgICBub25jZUNvbnRleHQsXG4gICAgc2VxdWVuY2VDb250ZXh0LFxuICAgIHNldFRpbWVsaW5lQ29udGV4dCxcbiAgICB0aW1lbGluZUNvbnRleHQsXG4gICAgY2FuVXNlUmVtb3Rpb25Ib29rc0NvbnRleHQsXG4gICAgcHJlbG9hZENvbnRleHQsXG4gICAgcmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCxcbiAgICByZW5kZXJBc3NldE1hbmFnZXJDb250ZXh0LFxuICAgIHNlcXVlbmNlTWFuYWdlckNvbnRleHQsXG4gICAgYnVmZmVyTWFuYWdlckNvbnRleHQsXG4gICAgbG9nTGV2ZWxDb250ZXh0XG4gIF0pO1xufVxudmFyIFJlbW90aW9uQ29udGV4dFByb3ZpZGVyID0gKHByb3BzMikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBjb250ZXh0cyB9ID0gcHJvcHMyO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI3KExvZ0xldmVsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0cy5sb2dMZXZlbENvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhDYW5Vc2VSZW1vdGlvbkhvb2tzLlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogY29udGV4dHMuY2FuVXNlUmVtb3Rpb25Ib29rc0NvbnRleHQsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI3KE5vbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dHMubm9uY2VDb250ZXh0LFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI3KFByZWxvYWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnByZWxvYWRDb250ZXh0LFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoQ29tcG9zaXRpb25NYW5hZ2VyLlByb3ZpZGVyLCB7XG4gICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuY29tcG9zaXRpb25NYW5hZ2VyQ3R4LFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhTZXF1ZW5jZU1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnNlcXVlbmNlTWFuYWdlckNvbnRleHQsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoUmVuZGVyQXNzZXRNYW5hZ2VyLlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMucmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoVGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy50aW1lbGluZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoU2V0VGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnNldFRpbWVsaW5lQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI3KFNlcXVlbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnNlcXVlbmNlQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoQnVmZmVyaW5nQ29udGV4dFJlYWN0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5idWZmZXJNYW5hZ2VyQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvaW50ZXJuYWxzLnRzXG52YXIgY29tcG9zaXRpb25TZWxlY3RvclJlZiA9IGNyZWF0ZVJlZjMoKTtcbnZhciBJbnRlcm5hbHMgPSB7XG4gIHVzZVVuc2FmZVZpZGVvQ29uZmlnLFxuICBUaW1lbGluZTogZXhwb3J0c190aW1lbGluZV9wb3NpdGlvbl9zdGF0ZSxcbiAgQ29tcG9zaXRpb25NYW5hZ2VyLFxuICBDb21wb3NpdGlvblNldHRlcnMsXG4gIFNlcXVlbmNlTWFuYWdlcixcbiAgU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCxcbiAgUmVtb3Rpb25Sb290LFxuICB1c2VWaWRlbyxcbiAgZ2V0Um9vdCxcbiAgdXNlTWVkaWFWb2x1bWVTdGF0ZSxcbiAgdXNlTWVkaWFNdXRlZFN0YXRlLFxuICB1c2VMYXp5Q29tcG9uZW50LFxuICB0cnV0aHksXG4gIFNlcXVlbmNlQ29udGV4dCxcbiAgdXNlUmVtb3Rpb25Db250ZXh0cyxcbiAgUmVtb3Rpb25Db250ZXh0UHJvdmlkZXIsXG4gIENTU1V0aWxzOiBleHBvcnRzX2RlZmF1bHRfY3NzLFxuICBzZXR1cEVudlZhcmlhYmxlcyxcbiAgTWVkaWFWb2x1bWVDb250ZXh0LFxuICBTZXRNZWRpYVZvbHVtZUNvbnRleHQsXG4gIGdldFJlbW90aW9uRW52aXJvbm1lbnQsXG4gIFNoYXJlZEF1ZGlvQ29udGV4dCxcbiAgU2hhcmVkQXVkaW9Db250ZXh0UHJvdmlkZXIsXG4gIGludmFsaWRDb21wb3NpdGlvbkVycm9yTWVzc2FnZSxcbiAgaXNDb21wb3NpdGlvbklkVmFsaWQsXG4gIGdldFByZXZpZXdEb21FbGVtZW50LFxuICBjb21wb3NpdGlvbnNSZWYsXG4gIHBvcnRhbE5vZGUsXG4gIHdhaXRGb3JSb290LFxuICBDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIsXG4gIENhblVzZVJlbW90aW9uSG9va3MsXG4gIFByZWZldGNoUHJvdmlkZXIsXG4gIER1cmF0aW9uc0NvbnRleHRQcm92aWRlcixcbiAgSXNQbGF5ZXJDb250ZXh0UHJvdmlkZXIsXG4gIHVzZUlzUGxheWVyLFxuICBFZGl0b3JQcm9wc1Byb3ZpZGVyLFxuICBFZGl0b3JQcm9wc0NvbnRleHQsXG4gIHVzZVByZWxvYWQsXG4gIE5vbmNlQ29udGV4dCxcbiAgcmVzb2x2ZVZpZGVvQ29uZmlnLFxuICB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnLFxuICByZXNvbHZlQ29tcG9zaXRpb25zUmVmLFxuICBSZXNvbHZlQ29tcG9zaXRpb25Db25maWcsXG4gIFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCxcbiAgUmVuZGVyQXNzZXRNYW5hZ2VyLFxuICBwZXJzaXN0Q3VycmVudEZyYW1lLFxuICB1c2VUaW1lbGluZVNldEZyYW1lLFxuICBpc0lvc1NhZmFyaSxcbiAgV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTLFxuICBhZGRTZXF1ZW5jZVN0YWNrVHJhY2VzLFxuICB1c2VNZWRpYVN0YXJ0c0F0LFxuICBCdWZmZXJpbmdQcm92aWRlcixcbiAgQnVmZmVyaW5nQ29udGV4dFJlYWN0LFxuICBlbmFibGVTZXF1ZW5jZVN0YWNrVHJhY2VzLFxuICBDdXJyZW50U2NhbGVDb250ZXh0LFxuICBQcmV2aWV3U2l6ZUNvbnRleHQsXG4gIGNhbGN1bGF0ZVNjYWxlLFxuICBlZGl0b3JQcm9wc1Byb3ZpZGVyUmVmLFxuICBQUk9QU19VUERBVEVEX0VYVEVSTkFMTFksXG4gIHZhbGlkYXRlUmVuZGVyQXNzZXQsXG4gIExvZyxcbiAgTG9nTGV2ZWxDb250ZXh0LFxuICB1c2VMb2dMZXZlbCxcbiAgcGxheWJhY2tMb2dnaW5nLFxuICB0aW1lVmFsdWVSZWYsXG4gIGNvbXBvc2l0aW9uU2VsZWN0b3JSZWZcbn07XG4vLyBzcmMvaW50ZXJwb2xhdGUtY29sb3JzLnRzXG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbmZ1bmN0aW9uIGNhbGwoLi4uYXJncykge1xuICByZXR1cm4gXCJcXFxcKFxcXFxzKihcIiArIGFyZ3Muam9pbihcIilcXFxccyosXFxcXHMqKFwiKSArIFwiKVxcXFxzKlxcXFwpXCI7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVycygpIHtcbiAgY29uc3QgY2FjaGVkTWF0Y2hlcnMgPSB7XG4gICAgcmdiOiB1bmRlZmluZWQsXG4gICAgcmdiYTogdW5kZWZpbmVkLFxuICAgIGhzbDogdW5kZWZpbmVkLFxuICAgIGhzbGE6IHVuZGVmaW5lZCxcbiAgICBoZXgzOiB1bmRlZmluZWQsXG4gICAgaGV4NDogdW5kZWZpbmVkLFxuICAgIGhleDU6IHVuZGVmaW5lZCxcbiAgICBoZXg2OiB1bmRlZmluZWQsXG4gICAgaGV4ODogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChjYWNoZWRNYXRjaGVycy5yZ2IgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYiA9IG5ldyBSZWdFeHAoXCJyZ2JcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYmEgPSBuZXcgUmVnRXhwKFwicmdiYVwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oc2wgPSBuZXcgUmVnRXhwKFwiaHNsXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbGEgPSBuZXcgUmVnRXhwKFwiaHNsYVwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDMgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg0ID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4OCA9IC9eIyhbMC05YS1mQS1GXXs4fSkkLztcbiAgfVxuICByZXR1cm4gY2FjaGVkTWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB7XG4gICAgdCArPSAxO1xuICB9XG4gIGlmICh0ID4gMSkge1xuICAgIHQgLT0gMTtcbiAgfVxuICBpZiAodCA8IDEgLyA2KSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gIH1cbiAgaWYgKHQgPCAxIC8gMikge1xuICAgIHJldHVybiBxO1xuICB9XG4gIGlmICh0IDwgMiAvIDMpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xUb1JnYihoLCBzLCBsKSB7XG4gIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICBjb25zdCByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICBjb25zdCBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgY29uc3QgYjIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHIgKiAyNTUpIDw8IDI0IHwgTWF0aC5yb3VuZChnICogMjU1KSA8PCAxNiB8IE1hdGgucm91bmQoYjIgKiAyNTUpIDw8IDg7XG59XG5mdW5jdGlvbiBwYXJzZTI1NShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaW50IDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpbnQgPiAyNTUpIHtcbiAgICByZXR1cm4gMjU1O1xuICB9XG4gIHJldHVybiBpbnQ7XG59XG5mdW5jdGlvbiBwYXJzZTM2MChzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgcmV0dXJuIChpbnQgJSAzNjAgKyAzNjApICUgMzYwIC8gMzYwO1xufVxuZnVuY3Rpb24gcGFyc2UxKHN0cikge1xuICBjb25zdCBudW0gPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICBpZiAobnVtIDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChudW0gPiAxKSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAyNTUpO1xufVxuZnVuY3Rpb24gcGFyc2VQZXJjZW50YWdlKHN0cikge1xuICBjb25zdCBpbnQgPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICBpZiAoaW50IDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpbnQgPiAxMDApIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gaW50IC8gMTAwO1xufVxudmFyIGNvbG9yTmFtZXMgPSB7XG4gIHRyYW5zcGFyZW50OiAwLFxuICBhbGljZWJsdWU6IDQwNDI4NTAzMDMsXG4gIGFudGlxdWV3aGl0ZTogNDIwOTc2MDI1NSxcbiAgYXF1YTogMTY3NzcyMTUsXG4gIGFxdWFtYXJpbmU6IDIxNDc0NzI2MzksXG4gIGF6dXJlOiA0MDQzMzA5MDU1LFxuICBiZWlnZTogNDEyNjUzMDgxNSxcbiAgYmlzcXVlOiA0MjkzMTgyNzE5LFxuICBibGFjazogMjU1LFxuICBibGFuY2hlZGFsbW9uZDogNDI5MzY0Mzc3NSxcbiAgYmx1ZTogNjU1MzUsXG4gIGJsdWV2aW9sZXQ6IDIzMTgxMzE5NjcsXG4gIGJyb3duOiAyNzcxMDA0MTU5LFxuICBidXJseXdvb2Q6IDM3MzY2MzUzOTEsXG4gIGJ1cm50c2llbm5hOiAzOTM0MTUwMTQzLFxuICBjYWRldGJsdWU6IDE2MDQyMzE0MjMsXG4gIGNoYXJ0cmV1c2U6IDIxNDc0MTgzNjcsXG4gIGNob2NvbGF0ZTogMzUzMDEwNDU3NSxcbiAgY29yYWw6IDQyODY1MzM4ODcsXG4gIGNvcm5mbG93ZXJibHVlOiAxNjg3NTQ3MzkxLFxuICBjb3Juc2lsazogNDI5NDQ5OTU4MyxcbiAgY3JpbXNvbjogMzY5MjMxMzg1NSxcbiAgY3lhbjogMTY3NzcyMTUsXG4gIGRhcmtibHVlOiAzNTgzOSxcbiAgZGFya2N5YW46IDkxNDUzNDMsXG4gIGRhcmtnb2xkZW5yb2Q6IDMwOTU3OTI2MzksXG4gIGRhcmtncmF5OiAyODQ2NDY4NjA3LFxuICBkYXJrZ3JlZW46IDY1NTM4NTUsXG4gIGRhcmtncmV5OiAyODQ2NDY4NjA3LFxuICBkYXJra2hha2k6IDMxODI5MTQ1NTksXG4gIGRhcmttYWdlbnRhOiAyMzMyMDY4ODYzLFxuICBkYXJrb2xpdmVncmVlbjogMTQzMzA4Nzk5OSxcbiAgZGFya29yYW5nZTogNDI4NzM2NTM3NSxcbiAgZGFya29yY2hpZDogMjU3MDI0MzMyNyxcbiAgZGFya3JlZDogMjMzMjAzMzI3OSxcbiAgZGFya3NhbG1vbjogMzkxODk1MzIxNSxcbiAgZGFya3NlYWdyZWVuOiAyNDExNDk5NTE5LFxuICBkYXJrc2xhdGVibHVlOiAxMjExOTkzMDg3LFxuICBkYXJrc2xhdGVncmF5OiA3OTM3MjY5NzUsXG4gIGRhcmtzbGF0ZWdyZXk6IDc5MzcyNjk3NSxcbiAgZGFya3R1cnF1b2lzZTogMTM1NTQxNzUsXG4gIGRhcmt2aW9sZXQ6IDI0ODMwODIyMzksXG4gIGRlZXBwaW5rOiA0Mjc5NTM4Njg3LFxuICBkZWVwc2t5Ymx1ZTogMTI1ODI5MTEsXG4gIGRpbWdyYXk6IDE3Njg1MTYwOTUsXG4gIGRpbWdyZXk6IDE3Njg1MTYwOTUsXG4gIGRvZGdlcmJsdWU6IDUxMjgxOTE5OSxcbiAgZmlyZWJyaWNrOiAyOTg4NTgxNjMxLFxuICBmbG9yYWx3aGl0ZTogNDI5NDYzNTc3NSxcbiAgZm9yZXN0Z3JlZW46IDU3OTU0MzgwNyxcbiAgZnVjaHNpYTogNDI3ODI1NTYxNSxcbiAgZ2FpbnNib3JvOiAzNzA1NDYyMDE1LFxuICBnaG9zdHdoaXRlOiA0MTc3MDY4MDMxLFxuICBnb2xkOiA0MjkyMjgwNTc1LFxuICBnb2xkZW5yb2Q6IDM2NjgyNTQ5NzUsXG4gIGdyYXk6IDIxNTU5MDUyNzksXG4gIGdyZWVuOiA4Mzg4ODYzLFxuICBncmVlbnllbGxvdzogMjkxOTE4MjMzNSxcbiAgZ3JleTogMjE1NTkwNTI3OSxcbiAgaG9uZXlkZXc6IDQwNDMzMDUyMTUsXG4gIGhvdHBpbms6IDQyODUxMTc2OTUsXG4gIGluZGlhbnJlZDogMzQ0NTM4MjM5OSxcbiAgaW5kaWdvOiAxMjU4MzI0NzM1LFxuICBpdm9yeTogNDI5NDk2MzQ1NSxcbiAga2hha2k6IDQwNDE2NDEyMTUsXG4gIGxhdmVuZGVyOiAzODczODk3MjE1LFxuICBsYXZlbmRlcmJsdXNoOiA0MjkzOTgxNjk1LFxuICBsYXduZ3JlZW46IDIwOTY4OTAxMTEsXG4gIGxlbW9uY2hpZmZvbjogNDI5NDYyNjgxNSxcbiAgbGlnaHRibHVlOiAyOTE2NjczMjc5LFxuICBsaWdodGNvcmFsOiA0MDM0OTUzNDcxLFxuICBsaWdodGN5YW46IDM3NzQ4NzM1OTksXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiA0MjEwNzQyMDE1LFxuICBsaWdodGdyYXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0Z3JlZW46IDI0MzE1NTM3OTEsXG4gIGxpZ2h0Z3JleTogMzU1Mzg3NDk0MyxcbiAgbGlnaHRwaW5rOiA0MjkwMTY3Mjk1LFxuICBsaWdodHNhbG1vbjogNDI4ODcwNzMyNyxcbiAgbGlnaHRzZWFncmVlbjogNTQ4NTgwMDk1LFxuICBsaWdodHNreWJsdWU6IDIyNzg0ODg4MzEsXG4gIGxpZ2h0c2xhdGVncmF5OiAyMDA1NDQxMDIzLFxuICBsaWdodHNsYXRlZ3JleTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzdGVlbGJsdWU6IDI5NjU2OTIxNTksXG4gIGxpZ2h0eWVsbG93OiA0Mjk0OTU5MzU5LFxuICBsaW1lOiAxNjcxMTkzNSxcbiAgbGltZWdyZWVuOiA4NTIzMDg3MzUsXG4gIGxpbmVuOiA0MjEwMDkxNzc1LFxuICBtYWdlbnRhOiA0Mjc4MjU1NjE1LFxuICBtYXJvb246IDIxNDc0ODM5MDMsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDE3MjQ3NTQ2ODcsXG4gIG1lZGl1bWJsdWU6IDUyNzM1LFxuICBtZWRpdW1vcmNoaWQ6IDMxMjYxODcwMDcsXG4gIG1lZGl1bXB1cnBsZTogMjQ3MzY0NzEwMyxcbiAgbWVkaXVtc2VhZ3JlZW46IDEwMTgzOTMwODcsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMjA3MDQ3NDQ5NSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDE2NDIzNjc5LFxuICBtZWRpdW10dXJxdW9pc2U6IDEyMjE3MDkwNTUsXG4gIG1lZGl1bXZpb2xldHJlZDogMzM0MDA3NjU0MyxcbiAgbWlkbmlnaHRibHVlOiA0MjEwOTc3MjcsXG4gIG1pbnRjcmVhbTogNDEyNzE5Mzg1NSxcbiAgbWlzdHlyb3NlOiA0MjkzMTkwMTQzLFxuICBtb2NjYXNpbjogNDI5MzE3ODg3OSxcbiAgbmF2YWpvd2hpdGU6IDQyOTI3ODM2MTUsXG4gIG5hdnk6IDMzMDIzLFxuICBvbGRsYWNlOiA0MjYwNzUxMTAzLFxuICBvbGl2ZTogMjE1NTg3MjUxMSxcbiAgb2xpdmVkcmFiOiAxODA0NDc3NDM5LFxuICBvcmFuZ2U6IDQyODkwMDM3NzUsXG4gIG9yYW5nZXJlZDogNDI4MjcxMjMxOSxcbiAgb3JjaGlkOiAzNjY0ODI4MTU5LFxuICBwYWxlZ29sZGVucm9kOiA0MDA4MjI1NTM1LFxuICBwYWxlZ3JlZW46IDI1NjY2MjU1MzUsXG4gIHBhbGV0dXJxdW9pc2U6IDI5NTE2NzE1NTEsXG4gIHBhbGV2aW9sZXRyZWQ6IDM2ODE1ODgyMjMsXG4gIHBhcGF5YXdoaXA6IDQyOTM5MDc5NjcsXG4gIHBlYWNocHVmZjogNDI5MjUyNDU0MyxcbiAgcGVydTogMzQ0ODA2MTk1MSxcbiAgcGluazogNDI5MDgyNTIxNSxcbiAgcGx1bTogMzcxODMwNzMyNyxcbiAgcG93ZGVyYmx1ZTogMjk2NzUyOTIxNSxcbiAgcHVycGxlOiAyMTQ3NTE2NjcxLFxuICByZWJlY2NhcHVycGxlOiAxNzE0NjU3NzkxLFxuICByZWQ6IDQyNzgxOTAzMzUsXG4gIHJvc3licm93bjogMzE2MzUyNTExOSxcbiAgcm95YWxibHVlOiAxMDk3NDU4MTc1LFxuICBzYWRkbGVicm93bjogMjMzNjU2MDEyNyxcbiAgc2FsbW9uOiA0MjAyNzIyMDQ3LFxuICBzYW5keWJyb3duOiA0MTA0NDEzNDM5LFxuICBzZWFncmVlbjogNzgwODgzOTY3LFxuICBzZWFzaGVsbDogNDI5NDMwNzU4MyxcbiAgc2llbm5hOiAyNjg5NzQwMjg3LFxuICBzaWx2ZXI6IDMyMzM4NTc3OTEsXG4gIHNreWJsdWU6IDIyNzg0ODQ5OTEsXG4gIHNsYXRlYmx1ZTogMTc4NDMzNTg3MSxcbiAgc2xhdGVncmF5OiAxODg3NDczOTE5LFxuICBzbGF0ZWdyZXk6IDE4ODc0NzM5MTksXG4gIHNub3c6IDQyOTQ2MzgzMzUsXG4gIHNwcmluZ2dyZWVuOiAxNjc0NDQ0NyxcbiAgc3RlZWxibHVlOiAxMTgyOTcxMTM1LFxuICB0YW46IDM1MzUwNDc5MzUsXG4gIHRlYWw6IDg0MjE2MzEsXG4gIHRoaXN0bGU6IDM2MzY0NTE1ODMsXG4gIHRvbWF0bzogNDI4NDY5NjU3NSxcbiAgdHVycXVvaXNlOiAxMDg4NDc1MzkxLFxuICB2aW9sZXQ6IDQwMDE1NTgyNzEsXG4gIHdoZWF0OiA0MTI1MDEyOTkxLFxuICB3aGl0ZTogNDI5NDk2NzI5NSxcbiAgd2hpdGVzbW9rZTogNDEyNjUzNzIxNSxcbiAgeWVsbG93OiA0Mjk0OTAyMDE1LFxuICB5ZWxsb3dncmVlbjogMjU5NzEzOTE5OVxufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG1hdGNoZXJzID0gZ2V0TWF0Y2hlcnMoKTtcbiAgbGV0IG1hdGNoO1xuICBpZiAobWF0Y2hlcnMuaGV4Nikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbG9yTmFtZXNbY29sb3JdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29sb3JOYW1lc1tjb2xvcl07XG4gIH1cbiAgaWYgKG1hdGNoZXJzLnJnYikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IDI1NSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5yZ2JhKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4Mykge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXg4KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4NCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDQuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgbWF0Y2hbNF0gKyBtYXRjaFs0XSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAoaHNsVG9SZ2IocGFyc2UzNjAobWF0Y2hbMV0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pKSB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY29sb3Igc3RyaW5nICR7Y29sb3J9IHByb3ZpZGVkYCk7XG59XG52YXIgb3BhY2l0eSA9IChjMikgPT4ge1xuICByZXR1cm4gKGMyID4+IDI0ICYgMjU1KSAvIDI1NTtcbn07XG52YXIgcmVkID0gKGMyKSA9PiB7XG4gIHJldHVybiBjMiA+PiAxNiAmIDI1NTtcbn07XG52YXIgZ3JlZW4gPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyID4+IDggJiAyNTU7XG59O1xudmFyIGJsdWUgPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyICYgMjU1O1xufTtcbnZhciByZ2JhQ29sb3IgPSAociwgZywgYjIsIGFscGhhKSA9PiB7XG4gIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2IyfSwgJHthbHBoYX0pYDtcbn07XG5mdW5jdGlvbiBwcm9jZXNzQ29sb3IoY29sb3IpIHtcbiAgY29uc3Qgbm9ybWFsaXplZENvbG9yID0gbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICByZXR1cm4gKG5vcm1hbGl6ZWRDb2xvciA8PCAyNCB8IG5vcm1hbGl6ZWRDb2xvciA+Pj4gOCkgPj4+IDA7XG59XG52YXIgaW50ZXJwb2xhdGVDb2xvcnNSR0IgPSAodmFsdWUsIGlucHV0UmFuZ2UsIGNvbG9ycykgPT4ge1xuICBjb25zdCBbciwgZywgYjIsIGEyXSA9IFtyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5XS5tYXAoKGYpID0+IHtcbiAgICBjb25zdCB1bnJvdW5kZWQgPSBpbnRlcnBvbGF0ZSh2YWx1ZSwgaW5wdXRSYW5nZSwgY29sb3JzLm1hcCgoYzIpID0+IGYoYzIpKSwge1xuICAgICAgZXh0cmFwb2xhdGVMZWZ0OiBcImNsYW1wXCIsXG4gICAgICBleHRyYXBvbGF0ZVJpZ2h0OiBcImNsYW1wXCJcbiAgICB9KTtcbiAgICBpZiAoZiA9PT0gb3BhY2l0eSkge1xuICAgICAgcmV0dXJuIE51bWJlcih1bnJvdW5kZWQudG9GaXhlZCgzKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKHVucm91bmRlZCk7XG4gIH0pO1xuICByZXR1cm4gcmdiYUNvbG9yKHIsIGcsIGIyLCBhMik7XG59O1xudmFyIGludGVycG9sYXRlQ29sb3JzID0gKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImlucHV0IGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0cHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXRSYW5nZSAoXCIgKyBpbnB1dFJhbmdlLmxlbmd0aCArIFwiIHZhbHVlcyBwcm92aWRlZCkgYW5kIG91dHB1dFJhbmdlIChcIiArIG91dHB1dFJhbmdlLmxlbmd0aCArIFwiIHZhbHVlcyBwcm92aWRlZCkgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjb25zdCBwcm9jZXNzZWRPdXRwdXRSYW5nZSA9IG91dHB1dFJhbmdlLm1hcCgoYzIpID0+IHByb2Nlc3NDb2xvcihjMikpO1xuICByZXR1cm4gaW50ZXJwb2xhdGVDb2xvcnNSR0IoaW5wdXQsIGlucHV0UmFuZ2UsIHByb2Nlc3NlZE91dHB1dFJhbmdlKTtcbn07XG4vLyBzcmMvdmFsaWRhdGUtZnJhbWUudHNcbnZhciB2YWxpZGF0ZUZyYW1lID0gKHtcbiAgYWxsb3dGbG9hdHMsXG4gIGR1cmF0aW9uSW5GcmFtZXMsXG4gIGZyYW1lXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgZnJhbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBtaXNzaW5nIGZvciBwYXJhbWV0ZXIgXCJmcmFtZVwiYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcmFtZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFyZ3VtZW50IHBhc3NlZCBmb3IgXCJmcmFtZVwiIGlzIG5vdCBhIG51bWJlcjogJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRnJhbWUgJHtmcmFtZX0gaXMgbm90IGZpbml0ZWApO1xuICB9XG4gIGlmIChmcmFtZSAlIDEgIT09IDAgJiYgIWFsbG93RmxvYXRzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEFyZ3VtZW50IGZvciBmcmFtZSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoZnJhbWUgPCAwICYmIGZyYW1lIDwgLWR1cmF0aW9uSW5GcmFtZXMpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IHVzZSBmcmFtZSAke2ZyYW1lfTogRHVyYXRpb24gb2YgY29tcG9zaXRpb24gaXMgJHtkdXJhdGlvbkluRnJhbWVzfSwgdGhlcmVmb3JlIHRoZSBsb3dlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHstZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZnJhbWUgPiBkdXJhdGlvbkluRnJhbWVzIC0gMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGhpZ2hlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHtkdXJhdGlvbkluRnJhbWVzIC0gMX1gKTtcbiAgfVxufTtcblxuLy8gc3JjL3ZpZGVvL29mZnRocmVhZC12aWRlby1zb3VyY2UudHNcbnZhciBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSA9ICh7XG4gIHNyYyxcbiAgdHJhbnNwYXJlbnQsXG4gIGN1cnJlbnRUaW1lLFxuICB0b25lTWFwcGVkXG59KSA9PiB7XG4gIHJldHVybiBgaHR0cDovL2xvY2FsaG9zdDoke3dpbmRvdy5yZW1vdGlvbl9wcm94eVBvcnR9L3Byb3h5P3NyYz0ke2VuY29kZVVSSUNvbXBvbmVudChnZXRBYnNvbHV0ZVNyYyhzcmMpKX0mdGltZT0ke2VuY29kZVVSSUNvbXBvbmVudChjdXJyZW50VGltZSl9JnRyYW5zcGFyZW50PSR7U3RyaW5nKHRyYW5zcGFyZW50KX0mdG9uZU1hcHBlZD0ke1N0cmluZyh0b25lTWFwcGVkKX1gO1xufTtcbi8vIHNyYy9zZXJpZXMvaW5kZXgudHN4XG5pbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmOSwgdXNlTWVtbyBhcyB1c2VNZW1vMjYgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3Nlcmllcy9mbGF0dGVuLWNoaWxkcmVuLnRzeFxuaW1wb3J0IFJlYWN0MjYgZnJvbSBcInJlYWN0XCI7XG52YXIgZmxhdHRlbkNoaWxkcmVuID0gKGNoaWxkcmVuKSA9PiB7XG4gIGNvbnN0IGNoaWxkcmVuQXJyYXkgPSBSZWFjdDI2LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW5BcnJheS5yZWR1Y2UoKGZsYXRDaGlsZHJlbiwgY2hpbGQpID0+IHtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gUmVhY3QyNi5GcmFnbWVudCkge1xuICAgICAgcmV0dXJuIGZsYXRDaGlsZHJlbi5jb25jYXQoZmxhdHRlbkNoaWxkcmVuKGNoaWxkLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIGZsYXRDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gZmxhdENoaWxkcmVuO1xuICB9LCBbXSk7XG59O1xuXG4vLyBzcmMvc2VyaWVzL2lzLWluc2lkZS1zZXJpZXMudHN4XG5pbXBvcnQgUmVhY3QyNywgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxOSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSXNJbnNpZGVTZXJpZXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE5KGZhbHNlKTtcbnZhciBJc0luc2lkZVNlcmllc0NvbnRhaW5lciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOChJc0luc2lkZVNlcmllc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgSXNOb3RJbnNpZGVTZXJpZXNQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOChJc0luc2lkZVNlcmllc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZmFsc2UsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZVJlcXVpcmVUb0JlSW5zaWRlU2VyaWVzID0gKCkgPT4ge1xuICBjb25zdCBpc0luc2lkZVNlcmllcyA9IFJlYWN0MjcudXNlQ29udGV4dChJc0luc2lkZVNlcmllc0NvbnRleHQpO1xuICBpZiAoIWlzSW5zaWRlU2VyaWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBjb21wb25lbnQgbXVzdCBiZSBpbnNpZGUgYSA8U2VyaWVzIC8+IGNvbXBvbmVudC5cIik7XG4gIH1cbn07XG5cbi8vIHNyYy9zZXJpZXMvaW5kZXgudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjkgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBTZXJpZXNTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9ICh7IGNoaWxkcmVuIH0sIF9yZWYpID0+IHtcbiAgdXNlUmVxdWlyZVRvQmVJbnNpZGVTZXJpZXMoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOShJc05vdEluc2lkZVNlcmllc1Byb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIFNlcmllc1NlcXVlbmNlID0gZm9yd2FyZFJlZjkoU2VyaWVzU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xudmFyIFNlcmllcyA9IChwcm9wczIpID0+IHtcbiAgY29uc3QgY2hpbGRyZW5WYWx1ZSA9IHVzZU1lbW8yNigoKSA9PiB7XG4gICAgbGV0IHN0YXJ0RnJhbWUgPSAwO1xuICAgIGNvbnN0IGZsYXR0ZW5lZENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzMi5jaGlsZHJlbik7XG4gICAgcmV0dXJuIENoaWxkcmVuLm1hcChmbGF0dGVuZWRDaGlsZHJlbiwgKGNoaWxkLCBpKSA9PiB7XG4gICAgICBjb25zdCBjYXN0ZWRDaGlsZCA9IGNoaWxkO1xuICAgICAgaWYgKHR5cGVvZiBjYXN0ZWRDaGlsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoY2FzdGVkQ2hpbGQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIDxTZXJpZXMgLz4gY29tcG9uZW50IG9ubHkgYWNjZXB0cyBhIGxpc3Qgb2YgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRzIGFzIGl0cyBjaGlsZHJlbiwgYnV0IHlvdSBwYXNzZWQgYSBzdHJpbmcgXCIke2Nhc3RlZENoaWxkfVwiYCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzdGVkQ2hpbGQudHlwZSAhPT0gU2VyaWVzU2VxdWVuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIDxTZXJpZXMgLz4gY29tcG9uZW50IG9ubHkgYWNjZXB0cyBhIGxpc3Qgb2YgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRzIGFzIGl0cyBjaGlsZHJlbiwgYnV0IGdvdCAke2Nhc3RlZENoaWxkfSBpbnN0ZWFkYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWJ1Z0luZm8gPSBgaW5kZXggPSAke2l9LCBkdXJhdGlvbiA9ICR7Y2FzdGVkQ2hpbGQucHJvcHMuZHVyYXRpb25JbkZyYW1lc31gO1xuICAgICAgaWYgKCFjYXN0ZWRDaGlsZD8ucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudCAoJHtkZWJ1Z0luZm99KSB3YXMgZGV0ZWN0ZWQgdG8gbm90IGhhdmUgYW55IGNoaWxkcmVuLiBEZWxldGUgaXQgdG8gZml4IHRoaXMgZXJyb3IuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkdXJhdGlvbkluRnJhbWVzUHJvcCA9IGNhc3RlZENoaWxkLnByb3BzLmR1cmF0aW9uSW5GcmFtZXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGNoaWxkcmVuOiBfY2hpbGRyZW4sXG4gICAgICAgIGZyb20sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIC4uLnBhc3NlZFByb3BzXG4gICAgICB9ID0gY2FzdGVkQ2hpbGQucHJvcHM7XG4gICAgICBpZiAoaSAhPT0gZmxhdHRlbmVkQ2hpbGRyZW4ubGVuZ3RoIC0gMSB8fCBkdXJhdGlvbkluRnJhbWVzUHJvcCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXNQcm9wLCB7XG4gICAgICAgICAgY29tcG9uZW50OiBgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudGAsXG4gICAgICAgICAgYWxsb3dGbG9hdHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXQgPSBjYXN0ZWRDaGlsZC5wcm9wcy5vZmZzZXQgPz8gMDtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJvZmZzZXRcIiBwcm9wZXJ0eSBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gbXVzdCBub3QgYmUgTmFOLCBidXQgZ290IE5hTiAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwib2Zmc2V0XCIgcHJvcGVydHkgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7b2Zmc2V0fSAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIm9mZnNldFwiIHByb3BlcnR5IG9mIGEgPFNlcmllcy5TZXF1ZW5jZSAvPiBtdXN0IGJlIGZpbml0ZSwgYnV0IGdvdCAke29mZnNldH0gKCR7ZGVidWdJbmZvfSkuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50U3RhcnRGcmFtZSA9IHN0YXJ0RnJhbWUgKyBvZmZzZXQ7XG4gICAgICBzdGFydEZyYW1lICs9IGR1cmF0aW9uSW5GcmFtZXNQcm9wICsgb2Zmc2V0O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOShTZXF1ZW5jZSwge1xuICAgICAgICBuYW1lOiBuYW1lIHx8IFwiPFNlcmllcy5TZXF1ZW5jZT5cIixcbiAgICAgICAgZnJvbTogY3VycmVudFN0YXJ0RnJhbWUsXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGR1cmF0aW9uSW5GcmFtZXNQcm9wLFxuICAgICAgICAuLi5wYXNzZWRQcm9wcyxcbiAgICAgICAgcmVmOiBjYXN0ZWRDaGlsZC5yZWYsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtwcm9wczIuY2hpbGRyZW5dKTtcbiAgaWYgKEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOShJc0luc2lkZVNlcmllc0NvbnRhaW5lciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOShTZXF1ZW5jZSwge1xuICAgICAgICAuLi5wcm9wczIsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblZhbHVlXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjkoSXNJbnNpZGVTZXJpZXNDb250YWluZXIsIHtcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5WYWx1ZVxuICB9KTtcbn07XG5TZXJpZXMuU2VxdWVuY2UgPSBTZXJpZXNTZXF1ZW5jZTtcbmFkZFNlcXVlbmNlU3RhY2tUcmFjZXMoU2VyaWVzU2VxdWVuY2UpO1xuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGlvbi1zcHJpbmctZHVyYXRpb24udHNcbnZhciB2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uID0gKGR1cikgPT4ge1xuICBpZiAodHlwZW9mIGR1ciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGR1ciAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIG11c3QgYmUgYSBcIm51bWJlclwiIGJ1dCBpcyBcIiR7dHlwZW9mIGR1cn1cImApO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZHVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIGlzIE5hTiwgd2hpY2ggaXQgbXVzdCBub3QgYmUnKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBcImR1cmF0aW9uXCIgb2YgYSBzcHJpbmcgbXVzdCBiZSBmaW5pdGUsIGJ1dCBpcyAnICsgZHVyKTtcbiAgfVxuICBpZiAoZHVyIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIFwiZHVyYXRpb25cIiBvZiBhIHNwcmluZyBtdXN0IGJlIHBvc2l0aXZlLCBidXQgaXMgJyArIGR1cik7XG4gIH1cbn07XG5cbi8vIHNyYy9zcHJpbmcvc3ByaW5nLXV0aWxzLnRzXG52YXIgZGVmYXVsdFNwcmluZ0NvbmZpZyA9IHtcbiAgZGFtcGluZzogMTAsXG4gIG1hc3M6IDEsXG4gIHN0aWZmbmVzczogMTAwLFxuICBvdmVyc2hvb3RDbGFtcGluZzogZmFsc2Vcbn07XG52YXIgYWR2YW5jZUNhY2hlID0ge307XG5mdW5jdGlvbiBhZHZhbmNlKHtcbiAgYW5pbWF0aW9uLFxuICBub3csXG4gIGNvbmZpZ1xufSkge1xuICBjb25zdCB7IHRvVmFsdWUsIGxhc3RUaW1lc3RhbXAsIGN1cnJlbnQsIHZlbG9jaXR5IH0gPSBhbmltYXRpb247XG4gIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKG5vdyAtIGxhc3RUaW1lc3RhbXAsIDY0KTtcbiAgaWYgKGNvbmZpZy5kYW1waW5nIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcHJpbmcgZGFtcGluZyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLCBvdGhlcndpc2UgdGhlIHNwcmluZygpIGFuaW1hdGlvbiB3aWxsIG5ldmVyIGVuZCwgY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wLlwiKTtcbiAgfVxuICBjb25zdCBjMiA9IGNvbmZpZy5kYW1waW5nO1xuICBjb25zdCBtID0gY29uZmlnLm1hc3M7XG4gIGNvbnN0IGsgPSBjb25maWcuc3RpZmZuZXNzO1xuICBjb25zdCBjYWNoZUtleSA9IFtcbiAgICB0b1ZhbHVlLFxuICAgIGxhc3RUaW1lc3RhbXAsXG4gICAgY3VycmVudCxcbiAgICB2ZWxvY2l0eSxcbiAgICBjMixcbiAgICBtLFxuICAgIGssXG4gICAgbm93XG4gIF0uam9pbihcIi1cIik7XG4gIGlmIChhZHZhbmNlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuIGFkdmFuY2VDYWNoZVtjYWNoZUtleV07XG4gIH1cbiAgY29uc3QgdjAgPSAtdmVsb2NpdHk7XG4gIGNvbnN0IHgwID0gdG9WYWx1ZSAtIGN1cnJlbnQ7XG4gIGNvbnN0IHpldGEgPSBjMiAvICgyICogTWF0aC5zcXJ0KGsgKiBtKSk7XG4gIGNvbnN0IG9tZWdhMCA9IE1hdGguc3FydChrIC8gbSk7XG4gIGNvbnN0IG9tZWdhMSA9IG9tZWdhMCAqIE1hdGguc3FydCgxIC0gemV0YSAqKiAyKTtcbiAgY29uc3QgdCA9IGRlbHRhVGltZSAvIDEwMDA7XG4gIGNvbnN0IHNpbjEgPSBNYXRoLnNpbihvbWVnYTEgKiB0KTtcbiAgY29uc3QgY29zMSA9IE1hdGguY29zKG9tZWdhMSAqIHQpO1xuICBjb25zdCB1bmRlckRhbXBlZEVudmVsb3BlID0gTWF0aC5leHAoLXpldGEgKiBvbWVnYTAgKiB0KTtcbiAgY29uc3QgdW5kZXJEYW1wZWRGcmFnMSA9IHVuZGVyRGFtcGVkRW52ZWxvcGUgKiAoc2luMSAqICgodjAgKyB6ZXRhICogb21lZ2EwICogeDApIC8gb21lZ2ExKSArIHgwICogY29zMSk7XG4gIGNvbnN0IHVuZGVyRGFtcGVkUG9zaXRpb24gPSB0b1ZhbHVlIC0gdW5kZXJEYW1wZWRGcmFnMTtcbiAgY29uc3QgdW5kZXJEYW1wZWRWZWxvY2l0eSA9IHpldGEgKiBvbWVnYTAgKiB1bmRlckRhbXBlZEZyYWcxIC0gdW5kZXJEYW1wZWRFbnZlbG9wZSAqIChjb3MxICogKHYwICsgemV0YSAqIG9tZWdhMCAqIHgwKSAtIG9tZWdhMSAqIHgwICogc2luMSk7XG4gIGNvbnN0IGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSA9IE1hdGguZXhwKC1vbWVnYTAgKiB0KTtcbiAgY29uc3QgY3JpdGljYWxseURhbXBlZFBvc2l0aW9uID0gdG9WYWx1ZSAtIGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSAqICh4MCArICh2MCArIG9tZWdhMCAqIHgwKSAqIHQpO1xuICBjb25zdCBjcml0aWNhbGx5RGFtcGVkVmVsb2NpdHkgPSBjcml0aWNhbGx5RGFtcGVkRW52ZWxvcGUgKiAodjAgKiAodCAqIG9tZWdhMCAtIDEpICsgdCAqIHgwICogb21lZ2EwICogb21lZ2EwKTtcbiAgY29uc3QgYW5pbWF0aW9uTm9kZSA9IHtcbiAgICB0b1ZhbHVlLFxuICAgIHByZXZQb3NpdGlvbjogY3VycmVudCxcbiAgICBsYXN0VGltZXN0YW1wOiBub3csXG4gICAgY3VycmVudDogemV0YSA8IDEgPyB1bmRlckRhbXBlZFBvc2l0aW9uIDogY3JpdGljYWxseURhbXBlZFBvc2l0aW9uLFxuICAgIHZlbG9jaXR5OiB6ZXRhIDwgMSA/IHVuZGVyRGFtcGVkVmVsb2NpdHkgOiBjcml0aWNhbGx5RGFtcGVkVmVsb2NpdHlcbiAgfTtcbiAgYWR2YW5jZUNhY2hlW2NhY2hlS2V5XSA9IGFuaW1hdGlvbk5vZGU7XG4gIHJldHVybiBhbmltYXRpb25Ob2RlO1xufVxudmFyIGNhbGN1bGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIHNwcmluZ0NhbGN1bGF0aW9uKHtcbiAgZnJhbWUsXG4gIGZwcyxcbiAgY29uZmlnID0ge31cbn0pIHtcbiAgY29uc3QgZnJvbSA9IDA7XG4gIGNvbnN0IHRvID0gMTtcbiAgY29uc3QgY2FjaGVLZXkgPSBbXG4gICAgZnJhbWUsXG4gICAgZnBzLFxuICAgIGNvbmZpZy5kYW1waW5nLFxuICAgIGNvbmZpZy5tYXNzLFxuICAgIGNvbmZpZy5vdmVyc2hvb3RDbGFtcGluZyxcbiAgICBjb25maWcuc3RpZmZuZXNzXG4gIF0uam9pbihcIi1cIik7XG4gIGlmIChjYWxjdWxhdGlvbkNhY2hlW2NhY2hlS2V5XSkge1xuICAgIHJldHVybiBjYWxjdWxhdGlvbkNhY2hlW2NhY2hlS2V5XTtcbiAgfVxuICBsZXQgYW5pbWF0aW9uID0ge1xuICAgIGxhc3RUaW1lc3RhbXA6IDAsXG4gICAgY3VycmVudDogZnJvbSxcbiAgICB0b1ZhbHVlOiB0byxcbiAgICB2ZWxvY2l0eTogMCxcbiAgICBwcmV2UG9zaXRpb246IDBcbiAgfTtcbiAgY29uc3QgZnJhbWVDbGFtcGVkID0gTWF0aC5tYXgoMCwgZnJhbWUpO1xuICBjb25zdCB1bmV2ZW5SZXN0ID0gZnJhbWVDbGFtcGVkICUgMTtcbiAgZm9yIChsZXQgZiA9IDA7ZiA8PSBNYXRoLmZsb29yKGZyYW1lQ2xhbXBlZCk7IGYrKykge1xuICAgIGlmIChmID09PSBNYXRoLmZsb29yKGZyYW1lQ2xhbXBlZCkpIHtcbiAgICAgIGYgKz0gdW5ldmVuUmVzdDtcbiAgICB9XG4gICAgY29uc3QgdGltZSA9IGYgLyBmcHMgKiAxMDAwO1xuICAgIGFuaW1hdGlvbiA9IGFkdmFuY2Uoe1xuICAgICAgYW5pbWF0aW9uLFxuICAgICAgbm93OiB0aW1lLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIC4uLmRlZmF1bHRTcHJpbmdDb25maWcsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldID0gYW5pbWF0aW9uO1xuICByZXR1cm4gYW5pbWF0aW9uO1xufVxuXG4vLyBzcmMvc3ByaW5nL21lYXN1cmUtc3ByaW5nLnRzXG52YXIgY2FjaGUgPSBuZXcgTWFwO1xuZnVuY3Rpb24gbWVhc3VyZVNwcmluZyh7XG4gIGZwcyxcbiAgY29uZmlnID0ge30sXG4gIHRocmVzaG9sZCA9IDAuMDA1XG59KSB7XG4gIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdGhyZXNob2xkIG11c3QgYmUgYSBudW1iZXIsIGdvdCAke3RocmVzaG9sZH0gb2YgdHlwZSAke3R5cGVvZiB0aHJlc2hvbGR9YCk7XG4gIH1cbiAgaWYgKHRocmVzaG9sZCA9PT0gMCkge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuICBpZiAodGhyZXNob2xkID09PSAxKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGlzTmFOKHRocmVzaG9sZCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhyZXNob2xkIGlzIE5hTlwiKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aHJlc2hvbGQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRocmVzaG9sZCBpcyBub3QgZmluaXRlXCIpO1xuICB9XG4gIGlmICh0aHJlc2hvbGQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRocmVzaG9sZCBpcyBiZWxvdyAwXCIpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gW1xuICAgIGZwcyxcbiAgICBjb25maWcuZGFtcGluZyxcbiAgICBjb25maWcubWFzcyxcbiAgICBjb25maWcub3ZlcnNob290Q2xhbXBpbmcsXG4gICAgY29uZmlnLnN0aWZmbmVzcyxcbiAgICB0aHJlc2hvbGRcbiAgXS5qb2luKFwiLVwiKTtcbiAgaWYgKGNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICB2YWxpZGF0ZUZwcyhmcHMsIFwidG8gdGhlIG1lYXN1cmVTcHJpbmcoKSBmdW5jdGlvblwiLCBmYWxzZSk7XG4gIGxldCBmcmFtZSA9IDA7XG4gIGxldCBmaW5pc2hlZEZyYW1lID0gMDtcbiAgY29uc3QgY2FsYyA9ICgpID0+IHtcbiAgICByZXR1cm4gc3ByaW5nQ2FsY3VsYXRpb24oe1xuICAgICAgZnBzLFxuICAgICAgZnJhbWUsXG4gICAgICBjb25maWdcbiAgICB9KTtcbiAgfTtcbiAgbGV0IGFuaW1hdGlvbiA9IGNhbGMoKTtcbiAgY29uc3QgY2FsY0RpZmZlcmVuY2UgPSAoKSA9PiB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGFuaW1hdGlvbi5jdXJyZW50IC0gYW5pbWF0aW9uLnRvVmFsdWUpO1xuICB9O1xuICBsZXQgZGlmZmVyZW5jZSA9IGNhbGNEaWZmZXJlbmNlKCk7XG4gIHdoaWxlIChkaWZmZXJlbmNlID49IHRocmVzaG9sZCkge1xuICAgIGZyYW1lKys7XG4gICAgYW5pbWF0aW9uID0gY2FsYygpO1xuICAgIGRpZmZlcmVuY2UgPSBjYWxjRGlmZmVyZW5jZSgpO1xuICB9XG4gIGZpbmlzaGVkRnJhbWUgPSBmcmFtZTtcbiAgZm9yIChsZXQgaSA9IDA7aSA8IDIwOyBpKyspIHtcbiAgICBmcmFtZSsrO1xuICAgIGFuaW1hdGlvbiA9IGNhbGMoKTtcbiAgICBkaWZmZXJlbmNlID0gY2FsY0RpZmZlcmVuY2UoKTtcbiAgICBpZiAoZGlmZmVyZW5jZSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIGkgPSAwO1xuICAgICAgZmluaXNoZWRGcmFtZSA9IGZyYW1lICsgMTtcbiAgICB9XG4gIH1cbiAgY2FjaGUuc2V0KGNhY2hlS2V5LCBmaW5pc2hlZEZyYW1lKTtcbiAgcmV0dXJuIGZpbmlzaGVkRnJhbWU7XG59XG5cbi8vIHNyYy9zcHJpbmcvaW5kZXgudHNcbmZ1bmN0aW9uIHNwcmluZyh7XG4gIGZyYW1lOiBwYXNzZWRGcmFtZSxcbiAgZnBzLFxuICBjb25maWcgPSB7fSxcbiAgZnJvbSA9IDAsXG4gIHRvID0gMSxcbiAgZHVyYXRpb25JbkZyYW1lczogcGFzc2VkRHVyYXRpb25JbkZyYW1lcyxcbiAgZHVyYXRpb25SZXN0VGhyZXNob2xkLFxuICBkZWxheSA9IDAsXG4gIHJldmVyc2UgPSBmYWxzZVxufSkge1xuICB2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMpO1xuICB2YWxpZGF0ZUZyYW1lKHtcbiAgICBmcmFtZTogcGFzc2VkRnJhbWUsXG4gICAgZHVyYXRpb25JbkZyYW1lczogSW5maW5pdHksXG4gICAgYWxsb3dGbG9hdHM6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlRnBzKGZwcywgXCJ0byBzcHJpbmcoKVwiLCBmYWxzZSk7XG4gIGNvbnN0IG5lZWRzVG9DYWxjdWxhdGVOYXR1cmFsRHVyYXRpb24gPSByZXZlcnNlIHx8IHR5cGVvZiBwYXNzZWREdXJhdGlvbkluRnJhbWVzICE9PSBcInVuZGVmaW5lZFwiO1xuICBjb25zdCBuYXR1cmFsRHVyYXRpb24gPSBuZWVkc1RvQ2FsY3VsYXRlTmF0dXJhbER1cmF0aW9uID8gbWVhc3VyZVNwcmluZyh7XG4gICAgZnBzLFxuICAgIGNvbmZpZyxcbiAgICB0aHJlc2hvbGQ6IGR1cmF0aW9uUmVzdFRocmVzaG9sZFxuICB9KSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbmF0dXJhbER1cmF0aW9uR2V0dGVyID0gbmVlZHNUb0NhbGN1bGF0ZU5hdHVyYWxEdXJhdGlvbiA/IHtcbiAgICBnZXQ6ICgpID0+IG5hdHVyYWxEdXJhdGlvblxuICB9IDoge1xuICAgIGdldDogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlkIG5vdCBjYWxjdWxhdGUgbmF0dXJhbCBkdXJhdGlvbiwgdGhpcyBpcyBhbiBlcnJvciB3aXRoIFJlbW90aW9uLiBQbGVhc2UgcmVwb3J0XCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmV2ZXJzZVByb2Nlc3NlZCA9IHJldmVyc2UgPyAocGFzc2VkRHVyYXRpb25JbkZyYW1lcyA/PyBuYXR1cmFsRHVyYXRpb25HZXR0ZXIuZ2V0KCkpIC0gcGFzc2VkRnJhbWUgOiBwYXNzZWRGcmFtZTtcbiAgY29uc3QgZGVsYXlQcm9jZXNzZWQgPSByZXZlcnNlUHJvY2Vzc2VkICsgKHJldmVyc2UgPyBkZWxheSA6IC1kZWxheSk7XG4gIGNvbnN0IGR1cmF0aW9uUHJvY2Vzc2VkID0gcGFzc2VkRHVyYXRpb25JbkZyYW1lcyA9PT0gdW5kZWZpbmVkID8gZGVsYXlQcm9jZXNzZWQgOiBkZWxheVByb2Nlc3NlZCAvIChwYXNzZWREdXJhdGlvbkluRnJhbWVzIC8gbmF0dXJhbER1cmF0aW9uR2V0dGVyLmdldCgpKTtcbiAgaWYgKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMgJiYgZGVsYXlQcm9jZXNzZWQgPiBwYXNzZWREdXJhdGlvbkluRnJhbWVzKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG4gIGNvbnN0IHNwciA9IHNwcmluZ0NhbGN1bGF0aW9uKHtcbiAgICBmcHMsXG4gICAgZnJhbWU6IGR1cmF0aW9uUHJvY2Vzc2VkLFxuICAgIGNvbmZpZ1xuICB9KTtcbiAgY29uc3QgaW5uZXIgPSBjb25maWcub3ZlcnNob290Q2xhbXBpbmcgPyB0byA+PSBmcm9tID8gTWF0aC5taW4oc3ByLmN1cnJlbnQsIHRvKSA6IE1hdGgubWF4KHNwci5jdXJyZW50LCB0bykgOiBzcHIuY3VycmVudDtcbiAgY29uc3QgaW50ZXJwb2xhdGVkID0gZnJvbSA9PT0gMCAmJiB0byA9PT0gMSA/IGlubmVyIDogaW50ZXJwb2xhdGUoaW5uZXIsIFswLCAxXSwgW2Zyb20sIHRvXSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZWQ7XG59XG4vLyBzcmMvc3RhdGljLWZpbGUudHNcbnZhciBwcm9ibGVtYXRpY0NoYXJhY3RlcnMgPSB7XG4gIFwiJTNBXCI6IFwiOlwiLFxuICBcIiUyRlwiOiBcIi9cIixcbiAgXCIlM0ZcIjogXCI/XCIsXG4gIFwiJTIzXCI6IFwiI1wiLFxuICBcIiU1QlwiOiBcIltcIixcbiAgXCIlNURcIjogXCJdXCIsXG4gIFwiJTQwXCI6IFwiQFwiLFxuICBcIiUyMVwiOiBcIiFcIixcbiAgXCIlMjRcIjogXCIkXCIsXG4gIFwiJTI2XCI6IFwiJlwiLFxuICBcIiUyN1wiOiBcIidcIixcbiAgXCIlMjhcIjogXCIoXCIsXG4gIFwiJTI5XCI6IFwiKVwiLFxuICBcIiUyQVwiOiBcIipcIixcbiAgXCIlMkJcIjogXCIrXCIsXG4gIFwiJTJDXCI6IFwiLFwiLFxuICBcIiUzQlwiOiBcIjtcIlxufTtcbnZhciBkaWRXYXJuMiA9IHt9O1xudmFyIHdhcm5PbmNlMyA9IChtZXNzYWdlKSA9PiB7XG4gIGlmIChkaWRXYXJuMlttZXNzYWdlXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIGRpZFdhcm4yW21lc3NhZ2VdID0gdHJ1ZTtcbn07XG52YXIgaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIgPSAocGF0aCkgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwcm9ibGVtYXRpY0NoYXJhY3RlcnMpKSB7XG4gICAgaWYgKHBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHsgY29udGFpbnNIZXg6IHRydWUsIGhleENvZGU6IGtleSB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBjb250YWluc0hleDogZmFsc2UgfTtcbn07XG52YXIgdHJpbUxlYWRpbmdTbGFzaCA9IChwYXRoKSA9PiB7XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIHRyaW1MZWFkaW5nU2xhc2gocGF0aC5zdWJzdHJpbmcoMSkpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufTtcbnZhciBpbm5lciA9IChwYXRoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCh3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHZhbHVlIFwiJHtwYXRofVwiIGlzIGFscmVhZHkgcHJlZml4ZWQgd2l0aCB0aGUgc3RhdGljIGJhc2UgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0uIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgc3RhdGljRmlsZSgpIG9uIGl0LmApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7d2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2V9LyR7dHJpbUxlYWRpbmdTbGFzaChwYXRoKX1gO1xuICB9XG4gIHJldHVybiBgLyR7dHJpbUxlYWRpbmdTbGFzaChwYXRoKX1gO1xufTtcbnZhciBlbmNvZGVCeVNwbGl0dGluZyA9IChwYXRoKSA9PiB7XG4gIGNvbnN0IHNwbGl0QnlTbGFzaCA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBjb25zdCBlbmNvZGVkQXJyYXkgPSBzcGxpdEJ5U2xhc2gubWFwKChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlbGVtZW50KTtcbiAgfSk7XG4gIGNvbnN0IG1lcmdlZCA9IGVuY29kZWRBcnJheS5qb2luKFwiL1wiKTtcbiAgcmV0dXJuIG1lcmdlZDtcbn07XG52YXIgc3RhdGljRmlsZSA9IChwYXRoKSA9PiB7XG4gIGlmIChwYXRoID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm51bGwgd2FzIHBhc3NlZCB0byBzdGF0aWNGaWxlKClcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVuZGVmaW5lZCB3YXMgcGFzc2VkIHRvIHN0YXRpY0ZpbGUoKVwiKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXRpY0ZpbGUoKSBkb2VzIG5vdCBzdXBwb3J0IHJlbW90ZSBVUkxzIC0gZ290IFwiJHtwYXRofVwiLiBJbnN0ZWFkLCBwYXNzIHRoZSBVUkwgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBzdGF0aWNGaWxlKCkuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbW90ZS11cmxzYCk7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi4uXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgcmVsYXRpdmUgcGF0aHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIG5hbWUgb2YgYSBmaWxlIHRoYXQgaXMgaW5zaWRlIHRoZSBwdWJsaWMvIGZvbGRlci4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVsYXRpdmUtcGF0aHNgKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1VzZXJzXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi9ob21lXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi90bXBcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL2V0Y1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvb3B0XCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi92YXJcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiQzpcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiRDpcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiRTpcIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGF0aWNGaWxlKCkgZG9lcyBub3Qgc3VwcG9ydCBhYnNvbHV0ZSBwYXRocyAtIGdvdCBcIiR7cGF0aH1cIi4gSW5zdGVhZCwgcGFzcyB0aGUgbmFtZSBvZiBhIGZpbGUgdGhhdCBpcyBpbnNpZGUgdGhlIHB1YmxpYy8gZm9sZGVyLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCJwdWJsaWMvXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRG8gbm90IGluY2x1ZGUgdGhlIHB1YmxpYy8gcHJlZml4IHdoZW4gdXNpbmcgc3RhdGljRmlsZSgpIC0gZ290IFwiJHtwYXRofVwiLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGNvbnN0IGluY2x1ZGVzSGV4ID0gaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIocGF0aCk7XG4gIGlmIChpbmNsdWRlc0hleC5jb250YWluc0hleCkge1xuICAgIHdhcm5PbmNlMyhgV0FSTklORzogWW91IHNlZW0gdG8gcGFzcyBhbiBhbHJlYWR5IGVuY29kZWQgcGF0aCAocGF0aCBjb250YWlucyAke2luY2x1ZGVzSGV4LmhleENvZGV9KS4gU2luY2UgUmVtb3Rpb24gNC4wLCB0aGUgZW5jb2RpbmcgaXMgZG9uZSBieSBzdGF0aWNGaWxlKCkgaXRzZWxmLiBZb3UgbWF5IHdhbnQgdG8gcmVtb3ZlIGEgZW5jb2RlVVJJQ29tcG9uZW50KCkgd3JhcHBpbmcuYCk7XG4gIH1cbiAgY29uc3QgcHJlcHJvY2Vzc2VkID0gZW5jb2RlQnlTcGxpdHRpbmcocGF0aCk7XG4gIGNvbnN0IHByZXBhcnNlZCA9IGlubmVyKHByZXByb2Nlc3NlZCk7XG4gIGlmICghcHJlcGFyc2VkLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGAvJHtwcmVwYXJzZWR9YDtcbiAgfVxuICByZXR1cm4gcHJlcGFyc2VkO1xufTtcbi8vIHNyYy9TdGlsbC50c3hcbmltcG9ydCBSZWFjdDI5IGZyb20gXCJyZWFjdFwiO1xudmFyIFN0aWxsID0gKHByb3BzMikgPT4ge1xuICBjb25zdCBuZXdQcm9wcyA9IHtcbiAgICAuLi5wcm9wczIsXG4gICAgZHVyYXRpb25JbkZyYW1lczogMSxcbiAgICBmcHM6IDFcbiAgfTtcbiAgcmV0dXJuIFJlYWN0MjkuY3JlYXRlRWxlbWVudChDb21wb3NpdGlvbiwgbmV3UHJvcHMpO1xufTtcbi8vIHNyYy92aWRlby9PZmZ0aHJlYWRWaWRlby50c3hcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTYgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZpZGVvL09mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHtcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxNSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjcsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxOSxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDgsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzI3LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE3XG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDMwIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgT2ZmdGhyZWFkVmlkZW9Gb3JSZW5kZXJpbmcgPSAoe1xuICBvbkVycm9yLFxuICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3JjLFxuICBtdXRlZCxcbiAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICB0cmFuc3BhcmVudCA9IGZhbHNlLFxuICB0b25lTWFwcGVkID0gdHJ1ZSxcbiAgdG9uZUZyZXF1ZW5jeSxcbiAgbmFtZSxcbiAgbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IsXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIG9uVmlkZW9GcmFtZSxcbiAgY3Jvc3NPcmlnaW4sXG4gIC4uLnByb3BzMlxufSkgPT4ge1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB2b2x1bWVQcm9wc0ZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVVuc2FmZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyNyhTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBtZWRpYVN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDI3KFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGlmICghc3JjKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIGBzcmNgIHdhcyBwYXNzZWQgdG8gPE9mZnRocmVhZFZpZGVvPi5cIik7XG4gIH1cbiAgY29uc3QgaWQgPSB1c2VNZW1vMjcoKCkgPT4gYG9mZnRocmVhZHZpZGVvLSR7cmFuZG9tKHNyYyA/PyBcIlwiKX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzfWAsIFtcbiAgICBzcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc1xuICBdKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgIG1lZGlhVm9sdW1lOiAxXG4gIH0pO1xuICB1c2VFZmZlY3QxOSgoKSA9PiB7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgdHlwZTogXCJ2aWRlb1wiLFxuICAgICAgc3JjOiBnZXRBYnNvbHV0ZVNyYyhzcmMpLFxuICAgICAgaWQsXG4gICAgICBmcmFtZTogYWJzb2x1dGVGcmFtZSxcbiAgICAgIHZvbHVtZSxcbiAgICAgIG1lZGlhRnJhbWU6IGZyYW1lLFxuICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgPz8gMSxcbiAgICAgIHRvbmVGcmVxdWVuY3k6IHRvbmVGcmVxdWVuY3kgPz8gbnVsbCxcbiAgICAgIGF1ZGlvU3RhcnRGcmFtZTogTWF0aC5tYXgoMCwgLShzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSA/PyAwKSlcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgfSwgW1xuICAgIG11dGVkLFxuICAgIHNyYyxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIGlkLFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB2b2x1bWUsXG4gICAgZnJhbWUsXG4gICAgYWJzb2x1dGVGcmFtZSxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbVxuICBdKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSB1c2VNZW1vMjcoKCkgPT4ge1xuICAgIHJldHVybiBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCh7XG4gICAgICBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlIHx8IDEsXG4gICAgICBzdGFydEZyb206IC1tZWRpYVN0YXJ0c0F0XG4gICAgfSkgLyB2aWRlb0NvbmZpZy5mcHM7XG4gIH0sIFtmcmFtZSwgbWVkaWFTdGFydHNBdCwgcGxheWJhY2tSYXRlLCB2aWRlb0NvbmZpZy5mcHNdKTtcbiAgY29uc3QgYWN0dWFsU3JjID0gdXNlTWVtbzI3KCgpID0+IHtcbiAgICByZXR1cm4gZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2Uoe1xuICAgICAgc3JjLFxuICAgICAgY3VycmVudFRpbWUsXG4gICAgICB0cmFuc3BhcmVudCxcbiAgICAgIHRvbmVNYXBwZWRcbiAgICB9KTtcbiAgfSwgW3RvbmVNYXBwZWQsIGN1cnJlbnRUaW1lLCBzcmMsIHRyYW5zcGFyZW50XSk7XG4gIGNvbnN0IFtpbWFnZVNyYywgc2V0SW1hZ2VTcmNdID0gdXNlU3RhdGUxNyhudWxsKTtcbiAgdXNlTGF5b3V0RWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fdmlkZW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsZWFudXAgPSBbXTtcbiAgICBzZXRJbWFnZVNyYyhudWxsKTtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcihgRmV0Y2hpbmcgJHthY3R1YWxTcmN9IGZyb20gc2VydmVyYCwge1xuICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFjdHVhbFNyYywge1xuICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgY2FjaGU6IFwibm8tc3RvcmVcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgaWYgKGpzb24uZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZFVwRXJyb3JNZXNzYWdlID0ganNvbi5lcnJvci5yZXBsYWNlKC9eRXJyb3I6IC8sIFwiXCIpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2xlYW5lZFVwRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgcmV0dXJuZWQgc3RhdHVzICR7cmVzLnN0YXR1c30gd2hpbGUgZmV0Y2hpbmcgJHthY3R1YWxTcmN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlcy5ibG9iKCk7XG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIGNsZWFudXAucHVzaCgoKSA9PiBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCkpO1xuICAgICAgICBzZXRJbWFnZVNyYyh7XG4gICAgICAgICAgc3JjOiB1cmwsXG4gICAgICAgICAgaGFuZGxlOiBuZXdIYW5kbGVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwiYWJvcnRlZFwiKSkge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpKSB7XG4gICAgICAgICAgZXJyID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggJHthY3R1YWxTcmN9LiBUaGlzIGNvdWxkIGJlIGNhdXNlZCBieSBDaHJvbWUgcmVqZWN0aW5nIHRoZSByZXF1ZXN0IGJlY2F1c2UgdGhlIGRpc2sgc3BhY2UgaXMgbG93LiBDb25zaWRlciBpbmNyZWFzaW5nIHRoZSBkaXNrIHNpemUgb2YgeW91ciBlbnZpcm9ubWVudC5gLCB7IGNhdXNlOiBlcnIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuY2VsUmVuZGVyKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGV4ZWN1dGUoKTtcbiAgICBjbGVhbnVwLnB1c2goKCkgPT4ge1xuICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwLmZvckVhY2goKGMyKSA9PiBjMigpKTtcbiAgICB9O1xuICB9LCBbXG4gICAgYWN0dWFsU3JjLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBvbkVycm9yXG4gIF0pO1xuICBjb25zdCBvbkVyciA9IHVzZUNhbGxiYWNrMTUoKCkgPT4ge1xuICAgIGlmIChvbkVycm9yKSB7XG4gICAgICBvbkVycm9yPy4obmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgaW1hZ2Ugd2l0aCBzcmMgXCIgKyBpbWFnZVNyYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5jZWxSZW5kZXIoXCJGYWlsZWQgdG8gbG9hZCBpbWFnZSB3aXRoIHNyYyBcIiArIGltYWdlU3JjKTtcbiAgICB9XG4gIH0sIFtpbWFnZVNyYywgb25FcnJvcl0pO1xuICBjb25zdCBjbGFzc05hbWUgPSB1c2VNZW1vMjcoKCkgPT4ge1xuICAgIHJldHVybiBbT0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUUsIHByb3BzMi5jbGFzc05hbWVdLmZpbHRlcih0cnV0aHkpLmpvaW4oXCIgXCIpO1xuICB9LCBbcHJvcHMyLmNsYXNzTmFtZV0pO1xuICBjb25zdCBvbkltYWdlRnJhbWUgPSB1c2VDYWxsYmFjazE1KChpbWcpID0+IHtcbiAgICBpZiAob25WaWRlb0ZyYW1lKSB7XG4gICAgICBvblZpZGVvRnJhbWUoaW1nKTtcbiAgICB9XG4gIH0sIFtvblZpZGVvRnJhbWVdKTtcbiAgaWYgKCFpbWFnZVNyYyB8fCAhd2luZG93LnJlbW90aW9uX3ZpZGVvRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnRpbnVlUmVuZGVyKGltYWdlU3JjLmhhbmRsZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzAoSW1nLCB7XG4gICAgc3JjOiBpbWFnZVNyYy5zcmMsXG4gICAgY2xhc3NOYW1lLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBvbkltYWdlRnJhbWUsXG4gICAgLi4ucHJvcHMyLFxuICAgIG9uRXJyb3I6IG9uRXJyXG4gIH0pO1xufTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvRm9yUHJldmlldy50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjEwLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyOCxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIxLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU5LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yOCxcbiAgdXNlUmVmIGFzIHVzZVJlZjE2LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE4XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vZW1pdC12aWRlby1mcmFtZS50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIwIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlRW1pdFZpZGVvRnJhbWUgPSAoe1xuICByZWYsXG4gIG9uVmlkZW9GcmFtZVxufSkgPT4ge1xuICB1c2VFZmZlY3QyMCgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSByZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb25WaWRlb0ZyYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBoYW5kbGUgPSAwO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKCFyZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvblZpZGVvRnJhbWUocmVmLmN1cnJlbnQpO1xuICAgICAgaGFuZGxlID0gcmVmLmN1cnJlbnQucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgfTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayhoYW5kbGUpO1xuICAgIH07XG4gIH0sIFtvblZpZGVvRnJhbWUsIHJlZl0pO1xufTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvRm9yUHJldmlldy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzMSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFZpZGVvRm9yRGV2ZWxvcG1lbnRSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMyLCByZWYpID0+IHtcbiAgY29uc3QgdmlkZW9SZWYgPSB1c2VSZWYxNihudWxsKTtcbiAgY29uc3Qge1xuICAgIHZvbHVtZSxcbiAgICBtdXRlZCxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcixcbiAgICBzcmMsXG4gICAgb25EdXJhdGlvbixcbiAgICBhY2NlcHRhYmxlVGltZVNoaWZ0LFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBuYW1lLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrLFxuICAgIHN0eWxlLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgICBvbkVycm9yLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICBvblZpZGVvRnJhbWUsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSA9IHByb3BzMjtcbiAgY29uc3Qgdm9sdW1lUHJvcEZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB7IGZwcywgZHVyYXRpb25JbkZyYW1lcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgcGFyZW50U2VxdWVuY2UgPSB1c2VDb250ZXh0MjgoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgeyBoaWRkZW4gfSA9IHVzZUNvbnRleHQyOChTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0KTtcbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCBtb3VudFRpbWUgPSB1c2VNb3VudFRpbWUoKTtcbiAgY29uc3QgW3RpbWVsaW5lSWRdID0gdXNlU3RhdGUxOCgoKSA9PiBTdHJpbmcoTWF0aC5yYW5kb20oKSkpO1xuICBjb25zdCBpc1NlcXVlbmNlSGlkZGVuID0gaGlkZGVuW3RpbWVsaW5lSWRdID8/IGZhbHNlO1xuICBpZiAodHlwZW9mIGFjY2VwdGFibGVUaW1lU2hpZnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhY2NlcHRhYmxlVGltZVNoaWZ0IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzIGluc3RlYWQuXCIpO1xuICB9XG4gIGNvbnN0IFttZWRpYVZvbHVtZV0gPSB1c2VNZWRpYVZvbHVtZVN0YXRlKCk7XG4gIGNvbnN0IFttZWRpYU11dGVkXSA9IHVzZU1lZGlhTXV0ZWRTdGF0ZSgpO1xuICBjb25zdCB1c2VyUHJlZmVycmVkVm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lXG4gIH0pO1xuICB1c2VNZWRpYUluVGltZWxpbmUoe1xuICAgIG1lZGlhUmVmOiB2aWRlb1JlZixcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWUsXG4gICAgbWVkaWFUeXBlOiBcInZpZGVvXCIsXG4gICAgc3JjLFxuICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIGRpc3BsYXlOYW1lOiBuYW1lID8/IG51bGwsXG4gICAgaWQ6IHRpbWVsaW5lSWQsXG4gICAgc3RhY2s6IF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgcHJlbW91bnREaXNwbGF5OiBudWxsLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IG51bGwsXG4gICAgaXNQcmVtb3VudGluZzogQm9vbGVhbihwYXJlbnRTZXF1ZW5jZT8ucHJlbW91bnRpbmcpXG4gIH0pO1xuICB1c2VTeW5jVm9sdW1lV2l0aE1lZGlhVGFnKHtcbiAgICB2b2x1bWVQcm9wRnJhbWUsXG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lLFxuICAgIG1lZGlhUmVmOiB2aWRlb1JlZlxuICB9KTtcbiAgdXNlQW1wbGlmaWNhdGlvbih7XG4gICAgbG9nTGV2ZWwsXG4gICAgbWVkaWFSZWY6IHZpZGVvUmVmLFxuICAgIHZvbHVtZTogdXNlclByZWZlcnJlZFZvbHVtZVxuICB9KTtcbiAgdXNlTWVkaWFQbGF5YmFjayh7XG4gICAgbWVkaWFSZWY6IHZpZGVvUmVmLFxuICAgIHNyYyxcbiAgICBtZWRpYVR5cGU6IFwidmlkZW9cIixcbiAgICBwbGF5YmFja1JhdGU6IHByb3BzMi5wbGF5YmFja1JhdGUgPz8gMSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yLFxuICAgIGFjY2VwdGFibGVUaW1lc2hpZnQ6IGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMgPz8gbnVsbCxcbiAgICBpc1ByZW1vdW50aW5nOiBCb29sZWFuKHBhcmVudFNlcXVlbmNlPy5wcmVtb3VudGluZyksXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IG51bGwsXG4gICAgdXNlclByZWZlcnJlZFZvbHVtZVxuICB9KTtcbiAgY29uc3QgYWN0dWFsRnJvbSA9IHBhcmVudFNlcXVlbmNlID8gcGFyZW50U2VxdWVuY2UucmVsYXRpdmVGcm9tIDogMDtcbiAgY29uc3QgZHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZSA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMsIGR1cmF0aW9uSW5GcmFtZXMpIDogZHVyYXRpb25JbkZyYW1lcztcbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChzcmMpO1xuICBjb25zdCBhY3R1YWxTcmMgPSB1c2VBcHBlbmRWaWRlb0ZyYWdtZW50KHtcbiAgICBhY3R1YWxTcmM6IHByZWxvYWRlZFNyYyxcbiAgICBhY3R1YWxGcm9tLFxuICAgIGR1cmF0aW9uLFxuICAgIGZwc1xuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTkocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIHZpZGVvUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdXNlU3RhdGUxOCgoKSA9PiBwbGF5YmFja0xvZ2dpbmcoe1xuICAgIGxvZ0xldmVsLFxuICAgIG1lc3NhZ2U6IGBNb3VudGluZyB2aWRlbyB3aXRoIHNvdXJjZSA9ICR7YWN0dWFsU3JjfSwgdj0ke1ZFUlNJT059LCB1c2VyIGFnZW50PSR7dHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwic2VydmVyXCIgOiBuYXZpZ2F0b3IudXNlckFnZW50fWAsXG4gICAgdGFnOiBcInZpZGVvXCIsXG4gICAgbW91bnRUaW1lXG4gIH0pKTtcbiAgdXNlRWZmZWN0MjEoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVycm9ySGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGlmIChjdXJyZW50LmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvY2N1cnJlZCBpbiB2aWRlb1wiLCBjdXJyZW50Py5lcnJvcik7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBDb2RlICR7Y3VycmVudC5lcnJvci5jb2RlfTogJHtjdXJyZW50LmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yIHdoaWxlIHBsYXlpbmcgdGhlIHZpZGVvICR7c3JjfTogQ29kZSAke2N1cnJlbnQuZXJyb3IuY29kZX0gLSAke2N1cnJlbnQ/LmVycm9yPy5tZXNzYWdlfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuIFBhc3MgYW4gb25FcnJvcigpIHByb3AgdG8gaGFuZGxlIHRoZSBlcnJvci5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBUaGUgYnJvd3NlciB0aHJldyBhbiBlcnJvciB3aGlsZSBwbGF5aW5nIHRoZSB2aWRlbyAke3NyY31gKTtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yIHdoaWxlIHBsYXlpbmcgdGhlIHZpZGVvXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW29uRXJyb3IsIHNyY10pO1xuICBjb25zdCBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrID0gdXNlUmVmMTYob25EdXJhdGlvbik7XG4gIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudCA9IG9uRHVyYXRpb247XG4gIHVzZUVtaXRWaWRlb0ZyYW1lKHsgcmVmOiB2aWRlb1JlZiwgb25WaWRlb0ZyYW1lIH0pO1xuICB1c2VFZmZlY3QyMSgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQuZHVyYXRpb24pIHtcbiAgICAgIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudD8uKHNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uTG9hZGVkTWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgb25Mb2FkZWRNZXRhZGF0YSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgIH07XG4gIH0sIFtzcmNdKTtcbiAgdXNlRWZmZWN0MjEoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0lvc1NhZmFyaSgpKSB7XG4gICAgICBjdXJyZW50LnByZWxvYWQgPSBcIm1ldGFkYXRhXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQucHJlbG9hZCA9IFwiYXV0b1wiO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBhY3R1YWxTdHlsZSA9IHVzZU1lbW8yOCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgb3BhY2l0eTogaXNTZXF1ZW5jZUhpZGRlbiA/IDAgOiBzdHlsZT8ub3BhY2l0eSA/PyAxXG4gICAgfTtcbiAgfSwgW2lzU2VxdWVuY2VIaWRkZW4sIHN0eWxlXSk7XG4gIGNvbnN0IGNyb3NzT3JpZ2luVmFsdWUgPSBjcm9zc09yaWdpbiA/PyAob25WaWRlb0ZyYW1lID8gXCJhbm9ueW1vdXNcIiA6IHVuZGVmaW5lZCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzEoXCJ2aWRlb1wiLCB7XG4gICAgcmVmOiB2aWRlb1JlZixcbiAgICBtdXRlZDogbXV0ZWQgfHwgbWVkaWFNdXRlZCB8fCBpc1NlcXVlbmNlSGlkZGVuIHx8IHVzZXJQcmVmZXJyZWRWb2x1bWUgPD0gMCxcbiAgICBwbGF5c0lubGluZTogdHJ1ZSxcbiAgICBzcmM6IGFjdHVhbFNyYyxcbiAgICBsb29wOiBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgc3R5bGU6IGFjdHVhbFN0eWxlLFxuICAgIGRpc2FibGVSZW1vdGVQbGF5YmFjazogdHJ1ZSxcbiAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW5WYWx1ZSxcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9KTtcbn07XG52YXIgVmlkZW9Gb3JQcmV2aWV3ID0gZm9yd2FyZFJlZjEwKFZpZGVvRm9yRGV2ZWxvcG1lbnRSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuXG4vLyBzcmMvdmlkZW8vT2ZmdGhyZWFkVmlkZW8udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MzIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBPZmZ0aHJlYWRWaWRlbyA9IChwcm9wczIpID0+IHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICBuYW1lLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzdGFjayxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICAuLi5vdGhlclByb3BzXG4gIH0gPSBwcm9wczI7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBvbkR1cmF0aW9uID0gdXNlQ2FsbGJhY2sxNigoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LCBbXSk7XG4gIGlmICh0eXBlb2YgcHJvcHMyLnNyYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8T2ZmdGhyZWFkVmlkZW8+XFxgIHRhZyByZXF1aXJlcyBhIHN0cmluZyBmb3IgXFxgc3JjXFxgLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkocHJvcHMyLnNyYyl9IGluc3RlYWQuYCk7XG4gIH1cbiAgaWYgKHByb3BzMi5pbWFnZUZvcm1hdCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8T2ZmdGhyZWFkVmlkZW8+XFxgIHRhZyBkb2VzIG5vIGxvbmdlciBhY2NlcHQgXFxgaW1hZ2VGb3JtYXRcXGAuIFVzZSB0aGUgXFxgdHJhbnNwYXJlbnRcXGAgcHJvcCBpZiB5b3Ugd2FudCB0byByZW5kZXIgYSB0cmFuc3BhcmVudCB2aWRlby5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzKHN0YXJ0RnJvbSwgZW5kQXQpO1xuICAgIGNvbnN0IHN0YXJ0RnJvbUZyYW1lTm8gPSBzdGFydEZyb20gPz8gMDtcbiAgICBjb25zdCBlbmRBdEZyYW1lTm8gPSBlbmRBdCA/PyBJbmZpbml0eTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMyKFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtIHN0YXJ0RnJvbUZyYW1lTm8sXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBlbmRBdEZyYW1lTm8sXG4gICAgICBuYW1lLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMihPZmZ0aHJlYWRWaWRlbywge1xuICAgICAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICAgICAgLi4ub3RoZXJQcm9wc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICB2YWxpZGF0ZU1lZGlhUHJvcHMocHJvcHMyLCBcIlZpZGVvXCIpO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMyKE9mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nLCB7XG4gICAgICAuLi5vdGhlclByb3BzXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHRyYW5zcGFyZW50LFxuICAgIHRvbmVNYXBwZWQsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIG9uVmlkZW9GcmFtZSxcbiAgICBjcm9zc09yaWdpbixcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgLi4ucHJvcHNGb3JQcmV2aWV3XG4gIH0gPSBvdGhlclByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMyKFZpZGVvRm9yUHJldmlldywge1xuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiBmYWxzZSxcbiAgICBvbkR1cmF0aW9uLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3I6IHRydWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgc2hvd0luVGltZWxpbmU6IHNob3dJblRpbWVsaW5lID8/IHRydWUsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gdW5kZWZpbmVkLFxuICAgIG9uVmlkZW9GcmFtZTogb25WaWRlb0ZyYW1lID8/IG51bGwsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgLi4ucHJvcHNGb3JQcmV2aWV3XG4gIH0pO1xufTtcbi8vIHNyYy92aWRlby9WaWRlby50c3hcbmltcG9ydCB7IGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjEyLCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazE3LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzMCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vVmlkZW9Gb3JSZW5kZXJpbmcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYxMSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjksXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyMixcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlMTAsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q5LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yOSxcbiAgdXNlUmVmIGFzIHVzZVJlZjE3XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vc2Vlay11bnRpbC1yaWdodC50c1xudmFyIHJvdW5kVG82Q29tbWFzID0gKG51bSkgPT4ge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAxZTUpIC8gMWU1O1xufTtcbnZhciBzZWVrVG9UaW1lID0gKHtcbiAgZWxlbWVudCxcbiAgZGVzaXJlZFRpbWUsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgaWYgKGlzQXBwcm94aW1hdGVseVRoZVNhbWUoZWxlbWVudC5jdXJyZW50VGltZSwgZGVzaXJlZFRpbWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhaXQ6IFByb21pc2UucmVzb2x2ZShkZXNpcmVkVGltZSksXG4gICAgICBjYW5jZWw6ICgpID0+IHt9XG4gICAgfTtcbiAgfVxuICBzZWVrKHtcbiAgICBsb2dMZXZlbCxcbiAgICBtZWRpYVJlZjogZWxlbWVudCxcbiAgICB0aW1lOiBkZXNpcmVkVGltZSxcbiAgICB3aHk6IFwiU2Vla2luZyBkdXJpbmcgcmVuZGVyaW5nXCIsXG4gICAgbW91bnRUaW1lXG4gIH0pO1xuICBsZXQgY2FuY2VsO1xuICBsZXQgY2FuY2VsU2Vla2VkID0gbnVsbDtcbiAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY2FuY2VsID0gZWxlbWVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChub3csIG1ldGFkYXRhKSA9PiB7XG4gICAgICBjb25zdCBkaXNwbGF5SW4gPSBtZXRhZGF0YS5leHBlY3RlZERpc3BsYXlUaW1lIC0gbm93O1xuICAgICAgaWYgKGRpc3BsYXlJbiA8PSAwKSB7XG4gICAgICAgIHJlc29sdmUobWV0YWRhdGEubWVkaWFUaW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobWV0YWRhdGEubWVkaWFUaW1lKTtcbiAgICAgIH0sIGRpc3BsYXlJbiArIDE1MCk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCB3YWl0Rm9yU2Vla2VkRXZlbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IG9uRG9uZSA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCBvbkRvbmUsIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBjYW5jZWxTZWVrZWQgPSAoKSA9PiB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIiwgb25Eb25lKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB3YWl0OiBQcm9taXNlLmFsbChbcHJvbSwgd2FpdEZvclNlZWtlZEV2ZW50XSkudGhlbigoW3RpbWVdKSA9PiB0aW1lKSxcbiAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgIGNhbmNlbFNlZWtlZD8uKCk7XG4gICAgICBlbGVtZW50LmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayhjYW5jZWwpO1xuICAgIH1cbiAgfTtcbn07XG52YXIgc2Vla1RvVGltZU11bHRpcGxlVW50aWxSaWdodCA9ICh7XG4gIGVsZW1lbnQsXG4gIGRlc2lyZWRUaW1lLFxuICBmcHMsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgY29uc3QgdGhyZXNob2xkID0gMSAvIGZwcyAvIDI7XG4gIGxldCBjdXJyZW50Q2FuY2VsID0gKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfTtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShlbGVtZW50LmR1cmF0aW9uKSAmJiBlbGVtZW50LmN1cnJlbnRUaW1lID49IGVsZW1lbnQuZHVyYXRpb24gJiYgZGVzaXJlZFRpbWUgPj0gZWxlbWVudC5kdXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9tOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgIGNhbmNlbDogKCkgPT4ge31cbiAgICB9O1xuICB9XG4gIGNvbnN0IHByb20gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZmlyc3RTZWVrID0gc2Vla1RvVGltZSh7XG4gICAgICBlbGVtZW50LFxuICAgICAgZGVzaXJlZFRpbWU6IGRlc2lyZWRUaW1lICsgdGhyZXNob2xkLFxuICAgICAgbG9nTGV2ZWwsXG4gICAgICBtb3VudFRpbWVcbiAgICB9KTtcbiAgICBmaXJzdFNlZWsud2FpdC50aGVuKChzZWVrZWRUbykgPT4ge1xuICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IE1hdGguYWJzKGRlc2lyZWRUaW1lIC0gc2Vla2VkVG8pO1xuICAgICAgaWYgKGRpZmZlcmVuY2UgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduID0gZGVzaXJlZFRpbWUgPiBzZWVrZWRUbyA/IDEgOiAtMTtcbiAgICAgIGNvbnN0IG5ld1NlZWsgPSBzZWVrVG9UaW1lKHtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgZGVzaXJlZFRpbWU6IHNlZWtlZFRvICsgdGhyZXNob2xkICogc2lnbixcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBjdXJyZW50Q2FuY2VsID0gbmV3U2Vlay5jYW5jZWw7XG4gICAgICBuZXdTZWVrLndhaXQudGhlbigobmV3VGltZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdEaWZmZXJlbmNlID0gTWF0aC5hYnMoZGVzaXJlZFRpbWUgLSBuZXdUaW1lKTtcbiAgICAgICAgaWYgKHJvdW5kVG82Q29tbWFzKG5ld0RpZmZlcmVuY2UpIDw9IHJvdW5kVG82Q29tbWFzKHRocmVzaG9sZCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoaXJkU2VlayA9IHNlZWtUb1RpbWUoe1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgZGVzaXJlZFRpbWU6IGRlc2lyZWRUaW1lICsgdGhyZXNob2xkLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudENhbmNlbCA9IHRoaXJkU2Vlay5jYW5jZWw7XG4gICAgICAgIHJldHVybiB0aGlyZFNlZWsud2FpdC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY3VycmVudENhbmNlbCA9IGZpcnN0U2Vlay5jYW5jZWw7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb20sXG4gICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICBjdXJyZW50Q2FuY2VsKCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgVmlkZW9Gb3JSZW5kZXJpbmdGb3J3YXJkRnVuY3Rpb24gPSAoe1xuICBvbkVycm9yLFxuICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgcGxheWJhY2tSYXRlLFxuICBvbkR1cmF0aW9uLFxuICB0b25lRnJlcXVlbmN5LFxuICBuYW1lLFxuICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgLi4ucHJvcHMyXG59LCByZWYpID0+IHtcbiAgY29uc3QgYWJzb2x1dGVGcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgdm9sdW1lUHJvcHNGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZjE3KG51bGwpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjkoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgbWVkaWFTdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBnZXRSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IGxvZ0xldmVsID0gdXNlTG9nTGV2ZWwoKTtcbiAgY29uc3QgbW91bnRUaW1lID0gdXNlTW91bnRUaW1lKCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MjkoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3QgaWQgPSB1c2VNZW1vMjkoKCkgPT4gYHZpZGVvLSR7cmFuZG9tKHByb3BzMi5zcmMgPz8gXCJcIil9LSR7c2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc31gLCBbXG4gICAgcHJvcHMyLnNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzXG4gIF0pO1xuICBpZiAoIXZpZGVvQ29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmlkZW8gY29uZmlnIGZvdW5kXCIpO1xuICB9XG4gIGNvbnN0IHZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgZnJhbWU6IHZvbHVtZVByb3BzRnJhbWUsXG4gICAgbWVkaWFWb2x1bWU6IDFcbiAgfSk7XG4gIHVzZUVmZmVjdDIyKCgpID0+IHtcbiAgICBpZiAoIXByb3BzMi5zcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmIChwcm9wczIubXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgIHNyYzogZ2V0QWJzb2x1dGVTcmMocHJvcHMyLnNyYyksXG4gICAgICBpZCxcbiAgICAgIGZyYW1lOiBhYnNvbHV0ZUZyYW1lLFxuICAgICAgdm9sdW1lLFxuICAgICAgbWVkaWFGcmFtZTogZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgICAgdG9uZUZyZXF1ZW5jeTogdG9uZUZyZXF1ZW5jeSA/PyBudWxsLFxuICAgICAgYXVkaW9TdGFydEZyYW1lOiBNYXRoLm1heCgwLCAtKHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDApKVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICB9LCBbXG4gICAgcHJvcHMyLm11dGVkLFxuICAgIHByb3BzMi5zcmMsXG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICBpZCxcbiAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgdm9sdW1lLFxuICAgIGZyYW1lLFxuICAgIGFic29sdXRlRnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb21cbiAgXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUxMChyZWYsICgpID0+IHtcbiAgICByZXR1cm4gdmlkZW9SZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QyMigoKSA9PiB7XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fdmlkZW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gZ2V0TWVkaWFUaW1lKHtcbiAgICAgIGZyYW1lLFxuICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgfHwgMSxcbiAgICAgIHN0YXJ0RnJvbTogLW1lZGlhU3RhcnRzQXQsXG4gICAgICBmcHM6IHZpZGVvQ29uZmlnLmZwc1xuICAgIH0pO1xuICAgIGNvbnN0IGhhbmRsZSA9IGRlbGF5UmVuZGVyKGBSZW5kZXJpbmcgPFZpZGVvIC8+IHdpdGggc3JjPVwiJHtwcm9wczIuc3JjfVwiIGF0IHRpbWUgJHtjdXJyZW50VGltZX1gLCB7XG4gICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBpZiAod2luZG93LnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09IFwidGVzdFwiKSB7XG4gICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNBcHByb3hpbWF0ZWx5VGhlU2FtZShjdXJyZW50LmN1cnJlbnRUaW1lLCBjdXJyZW50VGltZSkpIHtcbiAgICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZWREYXRhSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICAgIH07XG4gICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIGxvYWRlZERhdGFIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIGxvYWRlZERhdGFIYW5kbGVyKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZWVrMiA9IHNlZWtUb1RpbWVNdWx0aXBsZVVudGlsUmlnaHQoe1xuICAgICAgZWxlbWVudDogY3VycmVudCxcbiAgICAgIGRlc2lyZWRUaW1lOiBjdXJyZW50VGltZSxcbiAgICAgIGZwczogdmlkZW9Db25maWcuZnBzLFxuICAgICAgbG9nTGV2ZWwsXG4gICAgICBtb3VudFRpbWVcbiAgICB9KTtcbiAgICBzZWVrMi5wcm9tLnRoZW4oKCkgPT4ge1xuICAgICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICB9KTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLCBlbmRlZEhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoY3VycmVudD8uZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9jY3VycmVkIGluIHZpZGVvXCIsIGN1cnJlbnQ/LmVycm9yKTtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgYnJvd3NlciB0aHJldyBhbiBlcnJvciB3aGlsZSBwbGF5aW5nIHRoZSB2aWRlbyAke3Byb3BzMi5zcmN9OiBDb2RlICR7Y3VycmVudC5lcnJvci5jb2RlfSAtICR7Y3VycmVudD8uZXJyb3I/Lm1lc3NhZ2V9LiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9tZWRpYS1wbGF5YmFjay1lcnJvciBmb3IgaGVscC4gUGFzcyBhbiBvbkVycm9yKCkgcHJvcCB0byBoYW5kbGUgdGhlIGVycm9yLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3JcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2VlazIuY2FuY2VsKCk7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLCBlbmRlZEhhbmRsZXIpO1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgfTtcbiAgfSwgW1xuICAgIHZvbHVtZVByb3BzRnJhbWUsXG4gICAgcHJvcHMyLnNyYyxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgdmlkZW9Db25maWcuZnBzLFxuICAgIGZyYW1lLFxuICAgIG1lZGlhU3RhcnRzQXQsXG4gICAgb25FcnJvcixcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgbG9nTGV2ZWwsXG4gICAgbW91bnRUaW1lXG4gIF0pO1xuICBjb25zdCB7IHNyYyB9ID0gcHJvcHMyO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICB1c2VMYXlvdXRFZmZlY3Q5KCgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIoXCJMb2FkaW5nIDxWaWRlbz4gZHVyYXRpb24gd2l0aCBzcmM9XCIgKyBzcmMsIHtcbiAgICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICAgIGNvbnN0IGRpZExvYWQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICAgIG9uRHVyYXRpb24oc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICBvbkR1cmF0aW9uKHNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Py5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZGlkTG9hZCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY3VycmVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGRpZExvYWQpO1xuICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICB9LCBbc3JjLCBvbkR1cmF0aW9uLCBkZWxheVJlbmRlclJldHJpZXMsIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzXSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMyhcInZpZGVvXCIsIHtcbiAgICByZWY6IHZpZGVvUmVmLFxuICAgIGRpc2FibGVSZW1vdGVQbGF5YmFjazogdHJ1ZSxcbiAgICAuLi5wcm9wczJcbiAgfSk7XG59O1xudmFyIFZpZGVvRm9yUmVuZGVyaW5nID0gZm9yd2FyZFJlZjExKFZpZGVvRm9yUmVuZGVyaW5nRm9yd2FyZEZ1bmN0aW9uKTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDM0IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgVmlkZW9Gb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMyLCByZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICBuYW1lLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzdGFjayxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIC4uLm90aGVyUHJvcHNcbiAgfSA9IHByb3BzMjtcbiAgY29uc3QgeyBsb29wLCAuLi5wcm9wc090aGVyVGhhbkxvb3AgfSA9IHByb3BzMjtcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCB7IGR1cmF0aW9ucywgc2V0RHVyYXRpb25zIH0gPSB1c2VDb250ZXh0MzAoRHVyYXRpb25zQ29udGV4dCk7XG4gIGlmICh0eXBlb2YgcmVmID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHJlZnMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9wczIuc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxWaWRlbz5cXGAgdGFnIHJlcXVpcmVzIGEgc3RyaW5nIGZvciBcXGBzcmNcXGAsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShwcm9wczIuc3JjKX0gaW5zdGVhZC5gKTtcbiAgfVxuICBjb25zdCBwcmVsb2FkZWRTcmMgPSB1c2VQcmVsb2FkKHByb3BzMi5zcmMpO1xuICBjb25zdCBvbkR1cmF0aW9uID0gdXNlQ2FsbGJhY2sxNygoc3JjLCBkdXJhdGlvbkluU2Vjb25kcykgPT4ge1xuICAgIHNldER1cmF0aW9ucyh7IHR5cGU6IFwiZ290LWR1cmF0aW9uXCIsIGR1cmF0aW9uSW5TZWNvbmRzLCBzcmMgfSk7XG4gIH0sIFtzZXREdXJhdGlvbnNdKTtcbiAgY29uc3Qgb25WaWRlb0ZyYW1lID0gdXNlQ2FsbGJhY2sxNygoKSA9PiB7fSwgW10pO1xuICBjb25zdCBkdXJhdGlvbkZldGNoZWQgPSBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJlbG9hZGVkU3JjKV0gPz8gZHVyYXRpb25zW2dldEFic29sdXRlU3JjKHByb3BzMi5zcmMpXTtcbiAgaWYgKGxvb3AgJiYgZHVyYXRpb25GZXRjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbkZldGNoZWQpKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDM0KFZpZGVvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZWRpYUR1cmF0aW9uID0gZHVyYXRpb25GZXRjaGVkICogZnBzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzQoTG9vcCwge1xuICAgICAgZHVyYXRpb25JbkZyYW1lczogY2FsY3VsYXRlTG9vcER1cmF0aW9uKHtcbiAgICAgICAgZW5kQXQsXG4gICAgICAgIG1lZGlhRHVyYXRpb24sXG4gICAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgICAgICBzdGFydEZyb21cbiAgICAgIH0pLFxuICAgICAgbGF5b3V0OiBcIm5vbmVcIixcbiAgICAgIG5hbWUsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDM0KFZpZGVvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGVuZEF0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFsaWRhdGVTdGFydEZyb21Qcm9wcyhzdGFydEZyb20sIGVuZEF0KTtcbiAgICBjb25zdCBzdGFydEZyb21GcmFtZU5vID0gc3RhcnRGcm9tID8/IDA7XG4gICAgY29uc3QgZW5kQXRGcmFtZU5vID0gZW5kQXQgPz8gSW5maW5pdHk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNChTZXF1ZW5jZSwge1xuICAgICAgbGF5b3V0OiBcIm5vbmVcIixcbiAgICAgIGZyb206IDAgLSBzdGFydEZyb21GcmFtZU5vLFxuICAgICAgc2hvd0luVGltZWxpbmU6IGZhbHNlLFxuICAgICAgZHVyYXRpb25JbkZyYW1lczogZW5kQXRGcmFtZU5vLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzQoVmlkZW8sIHtcbiAgICAgICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgICAgIC4uLm90aGVyUHJvcHMsXG4gICAgICAgIHJlZlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICB2YWxpZGF0ZU1lZGlhUHJvcHMocHJvcHMyLCBcIlZpZGVvXCIpO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDM0KFZpZGVvRm9yUmVuZGVyaW5nLCB7XG4gICAgICBvbkR1cmF0aW9uLFxuICAgICAgb25WaWRlb0ZyYW1lOiBvblZpZGVvRnJhbWUgPz8gbnVsbCxcbiAgICAgIC4uLm90aGVyUHJvcHMsXG4gICAgICByZWZcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDM0KFZpZGVvRm9yUHJldmlldywge1xuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3I6IGZhbHNlLFxuICAgIC4uLm90aGVyUHJvcHMsXG4gICAgcmVmLFxuICAgIG9uVmlkZW9GcmFtZTogbnVsbCxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICBvbkR1cmF0aW9uLFxuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQgPz8gZmFsc2UsXG4gICAgc2hvd0luVGltZWxpbmU6IHNob3dJblRpbWVsaW5lID8/IHRydWUsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gdW5kZWZpbmVkXG4gIH0pO1xufTtcbnZhciBWaWRlbyA9IGZvcndhcmRSZWYxMihWaWRlb0ZvcndhcmRpbmdGdW5jdGlvbik7XG5hZGRTZXF1ZW5jZVN0YWNrVHJhY2VzKFZpZGVvKTtcbi8vIHNyYy9pbmRleC50c1xuY2hlY2tNdWx0aXBsZVJlbW90aW9uVmVyc2lvbnMoKTtcbnZhciBFeHBlcmltZW50YWwgPSB7XG4gIENsaXBwZXIsXG4gIE51bGwsXG4gIHVzZUlzUGxheWVyXG59O1xudmFyIHByb3h5T2JqID0ge307XG52YXIgQ29uZmlnID0gbmV3IFByb3h5KHByb3h5T2JqLCB7XG4gIGdldChfLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgPT09IFwiQnVuZGxpbmdcIiB8fCBwcm9wID09PSBcIlJlbmRlcmluZ1wiIHx8IHByb3AgPT09IFwiTG9nXCIgfHwgcHJvcCA9PT0gXCJQdXBwZXRlZXJcIiB8fCBwcm9wID09PSBcIk91dHB1dFwiKSB7XG4gICAgICByZXR1cm4gQ29uZmlnO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPICBUaGUgQ0xJIGNvbmZpZ3VyYXRpb24gaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gUmVtb3Rpb24gQ29yZS5cIik7XG4gICAgICBjb25zb2xlLndhcm4oXCJVcGRhdGUgdGhlIGltcG9ydCBmcm9tIHRoZSBjb25maWcgZmlsZTpcIik7XG4gICAgICBjb25zb2xlLndhcm4oKTtcbiAgICAgIGNvbnNvbGUud2FybihcIi0gRGVsZXRlOlwiKTtcbiAgICAgIGNvbnNvbGUud2FybignaW1wb3J0IHtDb25maWd9IGZyb20gXCJyZW1vdGlvblwiOycpO1xuICAgICAgY29uc29sZS53YXJuKFwiKyBSZXBsYWNlOlwiKTtcbiAgICAgIGNvbnNvbGUud2FybignaW1wb3J0IHtDb25maWd9IGZyb20gXCJAcmVtb3Rpb24vY2xpL2NvbmZpZ1wiOycpO1xuICAgICAgY29uc29sZS53YXJuKCk7XG4gICAgICBjb25zb2xlLndhcm4oXCJGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzLzQtMC1taWdyYXRpb24uXCIpO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH07XG4gIH1cbn0pO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhTZXF1ZW5jZSk7XG5leHBvcnQge1xuICB3YXRjaFN0YXRpY0ZpbGUsXG4gIHVzZVZpZGVvQ29uZmlnLFxuICB1c2VDdXJyZW50U2NhbGUsXG4gIHVzZUN1cnJlbnRGcmFtZSxcbiAgdXNlQnVmZmVyU3RhdGUsXG4gIHN0YXRpY0ZpbGUsXG4gIHNwcmluZyxcbiAgcmVnaXN0ZXJSb290LFxuICByYW5kb20sXG4gIHByZWZldGNoLFxuICBtZWFzdXJlU3ByaW5nLFxuICBpbnRlcnBvbGF0ZUNvbG9ycyxcbiAgaW50ZXJwb2xhdGUsXG4gIGdldFN0YXRpY0ZpbGVzLFxuICBnZXRSZW1vdGlvbkVudmlyb25tZW50LFxuICBnZXRJbnB1dFByb3BzLFxuICBkZWxheVJlbmRlcixcbiAgY29udGludWVSZW5kZXIsXG4gIGNhbmNlbFJlbmRlcixcbiAgVmlkZW8sXG4gIFZFUlNJT04sXG4gIFN0aWxsLFxuICBTZXJpZXMsXG4gIFNlcXVlbmNlLFxuICBPZmZ0aHJlYWRWaWRlbyxcbiAgTG9vcCxcbiAgSW50ZXJuYWxzLFxuICBJbWcsXG4gIElGcmFtZSxcbiAgRnJlZXplLFxuICBGb2xkZXJDb250ZXh0LFxuICBGb2xkZXIsXG4gIEV4cGVyaW1lbnRhbCxcbiAgRWFzaW5nLFxuICBDb25maWcsXG4gIENvbXBvc2l0aW9uLFxuICBBdWRpbyxcbiAgQXJ0aWZhY3QsXG4gIEFuaW1hdGVkSW1hZ2UsXG4gIEFic29sdXRlRmlsbFxufTtcbiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJzZXQiLCJuZXdWYWx1ZSIsImNyZWF0ZUNvbnRleHQiLCJlcnIiLCJFcnJvciIsImpvaW4iLCJDbGlwcGVyIiwiUmVhY3QiLCJnZXROb2RlRW52U3RyaW5nIiwiZ2V0RW52U3RyaW5nIiwiZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCIsImlzUGxheWVyIiwid2luZG93IiwicmVtb3Rpb25faXNQbGF5ZXIiLCJpc1JlbmRlcmluZyIsInByb2Nlc3MiLCJlbnYiLCJyZW1vdGlvbl9wdXBwZXRlZXJUaW1lb3V0IiwiaXNTdHVkaW8iLCJyZW1vdGlvbl9pc1N0dWRpbyIsImlzUmVhZE9ubHlTdHVkaW8iLCJyZW1vdGlvbl9pc1JlYWRPbmx5U3R1ZGlvIiwib3JpZ2luYWxDcmVhdGVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbXBvbmVudHNUb0FkZFN0YWNrc1RvIiwiZW5hYmxlU2VxdWVuY2VTdGFja1RyYWNlcyIsInByb3h5IiwiUHJveHkiLCJhcHBseSIsInRoaXNBcmciLCJhcmdBcnJheSIsImluY2x1ZGVzIiwiZmlyc3QiLCJwcm9wcyIsInJlc3QiLCJuZXdQcm9wcyIsInN0YWNrIiwiUmVmbGVjdCIsImFkZFNlcXVlbmNlU3RhY2tUcmFjZXMiLCJjb21wb25lbnQiLCJwdXNoIiwiY3JlYXRlQ29udGV4dDIiLCJ1c2VDb250ZXh0IiwianN4IiwiSXNQbGF5ZXJDb250ZXh0IiwiSXNQbGF5ZXJDb250ZXh0UHJvdmlkZXIiLCJjaGlsZHJlbiIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VJc1BsYXllciIsInRydXRoeSIsIkJvb2xlYW4iLCJWRVJTSU9OIiwiY2hlY2tNdWx0aXBsZVJlbW90aW9uVmVyc2lvbnMiLCJnbG9iYWxUaGlzIiwicmVtb3Rpb25faW1wb3J0ZWQiLCJhbHJlYWR5SW1wb3J0ZWQiLCJUeXBlRXJyb3IiLCJmaWx0ZXIiLCJOdWxsIiwiZm9yd2FyZFJlZiIsImZvcndhcmRSZWYyIiwidXNlQ29udGV4dDEwIiwidXNlRWZmZWN0IiwidXNlRWZmZWN0MyIsInVzZU1lbW8iLCJ1c2VNZW1vOSIsInVzZVN0YXRlIiwidXNlU3RhdGU0IiwianN4MiIsImhhc1RhaWx3aW5kQ2xhc3NOYW1lIiwiY2xhc3NOYW1lIiwiY2xhc3NQcmVmaXgiLCJzb21lIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsIkFic29sdXRlRmlsbFJlZkZvcndhcmRpbmciLCJyZWYiLCJzdHlsZSIsIm90aGVyIiwiYWN0dWFsU3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsInVuZGVmaW5lZCIsImxlZnQiLCJyaWdodCIsImJvdHRvbSIsIndpZHRoIiwiaGVpZ2h0IiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJBYnNvbHV0ZUZpbGwiLCJjcmVhdGVDb250ZXh0MyIsIlNlcXVlbmNlQ29udGV4dCIsIlJlYWN0MyIsInVzZUNhbGxiYWNrIiwidXNlTWVtbzIiLCJqc3gzIiwiU2VxdWVuY2VNYW5hZ2VyIiwicmVnaXN0ZXJTZXF1ZW5jZSIsInVucmVnaXN0ZXJTZXF1ZW5jZSIsInNlcXVlbmNlcyIsIlNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQiLCJoaWRkZW4iLCJzZXRIaWRkZW4iLCJTZXF1ZW5jZU1hbmFnZXJQcm92aWRlciIsInNldFNlcXVlbmNlcyIsInNlcSIsInNlcXMiLCJzIiwiaWQiLCJzZXF1ZW5jZUNvbnRleHQiLCJoaWRkZW5Db250ZXh0IiwiY3JlYXRlQ29udGV4dDQiLCJ1c2VDb250ZXh0MiIsInVzZVJlZiIsInVzZVN0YXRlMiIsIk5vbmNlQ29udGV4dCIsImdldE5vbmNlIiwiZmFzdFJlZnJlc2hlcyIsInVzZU5vbmNlIiwiY29udGV4dCIsIm5vbmNlIiwic2V0Tm9uY2UiLCJsYXN0Q29udGV4dCIsImN1cnJlbnQiLCJleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlIiwidXNlVGltZWxpbmVTZXRGcmFtZSIsInVzZVRpbWVsaW5lUG9zaXRpb24iLCJ1c2VQbGF5aW5nU3RhdGUiLCJwZXJzaXN0Q3VycmVudEZyYW1lIiwiZ2V0SW5pdGlhbEZyYW1lU3RhdGUiLCJnZXRGcmFtZUZvckNvbXBvc2l0aW9uIiwiVGltZWxpbmVDb250ZXh0IiwiU2V0VGltZWxpbmVDb250ZXh0IiwiY3JlYXRlQ29udGV4dDgiLCJ1c2VDb250ZXh0NSIsInVzZU1lbW82IiwidXNlQ29udGV4dDQiLCJ1c2VNZW1vNSIsImNyZWF0ZUNvbnRleHQ1IiwiQ29tcG9zaXRpb25NYW5hZ2VyIiwiY29tcG9zaXRpb25zIiwiZm9sZGVycyIsImN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIiwiY2FudmFzQ29udGVudCIsIkNvbXBvc2l0aW9uU2V0dGVycyIsInJlZ2lzdGVyQ29tcG9zaXRpb24iLCJ1bnJlZ2lzdGVyQ29tcG9zaXRpb24iLCJyZWdpc3RlckZvbGRlciIsInVucmVnaXN0ZXJGb2xkZXIiLCJzZXRDYW52YXNDb250ZW50IiwidXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHMiLCJvbmx5UmVuZGVyQ29tcG9zaXRpb24iLCJjcmVhdGVDb250ZXh0NyIsImNyZWF0ZVJlZiIsInVzZUNhbGxiYWNrMyIsInVzZUNvbnRleHQzIiwidXNlRWZmZWN0MiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlMiIsInVzZU1lbW80IiwidXNlU3RhdGUzIiwiUmVhY3Q0IiwiY3JlYXRlQ29udGV4dDYiLCJ1c2VDYWxsYmFjazIiLCJ1c2VNZW1vMyIsImpzeDQiLCJFZGl0b3JQcm9wc0NvbnRleHQiLCJ1cGRhdGVQcm9wcyIsInJlc2V0VW5zYXZlZCIsImVkaXRvclByb3BzUHJvdmlkZXJSZWYiLCJ0aW1lVmFsdWVSZWYiLCJFZGl0b3JQcm9wc1Byb3ZpZGVyIiwic2V0UHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJwcmV2IiwiZ2V0UHJvcHMiLCJjdHgiLCJEQVRFX1RPS0VOIiwiRklMRV9UT0tFTiIsInNlcmlhbGl6ZUpTT05XaXRoRGF0ZSIsImRhdGEiLCJpbmRlbnQiLCJzdGF0aWNCYXNlIiwiY3VzdG9tRGF0ZVVzZWQiLCJjdXN0b21GaWxlVXNlZCIsIm1hcFVzZWQiLCJzZXRVc2VkIiwic2VyaWFsaXplZFN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXkiLCJpdGVtIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiTWFwIiwiU2V0IiwicmVwbGFjZSIsIm1lc3NhZ2UiLCJkZXNlcmlhbGl6ZUpTT05XaXRoQ3VzdG9tRmllbGRzIiwicGFyc2UiLCJfIiwicmVtb3Rpb25fc3RhdGljQmFzZSIsInNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvIiwiZGlkV2FyblNTUkltcG9ydCIsIndhcm5PbmNlU1NSSW1wb3J0IiwiY29uc29sZSIsIndhcm4iLCJnZXRJbnB1dFByb3BzIiwicGFyYW0iLCJyZW1vdGlvbl9pbnB1dFByb3BzIiwicGFyc2VkIiwidmFsaWRDb2RlY3MiLCJ2YWxpZGF0ZURlZmF1bHRDb2RlYyIsImRlZmF1bHRDb2RlYyIsImxvY2F0aW9uIiwidmFsaWRhdGVEaW1lbnNpb24iLCJhbW91bnQiLCJuYW1lT2ZQcm9wIiwiaXNOYU4iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyIsImR1cmF0aW9uSW5GcmFtZXMiLCJvcHRpb25zIiwiYWxsb3dGbG9hdHMiLCJ2YWxpZGF0ZUZwcyIsImZwcyIsImlzR2lmIiwidmFsaWRhdGVDYWxjdWxhdGVkIiwiY2FsY3VsYXRlZCIsImNvbXBvc2l0aW9uSWQiLCJjb21wb3NpdGlvbkZwcyIsImNvbXBvc2l0aW9uSGVpZ2h0IiwiY29tcG9zaXRpb25XaWR0aCIsImNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyIsImNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiIsImRlZmF1bHRFcnJvckxvY2F0aW9uIiwiZGVmYXVsdE91dE5hbWUiLCJyZXNvbHZlVmlkZW9Db25maWciLCJjYWxjdWxhdGVNZXRhZGF0YSIsInNpZ25hbCIsIm9yaWdpbmFsUHJvcHMiLCJjYWxjdWxhdGVkUHJvbSIsImFib3J0U2lnbmFsIiwidGhlbiIsImMiLCJyZXNvbHZlVmlkZW9Db25maWdPckNhdGNoIiwicGFyYW1zIiwicHJvbWlzZU9yUmV0dXJuVmFsdWUiLCJ0eXBlIiwicmVzdWx0IiwiZXJyb3IiLCJqc3g1IiwiUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCIsInJlc29sdmVDb21wb3NpdGlvbnNSZWYiLCJuZWVkc1Jlc29sdXRpb24iLCJjb21wb3NpdGlvbiIsIlBST1BTX1VQREFURURfRVhURVJOQUxMWSIsIlJlc29sdmVDb21wb3NpdGlvbkNvbmZpZyIsImN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uIiwic2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24iLCJzZWxlY3RlZENvbXBvc2l0aW9uIiwiZmluZCIsInJlbmRlck1vZGFsQ29tcG9zaXRpb24iLCJhbGxFZGl0b3JQcm9wcyIsImlucHV0UHJvcHMiLCJyZXNvbHZlZENvbmZpZ3MiLCJzZXRSZXNvbHZlZENvbmZpZ3MiLCJzZWxlY3RlZEVkaXRvclByb3BzIiwicmVuZGVyTW9kYWxQcm9wcyIsImhhc1Jlc29sdXRpb24iLCJkb1Jlc29sdXRpb24iLCJjb21iaW5lZFByb3BzIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInIiLCJwcm9tT3JOb3QiLCJhYm9ydGVkIiwiY2F0Y2giLCJjdXJyZW50Q29tcG9zaXRpb24iLCJyZWxvYWRDdXJyZW50bHlTZWxlY3RlZENvbXBvc2l0aW9uIiwiZWRpdG9yUHJvcHMiLCJpc1RoZVNhbWUiLCJjdXJyZW50RGVmYXVsdFByb3BzIiwiY2FuUmVzb2x2ZSIsInNob3VsZElnbm9yZVVwZGF0ZSIsInJlbW90aW9uX2lnbm9yZUZhc3RSZWZyZXNoVXBkYXRlIiwiYWJvcnQiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJyZXNvbHZlZENvbmZpZ3NJbmNsdWRpbmdTdGF0aWNPbmVzIiwic3RhdGljQ29tcHMiLCJyZWR1Y2UiLCJhY2MiLCJjdXJyIiwidXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyIsInByZWZlcnJlZENvbXBvc2l0aW9uSWQiLCJ1c2VWaWRlbyIsInNlbGVjdGVkIiwicmVzb2x2ZWQiLCJmcmFtZSIsInBsYXlpbmciLCJwbGF5YmFja1JhdGUiLCJyb290SWQiLCJpbXBlcmF0aXZlUGxheWluZyIsInNldFBsYXliYWNrUmF0ZSIsImF1ZGlvQW5kVmlkZW9UYWdzIiwic2V0RnJhbWUiLCJzZXRQbGF5aW5nIiwibWFrZUtleSIsInRpbWUiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiZ2V0SXRlbSIsIm9iaiIsInJlbW90aW9uX2luaXRpYWxGcmFtZSIsInZpZGVvQ29uZmlnIiwic3RhdGUiLCJ1bmNsYW1wZWQiLCJNYXRoIiwibWluIiwidXNlQ29udGV4dDciLCJjcmVhdGVDb250ZXh0OSIsImpzeDYiLCJDYW5Vc2VSZW1vdGlvbkhvb2tzIiwiQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyIiwidXNlQ29udGV4dDYiLCJ1c2VNZW1vNyIsInVzZVVuc2FmZVZpZGVvQ29uZmlnIiwiY3R4V2lkdGgiLCJjdHhIZWlnaHQiLCJjdHhEdXJhdGlvbiIsInZpZGVvIiwidXNlVmlkZW9Db25maWciLCJ1c2VDb250ZXh0OSIsInVzZU1lbW84IiwidXNlQ29udGV4dDgiLCJ1c2VDdXJyZW50RnJhbWUiLCJjYW5Vc2VSZW1vdGlvbkhvb2tzIiwiY29udGV4dE9mZnNldCIsImN1bXVsYXRlZEZyb20iLCJyZWxhdGl2ZUZyb20iLCJqc3g3IiwiRnJlZXplIiwiZnJhbWVUb0ZyZWV6ZSIsImFjdGl2ZSIsImlzQWN0aXZlIiwidGltZWxpbmVDb250ZXh0IiwidGltZWxpbmVWYWx1ZSIsImpzeDgiLCJSZWd1bGFyU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJmcm9tIiwiSW5maW5pdHkiLCJzaG93SW5UaW1lbGluZSIsIl9yZW1vdGlvbkludGVybmFsTG9vcERpc3BsYXkiLCJsb29wRGlzcGxheSIsIl9yZW1vdGlvbkludGVybmFsU3RhY2siLCJfcmVtb3Rpb25JbnRlcm5hbFByZW1vdW50RGlzcGxheSIsInByZW1vdW50RGlzcGxheSIsImxheW91dCIsIlN0cmluZyIsInJhbmRvbSIsInBhcmVudFNlcXVlbmNlIiwiYWJzb2x1dGVGcmFtZSIsInBhcmVudFNlcXVlbmNlRHVyYXRpb24iLCJhY3R1YWxEdXJhdGlvbkluRnJhbWVzIiwibWF4IiwicHJlbW91bnRpbmciLCJfcmVtb3Rpb25JbnRlcm5hbElzUHJlbW91bnRpbmciLCJjb250ZXh0VmFsdWUiLCJwYXJlbnRGcm9tIiwidGltZWxpbmVDbGlwTmFtZSIsImR1cmF0aW9uIiwiZGlzcGxheU5hbWUiLCJwYXJlbnQiLCJlbmRUaHJlc2hvbGQiLCJjZWlsIiwiY29udGVudCIsInN0eWxlSWZUaGVyZSIsImRlZmF1bHRTdHlsZSIsImlzU2VxdWVuY2VIaWRkZW4iLCJSZWd1bGFyU2VxdWVuY2UiLCJQcmVtb3VudGVkU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJwYXNzZWRTdHlsZSIsInByZW1vdW50Rm9yIiwic3R5bGVXaGlsZVByZW1vdW50ZWQiLCJvdGhlclByb3BzIiwicHJlbW91bnRpbmdBY3RpdmUiLCJvcGFjaXR5IiwicG9pbnRlckV2ZW50cyIsIlNlcXVlbmNlIiwiUHJlbW91bnRlZFNlcXVlbmNlIiwiU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJmb3J3YXJkUmVmMyIsInVzZUVmZmVjdDQiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlNCIsInVzZUxheW91dEVmZmVjdCIsInVzZVJlZjMiLCJ1c2VTdGF0ZTUiLCJpc0Vycm9yTGlrZSIsImNhbmNlbFJlbmRlciIsInJlbW90aW9uX2NhbmNlbGxlZEVycm9yIiwibG9nTGV2ZWxzIiwiZ2V0TnVtYmVyRm9yTG9nTGV2ZWwiLCJsZXZlbCIsImluZGV4T2YiLCJpc0VxdWFsT3JCZWxvd0xvZ0xldmVsIiwiY3VycmVudExldmVsIiwiTG9nIiwidHJhY2UiLCJsb2dMZXZlbCIsImFyZ3MiLCJsb2ciLCJ2ZXJib3NlIiwiaW5mbyIsInJlbW90aW9uX3JlbmRlclJlYWR5IiwiaGFuZGxlcyIsInJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHMiLCJERUxBWV9SRU5ERVJfQ0FMTFNUQUNLX1RPS0VOIiwiREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCIsIkRFTEFZX1JFTkRFUl9SRVRSWV9UT0tFTiIsIkRFTEFZX1JFTkRFUl9DTEVBUl9UT0tFTiIsImRlZmF1bHRUaW1lb3V0IiwiZGVsYXlSZW5kZXIiLCJsYWJlbCIsImhhbmRsZSIsImNhbGxlZCIsInRpbWVvdXRUb1VzZSIsInRpbWVvdXRJbk1pbGxpc2Vjb25kcyIsInJldHJpZXNMZWZ0IiwicmV0cmllcyIsInJlbW90aW9uX2F0dGVtcHQiLCJzdGFydFRpbWUiLCJub3ciLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImNvbnRpbnVlUmVuZGVyIiwiaCIsImNsZWFyVGltZW91dCIsInJlbW90aW9uX2xvZ0xldmVsIiwibGVuZ3RoIiwiUmVhY3Q4IiwidXNlQ2FsbGJhY2s0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZTMiLCJ1c2VSZWYyIiwianN4OSIsImNhbGNBcmdzIiwiZml0IiwiZnJhbWVTaXplIiwiY2FudmFzU2l6ZSIsInJhdGlvIiwiY2VudGVyWCIsImNlbnRlclkiLCJDYW52YXNSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJjYW52YXNSZWYiLCJkcmF3IiwiaW1hZ2VEYXRhIiwiY2FudmFzIiwiY2FudmFzV2lkdGgiLCJkaXNwbGF5V2lkdGgiLCJjYW52YXNIZWlnaHQiLCJkaXNwbGF5SGVpZ2h0IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsImdldENhbnZhcyIsImNsZWFyIiwiY2xlYXJSZWN0IiwiQ2FudmFzIiwiQ0FDSEVfU0laRSIsImdldEFjdHVhbFRpbWUiLCJsb29wQmVoYXZpb3IiLCJkdXJhdGlvbkZvdW5kIiwidGltZUluU2VjIiwiZGVjb2RlSW1hZ2UiLCJyZXNvbHZlZFNyYyIsImN1cnJlbnRUaW1lIiwiaW5pdGlhbExvb3BCZWhhdmlvciIsIkltYWdlRGVjb2RlciIsInJlcyIsImZldGNoIiwiYm9keSIsImRlY29kZXIiLCJoZWFkZXJzIiwiY29tcGxldGVkIiwic2VsZWN0ZWRUcmFjayIsInRyYWNrcyIsImNhY2hlIiwiZ2V0RnJhbWVCeUluZGV4IiwiZnJhbWVJbmRleCIsImZvdW5kSW5DYWNoZSIsImRlY29kZSIsImNvbXBsZXRlRnJhbWVzT25seSIsImltYWdlIiwidGltZUluU2Vjb25kcyIsInRpbWVzdGFtcCIsImNsZWFyQ2FjaGUiLCJjbG9zZVRvVGltZUluU2VjIiwiaXRlbXNJbkNhY2hlIiwic29ydEJ5Q2xvc2VzdFRvQ3VycmVudFRpbWUiLCJzb3J0IiwiYSIsImIiLCJhRGlmZiIsImFicyIsImJEaWZmIiwiaSIsImVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIiLCJhY3R1YWxUaW1lSW5TZWMiLCJmcmFtZXNCZWZvcmUiLCJiaWdnZXN0SW5kZXgiLCJtYXAiLCJmIiwiZnJhbWVDb3VudCIsImdldEZyYW1lIiwiY2xvc2VzdCIsInJlc29sdmVBbmltYXRlZEltYWdlU291cmNlIiwic3JjIiwiVVJMIiwib3JpZ2luIiwiaHJlZiIsImpzeDEwIiwiQW5pbWF0ZWRJbWFnZSIsIm9uRXJyb3IiLCJtb3VudFN0YXRlIiwiaXNNb3VudGVkIiwiaW1hZ2VEZWNvZGVyIiwic2V0SW1hZ2VEZWNvZGVyIiwiZGVjb2RlSGFuZGxlIiwiY3VycmVudFRpbWVSZWYiLCJkIiwiZGVsYXkiLCJ2aWRlb0ZyYW1lIiwidXNlQ29udGV4dDExIiwidXNlRWZmZWN0NSIsInVzZVN0YXRlNyIsImNyZWF0ZUNvbnRleHQxMCIsInVzZUNhbGxiYWNrNSIsInVzZUxheW91dEVmZmVjdDIiLCJ1c2VNZW1vMTAiLCJ1c2VTdGF0ZTYiLCJ2YWxpZGF0ZUFydGlmYWN0RmlsZW5hbWUiLCJmaWxlbmFtZSIsInRyaW0iLCJtYXRjaCIsInZhbGlkYXRlQ29udGVudCIsIlVpbnQ4QXJyYXkiLCJ2YWxpZGF0ZVJlbmRlckFzc2V0IiwiYXJ0aWZhY3QiLCJjb250ZW50VHlwZSIsImpzeDExIiwiUmVuZGVyQXNzZXRNYW5hZ2VyIiwicmVnaXN0ZXJSZW5kZXJBc3NldCIsInVucmVnaXN0ZXJSZW5kZXJBc3NldCIsInJlbmRlckFzc2V0cyIsIlJlbmRlckFzc2V0TWFuYWdlclByb3ZpZGVyIiwic2V0UmVuZGVyQXNzZXRzIiwicmVuZGVyQXNzZXQiLCJhc3NldHMiLCJhc3N0cyIsInJlbW90aW9uX2NvbGxlY3RBc3NldHMiLCJBcnRpZmFjdFRodW1ibmFpbCIsIlN5bWJvbCIsIkFydGlmYWN0IiwiYnRvYSIsIlRleHREZWNvZGVyIiwiVGh1bWJuYWlsIiwiZm9yd2FyZFJlZjYiLCJ1c2VDYWxsYmFjazExIiwidXNlQ29udGV4dDIzIiwiZ2V0QWJzb2x1dGVTcmMiLCJyZWxhdGl2ZVNyYyIsImNhbGN1bGF0ZUxvb3BEdXJhdGlvbiIsImVuZEF0IiwibWVkaWFEdXJhdGlvbiIsInN0YXJ0RnJvbSIsImFjdHVhbER1cmF0aW9uIiwiZmxvb3IiLCJSZWFjdDkiLCJjcmVhdGVDb250ZXh0MTEiLCJ1c2VNZW1vMTEiLCJqc3gxMiIsIkxvb3BDb250ZXh0IiwidXNlTG9vcCIsIkxvb3AiLCJ0aW1lcyIsImN1cnJlbnRGcmFtZSIsImNvbXBEdXJhdGlvbiIsIm1heFRpbWVzIiwiYWN0dWFsVGltZXMiLCJtYXhGcmFtZSIsIml0ZXJhdGlvbiIsInN0YXJ0IiwibnVtYmVyT2ZUaW1lcyIsInN0YXJ0T2Zmc2V0IiwibG9vcENvbnRleHQiLCJ1c2VDb250ZXh0MTIiLCJwbGF5YmFja0xvZ2dpbmciLCJ0YWciLCJtb3VudFRpbWUiLCJ0YWdzIiwiY3JlYXRlQ29udGV4dDEyIiwidXNlRWZmZWN0NiIsInVzZVN0YXRlOCIsImpzeDEzIiwiUHJlbG9hZENvbnRleHQiLCJwcmVsb2FkcyIsInVwZGF0ZXJzIiwic2V0UHJlbG9hZHMiLCJ1cGRhdGVyIiwiZm9yRWFjaCIsInUiLCJQcmVmZXRjaFByb3ZpZGVyIiwiX3ByZWxvYWRzIiwiX3NldFByZWxvYWRzIiwidXBkYXRlckZ1bmN0aW9uIiwicmVtb3ZlQW5kR2V0SGFzaEZyYWdtZW50IiwiaGFzaEluZGV4IiwiZ2V0U3JjV2l0aG91dEhhc2giLCJzbGljZSIsInVzZVByZWxvYWQiLCJwcmVsb2FkczIiLCJoYXNoRnJhZ21lbnRJbmRleCIsIndpdGhvdXRIYXNoRnJhZ21lbnQiLCJibG9iVG9CYXNlNjQiLCJibG9iIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25sb2FkIiwiZGF0YVVybCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwiZ2V0QmxvYkZyb21SZWFkZXIiLCJjb250ZW50TGVuZ3RoIiwib25Qcm9ncmVzcyIsInJlY2VpdmVkTGVuZ3RoIiwiY2h1bmtzIiwiZG9uZSIsInJlYWQiLCJsb2FkZWRCeXRlcyIsInRvdGFsQnl0ZXMiLCJjaHVua3NBbGwiLCJjaHVuayIsIkJsb2IiLCJwcmVmZXRjaCIsIm1ldGhvZCIsInNyY1dpdGhvdXRIYXNoIiwiZnJlZSIsIndhaXRVbnRpbERvbmUiLCJjYW5jZWxlZCIsIm9iamVjdFVybCIsInJlaiIsImNhbkJlQWJvcnRlZCIsImNyZWRlbnRpYWxzIiwib2siLCJzdGF0dXMiLCJoZWFkZXJDb250ZW50VHlwZSIsImhhc1Byb3BlckNvbnRlbnRUeXBlIiwiZ2V0UmVhZGVyIiwicGFyc2VJbnQiLCJidWYiLCJhY3R1YWxCbG9iIiwiY3JlYXRlT2JqZWN0VVJMIiwidXJsIiwicCIsInJldm9rZU9iamVjdFVSTCIsImNvcHkiLCJ2YWxpZGF0ZU1lZGlhUHJvcHMiLCJ2b2x1bWUiLCJ2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzIiwiY3JlYXRlQ29udGV4dDEzIiwidXNlTWVtbzEyIiwidXNlUmVkdWNlciIsImpzeDE0IiwiZHVyYXRpb25SZWR1Y2VyIiwiYWN0aW9uIiwiYWJzb2x1dGVTcmMiLCJkdXJhdGlvbkluU2Vjb25kcyIsIkR1cmF0aW9uc0NvbnRleHQiLCJkdXJhdGlvbnMiLCJzZXREdXJhdGlvbnMiLCJEdXJhdGlvbnNDb250ZXh0UHJvdmlkZXIiLCJmb3J3YXJkUmVmNCIsInVzZUNvbnRleHQyMSIsInVzZUVmZmVjdDE0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZTUiLCJ1c2VNZW1vMTkiLCJ1c2VSZWYxMSIsInVzZVN0YXRlMTMiLCJjcmVhdGVDb250ZXh0MTQiLCJSZWFjdDEyIiwiTG9nTGV2ZWxDb250ZXh0IiwidXNlTG9nTGV2ZWwiLCJ1c2VNb3VudFRpbWUiLCJtdWxiZXJyeTMyIiwidCIsImltdWwiLCJoYXNoQ29kZSIsInN0ciIsImNociIsImhhc2giLCJjaGFyQ29kZUF0Iiwic2VlZCIsImR1bW15IiwidXNlTGF5b3V0RWZmZWN0MyIsInVzZVJlZjQiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImdldFNob3VsZEFtcGxpZnkiLCJ1c2VBbXBsaWZpY2F0aW9uIiwibWVkaWFSZWYiLCJzaG91bGRBbXBsaWZ5IiwiYXVkaW9TdHVmZlJlZiIsImN1cnJlbnRWb2x1bWVSZWYiLCJBdWRpb0NvbnRleHQiLCJhdWRpb0NvbnRleHQiLCJsYXRlbmN5SGludCIsInNvdXJjZSIsIk1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSIsIm1lZGlhRWxlbWVudCIsImdhaW5Ob2RlIiwiR2Fpbk5vZGUiLCJnYWluIiwiY29ubmVjdCIsImRlc3RpbmF0aW9uIiwidmFsdWVUb1NldCIsInVzZUNvbnRleHQxNSIsInVzZUVmZmVjdDciLCJ1c2VNZW1vMTMiLCJ1c2VTdGF0ZTkiLCJ1c2VDb250ZXh0MTQiLCJ1c2VNZWRpYVN0YXJ0c0F0Iiwic3RhcnRzQXQiLCJ1c2VGcmFtZUZvclZvbHVtZVByb3AiLCJiZWhhdmlvciIsImxvb3AiLCJnZXRBc3NldERpc3BsYXlOYW1lIiwidGVzdCIsInN1YnN0cmluZyIsInNwbGl0dGVkIiwic3BsaXQiLCJmbGF0IiwicGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvciIsIm1lZGlhVHlwZSIsIm9uQXV0b1BsYXlFcnJvciIsInJlYXNvbiIsInByb20iLCJwbGF5IiwibXV0ZWQiLCJldmFsdWF0ZVZvbHVtZSIsIm1lZGlhVm9sdW1lIiwiZXZhbHVhdGVkIiwiZGlkV2FybiIsIndhcm5PbmNlMiIsInVzZU1lZGlhSW5UaW1lbGluZSIsImlzUHJlbW91bnRpbmciLCJhY3R1YWxGcm9tIiwiaW5pdGlhbFZvbHVtZSIsImRvZXNWb2x1bWVDaGFuZ2UiLCJ2b2x1bWVzIiwiQXJyYXkiLCJmaWxsIiwiTk9ERV9FTlYiLCJzdGFydE1lZGlhRnJvbSIsInVzZUNhbGxiYWNrOCIsInVzZUNvbnRleHQxOCIsInVzZUVmZmVjdDExIiwidXNlUmVmOSIsInVzZUNhbGxiYWNrNyIsInVzZU1lbW8xNiIsInVzZVJlZjYiLCJ1c2VDb250ZXh0MTciLCJ1c2VNZW1vMTUiLCJSZWFjdDEzIiwidXNlQ2FsbGJhY2s2IiwidXNlQ29udGV4dDE2IiwidXNlRWZmZWN0OCIsInVzZUxheW91dEVmZmVjdDQiLCJ1c2VNZW1vMTQiLCJ1c2VSZWY1IiwidXNlU3RhdGUxMCIsImpzeDE1IiwidXNlQnVmZmVyTWFuYWdlciIsImJsb2NrcyIsInNldEJsb2NrcyIsIm9uQnVmZmVyaW5nQ2FsbGJhY2tzIiwic2V0T25CdWZmZXJpbmdDYWxsYmFja3MiLCJvblJlc3VtZUNhbGxiYWNrcyIsInNldE9uUmVzdW1lQ2FsbGJhY2tzIiwiYnVmZmVyaW5nIiwiYWRkQmxvY2siLCJibG9jayIsInVuYmxvY2siLCJuZXdBcnIiLCJieCIsImxpc3RlbkZvckJ1ZmZlcmluZyIsImNhbGxiYWNrIiwicmVtb3ZlIiwiY2IiLCJsaXN0ZW5Gb3JSZXN1bWUiLCJCdWZmZXJpbmdDb250ZXh0UmVhY3QiLCJCdWZmZXJpbmdQcm92aWRlciIsImJ1ZmZlck1hbmFnZXIiLCJ1c2VJc1BsYXllckJ1ZmZlcmluZyIsImlzQnVmZmVyaW5nIiwic2V0SXNCdWZmZXJpbmciLCJvbkJ1ZmZlciIsIm9uUmVzdW1lIiwidXNlQnVmZmVyU3RhdGUiLCJidWZmZXIiLCJkZWxheVBsYXliYWNrIiwiaXNTYWZhcmlXZWJraXQiLCJpc1NhZmFyaSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInVzZUJ1ZmZlclVudGlsRmlyc3RGcmFtZSIsIm9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkIiwicGF1c2VXaGVuQnVmZmVyaW5nIiwiYnVmZmVyaW5nUmVmIiwiYnVmZmVyVW50aWxGaXJzdEZyYW1lIiwicmVxdWVzdGVkVGltZSIsInJlYWR5U3RhdGUiLCJIQVZFX0VOT1VHSF9EQVRBIiwicmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayIsInBsYXliYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSIsImRpZmZlcmVuY2VGcm9tUmVxdWVzdGVkIiwibWVkaWFUaW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsInVzZVJlZjciLCJ0b1NlY29uZHMiLCJyb3VuZCIsImlzSW9zU2FmYXJpIiwiaXNJcGFkSVBvZElQaG9uZSIsImlzQXBwbGVXZWJLaXQiLCJpc0lPU1NhZmFyaUFuZEJsb2IiLCJhY3R1YWxTcmMiLCJnZXRWaWRlb0ZyYWdtZW50U3RhcnQiLCJnZXRWaWRlb0ZyYWdtZW50RW5kIiwiYXBwZW5kVmlkZW9GcmFnbWVudCIsImV4aXN0aW5nSGFzaCIsIndpdGhTdGFydEhhc2giLCJpc1N1YnNldE9mRHVyYXRpb24iLCJwcmV2U3RhcnRGcm9tIiwibmV3U3RhcnRGcm9tIiwicHJldkR1cmF0aW9uIiwibmV3RHVyYXRpb24iLCJwcmV2aW91c0Zyb20iLCJuZXdGcm9tIiwicHJldmlvdXNFbmQiLCJuZXdFbmQiLCJ1c2VBcHBlbmRWaWRlb0ZyYWdtZW50IiwiaW5pdGlhbEFjdHVhbFNyYyIsImluaXRpYWxBY3R1YWxGcm9tIiwiaW5pdGlhbER1cmF0aW9uIiwiYWN0dWFsRnJvbVJlZiIsImFwcGVuZGVkIiwic2VlayIsIndoeSIsInRpbWVUb1NldCIsInRvRml4ZWQiLCJ1c2VFZmZlY3Q5IiwidXNlU3RhdGUxMSIsInVzZU1lZGlhQnVmZmVyaW5nIiwiZWxlbWVudCIsInNob3VsZEJ1ZmZlciIsImNsZWFudXBGbnMiLCJIQVZFX0ZVVFVSRV9EQVRBIiwibG9hZCIsImNsZWFudXAiLCJkaWREb1NvbWV0aGluZyIsImZuIiwicHJldmlvdXMiLCJibG9ja01lZGlhIiwib25DYW5QbGF5IiwiaW5pdCIsImNsZWFudXBSZWFzb24iLCJvbldhaXRpbmciLCJ1c2VFZmZlY3QxMCIsInVzZVJlZjgiLCJ1c2VSZXF1ZXN0VmlkZW9DYWxsYmFja1RpbWUiLCJsYXN0U2VlayIsInZpZGVvVGFnIiwiY2FuY2VsIiwicmVxdWVzdCIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlVG9MYXN0U2VlayIsImNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayIsImludGVycG9sYXRlRnVuY3Rpb24iLCJpbnB1dCIsImlucHV0UmFuZ2UiLCJvdXRwdXRSYW5nZSIsImV4dHJhcG9sYXRlTGVmdCIsImV4dHJhcG9sYXRlUmlnaHQiLCJlYXNpbmciLCJpbnB1dE1pbiIsImlucHV0TWF4Iiwib3V0cHV0TWluIiwib3V0cHV0TWF4IiwicmFuZ2UiLCJmaW5kUmFuZ2UiLCJjaGVja1ZhbGlkSW5wdXRSYW5nZSIsImFyciIsImNoZWNrSW5maW5pdGVSYW5nZSIsImludGVycG9sYXRlIiwibnVtIiwiZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQiLCJnZXRNZWRpYVRpbWUiLCJleHBlY3RlZEZyYW1lIiwibXNQZXJGcmFtZSIsImFscmVhZHlXYXJuZWQiLCJ3YXJuQWJvdXROb25TZWVrYWJsZU1lZGlhIiwic2Vla2FibGUiLCJlbmQiLCJtc2ciLCJ1c2VNZWRpYVBsYXliYWNrIiwibG9jYWxQbGF5YmFja1JhdGUiLCJvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yIiwiYWNjZXB0YWJsZVRpbWVzaGlmdCIsInVzZXJQcmVmZXJyZWRWb2x1bWUiLCJnbG9iYWxQbGF5YmFja1JhdGUiLCJtZWRpYVN0YXJ0c0F0IiwibGFzdFNlZWtEdWVUb1NoaWZ0IiwiaXNWYXJpYWJsZUZwc1ZpZGVvTWFwIiwiZGVzaXJlZFVuY2xhbXBlZFRpbWUiLCJpc01lZGlhVGFnQnVmZmVyaW5nIiwiYWNjZXB0YWJsZVRpbWVTaGlmdEJ1dExlc3NUaGFuRHVyYXRpb24iLCJERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfTk9STUFMX1BMQVlCQUNLIiwiREVGQVVMVF9BQ0NFUFRBQkxFX1RJTUVTSElGVF9XSVRIX0FNUExJRklDQVRJT04iLCJkZWZhdWx0QWNjZXB0YWJsZVRpbWVzaGlmdCIsImlzUGxheWVyQnVmZmVyaW5nIiwicGF1c2VkIiwicGF1c2UiLCJpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkIiwicGxheWVyQnVmZmVyaW5nTm90U3RhdGVCdXRMaXZlIiwidGFnTmFtZSIsInBsYXliYWNrUmF0ZVRvU2V0Iiwic2hvdWxkQmVUaW1lIiwibWVkaWFUYWdUaW1lIiwicnZjVGltZSIsImlzVmFyaWFibGVGcHNWaWRlbyIsInRpbWVTaGlmdE1lZGlhVGFnIiwidGltZVNoaWZ0UnZjVGFnIiwidGltZVNoaWZ0Iiwic2Vla1RocmVzaG9sZCIsIm1ha2VzU2Vuc2VUb1NlZWsiLCJpc1NvbWV0aGluZ0Vsc2VCdWZmZXJpbmciLCJwYXVzZWRDb25kaXRpb24iLCJlbmRlZCIsImZpcnN0RnJhbWVDb25kaXRpb24iLCJ1c2VDYWxsYmFjazkiLCJ1c2VFZmZlY3QxMiIsIkZMT0FUSU5HX1BPSU5UX0VSUk9SX1RIUkVTSE9MRCIsImlzQXBwcm94aW1hdGVseVRoZVNhbWUiLCJudW0xIiwibnVtMiIsInVzZVN5bmNWb2x1bWVXaXRoTWVkaWFUYWciLCJ2b2x1bWVQcm9wRnJhbWUiLCJhZGp1c3RWb2x1bWUiLCJtZWRpYSIsImhhbmRsZVZvbHVtZUNoYW5nZSIsImNyZWF0ZUNvbnRleHQxNSIsInVzZUNvbnRleHQxOSIsInVzZU1lbW8xNyIsIk1lZGlhVm9sdW1lQ29udGV4dCIsIm1lZGlhTXV0ZWQiLCJTZXRNZWRpYVZvbHVtZUNvbnRleHQiLCJzZXRNZWRpYU11dGVkIiwic2V0TWVkaWFWb2x1bWUiLCJ1c2VNZWRpYVZvbHVtZVN0YXRlIiwidXNlTWVkaWFNdXRlZFN0YXRlIiwiUmVhY3QxNCIsImNyZWF0ZUNvbnRleHQxNiIsImNyZWF0ZVJlZjIiLCJ1c2VDYWxsYmFjazEwIiwidXNlQ29udGV4dDIwIiwidXNlRWZmZWN0MTMiLCJ1c2VNZW1vMTgiLCJ1c2VSZWYxMCIsInVzZVN0YXRlMTIiLCJqc3gxNiIsImpzeHMiLCJFTVBUWV9BVURJTyIsImNvbXBhcmVQcm9wcyIsIm9iajEiLCJvYmoyIiwia2V5c0EiLCJrZXlzIiwia2V5c0IiLCJkaWRQcm9wQ2hhbmdlIiwibmV3UHJvcCIsInByZXZQcm9wIiwidG9TdHJpbmciLCJTaGFyZWRBdWRpb0NvbnRleHQiLCJTaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlciIsIm51bWJlck9mQXVkaW9UYWdzIiwiYXVkaW9zIiwiaW5pdGlhbE51bWJlck9mQXVkaW9UYWdzIiwicmVmcyIsInRha2VuQXVkaW9zIiwicmVyZW5kZXJBdWRpb3MiLCJyZWdpc3RlckF1ZGlvIiwiYXVkIiwiYXVkaW9JZCIsImZvdW5kIiwiZmlyc3RGcmVlQXVkaW8iLCJmaW5kSW5kZXgiLCJjbG9uZWQiLCJuZXdFbGVtIiwiZWwiLCJ1bnJlZ2lzdGVyQXVkaW8iLCJpbmRleCIsInVwZGF0ZUF1ZGlvIiwiY2hhbmdlZCIsInByZXZBIiwicGxheUFsbEF1ZGlvcyIsInJlc2V0QXVkaW8iLCJwcmVsb2FkIiwidXNlU2hhcmVkQXVkaW8iLCJlbGVtIiwiZWZmZWN0VG9Vc2UiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJkb2N1bWVudCIsImpzeDE3IiwiQXVkaW9Gb3JEZXZlbG9wbWVudEZvcndhcmRSZWZGdW5jdGlvbiIsImluaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHMiLCJzaG91bGRQcmVNb3VudEF1ZGlvVGFncyIsIm9uRHVyYXRpb24iLCJhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzIiwiX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb24iLCJfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQiLCJhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIiLCJsb29wVm9sdW1lQ3VydmVCZWhhdmlvciIsIm5hdGl2ZVByb3BzIiwicHJlbG9hZGVkU3JjIiwidGltZWxpbmVJZCIsInByb3BzVG9QYXNzIiwiYXVkaW9SZWYiLCJjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrIiwib25Mb2FkZWRNZXRhZGF0YSIsIkF1ZGlvRm9yUHJldmlldyIsImZvcndhcmRSZWY1IiwidXNlQ29udGV4dDIyIiwidXNlRWZmZWN0MTUiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlNiIsInVzZUxheW91dEVmZmVjdDUiLCJ1c2VNZW1vMjAiLCJ1c2VSZWYxMiIsImpzeDE4IiwiQXVkaW9Gb3JSZW5kZXJpbmdSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJ2b2x1bWVQcm9wIiwidG9uZUZyZXF1ZW5jeSIsImRlbGF5UmVuZGVyUmV0cmllcyIsImRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzIiwicmVtb3Rpb25fYXVkaW9FbmFibGVkIiwibWVkaWFGcmFtZSIsImF1ZGlvU3RhcnRGcmFtZSIsIm5lZWRzVG9SZW5kZXJBdWRpb1RhZyIsIm5ld0hhbmRsZSIsImRpZExvYWQiLCJBdWRpb0ZvclJlbmRlcmluZyIsImpzeDE5IiwiQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJwcm9wc090aGVyVGhhbkxvb3AiLCJlbnZpcm9ubWVudCIsImUiLCJjdXJyZW50VGFyZ2V0IiwiZXJyTWVzc2FnZSIsImR1cmF0aW9uRmV0Y2hlZCIsIkF1ZGlvIiwic3RhcnRGcm9tRnJhbWVObyIsImVuZEF0RnJhbWVObyIsIlN1c3BlbnNlIiwidXNlQ29udGV4dDI1IiwidXNlRWZmZWN0MTciLCJjcmVhdGVQb3J0YWwiLCJjcmVhdGVDb250ZXh0MTciLCJ1c2VDb250ZXh0MjQiLCJ1c2VFZmZlY3QxNiIsInVzZU1lbW8yMSIsImdldFJlZ2V4IiwiaXNGb2xkZXJOYW1lVmFsaWQiLCJ2YWxpZGF0ZUZvbGRlck5hbWUiLCJpbnZhbGlkRm9sZGVyTmFtZUVycm9yTWVzc2FnZSIsImpzeDIwIiwiRm9sZGVyQ29udGV4dCIsImZvbGRlck5hbWUiLCJwYXJlbnROYW1lIiwiRm9sZGVyIiwicGFyZW50TmFtZUFyciIsImpzeDIxIiwianN4czIiLCJyb3RhdGUiLCJ0cmFuc2Zvcm0iLCJJQ09OX1NJWkUiLCJjb2xvciIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImNvbnRhaW5lciIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsIkxvYWRpbmciLCJ2aWV3Qm94Iiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VMaW5lam9pbiIsIl9wb3J0YWxOb2RlIiwicG9ydGFsTm9kZSIsImNvbnRhaW5lck5vZGUiLCJhcHBlbmRDaGlsZCIsIlJlYWN0MTgiLCJ1c2VNZW1vMjIiLCJ1c2VMYXp5Q29tcG9uZW50IiwiY29tcFByb3BzIiwiY29tcG9uZW50TmFtZSIsIm5vU3VzcGVuc2UiLCJsYXp5IiwiZGVmYXVsdCIsImxhenlDb21wb25lbnQiLCJnZXRSZWdleDIiLCJpc0NvbXBvc2l0aW9uSWRWYWxpZCIsInZhbGlkYXRlQ29tcG9zaXRpb25JZCIsImludmFsaWRDb21wb3NpdGlvbkVycm9yTWVzc2FnZSIsInZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMiLCJpc0FycmF5IiwianN4MjIiLCJGYWxsYmFjayIsImZhbGxiYWNrIiwiSW5uZXJDb21wb3NpdGlvbiIsInNjaGVtYSIsImNvbXBNYW5hZ2VyIiwiY2FuVXNlQ29tcG9zaXRpb24iLCJwYXJlbnRGb2xkZXJOYW1lIiwiQ29tcCIsIkNvbXBvc2l0aW9uIiwicHJvcHMyIiwiTkVXVE9OX0lURVJBVElPTlMiLCJORVdUT05fTUlOX1NMT1BFIiwiU1VCRElWSVNJT05fUFJFQ0lTSU9OIiwiU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMiLCJrU3BsaW5lVGFibGVTaXplIiwia1NhbXBsZVN0ZXBTaXplIiwiZmxvYXQzMkFycmF5U3VwcG9ydGVkIiwiRmxvYXQzMkFycmF5IiwiYUExIiwiYUEyIiwiY2FsY0JlemllciIsImFUIiwiZ2V0U2xvcGUiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsIl9hQSIsIl9hQiIsIm1YMSIsIm1YMiIsImN1cnJlbnRYIiwiY3VycmVudFQiLCJhQSIsImFCIiwibmV3dG9uUmFwaHNvbkl0ZXJhdGUiLCJfYUd1ZXNzVCIsImFHdWVzc1QiLCJjdXJyZW50U2xvcGUiLCJiZXppZXIiLCJtWTEiLCJtWTIiLCJzYW1wbGVWYWx1ZXMiLCJnZXRURm9yWCIsImludGVydmFsU3RhcnQiLCJjdXJyZW50U2FtcGxlIiwibGFzdFNhbXBsZSIsImRpc3QiLCJndWVzc0ZvclQiLCJpbml0aWFsU2xvcGUiLCJ4IiwiRWFzaW5nIiwic3RlcDAiLCJuIiwic3RlcDEiLCJsaW5lYXIiLCJlYXNlIiwicXVhZCIsImN1YmljIiwicG9seSIsInNpbiIsImNvcyIsIlBJIiwiY2lyY2xlIiwic3FydCIsImV4cCIsImVsYXN0aWMiLCJib3VuY2luZXNzIiwiYmFjayIsImJvdW5jZSIsInQyXyIsInQyIiwieDEiLCJ5MSIsIngyIiwieTIiLCJpbiIsIm91dCIsImluT3V0IiwiRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMiLCJ3YXJuZWRTZXJ2ZXIiLCJ3YXJuZWRQbGF5ZXIiLCJ3YXJuU2VydmVyT25jZSIsIndhcm5QbGF5ZXJPbmNlIiwiZ2V0U3RhdGljRmlsZXMiLCJyZW1vdGlvbl9zdGF0aWNGaWxlcyIsImZvcndhcmRSZWY3IiwidXNlQ2FsbGJhY2sxMiIsInVzZVN0YXRlMTQiLCJqc3gyMyIsIklGcmFtZVJlZkZvcndhcmRpbmciLCJvbkxvYWQiLCJkaWRHZXRFcnJvciIsIklGcmFtZSIsImZvcndhcmRSZWY4IiwidXNlQ2FsbGJhY2sxMyIsInVzZUNvbnRleHQyNiIsInVzZUltcGVyYXRpdmVIYW5kbGU3IiwidXNlTGF5b3V0RWZmZWN0NiIsInVzZVJlZjEzIiwianN4MjQiLCJleHBvbmVudGlhbEJhY2tvZmYiLCJlcnJvckNvdW50IiwiSW1nUmVmRm9yd2FyZGluZyIsIm1heFJldHJpZXMiLCJwYXVzZVdoZW5Mb2FkaW5nIiwib25JbWFnZUZyYW1lIiwiaW1hZ2VSZWYiLCJlcnJvcnMiLCJyZXRyeUluIiwiY3VycmVudFNyYyIsIm5ld1NyYyIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImJhY2tvZmYiLCJ1bm1vdW50ZWQiLCJvbkNvbXBsZXRlIiwiY29tcGxldGUiLCJJbWciLCJjcmVhdGVSZWYzIiwiUmVhY3QyMiIsInVzZUNhbGxiYWNrMTQiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlOCIsInVzZU1lbW8yMyIsInVzZVJlZjE0IiwidXNlU3RhdGUxNSIsImpzeDI1IiwiY29tcG9zaXRpb25zUmVmIiwiQ29tcG9zaXRpb25NYW5hZ2VyUHJvdmlkZXIiLCJzZXRDb21wb3NpdGlvbnMiLCJjdXJyZW50Y29tcG9zaXRpb25zUmVmIiwic2V0Rm9sZGVycyIsInVwZGF0ZUNvbXBvc2l0aW9ucyIsInVwZGF0ZUNvbXBzIiwiY29tcHMiLCJ1cGRhdGVkIiwiY29tcCIsImMyIiwiYTIiLCJiMiIsInByZXZGb2xkZXJzIiwiZ2V0Q29tcG9zaXRpb25zIiwibmV3RGVmYXVsdFByb3BzIiwic2V0dGVycyIsImV4cG9ydHNfZGVmYXVsdF9jc3MiLCJtYWtlRGVmYXVsdFByZXZpZXdDU1MiLCJpbmplY3RDU1MiLCJPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRSIsImluamVjdGVkIiwiY3NzIiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiY3JlYXRlVGV4dE5vZGUiLCJwcmVwZW5kIiwic2NvcGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJSRU1PVElPTl9TVFVESU9fQ09OVEFJTkVSX0VMRU1FTlQiLCJnZXRQcmV2aWV3RG9tRWxlbWVudCIsImdldEVsZW1lbnRCeUlkIiwiUm9vdCIsImxpc3RlbmVycyIsInJlZ2lzdGVyUm9vdCIsImwiLCJnZXRSb290Iiwid2FpdEZvclJvb3QiLCJ1c2VFZmZlY3QxOCIsInVzZUxheW91dEVmZmVjdDciLCJ1c2VNZW1vMjQiLCJ1c2VSZWYxNSIsInVzZVN0YXRlMTYiLCJqc3gyNiIsIlJlbW90aW9uUm9vdCIsInJlbW90aW9uUm9vdElkIiwic2V0RmFzdFJlZnJlc2hlcyIsInJlbW90aW9uX3NldEZyYW1lIiwiYXR0ZW1wdCIsImFzeW5jVXBkYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGltZWxpbmVDb250ZXh0VmFsdWUiLCJzZXRUaW1lbGluZUNvbnRleHRWYWx1ZSIsIm5vbmNlQ29udGV4dCIsImNvdW50ZXIiLCJfX3dlYnBhY2tfbW9kdWxlX18iLCJob3QiLCJhZGRTdGF0dXNIYW5kbGVyIiwibG9nZ2luZyIsImdldEVudlZhcmlhYmxlcyIsInJlbW90aW9uX2VudlZhcmlhYmxlcyIsInNldHVwRW52VmFyaWFibGVzIiwiUmVhY3QyNCIsImNyZWF0ZUNvbnRleHQxOCIsIkN1cnJlbnRTY2FsZUNvbnRleHQiLCJQcmV2aWV3U2l6ZUNvbnRleHQiLCJzZXRTaXplIiwic2l6ZSIsInRyYW5zbGF0aW9uIiwieSIsImNhbGN1bGF0ZVNjYWxlIiwicHJldmlld1NpemUiLCJoZWlnaHRSYXRpbyIsIndpZHRoUmF0aW8iLCJ1c2VDdXJyZW50U2NhbGUiLCJoYXNDb250ZXh0Iiwiem9vbUNvbnRleHQiLCJjb25maWciLCJkb250VGhyb3dJZk91dHNpZGVPZlJlbW90aW9uIiwic2NhbGUiLCJXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMiLCJ3YXRjaFN0YXRpY0ZpbGUiLCJmaWxlTmFtZSIsIndpdGhvdXRTdGF0aWNCYXNlIiwid2l0aG91dExlYWRpbmdTbGFzaCIsInByZXZGaWxlRGF0YSIsImZpbGUiLCJjaGVja0ZpbGUiLCJldmVudCIsInN0YXRpY0ZpbGVzIiwiZmlsZXMiLCJuZXdGaWxlRGF0YSIsImxhc3RNb2RpZmllZCIsIlJlYWN0MjUiLCJ1c2VNZW1vMjUiLCJqc3gyNyIsInVzZVJlbW90aW9uQ29udGV4dHMiLCJjb21wb3NpdGlvbk1hbmFnZXJDdHgiLCJzZXRUaW1lbGluZUNvbnRleHQiLCJjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCIsInByZWxvYWRDb250ZXh0IiwicmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCIsInJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQiLCJzZXF1ZW5jZU1hbmFnZXJDb250ZXh0IiwiYnVmZmVyTWFuYWdlckNvbnRleHQiLCJsb2dMZXZlbENvbnRleHQiLCJSZW1vdGlvbkNvbnRleHRQcm92aWRlciIsImNvbnRleHRzIiwiY29tcG9zaXRpb25TZWxlY3RvclJlZiIsIkludGVybmFscyIsIlRpbWVsaW5lIiwiQ1NTVXRpbHMiLCJOVU1CRVIiLCJQRVJDRU5UQUdFIiwiY2FsbCIsImdldE1hdGNoZXJzIiwiY2FjaGVkTWF0Y2hlcnMiLCJyZ2IiLCJyZ2JhIiwiaHNsIiwiaHNsYSIsImhleDMiLCJoZXg0IiwiaGV4NSIsImhleDYiLCJoZXg4IiwiUmVnRXhwIiwiaHVlMnJnYiIsInEiLCJoc2xUb1JnYiIsImciLCJwYXJzZTI1NSIsImludCIsInBhcnNlMzYwIiwicGFyc2VGbG9hdCIsInBhcnNlMSIsInBhcnNlUGVyY2VudGFnZSIsImNvbG9yTmFtZXMiLCJ0cmFuc3BhcmVudCIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYWNrIiwiYmxhbmNoZWRhbG1vbmQiLCJibHVlIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiYnVybnRzaWVubmEiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImdyZXkiLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicmVkIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0YW4iLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93IiwieWVsbG93Z3JlZW4iLCJub3JtYWxpemVDb2xvciIsIm1hdGNoZXJzIiwiZXhlYyIsInJnYmFDb2xvciIsImFscGhhIiwicHJvY2Vzc0NvbG9yIiwibm9ybWFsaXplZENvbG9yIiwiaW50ZXJwb2xhdGVDb2xvcnNSR0IiLCJjb2xvcnMiLCJ1bnJvdW5kZWQiLCJpbnRlcnBvbGF0ZUNvbG9ycyIsInByb2Nlc3NlZE91dHB1dFJhbmdlIiwidmFsaWRhdGVGcmFtZSIsIlJhbmdlRXJyb3IiLCJnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSIsInRvbmVNYXBwZWQiLCJyZW1vdGlvbl9wcm94eVBvcnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJDaGlsZHJlbiIsImZvcndhcmRSZWY5IiwidXNlTWVtbzI2IiwiUmVhY3QyNiIsImZsYXR0ZW5DaGlsZHJlbiIsImNoaWxkcmVuQXJyYXkiLCJ0b0FycmF5IiwiZmxhdENoaWxkcmVuIiwiY2hpbGQiLCJGcmFnbWVudCIsImNvbmNhdCIsIlJlYWN0MjciLCJjcmVhdGVDb250ZXh0MTkiLCJqc3gyOCIsIklzSW5zaWRlU2VyaWVzQ29udGV4dCIsIklzSW5zaWRlU2VyaWVzQ29udGFpbmVyIiwiSXNOb3RJbnNpZGVTZXJpZXNQcm92aWRlciIsInVzZVJlcXVpcmVUb0JlSW5zaWRlU2VyaWVzIiwiaXNJbnNpZGVTZXJpZXMiLCJqc3gyOSIsIlNlcmllc1NlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uIiwiX3JlZiIsIlNlcmllc1NlcXVlbmNlIiwiU2VyaWVzIiwiY2hpbGRyZW5WYWx1ZSIsInN0YXJ0RnJhbWUiLCJmbGF0dGVuZWRDaGlsZHJlbiIsImNhc3RlZENoaWxkIiwiZGVidWdJbmZvIiwiZHVyYXRpb25JbkZyYW1lc1Byb3AiLCJfY2hpbGRyZW4iLCJwYXNzZWRQcm9wcyIsIm9mZnNldCIsImN1cnJlbnRTdGFydEZyYW1lIiwidmFsaWRhdGVTcHJpbmdEdXJhdGlvbiIsImR1ciIsImRlZmF1bHRTcHJpbmdDb25maWciLCJkYW1waW5nIiwibWFzcyIsInN0aWZmbmVzcyIsIm92ZXJzaG9vdENsYW1waW5nIiwiYWR2YW5jZUNhY2hlIiwiYWR2YW5jZSIsImFuaW1hdGlvbiIsInRvVmFsdWUiLCJsYXN0VGltZXN0YW1wIiwidmVsb2NpdHkiLCJkZWx0YVRpbWUiLCJtIiwiayIsImNhY2hlS2V5IiwidjAiLCJ4MCIsInpldGEiLCJvbWVnYTAiLCJvbWVnYTEiLCJzaW4xIiwiY29zMSIsInVuZGVyRGFtcGVkRW52ZWxvcGUiLCJ1bmRlckRhbXBlZEZyYWcxIiwidW5kZXJEYW1wZWRQb3NpdGlvbiIsInVuZGVyRGFtcGVkVmVsb2NpdHkiLCJjcml0aWNhbGx5RGFtcGVkRW52ZWxvcGUiLCJjcml0aWNhbGx5RGFtcGVkUG9zaXRpb24iLCJjcml0aWNhbGx5RGFtcGVkVmVsb2NpdHkiLCJhbmltYXRpb25Ob2RlIiwicHJldlBvc2l0aW9uIiwiY2FsY3VsYXRpb25DYWNoZSIsInNwcmluZ0NhbGN1bGF0aW9uIiwidG8iLCJmcmFtZUNsYW1wZWQiLCJ1bmV2ZW5SZXN0IiwibWVhc3VyZVNwcmluZyIsInRocmVzaG9sZCIsImhhcyIsImZpbmlzaGVkRnJhbWUiLCJjYWxjIiwiY2FsY0RpZmZlcmVuY2UiLCJzcHJpbmciLCJwYXNzZWRGcmFtZSIsInBhc3NlZER1cmF0aW9uSW5GcmFtZXMiLCJkdXJhdGlvblJlc3RUaHJlc2hvbGQiLCJyZXZlcnNlIiwibmVlZHNUb0NhbGN1bGF0ZU5hdHVyYWxEdXJhdGlvbiIsIm5hdHVyYWxEdXJhdGlvbiIsIm5hdHVyYWxEdXJhdGlvbkdldHRlciIsInJldmVyc2VQcm9jZXNzZWQiLCJkZWxheVByb2Nlc3NlZCIsImR1cmF0aW9uUHJvY2Vzc2VkIiwic3ByIiwiaW5uZXIiLCJpbnRlcnBvbGF0ZWQiLCJwcm9ibGVtYXRpY0NoYXJhY3RlcnMiLCJkaWRXYXJuMiIsIndhcm5PbmNlMyIsImluY2x1ZGVzSGV4T2ZVbnNhZmVDaGFyIiwicGF0aCIsImNvbnRhaW5zSGV4IiwiaGV4Q29kZSIsInRyaW1MZWFkaW5nU2xhc2giLCJlbmNvZGVCeVNwbGl0dGluZyIsInNwbGl0QnlTbGFzaCIsImVuY29kZWRBcnJheSIsIm1lcmdlZCIsInN0YXRpY0ZpbGUiLCJpbmNsdWRlc0hleCIsInByZXByb2Nlc3NlZCIsInByZXBhcnNlZCIsIlJlYWN0MjkiLCJTdGlsbCIsInVzZUNhbGxiYWNrMTYiLCJ1c2VDYWxsYmFjazE1IiwidXNlQ29udGV4dDI3IiwidXNlRWZmZWN0MTkiLCJ1c2VMYXlvdXRFZmZlY3Q4IiwidXNlTWVtbzI3IiwidXNlU3RhdGUxNyIsImpzeDMwIiwiT2ZmdGhyZWFkVmlkZW9Gb3JSZW5kZXJpbmciLCJvblZpZGVvRnJhbWUiLCJjcm9zc09yaWdpbiIsInZvbHVtZVByb3BzRnJhbWUiLCJpbWFnZVNyYyIsInNldEltYWdlU3JjIiwicmVtb3Rpb25fdmlkZW9FbmFibGVkIiwiZXhlY3V0ZSIsImpzb24iLCJjbGVhbmVkVXBFcnJvck1lc3NhZ2UiLCJjYXVzZSIsIm9uRXJyIiwiaW1nIiwiZm9yd2FyZFJlZjEwIiwidXNlQ29udGV4dDI4IiwidXNlRWZmZWN0MjEiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlOSIsInVzZU1lbW8yOCIsInVzZVJlZjE2IiwidXNlU3RhdGUxOCIsInVzZUVmZmVjdDIwIiwidXNlRW1pdFZpZGVvRnJhbWUiLCJqc3gzMSIsIlZpZGVvRm9yRGV2ZWxvcG1lbnRSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJ2aWRlb1JlZiIsImFjY2VwdGFibGVUaW1lU2hpZnQiLCJlcnJvckhhbmRsZXIiLCJjb2RlIiwiY3Jvc3NPcmlnaW5WYWx1ZSIsInBsYXlzSW5saW5lIiwiZGlzYWJsZVJlbW90ZVBsYXliYWNrIiwiVmlkZW9Gb3JQcmV2aWV3IiwianN4MzIiLCJPZmZ0aHJlYWRWaWRlbyIsImltYWdlRm9ybWF0IiwicHJvcHNGb3JQcmV2aWV3IiwiZm9yd2FyZFJlZjEyIiwidXNlQ2FsbGJhY2sxNyIsInVzZUNvbnRleHQzMCIsImZvcndhcmRSZWYxMSIsInVzZUNvbnRleHQyOSIsInVzZUVmZmVjdDIyIiwidXNlSW1wZXJhdGl2ZUhhbmRsZTEwIiwidXNlTGF5b3V0RWZmZWN0OSIsInVzZU1lbW8yOSIsInVzZVJlZjE3Iiwicm91bmRUbzZDb21tYXMiLCJzZWVrVG9UaW1lIiwiZGVzaXJlZFRpbWUiLCJ3YWl0IiwiY2FuY2VsU2Vla2VkIiwibWV0YWRhdGEiLCJkaXNwbGF5SW4iLCJleHBlY3RlZERpc3BsYXlUaW1lIiwid2FpdEZvclNlZWtlZEV2ZW50Iiwib25Eb25lIiwic2Vla1RvVGltZU11bHRpcGxlVW50aWxSaWdodCIsImN1cnJlbnRDYW5jZWwiLCJmaXJzdFNlZWsiLCJzZWVrZWRUbyIsInNpZ24iLCJuZXdTZWVrIiwibmV3VGltZSIsIm5ld0RpZmZlcmVuY2UiLCJ0aGlyZFNlZWsiLCJqc3gzMyIsIlZpZGVvRm9yUmVuZGVyaW5nRm9yd2FyZEZ1bmN0aW9uIiwibG9hZGVkRGF0YUhhbmRsZXIiLCJlbmRlZEhhbmRsZXIiLCJzZWVrMiIsIlZpZGVvRm9yUmVuZGVyaW5nIiwianN4MzQiLCJWaWRlb0ZvcndhcmRpbmdGdW5jdGlvbiIsIlZpZGVvIiwiRXhwZXJpbWVudGFsIiwicHJveHlPYmoiLCJDb25maWciLCJwcm9wIiwiZXhpdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/remotion/dist/esm/no-react.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/remotion/dist/esm/no-react.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoReactInternals: () => (/* binding */ NoReactInternals),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   random: () => (/* binding */ random)\n/* harmony export */ });\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n    const { extrapolateLeft, extrapolateRight, easing } = options;\n    let result = input;\n    const [inputMin, inputMax] = inputRange;\n    const [outputMin, outputMax] = outputRange;\n    if (result < inputMin) {\n        if (extrapolateLeft === \"identity\") {\n            return result;\n        }\n        if (extrapolateLeft === \"clamp\") {\n            result = inputMin;\n        } else if (extrapolateLeft === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateLeft === \"extend\") {}\n    }\n    if (result > inputMax) {\n        if (extrapolateRight === \"identity\") {\n            return result;\n        }\n        if (extrapolateRight === \"clamp\") {\n            result = inputMax;\n        } else if (extrapolateRight === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateRight === \"extend\") {}\n    }\n    if (outputMin === outputMax) {\n        return outputMin;\n    }\n    result = (result - inputMin) / (inputMax - inputMin);\n    result = easing(result);\n    result = result * (outputMax - outputMin) + outputMin;\n    return result;\n}\nfunction findRange(input, inputRange) {\n    let i;\n    for(i = 1; i < inputRange.length - 1; ++i){\n        if (inputRange[i] >= input) {\n            break;\n        }\n    }\n    return i - 1;\n}\nfunction checkValidInputRange(arr) {\n    for(let i = 1; i < arr.length; ++i){\n        if (!(arr[i] > arr[i - 1])) {\n            throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction checkInfiniteRange(name, arr) {\n    if (arr.length < 2) {\n        throw new Error(name + \" must have at least 2 elements\");\n    }\n    for (const element of arr){\n        if (typeof element !== \"number\") {\n            throw new Error(`${name} must contain only numbers`);\n        }\n        if (!Number.isFinite(element)) {\n            throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n    if (typeof input === \"undefined\") {\n        throw new Error(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new Error(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new Error(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n    }\n    checkInfiniteRange(\"inputRange\", inputRange);\n    checkInfiniteRange(\"outputRange\", outputRange);\n    checkValidInputRange(inputRange);\n    const easing = options?.easing ?? ((num)=>num);\n    let extrapolateLeft = \"extend\";\n    if (options?.extrapolateLeft !== undefined) {\n        extrapolateLeft = options.extrapolateLeft;\n    }\n    let extrapolateRight = \"extend\";\n    if (options?.extrapolateRight !== undefined) {\n        extrapolateRight = options.extrapolateRight;\n    }\n    if (typeof input !== \"number\") {\n        throw new TypeError(\"Cannot interpolate an input which is not a number\");\n    }\n    const range = findRange(input, inputRange);\n    return interpolateFunction(input, [\n        inputRange[range],\n        inputRange[range + 1]\n    ], [\n        outputRange[range],\n        outputRange[range + 1]\n    ], {\n        easing,\n        extrapolateLeft,\n        extrapolateRight\n    });\n}\n// src/random.ts\nfunction mulberry32(a) {\n    let t = a + 1831565813;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n    let i = 0;\n    let chr = 0;\n    let hash = 0;\n    for(i = 0; i < str.length; i++){\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0;\n    }\n    return hash;\n}\nvar random = (seed, dummy)=>{\n    if (dummy !== undefined) {\n        throw new TypeError(\"random() takes only one argument\");\n    }\n    if (seed === null) {\n        return Math.random();\n    }\n    if (typeof seed === \"string\") {\n        return mulberry32(hashCode(seed));\n    }\n    if (typeof seed === \"number\") {\n        return mulberry32(seed * 10000000000);\n    }\n    throw new Error(\"random() argument must be a number or a string\");\n};\n// src/truthy.ts\nfunction truthy(value) {\n    return Boolean(value);\n}\n// src/delay-render.ts\nif (false) {}\nif (false) {}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar DELAY_RENDER_CLEAR_TOKEN = \"handle was cleared after\";\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithDate = ({ data, indent, staticBase })=>{\n    let customDateUsed = false;\n    let customFileUsed = false;\n    let mapUsed = false;\n    let setUsed = false;\n    try {\n        const serializedString = JSON.stringify(data, function(key, value) {\n            const item = this[key];\n            if (item instanceof Date) {\n                customDateUsed = true;\n                return `${DATE_TOKEN}${item.toISOString()}`;\n            }\n            if (item instanceof Map) {\n                mapUsed = true;\n                return value;\n            }\n            if (item instanceof Set) {\n                setUsed = true;\n                return value;\n            }\n            if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n                customFileUsed = true;\n                return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n            }\n            return value;\n        }, indent);\n        return {\n            serializedString,\n            customDateUsed,\n            customFileUsed,\n            mapUsed,\n            setUsed\n        };\n    } catch (err) {\n        throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n    }\n};\nvar deserializeJSONWithCustomFields = (data)=>{\n    return JSON.parse(data, (_, value)=>{\n        if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n            return new Date(value.replace(DATE_TOKEN, \"\"));\n        }\n        if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n            return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, \"\")}`;\n        }\n        return value;\n    });\n};\n// src/interpolate-colors.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...args) {\n    return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n    const cachedMatchers = {\n        rgb: undefined,\n        rgba: undefined,\n        hsl: undefined,\n        hsla: undefined,\n        hex3: undefined,\n        hex4: undefined,\n        hex5: undefined,\n        hex6: undefined,\n        hex8: undefined\n    };\n    if (cachedMatchers.rgb === undefined) {\n        cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n        cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n        cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n        cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n        cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n        cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n    }\n    return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 1 / 2) {\n        return q;\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n}\nfunction hslToRgb(h, s, l) {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    const r = hue2rgb(p, q, h + 1 / 3);\n    const g = hue2rgb(p, q, h);\n    const b = hue2rgb(p, q, h - 1 / 3);\n    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;\n}\nfunction parse255(str) {\n    const int = Number.parseInt(str, 10);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 255) {\n        return 255;\n    }\n    return int;\n}\nfunction parse360(str) {\n    const int = Number.parseFloat(str);\n    return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n    const num = Number.parseFloat(str);\n    if (num < 0) {\n        return 0;\n    }\n    if (num > 1) {\n        return 255;\n    }\n    return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n    const int = Number.parseFloat(str);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 100) {\n        return 1;\n    }\n    return int / 100;\n}\nvar colorNames = {\n    transparent: 0,\n    aliceblue: 4042850303,\n    antiquewhite: 4209760255,\n    aqua: 16777215,\n    aquamarine: 2147472639,\n    azure: 4043309055,\n    beige: 4126530815,\n    bisque: 4293182719,\n    black: 255,\n    blanchedalmond: 4293643775,\n    blue: 65535,\n    blueviolet: 2318131967,\n    brown: 2771004159,\n    burlywood: 3736635391,\n    burntsienna: 3934150143,\n    cadetblue: 1604231423,\n    chartreuse: 2147418367,\n    chocolate: 3530104575,\n    coral: 4286533887,\n    cornflowerblue: 1687547391,\n    cornsilk: 4294499583,\n    crimson: 3692313855,\n    cyan: 16777215,\n    darkblue: 35839,\n    darkcyan: 9145343,\n    darkgoldenrod: 3095792639,\n    darkgray: 2846468607,\n    darkgreen: 6553855,\n    darkgrey: 2846468607,\n    darkkhaki: 3182914559,\n    darkmagenta: 2332068863,\n    darkolivegreen: 1433087999,\n    darkorange: 4287365375,\n    darkorchid: 2570243327,\n    darkred: 2332033279,\n    darksalmon: 3918953215,\n    darkseagreen: 2411499519,\n    darkslateblue: 1211993087,\n    darkslategray: 793726975,\n    darkslategrey: 793726975,\n    darkturquoise: 13554175,\n    darkviolet: 2483082239,\n    deeppink: 4279538687,\n    deepskyblue: 12582911,\n    dimgray: 1768516095,\n    dimgrey: 1768516095,\n    dodgerblue: 512819199,\n    firebrick: 2988581631,\n    floralwhite: 4294635775,\n    forestgreen: 579543807,\n    fuchsia: 4278255615,\n    gainsboro: 3705462015,\n    ghostwhite: 4177068031,\n    gold: 4292280575,\n    goldenrod: 3668254975,\n    gray: 2155905279,\n    green: 8388863,\n    greenyellow: 2919182335,\n    grey: 2155905279,\n    honeydew: 4043305215,\n    hotpink: 4285117695,\n    indianred: 3445382399,\n    indigo: 1258324735,\n    ivory: 4294963455,\n    khaki: 4041641215,\n    lavender: 3873897215,\n    lavenderblush: 4293981695,\n    lawngreen: 2096890111,\n    lemonchiffon: 4294626815,\n    lightblue: 2916673279,\n    lightcoral: 4034953471,\n    lightcyan: 3774873599,\n    lightgoldenrodyellow: 4210742015,\n    lightgray: 3553874943,\n    lightgreen: 2431553791,\n    lightgrey: 3553874943,\n    lightpink: 4290167295,\n    lightsalmon: 4288707327,\n    lightseagreen: 548580095,\n    lightskyblue: 2278488831,\n    lightslategray: 2005441023,\n    lightslategrey: 2005441023,\n    lightsteelblue: 2965692159,\n    lightyellow: 4294959359,\n    lime: 16711935,\n    limegreen: 852308735,\n    linen: 4210091775,\n    magenta: 4278255615,\n    maroon: 2147483903,\n    mediumaquamarine: 1724754687,\n    mediumblue: 52735,\n    mediumorchid: 3126187007,\n    mediumpurple: 2473647103,\n    mediumseagreen: 1018393087,\n    mediumslateblue: 2070474495,\n    mediumspringgreen: 16423679,\n    mediumturquoise: 1221709055,\n    mediumvioletred: 3340076543,\n    midnightblue: 421097727,\n    mintcream: 4127193855,\n    mistyrose: 4293190143,\n    moccasin: 4293178879,\n    navajowhite: 4292783615,\n    navy: 33023,\n    oldlace: 4260751103,\n    olive: 2155872511,\n    olivedrab: 1804477439,\n    orange: 4289003775,\n    orangered: 4282712319,\n    orchid: 3664828159,\n    palegoldenrod: 4008225535,\n    palegreen: 2566625535,\n    paleturquoise: 2951671551,\n    palevioletred: 3681588223,\n    papayawhip: 4293907967,\n    peachpuff: 4292524543,\n    peru: 3448061951,\n    pink: 4290825215,\n    plum: 3718307327,\n    powderblue: 2967529215,\n    purple: 2147516671,\n    rebeccapurple: 1714657791,\n    red: 4278190335,\n    rosybrown: 3163525119,\n    royalblue: 1097458175,\n    saddlebrown: 2336560127,\n    salmon: 4202722047,\n    sandybrown: 4104413439,\n    seagreen: 780883967,\n    seashell: 4294307583,\n    sienna: 2689740287,\n    silver: 3233857791,\n    skyblue: 2278484991,\n    slateblue: 1784335871,\n    slategray: 1887473919,\n    slategrey: 1887473919,\n    snow: 4294638335,\n    springgreen: 16744447,\n    steelblue: 1182971135,\n    tan: 3535047935,\n    teal: 8421631,\n    thistle: 3636451583,\n    tomato: 4284696575,\n    turquoise: 1088475391,\n    violet: 4001558271,\n    wheat: 4125012991,\n    white: 4294967295,\n    whitesmoke: 4126537215,\n    yellow: 4294902015,\n    yellowgreen: 2597139199\n};\nfunction normalizeColor(color) {\n    const matchers = getMatchers();\n    let match;\n    if (matchers.hex6) {\n        if (match = matchers.hex6.exec(color)) {\n            return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (colorNames[color] !== undefined) {\n        return colorNames[color];\n    }\n    if (matchers.rgb) {\n        if (match = matchers.rgb.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n        }\n    }\n    if (matchers.rgba) {\n        if (match = matchers.rgba.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n        }\n    }\n    if (matchers.hex3) {\n        if (match = matchers.hex3.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (matchers.hex8) {\n        if (match = matchers.hex8.exec(color)) {\n            return Number.parseInt(match[1], 16) >>> 0;\n        }\n    }\n    if (matchers.hex4) {\n        if (match = matchers.hex4.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n        }\n    }\n    if (matchers.hsl) {\n        if (match = matchers.hsl.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n        }\n    }\n    if (matchers.hsla) {\n        if (match = matchers.hsla.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n        }\n    }\n    throw new Error(`invalid color string ${color} provided`);\n}\nfunction processColor(color) {\n    const normalizedColor = normalizeColor(color);\n    return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n// src/validate-frame.ts\nvar validateFrame = ({ allowFloats, durationInFrames, frame })=>{\n    if (typeof frame === \"undefined\") {\n        throw new TypeError(`Argument missing for parameter \"frame\"`);\n    }\n    if (typeof frame !== \"number\") {\n        throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n    }\n    if (!Number.isFinite(frame)) {\n        throw new RangeError(`Frame ${frame} is not finite`);\n    }\n    if (frame % 1 !== 0 && !allowFloats) {\n        throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n    }\n    if (frame < 0 && frame < -durationInFrames) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n    }\n    if (frame > durationInFrames - 1) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n    }\n};\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId)=>{\n    if (!defaultProps) {\n        return;\n    }\n    if (typeof defaultProps !== \"object\") {\n        throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n    }\n    if (Array.isArray(defaultProps)) {\n        throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n    }\n};\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n    if (typeof amount !== \"number\") {\n        throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n    }\n    if (isNaN(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n    }\n    if (!Number.isFinite(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n    }\n    if (amount % 1 !== 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n    }\n    if (amount <= 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n    }\n}\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n    const { allowFloats, component } = options;\n    if (typeof durationInFrames === \"undefined\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n    }\n    if (!allowFloats && durationInFrames % 1 !== 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n    }\n    if (!Number.isFinite(durationInFrames)) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n    }\n}\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n    if (typeof fps !== \"number\") {\n        throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n    }\n    if (!Number.isFinite(fps)) {\n        throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n    }\n    if (isNaN(fps)) {\n        throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n    }\n    if (fps <= 0) {\n        throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n    }\n    if (isGif && fps > 50) {\n        throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n    }\n}\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({ frame, playbackRate, startFrom })=>{\n    return interpolate(frame, [\n        -1,\n        startFrom,\n        startFrom + 1\n    ], [\n        -1,\n        startFrom,\n        startFrom + playbackRate\n    ]);\n};\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc)=>{\n    if (true) {\n        return relativeSrc;\n    }\n    return new URL(relativeSrc, window.origin).href;\n};\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({ src, transparent, currentTime, toneMapped })=>{\n    return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(currentTime)}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n// src/no-react.ts\nvar NoReactInternals = {\n    processColor,\n    truthy,\n    validateFps,\n    validateDimension,\n    validateDurationInFrames,\n    validateDefaultAndInputProps,\n    validateFrame,\n    serializeJSONWithDate,\n    bundleName: \"bundle.js\",\n    bundleMapName: \"bundle.js.map\",\n    deserializeJSONWithCustomFields,\n    DELAY_RENDER_CALLSTACK_TOKEN,\n    DELAY_RENDER_RETRY_TOKEN,\n    DELAY_RENDER_CLEAR_TOKEN,\n    DELAY_RENDER_ATTEMPT_TOKEN: DELAY_RENDER_RETRIES_LEFT,\n    getOffthreadVideoSource,\n    getExpectedMediaFrameUncorrected,\n    ENABLE_V5_BREAKING_CHANGES,\n    MIN_NODE_VERSION: ENABLE_V5_BREAKING_CHANGES ? 18 : 16,\n    MIN_BUN_VERSION: ENABLE_V5_BREAKING_CHANGES ? \"1.1.3\" : \"1.0.3\",\n    colorNames,\n    DATE_TOKEN,\n    FILE_TOKEN\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vbm8tcmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHFCQUFxQjtBQUNyQixTQUFTQSxvQkFBb0JDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxXQUFXLEVBQUVDLE9BQU87SUFDbEUsTUFBTSxFQUFFQyxlQUFlLEVBQUVDLGdCQUFnQixFQUFFQyxNQUFNLEVBQUUsR0FBR0g7SUFDdEQsSUFBSUksU0FBU1A7SUFDYixNQUFNLENBQUNRLFVBQVVDLFNBQVMsR0FBR1I7SUFDN0IsTUFBTSxDQUFDUyxXQUFXQyxVQUFVLEdBQUdUO0lBQy9CLElBQUlLLFNBQVNDLFVBQVU7UUFDckIsSUFBSUosb0JBQW9CLFlBQVk7WUFDbEMsT0FBT0c7UUFDVDtRQUNBLElBQUlILG9CQUFvQixTQUFTO1lBQy9CRyxTQUFTQztRQUNYLE9BQU8sSUFBSUosb0JBQW9CLFFBQVE7WUFDckMsTUFBTVEsUUFBUUgsV0FBV0Q7WUFDekJELFNBQVMsQ0FBQyxDQUFDQSxTQUFTQyxRQUFPLElBQUtJLFFBQVFBLEtBQUksSUFBS0EsUUFBUUo7UUFDM0QsT0FBTyxJQUFJSixvQkFBb0IsVUFBVSxDQUFDO0lBQzVDO0lBQ0EsSUFBSUcsU0FBU0UsVUFBVTtRQUNyQixJQUFJSixxQkFBcUIsWUFBWTtZQUNuQyxPQUFPRTtRQUNUO1FBQ0EsSUFBSUYscUJBQXFCLFNBQVM7WUFDaENFLFNBQVNFO1FBQ1gsT0FBTyxJQUFJSixxQkFBcUIsUUFBUTtZQUN0QyxNQUFNTyxRQUFRSCxXQUFXRDtZQUN6QkQsU0FBUyxDQUFDLENBQUNBLFNBQVNDLFFBQU8sSUFBS0ksUUFBUUEsS0FBSSxJQUFLQSxRQUFRSjtRQUMzRCxPQUFPLElBQUlILHFCQUFxQixVQUFVLENBQUM7SUFDN0M7SUFDQSxJQUFJSyxjQUFjQyxXQUFXO1FBQzNCLE9BQU9EO0lBQ1Q7SUFDQUgsU0FBUyxDQUFDQSxTQUFTQyxRQUFPLElBQU1DLENBQUFBLFdBQVdELFFB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RUFDWkMsU0FBUyxFQUNWO0lBQ0MsT0FBTzdRLFlBQVkwUCxPQUFPO1FBQUMsQ0FBQztRQUFHbUI7UUFBV0EsWUFBWTtLQUFFLEVBQUU7UUFBQyxDQUFDO1FBQUdBO1FBQVdBLFlBQVlEO0tBQWE7QUFDckc7QUFFQSxzQkFBc0I7QUFDdEIsSUFBSUUsaUJBQWlCLENBQUNDO0lBQ3BCLElBQUksSUFBNkIsRUFBRTtRQUNqQyxPQUFPQTtJQUNUO0lBQ0EsT0FBTyxJQUFJQyxJQUFJRCxhQUFhM1AsT0FBTzZQLE1BQU0sRUFBRUMsSUFBSTtBQUNqRDtBQUVBLHNDQUFzQztBQUN0QyxJQUFJQywwQkFBMEIsQ0FBQyxFQUM3QkMsR0FBRyxFQUNIM0wsV0FBVyxFQUNYNEwsV0FBVyxFQUNYQyxVQUFVLEVBQ1g7SUFDQyxPQUFPLENBQUMsaUJBQWlCLEVBQUVsUSxPQUFPbVEsa0JBQWtCLENBQUMsV0FBVyxFQUFFQyxtQkFBbUJWLGVBQWVNLE1BQU0sTUFBTSxFQUFFSSxtQkFBbUJILGFBQWEsYUFBYSxFQUFFSSxPQUFPaE0sYUFBYSxZQUFZLEVBQUVnTSxPQUFPSCxZQUFZLENBQUM7QUFDek47QUFFQSxrQkFBa0I7QUFDbEIsSUFBSUksbUJBQW1CO0lBQ3JCdEM7SUFDQW5PO0lBQ0F1UDtJQUNBUDtJQUNBSztJQUNBVjtJQUNBTDtJQUNBMU47SUFDQThQLFlBQVk7SUFDWkMsZUFBZTtJQUNmMU87SUFDQTNCO0lBQ0FFO0lBQ0FDO0lBQ0FtUSw0QkFBNEJyUTtJQUM1QjJQO0lBQ0FSO0lBQ0FyQjtJQUNBd0Msa0JBQWtCeEMsNkJBQTZCLEtBQUs7SUFDcER5QyxpQkFBaUJ6Qyw2QkFBNkIsVUFBVTtJQUN4RDlKO0lBQ0E3RDtJQUNBQztBQUNGO0FBS0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGlwanMvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vbm8tcmVhY3QubWpzP2ExOTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2ludGVycG9sYXRlLnRzXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgZWFzaW5nIH0gPSBvcHRpb25zO1xuICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG4gIGNvbnN0IFtpbnB1dE1pbiwgaW5wdXRNYXhdID0gaW5wdXRSYW5nZTtcbiAgY29uc3QgW291dHB1dE1pbiwgb3V0cHV0TWF4XSA9IG91dHB1dFJhbmdlO1xuICBpZiAocmVzdWx0IDwgaW5wdXRNaW4pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiY2xhbXBcIikge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJleHRlbmRcIikge31cbiAgfVxuICBpZiAocmVzdWx0ID4gaW5wdXRNYXgpIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1heDtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiZXh0ZW5kXCIpIHt9XG4gIH1cbiAgaWYgKG91dHB1dE1pbiA9PT0gb3V0cHV0TWF4KSB7XG4gICAgcmV0dXJuIG91dHB1dE1pbjtcbiAgfVxuICByZXN1bHQgPSAocmVzdWx0IC0gaW5wdXRNaW4pIC8gKGlucHV0TWF4IC0gaW5wdXRNaW4pO1xuICByZXN1bHQgPSBlYXNpbmcocmVzdWx0KTtcbiAgcmVzdWx0ID0gcmVzdWx0ICogKG91dHB1dE1heCAtIG91dHB1dE1pbikgKyBvdXRwdXRNaW47XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpIHtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7aSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgaWYgKGlucHV0UmFuZ2VbaV0gPj0gaW5wdXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaSAtIDE7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkSW5wdXRSYW5nZShhcnIpIHtcbiAgZm9yIChsZXQgaSA9IDE7aSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmICghKGFycltpXSA+IGFycltpIC0gMV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0UmFuZ2UgbXVzdCBiZSBzdHJpY3RseSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbmZpbml0ZVJhbmdlKG5hbWUsIGFycikge1xuICBpZiAoYXJyLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGVsZW1lbnRzXCIpO1xuICB9XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBhcnIpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzYCk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBjb250YWluIG9ubHkgZmluaXRlIG51bWJlcnMsIGJ1dCBnb3QgWyR7YXJyLmpvaW4oXCIsXCIpfV1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG91dHB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIChcIiArIGlucHV0UmFuZ2UubGVuZ3RoICsgXCIpIGFuZCBvdXRwdXRSYW5nZSAoXCIgKyBvdXRwdXRSYW5nZS5sZW5ndGggKyBcIikgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjaGVja0luZmluaXRlUmFuZ2UoXCJpbnB1dFJhbmdlXCIsIGlucHV0UmFuZ2UpO1xuICBjaGVja0luZmluaXRlUmFuZ2UoXCJvdXRwdXRSYW5nZVwiLCBvdXRwdXRSYW5nZSk7XG4gIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGlucHV0UmFuZ2UpO1xuICBjb25zdCBlYXNpbmcgPSBvcHRpb25zPy5lYXNpbmcgPz8gKChudW0pID0+IG51bSk7XG4gIGxldCBleHRyYXBvbGF0ZUxlZnQgPSBcImV4dGVuZFwiO1xuICBpZiAob3B0aW9ucz8uZXh0cmFwb2xhdGVMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZUxlZnQgPSBvcHRpb25zLmV4dHJhcG9sYXRlTGVmdDtcbiAgfVxuICBsZXQgZXh0cmFwb2xhdGVSaWdodCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZVJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZVJpZ2h0ID0gb3B0aW9ucy5leHRyYXBvbGF0ZVJpZ2h0O1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGludGVycG9sYXRlIGFuIGlucHV0IHdoaWNoIGlzIG5vdCBhIG51bWJlclwiKTtcbiAgfVxuICBjb25zdCByYW5nZSA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBbaW5wdXRSYW5nZVtyYW5nZV0sIGlucHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIFtvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV1dLCB7XG4gICAgZWFzaW5nLFxuICAgIGV4dHJhcG9sYXRlTGVmdCxcbiAgICBleHRyYXBvbGF0ZVJpZ2h0XG4gIH0pO1xufVxuLy8gc3JjL3JhbmRvbS50c1xuZnVuY3Rpb24gbXVsYmVycnkzMihhKSB7XG4gIGxldCB0ID0gYSArIDE4MzE1NjU4MTM7XG4gIHQgPSBNYXRoLmltdWwodCBeIHQgPj4+IDE1LCB0IHwgMSk7XG4gIHQgXj0gdCArIE1hdGguaW11bCh0IF4gdCA+Pj4gNywgdCB8IDYxKTtcbiAgcmV0dXJuICgodCBeIHQgPj4+IDE0KSA+Pj4gMCkgLyA0Mjk0OTY3Mjk2O1xufVxuZnVuY3Rpb24gaGFzaENvZGUoc3RyKSB7XG4gIGxldCBpID0gMDtcbiAgbGV0IGNociA9IDA7XG4gIGxldCBoYXNoID0gMDtcbiAgZm9yIChpID0gMDtpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNocjtcbiAgICBoYXNoIHw9IDA7XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59XG52YXIgcmFuZG9tID0gKHNlZWQsIGR1bW15KSA9PiB7XG4gIGlmIChkdW1teSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJhbmRvbSgpIHRha2VzIG9ubHkgb25lIGFyZ3VtZW50XCIpO1xuICB9XG4gIGlmIChzZWVkID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG11bGJlcnJ5MzIoaGFzaENvZGUoc2VlZCkpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBtdWxiZXJyeTMyKHNlZWQgKiAxMDAwMDAwMDAwMCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwicmFuZG9tKCkgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlciBvciBhIHN0cmluZ1wiKTtcbn07XG4vLyBzcmMvdHJ1dGh5LnRzXG5mdW5jdGlvbiB0cnV0aHkodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xufVxuXG4vLyBzcmMvZGVsYXktcmVuZGVyLnRzXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSBmYWxzZTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzID0ge307XG59XG52YXIgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTiA9IFwiVGhlIGRlbGF5UmVuZGVyIHdhcyBjYWxsZWQ6XCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCA9IFwiUmV0cmllcyBsZWZ0OiBcIjtcbnZhciBERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4gPSBcIi0gUmVuZGVyaW5nIHRoZSBmcmFtZSB3aWxsIGJlIHJldHJpZWQuXCI7XG52YXIgREVMQVlfUkVOREVSX0NMRUFSX1RPS0VOID0gXCJoYW5kbGUgd2FzIGNsZWFyZWQgYWZ0ZXJcIjtcblxuLy8gc3JjL2lucHV0LXByb3BzLXNlcmlhbGl6YXRpb24udHNcbnZhciBEQVRFX1RPS0VOID0gXCJyZW1vdGlvbi1kYXRlOlwiO1xudmFyIEZJTEVfVE9LRU4gPSBcInJlbW90aW9uLWZpbGU6XCI7XG52YXIgc2VyaWFsaXplSlNPTldpdGhEYXRlID0gKHtcbiAgZGF0YSxcbiAgaW5kZW50LFxuICBzdGF0aWNCYXNlXG59KSA9PiB7XG4gIGxldCBjdXN0b21EYXRlVXNlZCA9IGZhbHNlO1xuICBsZXQgY3VzdG9tRmlsZVVzZWQgPSBmYWxzZTtcbiAgbGV0IG1hcFVzZWQgPSBmYWxzZTtcbiAgbGV0IHNldFVzZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXJpYWxpemVkU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXNba2V5XTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjdXN0b21EYXRlVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBgJHtEQVRFX1RPS0VOfSR7aXRlbS50b0lTT1N0cmluZygpfWA7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBtYXBVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgc2V0VXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiAmJiBzdGF0aWNCYXNlICE9PSBudWxsICYmIGl0ZW0uc3RhcnRzV2l0aChzdGF0aWNCYXNlKSkge1xuICAgICAgICBjdXN0b21GaWxlVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBgJHtGSUxFX1RPS0VOfSR7aXRlbS5yZXBsYWNlKHN0YXRpY0Jhc2UgKyBcIi9cIiwgXCJcIil9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBpbmRlbnQpO1xuICAgIHJldHVybiB7IHNlcmlhbGl6ZWRTdHJpbmcsIGN1c3RvbURhdGVVc2VkLCBjdXN0b21GaWxlVXNlZCwgbWFwVXNlZCwgc2V0VXNlZCB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3Qgc2VyaWFsaXplIHRoZSBwYXNzZWQgaW5wdXQgcHJvcHMgdG8gSlNPTjogXCIgKyBlcnIubWVzc2FnZSk7XG4gIH1cbn07XG52YXIgZGVzZXJpYWxpemVKU09OV2l0aEN1c3RvbUZpZWxkcyA9IChkYXRhKSA9PiB7XG4gIHJldHVybiBKU09OLnBhcnNlKGRhdGEsIChfLCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChEQVRFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLnJlcGxhY2UoREFURV9UT0tFTiwgXCJcIikpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoRklMRV9UT0tFTikpIHtcbiAgICAgIHJldHVybiBgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0vJHt2YWx1ZS5yZXBsYWNlKEZJTEVfVE9LRU4sIFwiXCIpfWA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvaW50ZXJwb2xhdGUtY29sb3JzLnRzXG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbmZ1bmN0aW9uIGNhbGwoLi4uYXJncykge1xuICByZXR1cm4gXCJcXFxcKFxcXFxzKihcIiArIGFyZ3Muam9pbihcIilcXFxccyosXFxcXHMqKFwiKSArIFwiKVxcXFxzKlxcXFwpXCI7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVycygpIHtcbiAgY29uc3QgY2FjaGVkTWF0Y2hlcnMgPSB7XG4gICAgcmdiOiB1bmRlZmluZWQsXG4gICAgcmdiYTogdW5kZWZpbmVkLFxuICAgIGhzbDogdW5kZWZpbmVkLFxuICAgIGhzbGE6IHVuZGVmaW5lZCxcbiAgICBoZXgzOiB1bmRlZmluZWQsXG4gICAgaGV4NDogdW5kZWZpbmVkLFxuICAgIGhleDU6IHVuZGVmaW5lZCxcbiAgICBoZXg2OiB1bmRlZmluZWQsXG4gICAgaGV4ODogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChjYWNoZWRNYXRjaGVycy5yZ2IgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYiA9IG5ldyBSZWdFeHAoXCJyZ2JcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYmEgPSBuZXcgUmVnRXhwKFwicmdiYVwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oc2wgPSBuZXcgUmVnRXhwKFwiaHNsXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbGEgPSBuZXcgUmVnRXhwKFwiaHNsYVwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDMgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg0ID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4OCA9IC9eIyhbMC05YS1mQS1GXXs4fSkkLztcbiAgfVxuICByZXR1cm4gY2FjaGVkTWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB7XG4gICAgdCArPSAxO1xuICB9XG4gIGlmICh0ID4gMSkge1xuICAgIHQgLT0gMTtcbiAgfVxuICBpZiAodCA8IDEgLyA2KSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gIH1cbiAgaWYgKHQgPCAxIC8gMikge1xuICAgIHJldHVybiBxO1xuICB9XG4gIGlmICh0IDwgMiAvIDMpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xUb1JnYihoLCBzLCBsKSB7XG4gIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICBjb25zdCByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICBjb25zdCBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgY29uc3QgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQociAqIDI1NSkgPDwgMjQgfCBNYXRoLnJvdW5kKGcgKiAyNTUpIDw8IDE2IHwgTWF0aC5yb3VuZChiICogMjU1KSA8PCA4O1xufVxuZnVuY3Rpb24gcGFyc2UyNTUoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMjU1KSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gaW50O1xufVxuZnVuY3Rpb24gcGFyc2UzNjAoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiAoaW50ICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDtcbn1cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKG51bSA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAobnVtID4gMSkge1xuICAgIHJldHVybiAyNTU7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMjU1KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudGFnZShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMTAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGludCAvIDEwMDtcbn1cbnZhciBjb2xvck5hbWVzID0ge1xuICB0cmFuc3BhcmVudDogMCxcbiAgYWxpY2VibHVlOiA0MDQyODUwMzAzLFxuICBhbnRpcXVld2hpdGU6IDQyMDk3NjAyNTUsXG4gIGFxdWE6IDE2Nzc3MjE1LFxuICBhcXVhbWFyaW5lOiAyMTQ3NDcyNjM5LFxuICBhenVyZTogNDA0MzMwOTA1NSxcbiAgYmVpZ2U6IDQxMjY1MzA4MTUsXG4gIGJpc3F1ZTogNDI5MzE4MjcxOSxcbiAgYmxhY2s6IDI1NSxcbiAgYmxhbmNoZWRhbG1vbmQ6IDQyOTM2NDM3NzUsXG4gIGJsdWU6IDY1NTM1LFxuICBibHVldmlvbGV0OiAyMzE4MTMxOTY3LFxuICBicm93bjogMjc3MTAwNDE1OSxcbiAgYnVybHl3b29kOiAzNzM2NjM1MzkxLFxuICBidXJudHNpZW5uYTogMzkzNDE1MDE0MyxcbiAgY2FkZXRibHVlOiAxNjA0MjMxNDIzLFxuICBjaGFydHJldXNlOiAyMTQ3NDE4MzY3LFxuICBjaG9jb2xhdGU6IDM1MzAxMDQ1NzUsXG4gIGNvcmFsOiA0Mjg2NTMzODg3LFxuICBjb3JuZmxvd2VyYmx1ZTogMTY4NzU0NzM5MSxcbiAgY29ybnNpbGs6IDQyOTQ0OTk1ODMsXG4gIGNyaW1zb246IDM2OTIzMTM4NTUsXG4gIGN5YW46IDE2Nzc3MjE1LFxuICBkYXJrYmx1ZTogMzU4MzksXG4gIGRhcmtjeWFuOiA5MTQ1MzQzLFxuICBkYXJrZ29sZGVucm9kOiAzMDk1NzkyNjM5LFxuICBkYXJrZ3JheTogMjg0NjQ2ODYwNyxcbiAgZGFya2dyZWVuOiA2NTUzODU1LFxuICBkYXJrZ3JleTogMjg0NjQ2ODYwNyxcbiAgZGFya2toYWtpOiAzMTgyOTE0NTU5LFxuICBkYXJrbWFnZW50YTogMjMzMjA2ODg2MyxcbiAgZGFya29saXZlZ3JlZW46IDE0MzMwODc5OTksXG4gIGRhcmtvcmFuZ2U6IDQyODczNjUzNzUsXG4gIGRhcmtvcmNoaWQ6IDI1NzAyNDMzMjcsXG4gIGRhcmtyZWQ6IDIzMzIwMzMyNzksXG4gIGRhcmtzYWxtb246IDM5MTg5NTMyMTUsXG4gIGRhcmtzZWFncmVlbjogMjQxMTQ5OTUxOSxcbiAgZGFya3NsYXRlYmx1ZTogMTIxMTk5MzA4NyxcbiAgZGFya3NsYXRlZ3JheTogNzkzNzI2OTc1LFxuICBkYXJrc2xhdGVncmV5OiA3OTM3MjY5NzUsXG4gIGRhcmt0dXJxdW9pc2U6IDEzNTU0MTc1LFxuICBkYXJrdmlvbGV0OiAyNDgzMDgyMjM5LFxuICBkZWVwcGluazogNDI3OTUzODY4NyxcbiAgZGVlcHNreWJsdWU6IDEyNTgyOTExLFxuICBkaW1ncmF5OiAxNzY4NTE2MDk1LFxuICBkaW1ncmV5OiAxNzY4NTE2MDk1LFxuICBkb2RnZXJibHVlOiA1MTI4MTkxOTksXG4gIGZpcmVicmljazogMjk4ODU4MTYzMSxcbiAgZmxvcmFsd2hpdGU6IDQyOTQ2MzU3NzUsXG4gIGZvcmVzdGdyZWVuOiA1Nzk1NDM4MDcsXG4gIGZ1Y2hzaWE6IDQyNzgyNTU2MTUsXG4gIGdhaW5zYm9ybzogMzcwNTQ2MjAxNSxcbiAgZ2hvc3R3aGl0ZTogNDE3NzA2ODAzMSxcbiAgZ29sZDogNDI5MjI4MDU3NSxcbiAgZ29sZGVucm9kOiAzNjY4MjU0OTc1LFxuICBncmF5OiAyMTU1OTA1Mjc5LFxuICBncmVlbjogODM4ODg2MyxcbiAgZ3JlZW55ZWxsb3c6IDI5MTkxODIzMzUsXG4gIGdyZXk6IDIxNTU5MDUyNzksXG4gIGhvbmV5ZGV3OiA0MDQzMzA1MjE1LFxuICBob3RwaW5rOiA0Mjg1MTE3Njk1LFxuICBpbmRpYW5yZWQ6IDM0NDUzODIzOTksXG4gIGluZGlnbzogMTI1ODMyNDczNSxcbiAgaXZvcnk6IDQyOTQ5NjM0NTUsXG4gIGtoYWtpOiA0MDQxNjQxMjE1LFxuICBsYXZlbmRlcjogMzg3Mzg5NzIxNSxcbiAgbGF2ZW5kZXJibHVzaDogNDI5Mzk4MTY5NSxcbiAgbGF3bmdyZWVuOiAyMDk2ODkwMTExLFxuICBsZW1vbmNoaWZmb246IDQyOTQ2MjY4MTUsXG4gIGxpZ2h0Ymx1ZTogMjkxNjY3MzI3OSxcbiAgbGlnaHRjb3JhbDogNDAzNDk1MzQ3MSxcbiAgbGlnaHRjeWFuOiAzNzc0ODczNTk5LFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogNDIxMDc0MjAxNSxcbiAgbGlnaHRncmF5OiAzNTUzODc0OTQzLFxuICBsaWdodGdyZWVuOiAyNDMxNTUzNzkxLFxuICBsaWdodGdyZXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0cGluazogNDI5MDE2NzI5NSxcbiAgbGlnaHRzYWxtb246IDQyODg3MDczMjcsXG4gIGxpZ2h0c2VhZ3JlZW46IDU0ODU4MDA5NSxcbiAgbGlnaHRza3libHVlOiAyMjc4NDg4ODMxLFxuICBsaWdodHNsYXRlZ3JheTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzbGF0ZWdyZXk6IDIwMDU0NDEwMjMsXG4gIGxpZ2h0c3RlZWxibHVlOiAyOTY1NjkyMTU5LFxuICBsaWdodHllbGxvdzogNDI5NDk1OTM1OSxcbiAgbGltZTogMTY3MTE5MzUsXG4gIGxpbWVncmVlbjogODUyMzA4NzM1LFxuICBsaW5lbjogNDIxMDA5MTc3NSxcbiAgbWFnZW50YTogNDI3ODI1NTYxNSxcbiAgbWFyb29uOiAyMTQ3NDgzOTAzLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAxNzI0NzU0Njg3LFxuICBtZWRpdW1ibHVlOiA1MjczNSxcbiAgbWVkaXVtb3JjaGlkOiAzMTI2MTg3MDA3LFxuICBtZWRpdW1wdXJwbGU6IDI0NzM2NDcxMDMsXG4gIG1lZGl1bXNlYWdyZWVuOiAxMDE4MzkzMDg3LFxuICBtZWRpdW1zbGF0ZWJsdWU6IDIwNzA0NzQ0OTUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAxNjQyMzY3OSxcbiAgbWVkaXVtdHVycXVvaXNlOiAxMjIxNzA5MDU1LFxuICBtZWRpdW12aW9sZXRyZWQ6IDMzNDAwNzY1NDMsXG4gIG1pZG5pZ2h0Ymx1ZTogNDIxMDk3NzI3LFxuICBtaW50Y3JlYW06IDQxMjcxOTM4NTUsXG4gIG1pc3R5cm9zZTogNDI5MzE5MDE0MyxcbiAgbW9jY2FzaW46IDQyOTMxNzg4NzksXG4gIG5hdmFqb3doaXRlOiA0MjkyNzgzNjE1LFxuICBuYXZ5OiAzMzAyMyxcbiAgb2xkbGFjZTogNDI2MDc1MTEwMyxcbiAgb2xpdmU6IDIxNTU4NzI1MTEsXG4gIG9saXZlZHJhYjogMTgwNDQ3NzQzOSxcbiAgb3JhbmdlOiA0Mjg5MDAzNzc1LFxuICBvcmFuZ2VyZWQ6IDQyODI3MTIzMTksXG4gIG9yY2hpZDogMzY2NDgyODE1OSxcbiAgcGFsZWdvbGRlbnJvZDogNDAwODIyNTUzNSxcbiAgcGFsZWdyZWVuOiAyNTY2NjI1NTM1LFxuICBwYWxldHVycXVvaXNlOiAyOTUxNjcxNTUxLFxuICBwYWxldmlvbGV0cmVkOiAzNjgxNTg4MjIzLFxuICBwYXBheWF3aGlwOiA0MjkzOTA3OTY3LFxuICBwZWFjaHB1ZmY6IDQyOTI1MjQ1NDMsXG4gIHBlcnU6IDM0NDgwNjE5NTEsXG4gIHBpbms6IDQyOTA4MjUyMTUsXG4gIHBsdW06IDM3MTgzMDczMjcsXG4gIHBvd2RlcmJsdWU6IDI5Njc1MjkyMTUsXG4gIHB1cnBsZTogMjE0NzUxNjY3MSxcbiAgcmViZWNjYXB1cnBsZTogMTcxNDY1Nzc5MSxcbiAgcmVkOiA0Mjc4MTkwMzM1LFxuICByb3N5YnJvd246IDMxNjM1MjUxMTksXG4gIHJveWFsYmx1ZTogMTA5NzQ1ODE3NSxcbiAgc2FkZGxlYnJvd246IDIzMzY1NjAxMjcsXG4gIHNhbG1vbjogNDIwMjcyMjA0NyxcbiAgc2FuZHlicm93bjogNDEwNDQxMzQzOSxcbiAgc2VhZ3JlZW46IDc4MDg4Mzk2NyxcbiAgc2Vhc2hlbGw6IDQyOTQzMDc1ODMsXG4gIHNpZW5uYTogMjY4OTc0MDI4NyxcbiAgc2lsdmVyOiAzMjMzODU3NzkxLFxuICBza3libHVlOiAyMjc4NDg0OTkxLFxuICBzbGF0ZWJsdWU6IDE3ODQzMzU4NzEsXG4gIHNsYXRlZ3JheTogMTg4NzQ3MzkxOSxcbiAgc2xhdGVncmV5OiAxODg3NDczOTE5LFxuICBzbm93OiA0Mjk0NjM4MzM1LFxuICBzcHJpbmdncmVlbjogMTY3NDQ0NDcsXG4gIHN0ZWVsYmx1ZTogMTE4Mjk3MTEzNSxcbiAgdGFuOiAzNTM1MDQ3OTM1LFxuICB0ZWFsOiA4NDIxNjMxLFxuICB0aGlzdGxlOiAzNjM2NDUxNTgzLFxuICB0b21hdG86IDQyODQ2OTY1NzUsXG4gIHR1cnF1b2lzZTogMTA4ODQ3NTM5MSxcbiAgdmlvbGV0OiA0MDAxNTU4MjcxLFxuICB3aGVhdDogNDEyNTAxMjk5MSxcbiAgd2hpdGU6IDQyOTQ5NjcyOTUsXG4gIHdoaXRlc21va2U6IDQxMjY1MzcyMTUsXG4gIHllbGxvdzogNDI5NDkwMjAxNSxcbiAgeWVsbG93Z3JlZW46IDI1OTcxMzkxOTlcbn07XG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICBjb25zdCBtYXRjaGVycyA9IGdldE1hdGNoZXJzKCk7XG4gIGxldCBtYXRjaDtcbiAgaWYgKG1hdGNoZXJzLmhleDYpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChjb2xvck5hbWVzW2NvbG9yXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbG9yTmFtZXNbY29sb3JdO1xuICB9XG4gIGlmIChtYXRjaGVycy5yZ2IpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5yZ2IuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMucmdiYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYmEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDMpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgbWF0Y2hbMV0gKyBtYXRjaFsyXSArIG1hdGNoWzJdICsgbWF0Y2hbM10gKyBtYXRjaFszXSArIFwiZmZcIiwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4OCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0sIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDQpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg0LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgbWF0Y2hbMV0gKyBtYXRjaFsyXSArIG1hdGNoWzJdICsgbWF0Y2hbM10gKyBtYXRjaFszXSArIG1hdGNoWzRdICsgbWF0Y2hbNF0sIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhzbCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChoc2xUb1JnYihwYXJzZTM2MChtYXRjaFsxXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFsyXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFszXSkpIHwgMjU1KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhzbGEpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oc2xhLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNvbG9yIHN0cmluZyAke2NvbG9yfSBwcm92aWRlZGApO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0NvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IG5vcm1hbGl6ZUNvbG9yKGNvbG9yKTtcbiAgcmV0dXJuIChub3JtYWxpemVkQ29sb3IgPDwgMjQgfCBub3JtYWxpemVkQ29sb3IgPj4+IDgpID4+PiAwO1xufVxuXG4vLyBzcmMvdjUtZmxhZy50c1xudmFyIEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTID0gZmFsc2U7XG5cbi8vIHNyYy92YWxpZGF0ZS1mcmFtZS50c1xudmFyIHZhbGlkYXRlRnJhbWUgPSAoe1xuICBhbGxvd0Zsb2F0cyxcbiAgZHVyYXRpb25JbkZyYW1lcyxcbiAgZnJhbWVcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBmcmFtZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFyZ3VtZW50IG1pc3NpbmcgZm9yIHBhcmFtZXRlciBcImZyYW1lXCJgKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyYW1lICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQXJndW1lbnQgcGFzc2VkIGZvciBcImZyYW1lXCIgaXMgbm90IGEgbnVtYmVyOiAke2ZyYW1lfWApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYW1lKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBGcmFtZSAke2ZyYW1lfSBpcyBub3QgZmluaXRlYCk7XG4gIH1cbiAgaWYgKGZyYW1lICUgMSAhPT0gMCAmJiAhYWxsb3dGbG9hdHMpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQXJndW1lbnQgZm9yIGZyYW1lIG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2ZyYW1lfWApO1xuICB9XG4gIGlmIChmcmFtZSA8IDAgJiYgZnJhbWUgPCAtZHVyYXRpb25JbkZyYW1lcykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGxvd2VzdCBmcmFtZSB0aGF0IGNhbiBiZSByZW5kZXJlZCBpcyAkey1kdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmIChmcmFtZSA+IGR1cmF0aW9uSW5GcmFtZXMgLSAxKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbm5vdCB1c2UgZnJhbWUgJHtmcmFtZX06IER1cmF0aW9uIG9mIGNvbXBvc2l0aW9uIGlzICR7ZHVyYXRpb25JbkZyYW1lc30sIHRoZXJlZm9yZSB0aGUgaGlnaGVzdCBmcmFtZSB0aGF0IGNhbiBiZSByZW5kZXJlZCBpcyAke2R1cmF0aW9uSW5GcmFtZXMgLSAxfWApO1xuICB9XG59O1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kZWZhdWx0LXByb3BzLnRzXG52YXIgdmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyA9IChkZWZhdWx0UHJvcHMsIG5hbWUsIGNvbXBvc2l0aW9uSWQpID0+IHtcbiAgaWYgKCFkZWZhdWx0UHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZhdWx0UHJvcHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZGVmYXVsdFByb3BzfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRQcm9wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSB3YXMgcGFzc2VkICR7Y29tcG9zaXRpb25JZCA/IGBmb3IgY29tcG9zaXRpb24gXCIke2NvbXBvc2l0aW9uSWR9XCJgIDogXCJcIn1gKTtcbiAgfVxufTtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZGltZW5zaW9ucy50c1xuZnVuY3Rpb24gdmFsaWRhdGVEaW1lbnNpb24oYW1vdW50LCBuYW1lT2ZQcm9wLCBsb2NhdGlvbikge1xuICBpZiAodHlwZW9mIGFtb3VudCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGFtb3VudH1gKTtcbiAgfVxuICBpZiAoaXNOYU4oYW1vdW50KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3Qgbm90IGJlIE5hTiwgYnV0IGlzIE5hTi5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBmaW5pdGUsIGJ1dCBpcyAke2Ftb3VudH0uYCk7XG4gIH1cbiAgaWYgKGFtb3VudCAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBpcyAke2Ftb3VudH0uYCk7XG4gIH1cbiAgaWYgKGFtb3VudCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2Ftb3VudH0uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZHVyYXRpb24taW4tZnJhbWVzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoZHVyYXRpb25JbkZyYW1lcywgb3B0aW9ucykge1xuICBjb25zdCB7IGFsbG93RmxvYXRzLCBjb21wb25lbnQgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IGlzIG1pc3NpbmcuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uSW5GcmFtZXN9YCk7XG4gIH1cbiAgaWYgKGR1cmF0aW9uSW5GcmFtZXMgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbiAgaWYgKCFhbGxvd0Zsb2F0cyAmJiBkdXJhdGlvbkluRnJhbWVzICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbkluRnJhbWVzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGZpbml0ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWZwcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVGcHMoZnBzLCBsb2NhdGlvbiwgaXNHaWYpIHtcbiAgaWYgKHR5cGVvZiBmcHMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGZwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3QgYmUgYSBmaW5pdGUsIGJ1dCB5b3UgcGFzc2VkICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChpc05hTihmcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3Qgbm90IGJlIE5hTiwgYnV0IGdvdCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoZnBzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcImZwc1wiIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGlzR2lmICYmIGZwcyA+IDUwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIEZQUyBmb3IgYSBHSUYgY2Fubm90IGJlIGhpZ2hlciB0aGFuIDUwLiBVc2UgdGhlIC0tZXZlcnktbnRoLWZyYW1lIG9wdGlvbiB0byBsb3dlciB0aGUgRlBTOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3JlbmRlci1hcy1naWZgKTtcbiAgfVxufVxuXG4vLyBzcmMvdmlkZW8vZ2V0LWN1cnJlbnQtdGltZS50c1xudmFyIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkID0gKHtcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIHJldHVybiBpbnRlcnBvbGF0ZShmcmFtZSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIDFdLCBbLTEsIHN0YXJ0RnJvbSwgc3RhcnRGcm9tICsgcGxheWJhY2tSYXRlXSk7XG59O1xuXG4vLyBzcmMvYWJzb2x1dGUtc3JjLnRzXG52YXIgZ2V0QWJzb2x1dGVTcmMgPSAocmVsYXRpdmVTcmMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVTcmM7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkwocmVsYXRpdmVTcmMsIHdpbmRvdy5vcmlnaW4pLmhyZWY7XG59O1xuXG4vLyBzcmMvdmlkZW8vb2ZmdGhyZWFkLXZpZGVvLXNvdXJjZS50c1xudmFyIGdldE9mZnRocmVhZFZpZGVvU291cmNlID0gKHtcbiAgc3JjLFxuICB0cmFuc3BhcmVudCxcbiAgY3VycmVudFRpbWUsXG4gIHRvbmVNYXBwZWRcbn0pID0+IHtcbiAgcmV0dXJuIGBodHRwOi8vbG9jYWxob3N0OiR7d2luZG93LnJlbW90aW9uX3Byb3h5UG9ydH0vcHJveHk/c3JjPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGdldEFic29sdXRlU3JjKHNyYykpfSZ0aW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGN1cnJlbnRUaW1lKX0mdHJhbnNwYXJlbnQ9JHtTdHJpbmcodHJhbnNwYXJlbnQpfSZ0b25lTWFwcGVkPSR7U3RyaW5nKHRvbmVNYXBwZWQpfWA7XG59O1xuXG4vLyBzcmMvbm8tcmVhY3QudHNcbnZhciBOb1JlYWN0SW50ZXJuYWxzID0ge1xuICBwcm9jZXNzQ29sb3IsXG4gIHRydXRoeSxcbiAgdmFsaWRhdGVGcHMsXG4gIHZhbGlkYXRlRGltZW5zaW9uLFxuICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMsXG4gIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMsXG4gIHZhbGlkYXRlRnJhbWUsXG4gIHNlcmlhbGl6ZUpTT05XaXRoRGF0ZSxcbiAgYnVuZGxlTmFtZTogXCJidW5kbGUuanNcIixcbiAgYnVuZGxlTWFwTmFtZTogXCJidW5kbGUuanMubWFwXCIsXG4gIGRlc2VyaWFsaXplSlNPTldpdGhDdXN0b21GaWVsZHMsXG4gIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4sXG4gIERFTEFZX1JFTkRFUl9SRVRSWV9UT0tFTixcbiAgREVMQVlfUkVOREVSX0NMRUFSX1RPS0VOLFxuICBERUxBWV9SRU5ERVJfQVRURU1QVF9UT0tFTjogREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCxcbiAgZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2UsXG4gIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkLFxuICBFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyxcbiAgTUlOX05PREVfVkVSU0lPTjogRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPyAxOCA6IDE2LFxuICBNSU5fQlVOX1ZFUlNJT046IEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTID8gXCIxLjEuM1wiIDogXCIxLjAuM1wiLFxuICBjb2xvck5hbWVzLFxuICBEQVRFX1RPS0VOLFxuICBGSUxFX1RPS0VOXG59O1xuZXhwb3J0IHtcbiAgcmFuZG9tLFxuICBpbnRlcnBvbGF0ZSxcbiAgTm9SZWFjdEludGVybmFsc1xufTtcbiJdLCJuYW1lcyI6WyJpbnRlcnBvbGF0ZUZ1bmN0aW9uIiwiaW5wdXQiLCJpbnB1dFJhbmdlIiwib3V0cHV0UmFuZ2UiLCJvcHRpb25zIiwiZXh0cmFwb2xhdGVMZWZ0IiwiZXh0cmFwb2xhdGVSaWdodCIsImVhc2luZyIsInJlc3VsdCIsImlucHV0TWluIiwiaW5wdXRNYXgiLCJvdXRwdXRNaW4iLCJvdXRwdXRNYXgiLCJyYW5nZSIsImZpbmRSYW5nZSIsImkiLCJsZW5ndGgiLCJjaGVja1ZhbGlkSW5wdXRSYW5nZSIsImFyciIsIkVycm9yIiwiam9pbiIsImNoZWNrSW5maW5pdGVSYW5nZSIsIm5hbWUiLCJlbGVtZW50IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpbnRlcnBvbGF0ZSIsIm51bSIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsIm11bGJlcnJ5MzIiLCJhIiwidCIsIk1hdGgiLCJpbXVsIiwiaGFzaENvZGUiLCJzdHIiLCJjaHIiLCJoYXNoIiwiY2hhckNvZGVBdCIsInJhbmRvbSIsInNlZWQiLCJkdW1teSIsInRydXRoeSIsInZhbHVlIiwiQm9vbGVhbiIsIndpbmRvdyIsInJlbW90aW9uX3JlbmRlclJlYWR5IiwicmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0cyIsIkRFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4iLCJERUxBWV9SRU5ERVJfUkVUUklFU19MRUZUIiwiREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOIiwiREVMQVlfUkVOREVSX0NMRUFSX1RPS0VOIiwiREFURV9UT0tFTiIsIkZJTEVfVE9LRU4iLCJzZXJpYWxpemVKU09OV2l0aERhdGUiLCJkYXRhIiwiaW5kZW50Iiwic3RhdGljQmFzZSIsImN1c3RvbURhdGVVc2VkIiwiY3VzdG9tRmlsZVVzZWQiLCJtYXBVc2VkIiwic2V0VXNlZCIsInNlcmlhbGl6ZWRTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5Iiwia2V5IiwiaXRlbSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIk1hcCIsIlNldCIsInN0YXJ0c1dpdGgiLCJyZXBsYWNlIiwiZXJyIiwibWVzc2FnZSIsImRlc2VyaWFsaXplSlNPTldpdGhDdXN0b21GaWVsZHMiLCJwYXJzZSIsIl8iLCJyZW1vdGlvbl9zdGF0aWNCYXNlIiwiTlVNQkVSIiwiUEVSQ0VOVEFHRSIsImNhbGwiLCJhcmdzIiwiZ2V0TWF0Y2hlcnMiLCJjYWNoZWRNYXRjaGVycyIsInJnYiIsInJnYmEiLCJoc2wiLCJoc2xhIiwiaGV4MyIsImhleDQiLCJoZXg1IiwiaGV4NiIsImhleDgiLCJSZWdFeHAiLCJodWUycmdiIiwicCIsInEiLCJoc2xUb1JnYiIsImgiLCJzIiwibCIsInIiLCJnIiwiYiIsInJvdW5kIiwicGFyc2UyNTUiLCJpbnQiLCJwYXJzZUludCIsInBhcnNlMzYwIiwicGFyc2VGbG9hdCIsInBhcnNlMSIsInBhcnNlUGVyY2VudGFnZSIsImNvbG9yTmFtZXMiLCJ0cmFuc3BhcmVudCIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYWNrIiwiYmxhbmNoZWRhbG1vbmQiLCJibHVlIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiYnVybnRzaWVubmEiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImdyZXkiLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicmVkIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0YW4iLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93IiwieWVsbG93Z3JlZW4iLCJub3JtYWxpemVDb2xvciIsImNvbG9yIiwibWF0Y2hlcnMiLCJtYXRjaCIsImV4ZWMiLCJwcm9jZXNzQ29sb3IiLCJub3JtYWxpemVkQ29sb3IiLCJFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyIsInZhbGlkYXRlRnJhbWUiLCJhbGxvd0Zsb2F0cyIsImR1cmF0aW9uSW5GcmFtZXMiLCJmcmFtZSIsIlJhbmdlRXJyb3IiLCJ2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzIiwiZGVmYXVsdFByb3BzIiwiY29tcG9zaXRpb25JZCIsIkFycmF5IiwiaXNBcnJheSIsInZhbGlkYXRlRGltZW5zaW9uIiwiYW1vdW50IiwibmFtZU9mUHJvcCIsImxvY2F0aW9uIiwiaXNOYU4iLCJ2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMiLCJjb21wb25lbnQiLCJ2YWxpZGF0ZUZwcyIsImZwcyIsImlzR2lmIiwiZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQiLCJwbGF5YmFja1JhdGUiLCJzdGFydEZyb20iLCJnZXRBYnNvbHV0ZVNyYyIsInJlbGF0aXZlU3JjIiwiVVJMIiwib3JpZ2luIiwiaHJlZiIsImdldE9mZnRocmVhZFZpZGVvU291cmNlIiwic3JjIiwiY3VycmVudFRpbWUiLCJ0b25lTWFwcGVkIiwicmVtb3Rpb25fcHJveHlQb3J0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiU3RyaW5nIiwiTm9SZWFjdEludGVybmFscyIsImJ1bmRsZU5hbWUiLCJidW5kbGVNYXBOYW1lIiwiREVMQVlfUkVOREVSX0FUVEVNUFRfVE9LRU4iLCJNSU5fTk9ERV9WRVJTSU9OIiwiTUlOX0JVTl9WRVJTSU9OIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/no-react.mjs\n");

/***/ })

};
;