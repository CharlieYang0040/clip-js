"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/overlap-area";
exports.ids = ["vendor-chunks/overlap-area"];
exports.modules = {

/***/ "(ssr)/./node_modules/overlap-area/dist/overlap-area.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/overlap-area/dist/overlap-area.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLines: () => (/* binding */ convertLines),\n/* harmony export */   findConnectedAreas: () => (/* binding */ findConnectedAreas),\n/* harmony export */   fitPoints: () => (/* binding */ fitPoints),\n/* harmony export */   getAreaSize: () => (/* binding */ getAreaSize),\n/* harmony export */   getDistanceFromPointToConstants: () => (/* binding */ getDistanceFromPointToConstants),\n/* harmony export */   getIntersectionPoints: () => (/* binding */ getIntersectionPoints),\n/* harmony export */   getIntersectionPointsByConstants: () => (/* binding */ getIntersectionPointsByConstants),\n/* harmony export */   getLinearConstants: () => (/* binding */ getLinearConstants),\n/* harmony export */   getMinMaxs: () => (/* binding */ getMinMaxs),\n/* harmony export */   getOverlapAreas: () => (/* binding */ getOverlapAreas),\n/* harmony export */   getOverlapPoints: () => (/* binding */ getOverlapPoints),\n/* harmony export */   getOverlapSize: () => (/* binding */ getOverlapSize),\n/* harmony export */   getPointsOnLines: () => (/* binding */ getPointsOnLines),\n/* harmony export */   getUnoverlapAreas: () => (/* binding */ getUnoverlapAreas),\n/* harmony export */   isInside: () => (/* binding */ isInside),\n/* harmony export */   isPointOnLine: () => (/* binding */ isPointOnLine)\n/* harmony export */ });\n/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @daybrush/utils */ \"(ssr)/./node_modules/@daybrush/utils/dist/utils.esm.js\");\n/*\nCopyright (c) 2020 Daybrush\nname: overlap-area\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/overlap-area.git\nversion: 1.1.0\n*/ \n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __spreadArrays() {\n    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;\n    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];\n    return r;\n}\nfunction tinyThrottle(num) {\n    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(num, _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM);\n}\nfunction isSameConstants(linearConstants1, linearConstants2) {\n    return linearConstants1.every(function(v, i) {\n        return tinyThrottle(v - linearConstants2[i]) === 0;\n    });\n}\nfunction isSamePoint(point1, point2) {\n    return !tinyThrottle(point1[0] - point2[0]) && !tinyThrottle(point1[1] - point2[1]);\n}\nfunction flat(arr) {\n    return arr.reduce(function(prev, current) {\n        prev.push.apply(prev, current);\n        return prev;\n    }, []);\n}\n/**\n * @namespace OverlapArea\n */ /**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */ function getAreaSize(points) {\n    if (points.length < 3) {\n        return 0;\n    }\n    return Math.abs((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.sum)(points.map(function(point, i) {\n        var nextPoint = points[i + 1] || points[0];\n        return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n    }))) / 2;\n}\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */ function fitPoints(points, rect) {\n    var width = rect.width, height = rect.height, left = rect.left, top = rect.top;\n    var _a = getMinMaxs(points), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\n    var ratioX = width / (maxX - minX);\n    var ratioY = height / (maxY - minY);\n    return points.map(function(point) {\n        return [\n            left + (point[0] - minX) * ratioX,\n            top + (point[1] - minY) * ratioY\n        ];\n    });\n}\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */ function getMinMaxs(points) {\n    var xs = points.map(function(point) {\n        return point[0];\n    });\n    var ys = points.map(function(point) {\n        return point[1];\n    });\n    return {\n        minX: Math.min.apply(Math, xs),\n        minY: Math.min.apply(Math, ys),\n        maxX: Math.max.apply(Math, xs),\n        maxY: Math.max.apply(Math, ys)\n    };\n}\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */ function isInside(pos, points, excludeLine) {\n    var x = pos[0], y = pos[1];\n    var _a = getMinMaxs(points), minX = _a.minX, maxX = _a.maxX;\n    var xLine = [\n        [\n            minX,\n            y\n        ],\n        [\n            maxX,\n            y\n        ]\n    ];\n    var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n    var lines = convertLines(points);\n    var intersectionPosInfos = [];\n    lines.forEach(function(line) {\n        var linearConstants = getLinearConstants(line[0], line[1]);\n        var standardPoint = line[0];\n        if (isSameConstants(xLinearConstants, linearConstants)) {\n            intersectionPosInfos.push({\n                pos: pos,\n                line: line,\n                type: \"line\"\n            });\n        } else {\n            var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [\n                xLine,\n                line\n            ]);\n            xPoints.forEach(function(point) {\n                if (line.some(function(linePoint) {\n                    return isSamePoint(linePoint, point);\n                })) {\n                    intersectionPosInfos.push({\n                        pos: point,\n                        line: line,\n                        type: \"point\"\n                    });\n                } else if (tinyThrottle(standardPoint[1] - y) !== 0) {\n                    intersectionPosInfos.push({\n                        pos: point,\n                        line: line,\n                        type: \"intersection\"\n                    });\n                }\n            });\n        }\n    });\n    if (!excludeLine) {\n        // on line\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.find)(intersectionPosInfos, function(p) {\n            return p[0] === x;\n        })) {\n            return true;\n        }\n    }\n    var intersectionCount = 0;\n    var xMap = {};\n    intersectionPosInfos.forEach(function(_a) {\n        var pos = _a.pos, type = _a.type, line = _a.line;\n        if (pos[0] > x) {\n            return;\n        }\n        if (type === \"intersection\") {\n            ++intersectionCount;\n        } else if (type === \"line\") {\n            return;\n        } else if (type === \"point\") {\n            var point = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.find)(line, function(linePoint) {\n                return linePoint[1] !== y;\n            });\n            var prevValue = xMap[pos[0]];\n            var nextValue = point[1] > y ? 1 : -1;\n            if (!prevValue) {\n                xMap[pos[0]] = nextValue;\n            } else if (prevValue !== nextValue) {\n                ++intersectionCount;\n            }\n        }\n    });\n    return intersectionCount % 2 === 1;\n}\n/**\n * Get distance from point to constants. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */ function getDistanceFromPointToConstants(_a, pos) {\n    var a = _a[0], b = _a[1], c = _a[2];\n    return (a * pos[0] + b * pos[1] + c) / (a * a + b * b);\n}\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */ function getLinearConstants(point1, point2) {\n    var x1 = point1[0], y1 = point1[1];\n    var x2 = point2[0], y2 = point2[1]; // ax + by + c = 0\n    // [a, b, c]\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    if (Math.abs(dx) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) {\n        dy = 0;\n    } // b > 0\n    // ax + by + c = 0\n    var a = 0;\n    var b = 0;\n    var c = 0;\n    if (!dx) {\n        if (dy) {\n            // -x + 1 = 0\n            a = -1;\n            c = x1;\n        }\n    } else if (!dy) {\n        // y - 1 = 0\n        b = 1;\n        c = -y1;\n    } else {\n        // y = -a(x - x1) + y1\n        // ax + y + a * x1 - y1 = 0\n        a = -dy / dx;\n        b = 1;\n        c = -a * x1 - y1;\n    }\n    return [\n        a,\n        b,\n        c\n    ];\n}\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */ function getIntersectionPointsByConstants(linearConstants1, linearConstants2) {\n    var a1 = linearConstants1[0], b1 = linearConstants1[1], c1 = linearConstants1[2];\n    var a2 = linearConstants2[0], b2 = linearConstants2[1], c2 = linearConstants2[2];\n    var isZeroA = a1 === 0 && a2 === 0;\n    var isZeroB = b1 === 0 && b2 === 0;\n    var results = [];\n    if (isZeroA && isZeroB) {\n        return [];\n    } else if (isZeroA) {\n        // b1 * y + c1 = 0\n        // b2 * y + c2 = 0\n        var y1 = -c1 / b1;\n        var y2 = -c2 / b2;\n        if (y1 !== y2) {\n            return [];\n        } else {\n            return [\n                [\n                    -Infinity,\n                    y1\n                ],\n                [\n                    Infinity,\n                    y1\n                ]\n            ];\n        }\n    } else if (isZeroB) {\n        // a1 * x + c1 = 0\n        // a2 * x + c2 = 0\n        var x1 = -c1 / a1;\n        var x2 = -c2 / a2;\n        if (x1 !== x2) {\n            return [];\n        } else {\n            return [\n                [\n                    x1,\n                    -Infinity\n                ],\n                [\n                    x1,\n                    Infinity\n                ]\n            ];\n        }\n    } else if (a1 === 0) {\n        // b1 * y + c1 = 0\n        // y = - c1 / b1;\n        // a2 * x + b2 * y + c2 = 0\n        var y = -c1 / b1;\n        var x = -(b2 * y + c2) / a2;\n        results = [\n            [\n                x,\n                y\n            ]\n        ];\n    } else if (a2 === 0) {\n        // b2 * y + c2 = 0\n        // y = - c2 / b2;\n        // a1 * x + b1 * y + c1 = 0\n        var y = -c2 / b2;\n        var x = -(b1 * y + c1) / a1;\n        results = [\n            [\n                x,\n                y\n            ]\n        ];\n    } else if (b1 === 0) {\n        // a1 * x + c1 = 0\n        // x = - c1 / a1;\n        // a2 * x + b2 * y + c2 = 0\n        var x = -c1 / a1;\n        var y = -(a2 * x + c2) / b2;\n        results = [\n            [\n                x,\n                y\n            ]\n        ];\n    } else if (b2 === 0) {\n        // a2 * x + c2 = 0\n        // x = - c2 / a2;\n        // a1 * x + b1 * y + c1 = 0\n        var x = -c2 / a2;\n        var y = -(a1 * x + c1) / b1;\n        results = [\n            [\n                x,\n                y\n            ]\n        ];\n    } else {\n        // a1 * x + b1 * y + c1 = 0\n        // a2 * x + b2 * y + c2 = 0\n        // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n        // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n        // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n        var x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n        var y = -(a1 * x + c1) / b1;\n        results = [\n            [\n                x,\n                y\n            ]\n        ];\n    }\n    return results.map(function(result) {\n        return [\n            result[0],\n            result[1]\n        ];\n    });\n}\n/**\n * Get intersection points to the two lines.\n * @memberof OverlapArea\n */ function getIntersectionPoints(line1, line2, isLimit) {\n    var points = getIntersectionPointsByConstants(getLinearConstants(line1[0], line1[1]), getLinearConstants(line2[0], line2[1]));\n    if (isLimit) {\n        return getPointsOnLines(points, [\n            line1,\n            line2\n        ]);\n    }\n    return points;\n}\nfunction isPointOnLine(pos, line) {\n    var linearConstants = getLinearConstants(line[0], line[1]);\n    return tinyThrottle(getDistanceFromPointToConstants(linearConstants, pos)) === 0;\n}\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */ function getPointsOnLines(points, lines) {\n    var minMaxs = lines.map(function(line) {\n        return [\n            0,\n            1\n        ].map(function(order) {\n            return [\n                Math.min(line[0][order], line[1][order]),\n                Math.max(line[0][order], line[1][order])\n            ];\n        });\n    });\n    var results = [];\n    if (points.length === 2) {\n        var _a = points[0], x = _a[0], y = _a[1];\n        if (!tinyThrottle(x - points[1][0])) {\n            /// Math.max(minY1, minY2)\n            var top = Math.max.apply(Math, minMaxs.map(function(minMax) {\n                return minMax[1][0];\n            })); /// Math.min(maxY1, miax2)\n            var bottom = Math.min.apply(Math, minMaxs.map(function(minMax) {\n                return minMax[1][1];\n            }));\n            if (tinyThrottle(top - bottom) > 0) {\n                return [];\n            }\n            results = [\n                [\n                    x,\n                    top\n                ],\n                [\n                    x,\n                    bottom\n                ]\n            ];\n        } else if (!tinyThrottle(y - points[1][1])) {\n            /// Math.max(minY1, minY2)\n            var left = Math.max.apply(Math, minMaxs.map(function(minMax) {\n                return minMax[0][0];\n            })); /// Math.min(maxY1, miax2)\n            var right = Math.min.apply(Math, minMaxs.map(function(minMax) {\n                return minMax[0][1];\n            }));\n            if (tinyThrottle(left - right) > 0) {\n                return [];\n            }\n            results = [\n                [\n                    left,\n                    y\n                ],\n                [\n                    right,\n                    y\n                ]\n            ];\n        }\n    }\n    if (!results.length) {\n        results = points.filter(function(point) {\n            var pointX = point[0], pointY = point[1];\n            return minMaxs.every(function(minMax) {\n                return 0 <= tinyThrottle(pointX - minMax[0][0]) && 0 <= tinyThrottle(minMax[0][1] - pointX) && 0 <= tinyThrottle(pointY - minMax[1][0]) && 0 <= tinyThrottle(minMax[1][1] - pointY);\n            });\n        });\n    }\n    return results.map(function(result) {\n        return [\n            tinyThrottle(result[0]),\n            tinyThrottle(result[1])\n        ];\n    });\n}\n/**\n* Convert two points into lines.\n* @function\n* @memberof OverlapArea\n*/ function convertLines(points) {\n    return __spreadArrays(points.slice(1), [\n        points[0]\n    ]).map(function(point, i) {\n        return [\n            points[i],\n            point\n        ];\n    });\n}\nfunction getOverlapPointInfos(points1, points2) {\n    var targetPoints1 = points1.slice();\n    var targetPoints2 = points2.slice();\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getShapeDirection)(targetPoints1) === -1) {\n        targetPoints1.reverse();\n    }\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getShapeDirection)(targetPoints2) === -1) {\n        targetPoints2.reverse();\n    }\n    var lines1 = convertLines(targetPoints1);\n    var lines2 = convertLines(targetPoints2);\n    var linearConstantsList1 = lines1.map(function(line1) {\n        return getLinearConstants(line1[0], line1[1]);\n    });\n    var linearConstantsList2 = lines2.map(function(line2) {\n        return getLinearConstants(line2[0], line2[1]);\n    });\n    var overlapInfos = [];\n    linearConstantsList1.forEach(function(linearConstants1, i) {\n        var line1 = lines1[i];\n        var linePointInfos = [];\n        linearConstantsList2.forEach(function(linearConstants2, j) {\n            var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n            var points = getPointsOnLines(intersectionPoints, [\n                line1,\n                lines2[j]\n            ]);\n            linePointInfos.push.apply(linePointInfos, points.map(function(pos) {\n                return {\n                    index1: i,\n                    index2: j,\n                    pos: pos,\n                    type: \"intersection\"\n                };\n            }));\n        });\n        linePointInfos.sort(function(a, b) {\n            return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(line1[0], a.pos) - (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(line1[0], b.pos);\n        });\n        overlapInfos.push.apply(overlapInfos, linePointInfos);\n        if (isInside(line1[1], targetPoints2)) {\n            overlapInfos.push({\n                index1: i,\n                index2: -1,\n                pos: line1[1],\n                type: \"inside\"\n            });\n        }\n    });\n    lines2.forEach(function(line2, i) {\n        if (!isInside(line2[1], targetPoints1)) {\n            return;\n        }\n        var isNext = false;\n        var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(overlapInfos, function(_a) {\n            var index2 = _a.index2;\n            if (index2 === i) {\n                isNext = true;\n                return false;\n            }\n            if (isNext) {\n                return true;\n            }\n            return false;\n        });\n        if (index === -1) {\n            isNext = false;\n            index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(overlapInfos, function(_a) {\n                var index1 = _a.index1, index2 = _a.index2;\n                if (index1 === -1 && index2 + 1 === i) {\n                    isNext = true;\n                    return false;\n                }\n                if (isNext) {\n                    return true;\n                }\n                return false;\n            });\n        }\n        if (index === -1) {\n            overlapInfos.push({\n                index1: -1,\n                index2: i,\n                pos: line2[1],\n                type: \"inside\"\n            });\n        } else {\n            overlapInfos.splice(index, 0, {\n                index1: -1,\n                index2: i,\n                pos: line2[1],\n                type: \"inside\"\n            });\n        }\n    });\n    var pointMap = {};\n    return overlapInfos.filter(function(_a) {\n        var pos = _a.pos;\n        var key = pos[0] + \"x\" + pos[1];\n        if (pointMap[key]) {\n            return false;\n        }\n        pointMap[key] = true;\n        return true;\n    });\n}\n/**\n* Get the points of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/ function getOverlapPoints(points1, points2) {\n    var infos = getOverlapPointInfos(points1, points2);\n    return infos.map(function(_a) {\n        var pos = _a.pos;\n        return pos;\n    });\n}\nfunction isConnectedLine(line) {\n    var _a = line[0], prevIndex1 = _a.index1, prevIndex2 = _a.index2, _b = line[1], nextIndex1 = _b.index1, nextIndex2 = _b.index2;\n    if (prevIndex1 !== -1) {\n        // same line\n        if (prevIndex1 === nextIndex1) {\n            return true;\n        }\n        if (prevIndex1 + 1 === nextIndex1) {\n            return true;\n        }\n    }\n    if (prevIndex2 !== -1) {\n        // same line\n        if (prevIndex2 === nextIndex2) {\n            return true;\n        }\n        if (prevIndex2 + 1 === nextIndex2) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n* Get the areas of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/ function getOverlapAreas(points1, points2) {\n    var infos = getOverlapPointInfos(points1, points2);\n    var areas = [];\n    var area;\n    getOverlapPointInfos(points1, points2).forEach(function(info, i, arr) {\n        if (i === 0 || !isConnectedLine([\n            arr[i - 1],\n            info\n        ])) {\n            area = [\n                info\n            ];\n            areas.push(area);\n        } else {\n            area.push(info);\n        }\n    });\n    return areas.map(function(area) {\n        return area.map(function(_a) {\n            var pos = _a.pos;\n            return pos;\n        });\n    });\n}\nfunction findReversedAreas(points1, points2, index, areas) {\n    if (index === void 0) {\n        index = 0;\n    }\n    if (areas === void 0) {\n        areas = [];\n    }\n    var isFirst = areas.length === 0;\n    var length = points1.length;\n    var nextIndex = points1[index] ? index : 0;\n    var nextPoints1 = __spreadArrays(points1.slice(nextIndex), points1.slice(0, nextIndex));\n    var _loop_1 = function(i) {\n        var point1 = nextPoints1[i];\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.find)(points2, function(point2) {\n            return point2[0] === point1[0] && point2[1] === point1[1];\n        })) {\n            return \"continue\";\n        }\n        if (areas.some(function(nextArea) {\n            return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.find)(nextArea, function(areaPoint) {\n                return areaPoint[0] === point1[0] && areaPoint[1] === point1[1];\n            });\n        })) {\n            if (isFirst) {\n                return \"continue\";\n            } else {\n                return \"break\";\n            }\n        }\n        var nextArea = void 0;\n        if (isFirst) {\n            nextArea = [];\n            areas.push(nextArea);\n        } else {\n            nextArea = areas[areas.length - 1];\n        }\n        nextArea.push(point1);\n        var line = [\n            point1,\n            points1[index + 1] || points1[0]\n        ];\n        var nextPoint2 = points2.filter(function(point2) {\n            return isPointOnLine(point2, line);\n        }).sort(function(a, b) {\n            return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(point1, a) - (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(point1, b);\n        })[0];\n        if (!nextPoint2) {\n            findReversedAreas(nextPoints1, points2, i + 1, areas);\n            return \"break\";\n        } else {\n            var point2Index = points2.indexOf(nextPoint2);\n            findReversedAreas(points2, points1, point2Index, areas);\n            if (!isFirst) {\n                return \"break\";\n            }\n        }\n    };\n    for(var i = 0; i < length; ++i){\n        var state_1 = _loop_1(i);\n        if (state_1 === \"break\") break;\n    }\n    return areas;\n}\nfunction findConnectedAreas(points1, points2) {\n    return findReversedAreas(points1, __spreadArrays(points2).reverse());\n}\n/**\n* Get non-overlapping areas of two shapes based on points1.\n* @memberof OverlapArea\n*/ function getUnoverlapAreas(points1, points2) {\n    if (!points2.length) {\n        return [\n            __spreadArrays(points1)\n        ];\n    }\n    var overlapAreas = getOverlapAreas(points1, points2);\n    var unoverlapAreas = [\n        points1\n    ];\n    overlapAreas.forEach(function(overlapArea) {\n        var nextOverlapArea = __spreadArrays(overlapArea).reverse();\n        unoverlapAreas = flat(unoverlapAreas.map(function(area) {\n            var connectedAreas = findReversedAreas(area, nextOverlapArea);\n            var firstConnectedArea = connectedAreas[0];\n            if (connectedAreas.length === 1 && nextOverlapArea.every(function(point) {\n                return firstConnectedArea.indexOf(point) === -1;\n            })) {\n                var lastPoint_1 = firstConnectedArea[firstConnectedArea.length - 1];\n                var firstPoint = __spreadArrays(nextOverlapArea).sort(function(a, b) {\n                    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(lastPoint_1, a) - (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(lastPoint_1, b);\n                })[0];\n                var firstIndex = nextOverlapArea.indexOf(firstPoint);\n                firstConnectedArea.push.apply(firstConnectedArea, __spreadArrays(nextOverlapArea.slice(firstIndex), nextOverlapArea.slice(0, firstIndex), [\n                    nextOverlapArea[firstIndex],\n                    lastPoint_1\n                ]));\n            }\n            return connectedAreas;\n        }));\n    });\n    return unoverlapAreas;\n}\n/**\n* Gets the size of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/ function getOverlapSize(points1, points2) {\n    var points = getOverlapPoints(points1, points2);\n    return getAreaSize(points);\n}\n //# sourceMappingURL=overlap-area.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3ZlcmxhcC1hcmVhL2Rpc3Qvb3ZlcmxhcC1hcmVhLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7O0FBT0EsR0FDdUc7QUFFdkc7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLFNBQVNPO0lBQ1AsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLElBQUksR0FBR0MsS0FBS0MsVUFBVUMsTUFBTSxFQUFFSCxJQUFJQyxJQUFJRCxJQUFLRCxLQUFLRyxTQUFTLENBQUNGLEVBQUUsQ0FBQ0csTUFBTTtJQUVuRixJQUFLLElBQUlDLElBQUlDLE1BQU1OLElBQUlPLElBQUksR0FBR04sSUFBSSxHQUFHQSxJQUFJQyxJQUFJRCxJQUFLLElBQUssSUFBSU8sSUFBSUwsU0FBUyxDQUFDRixFQUFFLEVBQUVRLElBQUksR0FBR0MsS0FBS0YsRUFBRUosTUFBTSxFQUFFSyxJQUFJQyxJQUFJRCxLQUFLRixJQUFLRixDQUFDLENBQUNFLEVBQUUsR0FBR0MsQ0FBQyxDQUFDQyxFQUFFO0lBRWhJLE9BQU9KO0FBQ1Q7QUFFQSxTQUFTTSxhQUFhQyxHQUFHO0lBQ3ZCLE9BQU9wQix5REFBUUEsQ0FBQ29CLEtBQUtuQixxREFBUUE7QUFDL0I7QUFDQSxTQUFTb0IsZ0JBQWdCQyxnQkFBZ0IsRUFBRUMsZ0JBQWdCO0lBQ3pELE9BQU9ELGlCQUFpQkUsS0FBSyxDQUFDLFNBQVVDLENBQUMsRUFBRWhCLENBQUM7UUFDMUMsT0FBT1UsYUFBYU0sSUFBSUYsZ0JBQWdCLENBQUNkLEVBQUUsTUFBTTtJQUNuRDtBQUNGO0FBQ0EsU0FBU2lCLFlBQVlDLE1BQU0sRUFBRUMsTUFBTTtJQUNqQyxPQUFPLENBQUNULGFBQWFRLE1BQU0sQ0FBQyxFQUFFLEdBQUdDLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQ1QsYUFBYVEsTUFBTSxDQUFDLEVBQUUsR0FBR0MsTUFBTSxDQUFDLEVBQUU7QUFDcEY7QUFDQSxTQUFTQyxLQUFLQyxH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SCxJQUFJO1lBQ3JELElBQUltQixpQkFBaUJqQixrQkFBa0JGLE1BQU1rQjtZQUM3QyxJQUFJRSxxQkFBcUJELGNBQWMsQ0FBQyxFQUFFO1lBRTFDLElBQUlBLGVBQWUvSixNQUFNLEtBQUssS0FBSzhKLGdCQUFnQmxKLEtBQUssQ0FBQyxTQUFVaUIsS0FBSztnQkFDdEUsT0FBT21JLG1CQUFtQlQsT0FBTyxDQUFDMUgsV0FBVyxDQUFDO1lBQ2hELElBQUk7Z0JBQ0YsSUFBSW9JLGNBQWNELGtCQUFrQixDQUFDQSxtQkFBbUJoSyxNQUFNLEdBQUcsRUFBRTtnQkFFbkUsSUFBSWtLLGFBQWF2SyxlQUFlbUssaUJBQWlCbEMsSUFBSSxDQUFDLFNBQVV4SCxDQUFDLEVBQUV3RSxDQUFDO29CQUNsRSxPQUFPcEYsd0RBQU9BLENBQUN5SyxhQUFhN0osS0FBS1osd0RBQU9BLENBQUN5SyxhQUFhckY7Z0JBQ3hELEVBQUUsQ0FBQyxFQUFFO2dCQUVMLElBQUl1RixhQUFhTCxnQkFBZ0JQLE9BQU8sQ0FBQ1c7Z0JBQ3pDRixtQkFBbUIxSSxJQUFJLENBQUNDLEtBQUssQ0FBQ3lJLG9CQUFvQnJLLGVBQWVtSyxnQkFBZ0JsRCxLQUFLLENBQUN1RCxhQUFhTCxnQkFBZ0JsRCxLQUFLLENBQUMsR0FBR3VELGFBQWE7b0JBQUNMLGVBQWUsQ0FBQ0ssV0FBVztvQkFBRUY7aUJBQVk7WUFDdEw7WUFFQSxPQUFPRjtRQUNUO0lBQ0Y7SUFDQSxPQUFPSDtBQUNUO0FBQ0E7Ozs7QUFJQSxHQUVBLFNBQVNRLGVBQWV0RCxPQUFPLEVBQUVDLE9BQU87SUFDdEMsSUFBSXRGLFNBQVN5RyxpQkFBaUJwQixTQUFTQztJQUN2QyxPQUFPdkYsWUFBWUM7QUFDckI7QUFFK1MsQ0FDL1MsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpcGpzLy4vbm9kZV9tb2R1bGVzL292ZXJsYXAtYXJlYS9kaXN0L292ZXJsYXAtYXJlYS5lc20uanM/MTZmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSAyMDIwIERheWJydXNoXG5uYW1lOiBvdmVybGFwLWFyZWFcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9vdmVybGFwLWFyZWEuZ2l0XG52ZXJzaW9uOiAxLjEuMFxuKi9cbmltcG9ydCB7IHRocm90dGxlLCBUSU5ZX05VTSwgc3VtLCBmaW5kLCBnZXREaXN0LCBnZXRTaGFwZURpcmVjdGlvbiwgZmluZEluZGV4IH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcblxuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKSByW2tdID0gYVtqXTtcblxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gdGlueVRocm90dGxlKG51bSkge1xuICByZXR1cm4gdGhyb3R0bGUobnVtLCBUSU5ZX05VTSk7XG59XG5mdW5jdGlvbiBpc1NhbWVDb25zdGFudHMobGluZWFyQ29uc3RhbnRzMSwgbGluZWFyQ29uc3RhbnRzMikge1xuICByZXR1cm4gbGluZWFyQ29uc3RhbnRzMS5ldmVyeShmdW5jdGlvbiAodiwgaSkge1xuICAgIHJldHVybiB0aW55VGhyb3R0bGUodiAtIGxpbmVhckNvbnN0YW50czJbaV0pID09PSAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVBvaW50KHBvaW50MSwgcG9pbnQyKSB7XG4gIHJldHVybiAhdGlueVRocm90dGxlKHBvaW50MVswXSAtIHBvaW50MlswXSkgJiYgIXRpbnlUaHJvdHRsZShwb2ludDFbMV0gLSBwb2ludDJbMV0pO1xufVxuZnVuY3Rpb24gZmxhdChhcnIpIHtcbiAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnJlbnQpIHtcbiAgICBwcmV2LnB1c2guYXBwbHkocHJldiwgY3VycmVudCk7XG4gICAgcmV0dXJuIHByZXY7XG4gIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBAbmFtZXNwYWNlIE92ZXJsYXBBcmVhXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGEgc2hhcGUgKHBvbHlnb24pIG1hZGUgb2YgcG9pbnRzLlxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gZ2V0QXJlYVNpemUocG9pbnRzKSB7XG4gIGlmIChwb2ludHMubGVuZ3RoIDwgMykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguYWJzKHN1bShwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCwgaSkge1xuICAgIHZhciBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdIHx8IHBvaW50c1swXTtcbiAgICByZXR1cm4gcG9pbnRbMF0gKiBuZXh0UG9pbnRbMV0gLSBuZXh0UG9pbnRbMF0gKiBwb2ludFsxXTtcbiAgfSkpKSAvIDI7XG59XG4vKipcbiAqIEdldCBwb2ludHMgdGhhdCBmaXQgdGhlIHJlY3QsXG4gKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiAqL1xuXG5mdW5jdGlvbiBmaXRQb2ludHMocG9pbnRzLCByZWN0KSB7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCxcbiAgICAgIGxlZnQgPSByZWN0LmxlZnQsXG4gICAgICB0b3AgPSByZWN0LnRvcDtcblxuICB2YXIgX2EgPSBnZXRNaW5NYXhzKHBvaW50cyksXG4gICAgICBtaW5YID0gX2EubWluWCxcbiAgICAgIG1pblkgPSBfYS5taW5ZLFxuICAgICAgbWF4WCA9IF9hLm1heFgsXG4gICAgICBtYXhZID0gX2EubWF4WTtcblxuICB2YXIgcmF0aW9YID0gd2lkdGggLyAobWF4WCAtIG1pblgpO1xuICB2YXIgcmF0aW9ZID0gaGVpZ2h0IC8gKG1heFkgLSBtaW5ZKTtcbiAgcmV0dXJuIHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcmV0dXJuIFtsZWZ0ICsgKHBvaW50WzBdIC0gbWluWCkgKiByYXRpb1gsIHRvcCArIChwb2ludFsxXSAtIG1pblkpICogcmF0aW9ZXTtcbiAgfSk7XG59XG4vKipcbiAqIEdldCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBwb2ludHMgb2YgdGhlIHBvaW50cy5cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldE1pbk1heHMocG9pbnRzKSB7XG4gIHZhciB4cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcmV0dXJuIHBvaW50WzBdO1xuICB9KTtcbiAgdmFyIHlzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnRbMV07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG1pblg6IE1hdGgubWluLmFwcGx5KE1hdGgsIHhzKSxcbiAgICBtaW5ZOiBNYXRoLm1pbi5hcHBseShNYXRoLCB5cyksXG4gICAgbWF4WDogTWF0aC5tYXguYXBwbHkoTWF0aCwgeHMpLFxuICAgIG1heFk6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHlzKVxuICB9O1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBwb2ludCBpcyBpbiBzaGFwZVxuICogQHBhcmFtIC0gcG9pbnQgcG9zXG4gKiBAcGFyYW0gLSBzaGFwZSBwb2ludHNcbiAqIEBwYXJhbSAtIHdoZXRoZXIgdG8gY2hlY2sgZXhjZXB0IGxpbmVcbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGlzSW5zaWRlKHBvcywgcG9pbnRzLCBleGNsdWRlTGluZSkge1xuICB2YXIgeCA9IHBvc1swXSxcbiAgICAgIHkgPSBwb3NbMV07XG5cbiAgdmFyIF9hID0gZ2V0TWluTWF4cyhwb2ludHMpLFxuICAgICAgbWluWCA9IF9hLm1pblgsXG4gICAgICBtYXhYID0gX2EubWF4WDtcblxuICB2YXIgeExpbmUgPSBbW21pblgsIHldLCBbbWF4WCwgeV1dO1xuICB2YXIgeExpbmVhckNvbnN0YW50cyA9IGdldExpbmVhckNvbnN0YW50cyh4TGluZVswXSwgeExpbmVbMV0pO1xuICB2YXIgbGluZXMgPSBjb252ZXJ0TGluZXMocG9pbnRzKTtcbiAgdmFyIGludGVyc2VjdGlvblBvc0luZm9zID0gW107XG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICB2YXIgbGluZWFyQ29uc3RhbnRzID0gZ2V0TGluZWFyQ29uc3RhbnRzKGxpbmVbMF0sIGxpbmVbMV0pO1xuICAgIHZhciBzdGFuZGFyZFBvaW50ID0gbGluZVswXTtcblxuICAgIGlmIChpc1NhbWVDb25zdGFudHMoeExpbmVhckNvbnN0YW50cywgbGluZWFyQ29uc3RhbnRzKSkge1xuICAgICAgaW50ZXJzZWN0aW9uUG9zSW5mb3MucHVzaCh7XG4gICAgICAgIHBvczogcG9zLFxuICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICB0eXBlOiBcImxpbmVcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4UG9pbnRzID0gZ2V0UG9pbnRzT25MaW5lcyhnZXRJbnRlcnNlY3Rpb25Qb2ludHNCeUNvbnN0YW50cyh4TGluZWFyQ29uc3RhbnRzLCBsaW5lYXJDb25zdGFudHMpLCBbeExpbmUsIGxpbmVdKTtcbiAgICAgIHhQb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgaWYgKGxpbmUuc29tZShmdW5jdGlvbiAobGluZVBvaW50KSB7XG4gICAgICAgICAgcmV0dXJuIGlzU2FtZVBvaW50KGxpbmVQb2ludCwgcG9pbnQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGludGVyc2VjdGlvblBvc0luZm9zLnB1c2goe1xuICAgICAgICAgICAgcG9zOiBwb2ludCxcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICB0eXBlOiBcInBvaW50XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW55VGhyb3R0bGUoc3RhbmRhcmRQb2ludFsxXSAtIHkpICE9PSAwKSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uUG9zSW5mb3MucHVzaCh7XG4gICAgICAgICAgICBwb3M6IHBvaW50LFxuICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgIHR5cGU6IFwiaW50ZXJzZWN0aW9uXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWV4Y2x1ZGVMaW5lKSB7XG4gICAgLy8gb24gbGluZVxuICAgIGlmIChmaW5kKGludGVyc2VjdGlvblBvc0luZm9zLCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHBbMF0gPT09IHg7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbnRlcnNlY3Rpb25Db3VudCA9IDA7XG4gIHZhciB4TWFwID0ge307XG4gIGludGVyc2VjdGlvblBvc0luZm9zLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHBvcyA9IF9hLnBvcyxcbiAgICAgICAgdHlwZSA9IF9hLnR5cGUsXG4gICAgICAgIGxpbmUgPSBfYS5saW5lO1xuXG4gICAgaWYgKHBvc1swXSA+IHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gXCJpbnRlcnNlY3Rpb25cIikge1xuICAgICAgKytpbnRlcnNlY3Rpb25Db3VudDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibGluZVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInBvaW50XCIpIHtcbiAgICAgIHZhciBwb2ludCA9IGZpbmQobGluZSwgZnVuY3Rpb24gKGxpbmVQb2ludCkge1xuICAgICAgICByZXR1cm4gbGluZVBvaW50WzFdICE9PSB5O1xuICAgICAgfSk7XG4gICAgICB2YXIgcHJldlZhbHVlID0geE1hcFtwb3NbMF1dO1xuICAgICAgdmFyIG5leHRWYWx1ZSA9IHBvaW50WzFdID4geSA/IDEgOiAtMTtcblxuICAgICAgaWYgKCFwcmV2VmFsdWUpIHtcbiAgICAgICAgeE1hcFtwb3NbMF1dID0gbmV4dFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChwcmV2VmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgICArK2ludGVyc2VjdGlvbkNvdW50O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbnRlcnNlY3Rpb25Db3VudCAlIDIgPT09IDE7XG59XG4vKipcbiAqIEdldCBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIGNvbnN0YW50cy4gW2EsIGIsIGNdIChheCArIGJ5ICsgYyA9IDApXG4gKiBAcmV0dXJuIFthLCBiLCBjXVxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VGcm9tUG9pbnRUb0NvbnN0YW50cyhfYSwgcG9zKSB7XG4gIHZhciBhID0gX2FbMF0sXG4gICAgICBiID0gX2FbMV0sXG4gICAgICBjID0gX2FbMl07XG4gIHJldHVybiAoYSAqIHBvc1swXSArIGIgKiBwb3NbMV0gKyBjKSAvIChhICogYSArIGIgKiBiKTtcbn1cbi8qKlxuICogR2V0IHRoZSBjb2VmZmljaWVudCBvZiB0aGUgbGluZWFyIGZ1bmN0aW9uLiBbYSwgYiwgY10gKGF4ICsgYnkgKyBjID0gMClcbiAqIEByZXR1cm4gW2EsIGIsIGNdXG4gKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiAqL1xuXG5mdW5jdGlvbiBnZXRMaW5lYXJDb25zdGFudHMocG9pbnQxLCBwb2ludDIpIHtcbiAgdmFyIHgxID0gcG9pbnQxWzBdLFxuICAgICAgeTEgPSBwb2ludDFbMV07XG4gIHZhciB4MiA9IHBvaW50MlswXSxcbiAgICAgIHkyID0gcG9pbnQyWzFdOyAvLyBheCArIGJ5ICsgYyA9IDBcbiAgLy8gW2EsIGIsIGNdXG5cbiAgdmFyIGR4ID0geDIgLSB4MTtcbiAgdmFyIGR5ID0geTIgLSB5MTtcblxuICBpZiAoTWF0aC5hYnMoZHgpIDwgVElOWV9OVU0pIHtcbiAgICBkeCA9IDA7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoZHkpIDwgVElOWV9OVU0pIHtcbiAgICBkeSA9IDA7XG4gIH0gLy8gYiA+IDBcbiAgLy8gYXggKyBieSArIGMgPSAwXG5cblxuICB2YXIgYSA9IDA7XG4gIHZhciBiID0gMDtcbiAgdmFyIGMgPSAwO1xuXG4gIGlmICghZHgpIHtcbiAgICBpZiAoZHkpIHtcbiAgICAgIC8vIC14ICsgMSA9IDBcbiAgICAgIGEgPSAtMTtcbiAgICAgIGMgPSB4MTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWR5KSB7XG4gICAgLy8geSAtIDEgPSAwXG4gICAgYiA9IDE7XG4gICAgYyA9IC15MTtcbiAgfSBlbHNlIHtcbiAgICAvLyB5ID0gLWEoeCAtIHgxKSArIHkxXG4gICAgLy8gYXggKyB5ICsgYSAqIHgxIC0geTEgPSAwXG4gICAgYSA9IC1keSAvIGR4O1xuICAgIGIgPSAxO1xuICAgIGMgPSAtYSAqIHgxIC0geTE7XG4gIH1cblxuICByZXR1cm4gW2EsIGIsIGNdO1xufVxuLyoqXG4gKiBHZXQgaW50ZXJzZWN0aW9uIHBvaW50cyB3aXRoIGxpbmVhciBmdW5jdGlvbnMuXG4gKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiAqL1xuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25Qb2ludHNCeUNvbnN0YW50cyhsaW5lYXJDb25zdGFudHMxLCBsaW5lYXJDb25zdGFudHMyKSB7XG4gIHZhciBhMSA9IGxpbmVhckNvbnN0YW50czFbMF0sXG4gICAgICBiMSA9IGxpbmVhckNvbnN0YW50czFbMV0sXG4gICAgICBjMSA9IGxpbmVhckNvbnN0YW50czFbMl07XG4gIHZhciBhMiA9IGxpbmVhckNvbnN0YW50czJbMF0sXG4gICAgICBiMiA9IGxpbmVhckNvbnN0YW50czJbMV0sXG4gICAgICBjMiA9IGxpbmVhckNvbnN0YW50czJbMl07XG4gIHZhciBpc1plcm9BID0gYTEgPT09IDAgJiYgYTIgPT09IDA7XG4gIHZhciBpc1plcm9CID0gYjEgPT09IDAgJiYgYjIgPT09IDA7XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgaWYgKGlzWmVyb0EgJiYgaXNaZXJvQikge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIGlmIChpc1plcm9BKSB7XG4gICAgLy8gYjEgKiB5ICsgYzEgPSAwXG4gICAgLy8gYjIgKiB5ICsgYzIgPSAwXG4gICAgdmFyIHkxID0gLWMxIC8gYjE7XG4gICAgdmFyIHkyID0gLWMyIC8gYjI7XG5cbiAgICBpZiAoeTEgIT09IHkyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbWy1JbmZpbml0eSwgeTFdLCBbSW5maW5pdHksIHkxXV07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzWmVyb0IpIHtcbiAgICAvLyBhMSAqIHggKyBjMSA9IDBcbiAgICAvLyBhMiAqIHggKyBjMiA9IDBcbiAgICB2YXIgeDEgPSAtYzEgLyBhMTtcbiAgICB2YXIgeDIgPSAtYzIgLyBhMjtcblxuICAgIGlmICh4MSAhPT0geDIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtbeDEsIC1JbmZpbml0eV0sIFt4MSwgSW5maW5pdHldXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYTEgPT09IDApIHtcbiAgICAvLyBiMSAqIHkgKyBjMSA9IDBcbiAgICAvLyB5ID0gLSBjMSAvIGIxO1xuICAgIC8vIGEyICogeCArIGIyICogeSArIGMyID0gMFxuICAgIHZhciB5ID0gLWMxIC8gYjE7XG4gICAgdmFyIHggPSAtKGIyICogeSArIGMyKSAvIGEyO1xuICAgIHJlc3VsdHMgPSBbW3gsIHldXTtcbiAgfSBlbHNlIGlmIChhMiA9PT0gMCkge1xuICAgIC8vIGIyICogeSArIGMyID0gMFxuICAgIC8vIHkgPSAtIGMyIC8gYjI7XG4gICAgLy8gYTEgKiB4ICsgYjEgKiB5ICsgYzEgPSAwXG4gICAgdmFyIHkgPSAtYzIgLyBiMjtcbiAgICB2YXIgeCA9IC0oYjEgKiB5ICsgYzEpIC8gYTE7XG4gICAgcmVzdWx0cyA9IFtbeCwgeV1dO1xuICB9IGVsc2UgaWYgKGIxID09PSAwKSB7XG4gICAgLy8gYTEgKiB4ICsgYzEgPSAwXG4gICAgLy8geCA9IC0gYzEgLyBhMTtcbiAgICAvLyBhMiAqIHggKyBiMiAqIHkgKyBjMiA9IDBcbiAgICB2YXIgeCA9IC1jMSAvIGExO1xuICAgIHZhciB5ID0gLShhMiAqIHggKyBjMikgLyBiMjtcbiAgICByZXN1bHRzID0gW1t4LCB5XV07XG4gIH0gZWxzZSBpZiAoYjIgPT09IDApIHtcbiAgICAvLyBhMiAqIHggKyBjMiA9IDBcbiAgICAvLyB4ID0gLSBjMiAvIGEyO1xuICAgIC8vIGExICogeCArIGIxICogeSArIGMxID0gMFxuICAgIHZhciB4ID0gLWMyIC8gYTI7XG4gICAgdmFyIHkgPSAtKGExICogeCArIGMxKSAvIGIxO1xuICAgIHJlc3VsdHMgPSBbW3gsIHldXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBhMSAqIHggKyBiMSAqIHkgKyBjMSA9IDBcbiAgICAvLyBhMiAqIHggKyBiMiAqIHkgKyBjMiA9IDBcbiAgICAvLyBiMiAqIGExICogeCArIGIyICogYjEgKiB5ICsgYjIgKiBjMSA9IDBcbiAgICAvLyBiMSAqIGEyICogeCArIGIxICogYjIgKiB5ICsgYjEgKiBjMiA9IDBcbiAgICAvLyAoYjIgKiBhMSAtIGIxICogYTIpICAqIHggPSAoYjEgKiBjMiAtIGIyICogYzEpXG4gICAgdmFyIHggPSAoYjEgKiBjMiAtIGIyICogYzEpIC8gKGIyICogYTEgLSBiMSAqIGEyKTtcbiAgICB2YXIgeSA9IC0oYTEgKiB4ICsgYzEpIC8gYjE7XG4gICAgcmVzdWx0cyA9IFtbeCwgeV1dO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gW3Jlc3VsdFswXSwgcmVzdWx0WzFdXTtcbiAgfSk7XG59XG4vKipcbiAqIEdldCBpbnRlcnNlY3Rpb24gcG9pbnRzIHRvIHRoZSB0d28gbGluZXMuXG4gKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiAqL1xuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25Qb2ludHMobGluZTEsIGxpbmUyLCBpc0xpbWl0KSB7XG4gIHZhciBwb2ludHMgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludHNCeUNvbnN0YW50cyhnZXRMaW5lYXJDb25zdGFudHMobGluZTFbMF0sIGxpbmUxWzFdKSwgZ2V0TGluZWFyQ29uc3RhbnRzKGxpbmUyWzBdLCBsaW5lMlsxXSkpO1xuXG4gIGlmIChpc0xpbWl0KSB7XG4gICAgcmV0dXJuIGdldFBvaW50c09uTGluZXMocG9pbnRzLCBbbGluZTEsIGxpbmUyXSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gaXNQb2ludE9uTGluZShwb3MsIGxpbmUpIHtcbiAgdmFyIGxpbmVhckNvbnN0YW50cyA9IGdldExpbmVhckNvbnN0YW50cyhsaW5lWzBdLCBsaW5lWzFdKTtcbiAgcmV0dXJuIHRpbnlUaHJvdHRsZShnZXREaXN0YW5jZUZyb21Qb2ludFRvQ29uc3RhbnRzKGxpbmVhckNvbnN0YW50cywgcG9zKSkgPT09IDA7XG59XG4vKipcbiAqIEdldCB0aGUgcG9pbnRzIG9uIHRoZSBsaW5lcyAoYmV0d2VlbiB0d28gcG9pbnRzKS5cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldFBvaW50c09uTGluZXMocG9pbnRzLCBsaW5lcykge1xuICB2YXIgbWluTWF4cyA9IGxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgIHJldHVybiBbMCwgMV0ubWFwKGZ1bmN0aW9uIChvcmRlcikge1xuICAgICAgcmV0dXJuIFtNYXRoLm1pbihsaW5lWzBdW29yZGVyXSwgbGluZVsxXVtvcmRlcl0pLCBNYXRoLm1heChsaW5lWzBdW29yZGVyXSwgbGluZVsxXVtvcmRlcl0pXTtcbiAgICB9KTtcbiAgfSk7XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgX2EgPSBwb2ludHNbMF0sXG4gICAgICAgIHggPSBfYVswXSxcbiAgICAgICAgeSA9IF9hWzFdO1xuXG4gICAgaWYgKCF0aW55VGhyb3R0bGUoeCAtIHBvaW50c1sxXVswXSkpIHtcbiAgICAgIC8vLyBNYXRoLm1heChtaW5ZMSwgbWluWTIpXG4gICAgICB2YXIgdG9wID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgbWluTWF4cy5tYXAoZnVuY3Rpb24gKG1pbk1heCkge1xuICAgICAgICByZXR1cm4gbWluTWF4WzFdWzBdO1xuICAgICAgfSkpOyAvLy8gTWF0aC5taW4obWF4WTEsIG1pYXgyKVxuXG4gICAgICB2YXIgYm90dG9tID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgbWluTWF4cy5tYXAoZnVuY3Rpb24gKG1pbk1heCkge1xuICAgICAgICByZXR1cm4gbWluTWF4WzFdWzFdO1xuICAgICAgfSkpO1xuXG4gICAgICBpZiAodGlueVRocm90dGxlKHRvcCAtIGJvdHRvbSkgPiAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0cyA9IFtbeCwgdG9wXSwgW3gsIGJvdHRvbV1dO1xuICAgIH0gZWxzZSBpZiAoIXRpbnlUaHJvdHRsZSh5IC0gcG9pbnRzWzFdWzFdKSkge1xuICAgICAgLy8vIE1hdGgubWF4KG1pblkxLCBtaW5ZMilcbiAgICAgIHZhciBsZWZ0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgbWluTWF4cy5tYXAoZnVuY3Rpb24gKG1pbk1heCkge1xuICAgICAgICByZXR1cm4gbWluTWF4WzBdWzBdO1xuICAgICAgfSkpOyAvLy8gTWF0aC5taW4obWF4WTEsIG1pYXgyKVxuXG4gICAgICB2YXIgcmlnaHQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBtaW5NYXhzLm1hcChmdW5jdGlvbiAobWluTWF4KSB7XG4gICAgICAgIHJldHVybiBtaW5NYXhbMF1bMV07XG4gICAgICB9KSk7XG5cbiAgICAgIGlmICh0aW55VGhyb3R0bGUobGVmdCAtIHJpZ2h0KSA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRzID0gW1tsZWZ0LCB5XSwgW3JpZ2h0LCB5XV07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgIHJlc3VsdHMgPSBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIHBvaW50WCA9IHBvaW50WzBdLFxuICAgICAgICAgIHBvaW50WSA9IHBvaW50WzFdO1xuICAgICAgcmV0dXJuIG1pbk1heHMuZXZlcnkoZnVuY3Rpb24gKG1pbk1heCkge1xuICAgICAgICByZXR1cm4gMCA8PSB0aW55VGhyb3R0bGUocG9pbnRYIC0gbWluTWF4WzBdWzBdKSAmJiAwIDw9IHRpbnlUaHJvdHRsZShtaW5NYXhbMF1bMV0gLSBwb2ludFgpICYmIDAgPD0gdGlueVRocm90dGxlKHBvaW50WSAtIG1pbk1heFsxXVswXSkgJiYgMCA8PSB0aW55VGhyb3R0bGUobWluTWF4WzFdWzFdIC0gcG9pbnRZKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gW3RpbnlUaHJvdHRsZShyZXN1bHRbMF0pLCB0aW55VGhyb3R0bGUocmVzdWx0WzFdKV07XG4gIH0pO1xufVxuLyoqXG4qIENvbnZlcnQgdHdvIHBvaW50cyBpbnRvIGxpbmVzLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4qL1xuXG5mdW5jdGlvbiBjb252ZXJ0TGluZXMocG9pbnRzKSB7XG4gIHJldHVybiBfX3NwcmVhZEFycmF5cyhwb2ludHMuc2xpY2UoMSksIFtwb2ludHNbMF1dKS5tYXAoZnVuY3Rpb24gKHBvaW50LCBpKSB7XG4gICAgcmV0dXJuIFtwb2ludHNbaV0sIHBvaW50XTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE92ZXJsYXBQb2ludEluZm9zKHBvaW50czEsIHBvaW50czIpIHtcbiAgdmFyIHRhcmdldFBvaW50czEgPSBwb2ludHMxLnNsaWNlKCk7XG4gIHZhciB0YXJnZXRQb2ludHMyID0gcG9pbnRzMi5zbGljZSgpO1xuXG4gIGlmIChnZXRTaGFwZURpcmVjdGlvbih0YXJnZXRQb2ludHMxKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRQb2ludHMxLnJldmVyc2UoKTtcbiAgfVxuXG4gIGlmIChnZXRTaGFwZURpcmVjdGlvbih0YXJnZXRQb2ludHMyKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRQb2ludHMyLnJldmVyc2UoKTtcbiAgfVxuXG4gIHZhciBsaW5lczEgPSBjb252ZXJ0TGluZXModGFyZ2V0UG9pbnRzMSk7XG4gIHZhciBsaW5lczIgPSBjb252ZXJ0TGluZXModGFyZ2V0UG9pbnRzMik7XG4gIHZhciBsaW5lYXJDb25zdGFudHNMaXN0MSA9IGxpbmVzMS5tYXAoZnVuY3Rpb24gKGxpbmUxKSB7XG4gICAgcmV0dXJuIGdldExpbmVhckNvbnN0YW50cyhsaW5lMVswXSwgbGluZTFbMV0pO1xuICB9KTtcbiAgdmFyIGxpbmVhckNvbnN0YW50c0xpc3QyID0gbGluZXMyLm1hcChmdW5jdGlvbiAobGluZTIpIHtcbiAgICByZXR1cm4gZ2V0TGluZWFyQ29uc3RhbnRzKGxpbmUyWzBdLCBsaW5lMlsxXSk7XG4gIH0pO1xuICB2YXIgb3ZlcmxhcEluZm9zID0gW107XG4gIGxpbmVhckNvbnN0YW50c0xpc3QxLmZvckVhY2goZnVuY3Rpb24gKGxpbmVhckNvbnN0YW50czEsIGkpIHtcbiAgICB2YXIgbGluZTEgPSBsaW5lczFbaV07XG4gICAgdmFyIGxpbmVQb2ludEluZm9zID0gW107XG4gICAgbGluZWFyQ29uc3RhbnRzTGlzdDIuZm9yRWFjaChmdW5jdGlvbiAobGluZWFyQ29uc3RhbnRzMiwgaikge1xuICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50cyA9IGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzKGxpbmVhckNvbnN0YW50czEsIGxpbmVhckNvbnN0YW50czIpO1xuICAgICAgdmFyIHBvaW50cyA9IGdldFBvaW50c09uTGluZXMoaW50ZXJzZWN0aW9uUG9pbnRzLCBbbGluZTEsIGxpbmVzMltqXV0pO1xuICAgICAgbGluZVBvaW50SW5mb3MucHVzaC5hcHBseShsaW5lUG9pbnRJbmZvcywgcG9pbnRzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXgxOiBpLFxuICAgICAgICAgIGluZGV4MjogaixcbiAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICB0eXBlOiBcImludGVyc2VjdGlvblwiXG4gICAgICAgIH07XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgbGluZVBvaW50SW5mb3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGdldERpc3QobGluZTFbMF0sIGEucG9zKSAtIGdldERpc3QobGluZTFbMF0sIGIucG9zKTtcbiAgICB9KTtcbiAgICBvdmVybGFwSW5mb3MucHVzaC5hcHBseShvdmVybGFwSW5mb3MsIGxpbmVQb2ludEluZm9zKTtcblxuICAgIGlmIChpc0luc2lkZShsaW5lMVsxXSwgdGFyZ2V0UG9pbnRzMikpIHtcbiAgICAgIG92ZXJsYXBJbmZvcy5wdXNoKHtcbiAgICAgICAgaW5kZXgxOiBpLFxuICAgICAgICBpbmRleDI6IC0xLFxuICAgICAgICBwb3M6IGxpbmUxWzFdLFxuICAgICAgICB0eXBlOiBcImluc2lkZVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBsaW5lczIuZm9yRWFjaChmdW5jdGlvbiAobGluZTIsIGkpIHtcbiAgICBpZiAoIWlzSW5zaWRlKGxpbmUyWzFdLCB0YXJnZXRQb2ludHMxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc05leHQgPSBmYWxzZTtcbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgob3ZlcmxhcEluZm9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBpbmRleDIgPSBfYS5pbmRleDI7XG5cbiAgICAgIGlmIChpbmRleDIgPT09IGkpIHtcbiAgICAgICAgaXNOZXh0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOZXh0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBpc05leHQgPSBmYWxzZTtcbiAgICAgIGluZGV4ID0gZmluZEluZGV4KG92ZXJsYXBJbmZvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpbmRleDEgPSBfYS5pbmRleDEsXG4gICAgICAgICAgICBpbmRleDIgPSBfYS5pbmRleDI7XG5cbiAgICAgICAgaWYgKGluZGV4MSA9PT0gLTEgJiYgaW5kZXgyICsgMSA9PT0gaSkge1xuICAgICAgICAgIGlzTmV4dCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgb3ZlcmxhcEluZm9zLnB1c2goe1xuICAgICAgICBpbmRleDE6IC0xLFxuICAgICAgICBpbmRleDI6IGksXG4gICAgICAgIHBvczogbGluZTJbMV0sXG4gICAgICAgIHR5cGU6IFwiaW5zaWRlXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdmVybGFwSW5mb3Muc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgICAgIGluZGV4MTogLTEsXG4gICAgICAgIGluZGV4MjogaSxcbiAgICAgICAgcG9zOiBsaW5lMlsxXSxcbiAgICAgICAgdHlwZTogXCJpbnNpZGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHBvaW50TWFwID0ge307XG4gIHJldHVybiBvdmVybGFwSW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwb3MgPSBfYS5wb3M7XG4gICAgdmFyIGtleSA9IHBvc1swXSArIFwieFwiICsgcG9zWzFdO1xuXG4gICAgaWYgKHBvaW50TWFwW2tleV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwb2ludE1hcFtrZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG4vKipcbiogR2V0IHRoZSBwb2ludHMgb2YgdGhlIG92ZXJsYXBwZWQgcGFydCBvZiB0d28gc2hhcGVzLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4qL1xuXG5cbmZ1bmN0aW9uIGdldE92ZXJsYXBQb2ludHMocG9pbnRzMSwgcG9pbnRzMikge1xuICB2YXIgaW5mb3MgPSBnZXRPdmVybGFwUG9pbnRJbmZvcyhwb2ludHMxLCBwb2ludHMyKTtcbiAgcmV0dXJuIGluZm9zLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcG9zID0gX2EucG9zO1xuICAgIHJldHVybiBwb3M7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0Nvbm5lY3RlZExpbmUobGluZSkge1xuICB2YXIgX2EgPSBsaW5lWzBdLFxuICAgICAgcHJldkluZGV4MSA9IF9hLmluZGV4MSxcbiAgICAgIHByZXZJbmRleDIgPSBfYS5pbmRleDIsXG4gICAgICBfYiA9IGxpbmVbMV0sXG4gICAgICBuZXh0SW5kZXgxID0gX2IuaW5kZXgxLFxuICAgICAgbmV4dEluZGV4MiA9IF9iLmluZGV4MjtcblxuICBpZiAocHJldkluZGV4MSAhPT0gLTEpIHtcbiAgICAvLyBzYW1lIGxpbmVcbiAgICBpZiAocHJldkluZGV4MSA9PT0gbmV4dEluZGV4MSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByZXZJbmRleDEgKyAxID09PSBuZXh0SW5kZXgxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJldkluZGV4MiAhPT0gLTEpIHtcbiAgICAvLyBzYW1lIGxpbmVcbiAgICBpZiAocHJldkluZGV4MiA9PT0gbmV4dEluZGV4Mikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByZXZJbmRleDIgKyAxID09PSBuZXh0SW5kZXgyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiogR2V0IHRoZSBhcmVhcyBvZiB0aGUgb3ZlcmxhcHBlZCBwYXJ0IG9mIHR3byBzaGFwZXMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiovXG5cblxuZnVuY3Rpb24gZ2V0T3ZlcmxhcEFyZWFzKHBvaW50czEsIHBvaW50czIpIHtcbiAgdmFyIGluZm9zID0gZ2V0T3ZlcmxhcFBvaW50SW5mb3MocG9pbnRzMSwgcG9pbnRzMik7XG4gIHZhciBhcmVhcyA9IFtdO1xuICB2YXIgYXJlYTtcbiAgZ2V0T3ZlcmxhcFBvaW50SW5mb3MocG9pbnRzMSwgcG9pbnRzMikuZm9yRWFjaChmdW5jdGlvbiAoaW5mbywgaSwgYXJyKSB7XG4gICAgaWYgKGkgPT09IDAgfHwgIWlzQ29ubmVjdGVkTGluZShbYXJyW2kgLSAxXSwgaW5mb10pKSB7XG4gICAgICBhcmVhID0gW2luZm9dO1xuICAgICAgYXJlYXMucHVzaChhcmVhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJlYS5wdXNoKGluZm8pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhcmVhcy5tYXAoZnVuY3Rpb24gKGFyZWEpIHtcbiAgICByZXR1cm4gYXJlYS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgcG9zID0gX2EucG9zO1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRSZXZlcnNlZEFyZWFzKHBvaW50czEsIHBvaW50czIsIGluZGV4LCBhcmVhcykge1xuICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgIGluZGV4ID0gMDtcbiAgfVxuXG4gIGlmIChhcmVhcyA9PT0gdm9pZCAwKSB7XG4gICAgYXJlYXMgPSBbXTtcbiAgfVxuXG4gIHZhciBpc0ZpcnN0ID0gYXJlYXMubGVuZ3RoID09PSAwO1xuICB2YXIgbGVuZ3RoID0gcG9pbnRzMS5sZW5ndGg7XG4gIHZhciBuZXh0SW5kZXggPSBwb2ludHMxW2luZGV4XSA/IGluZGV4IDogMDtcblxuICB2YXIgbmV4dFBvaW50czEgPSBfX3NwcmVhZEFycmF5cyhwb2ludHMxLnNsaWNlKG5leHRJbmRleCksIHBvaW50czEuc2xpY2UoMCwgbmV4dEluZGV4KSk7XG5cbiAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBwb2ludDEgPSBuZXh0UG9pbnRzMVtpXTtcblxuICAgIGlmIChmaW5kKHBvaW50czIsIGZ1bmN0aW9uIChwb2ludDIpIHtcbiAgICAgIHJldHVybiBwb2ludDJbMF0gPT09IHBvaW50MVswXSAmJiBwb2ludDJbMV0gPT09IHBvaW50MVsxXTtcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICB9XG5cbiAgICBpZiAoYXJlYXMuc29tZShmdW5jdGlvbiAobmV4dEFyZWEpIHtcbiAgICAgIHJldHVybiBmaW5kKG5leHRBcmVhLCBmdW5jdGlvbiAoYXJlYVBvaW50KSB7XG4gICAgICAgIHJldHVybiBhcmVhUG9pbnRbMF0gPT09IHBvaW50MVswXSAmJiBhcmVhUG9pbnRbMV0gPT09IHBvaW50MVsxXTtcbiAgICAgIH0pO1xuICAgIH0pKSB7XG4gICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dEFyZWEgPSB2b2lkIDA7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgbmV4dEFyZWEgPSBbXTtcbiAgICAgIGFyZWFzLnB1c2gobmV4dEFyZWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0QXJlYSA9IGFyZWFzW2FyZWFzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIG5leHRBcmVhLnB1c2gocG9pbnQxKTtcbiAgICB2YXIgbGluZSA9IFtwb2ludDEsIHBvaW50czFbaW5kZXggKyAxXSB8fCBwb2ludHMxWzBdXTtcbiAgICB2YXIgbmV4dFBvaW50MiA9IHBvaW50czIuZmlsdGVyKGZ1bmN0aW9uIChwb2ludDIpIHtcbiAgICAgIHJldHVybiBpc1BvaW50T25MaW5lKHBvaW50MiwgbGluZSk7XG4gICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGdldERpc3QocG9pbnQxLCBhKSAtIGdldERpc3QocG9pbnQxLCBiKTtcbiAgICB9KVswXTtcblxuICAgIGlmICghbmV4dFBvaW50Mikge1xuICAgICAgZmluZFJldmVyc2VkQXJlYXMobmV4dFBvaW50czEsIHBvaW50czIsIGkgKyAxLCBhcmVhcyk7XG4gICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcG9pbnQySW5kZXggPSBwb2ludHMyLmluZGV4T2YobmV4dFBvaW50Mik7XG4gICAgICBmaW5kUmV2ZXJzZWRBcmVhcyhwb2ludHMyLCBwb2ludHMxLCBwb2ludDJJbmRleCwgYXJlYXMpO1xuXG4gICAgICBpZiAoIWlzRmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShpKTtcblxuICAgIGlmIChzdGF0ZV8xID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGFyZWFzO1xufVxuXG5mdW5jdGlvbiBmaW5kQ29ubmVjdGVkQXJlYXMocG9pbnRzMSwgcG9pbnRzMikge1xuICByZXR1cm4gZmluZFJldmVyc2VkQXJlYXMocG9pbnRzMSwgX19zcHJlYWRBcnJheXMocG9pbnRzMikucmV2ZXJzZSgpKTtcbn1cbi8qKlxuKiBHZXQgbm9uLW92ZXJsYXBwaW5nIGFyZWFzIG9mIHR3byBzaGFwZXMgYmFzZWQgb24gcG9pbnRzMS5cbiogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4qL1xuXG5mdW5jdGlvbiBnZXRVbm92ZXJsYXBBcmVhcyhwb2ludHMxLCBwb2ludHMyKSB7XG4gIGlmICghcG9pbnRzMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gW19fc3ByZWFkQXJyYXlzKHBvaW50czEpXTtcbiAgfVxuXG4gIHZhciBvdmVybGFwQXJlYXMgPSBnZXRPdmVybGFwQXJlYXMocG9pbnRzMSwgcG9pbnRzMik7XG4gIHZhciB1bm92ZXJsYXBBcmVhcyA9IFtwb2ludHMxXTtcbiAgb3ZlcmxhcEFyZWFzLmZvckVhY2goZnVuY3Rpb24gKG92ZXJsYXBBcmVhKSB7XG4gICAgdmFyIG5leHRPdmVybGFwQXJlYSA9IF9fc3ByZWFkQXJyYXlzKG92ZXJsYXBBcmVhKS5yZXZlcnNlKCk7XG5cbiAgICB1bm92ZXJsYXBBcmVhcyA9IGZsYXQodW5vdmVybGFwQXJlYXMubWFwKGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgICB2YXIgY29ubmVjdGVkQXJlYXMgPSBmaW5kUmV2ZXJzZWRBcmVhcyhhcmVhLCBuZXh0T3ZlcmxhcEFyZWEpO1xuICAgICAgdmFyIGZpcnN0Q29ubmVjdGVkQXJlYSA9IGNvbm5lY3RlZEFyZWFzWzBdO1xuXG4gICAgICBpZiAoY29ubmVjdGVkQXJlYXMubGVuZ3RoID09PSAxICYmIG5leHRPdmVybGFwQXJlYS5ldmVyeShmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Q29ubmVjdGVkQXJlYS5pbmRleE9mKHBvaW50KSA9PT0gLTE7XG4gICAgICB9KSkge1xuICAgICAgICB2YXIgbGFzdFBvaW50XzEgPSBmaXJzdENvbm5lY3RlZEFyZWFbZmlyc3RDb25uZWN0ZWRBcmVhLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHZhciBmaXJzdFBvaW50ID0gX19zcHJlYWRBcnJheXMobmV4dE92ZXJsYXBBcmVhKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGdldERpc3QobGFzdFBvaW50XzEsIGEpIC0gZ2V0RGlzdChsYXN0UG9pbnRfMSwgYik7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIHZhciBmaXJzdEluZGV4ID0gbmV4dE92ZXJsYXBBcmVhLmluZGV4T2YoZmlyc3RQb2ludCk7XG4gICAgICAgIGZpcnN0Q29ubmVjdGVkQXJlYS5wdXNoLmFwcGx5KGZpcnN0Q29ubmVjdGVkQXJlYSwgX19zcHJlYWRBcnJheXMobmV4dE92ZXJsYXBBcmVhLnNsaWNlKGZpcnN0SW5kZXgpLCBuZXh0T3ZlcmxhcEFyZWEuc2xpY2UoMCwgZmlyc3RJbmRleCksIFtuZXh0T3ZlcmxhcEFyZWFbZmlyc3RJbmRleF0sIGxhc3RQb2ludF8xXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29ubmVjdGVkQXJlYXM7XG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIHVub3ZlcmxhcEFyZWFzO1xufVxuLyoqXG4qIEdldHMgdGhlIHNpemUgb2YgdGhlIG92ZXJsYXBwZWQgcGFydCBvZiB0d28gc2hhcGVzLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4qL1xuXG5mdW5jdGlvbiBnZXRPdmVybGFwU2l6ZShwb2ludHMxLCBwb2ludHMyKSB7XG4gIHZhciBwb2ludHMgPSBnZXRPdmVybGFwUG9pbnRzKHBvaW50czEsIHBvaW50czIpO1xuICByZXR1cm4gZ2V0QXJlYVNpemUocG9pbnRzKTtcbn1cblxuZXhwb3J0IHsgY29udmVydExpbmVzLCBmaW5kQ29ubmVjdGVkQXJlYXMsIGZpdFBvaW50cywgZ2V0QXJlYVNpemUsIGdldERpc3RhbmNlRnJvbVBvaW50VG9Db25zdGFudHMsIGdldEludGVyc2VjdGlvblBvaW50cywgZ2V0SW50ZXJzZWN0aW9uUG9pbnRzQnlDb25zdGFudHMsIGdldExpbmVhckNvbnN0YW50cywgZ2V0TWluTWF4cywgZ2V0T3ZlcmxhcEFyZWFzLCBnZXRPdmVybGFwUG9pbnRzLCBnZXRPdmVybGFwU2l6ZSwgZ2V0UG9pbnRzT25MaW5lcywgZ2V0VW5vdmVybGFwQXJlYXMsIGlzSW5zaWRlLCBpc1BvaW50T25MaW5lIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdmVybGFwLWFyZWEuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbInRocm90dGxlIiwiVElOWV9OVU0iLCJzdW0iLCJmaW5kIiwiZ2V0RGlzdCIsImdldFNoYXBlRGlyZWN0aW9uIiwiZmluZEluZGV4IiwiX19zcHJlYWRBcnJheXMiLCJzIiwiaSIsImlsIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiciIsIkFycmF5IiwiayIsImEiLCJqIiwiamwiLCJ0aW55VGhyb3R0bGUiLCJudW0iLCJpc1NhbWVDb25zdGFudHMiLCJsaW5lYXJDb25zdGFudHMxIiwibGluZWFyQ29uc3RhbnRzMiIsImV2ZXJ5IiwidiIsImlzU2FtZVBvaW50IiwicG9pbnQxIiwicG9pbnQyIiwiZmxhdCIsImFyciIsInJlZHVjZSIsInByZXYiLCJjdXJyZW50IiwicHVzaCIsImFwcGx5IiwiZ2V0QXJlYVNpemUiLCJwb2ludHMiLCJNYXRoIiwiYWJzIiwibWFwIiwicG9pbnQiLCJuZXh0UG9pbnQiLCJmaXRQb2ludHMiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJsZWZ0IiwidG9wIiwiX2EiLCJnZXRNaW5NYXhzIiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsInJhdGlvWCIsInJhdGlvWSIsInhzIiwieXMiLCJtaW4iLCJtYXgiLCJpc0luc2lkZSIsInBvcyIsImV4Y2x1ZGVMaW5lIiwieCIsInkiLCJ4TGluZSIsInhMaW5lYXJDb25zdGFudHMiLCJnZXRMaW5lYXJDb25zdGFudHMiLCJsaW5lcyIsImNvbnZlcnRMaW5lcyIsImludGVyc2VjdGlvblBvc0luZm9zIiwiZm9yRWFjaCIsImxpbmUiLCJsaW5lYXJDb25zdGFudHMiLCJzdGFuZGFyZFBvaW50IiwidHlwZSIsInhQb2ludHMiLCJnZXRQb2ludHNPbkxpbmVzIiwiZ2V0SW50ZXJzZWN0aW9uUG9pbnRzQnlDb25zdGFudHMiLCJzb21lIiwibGluZVBvaW50IiwicCIsImludGVyc2VjdGlvbkNvdW50IiwieE1hcCIsInByZXZWYWx1ZSIsIm5leHRWYWx1ZSIsImdldERpc3RhbmNlRnJvbVBvaW50VG9Db25zdGFudHMiLCJiIiwiYyIsIngxIiwieTEiLCJ4MiIsInkyIiwiZHgiLCJkeSIsImExIiwiYjEiLCJjMSIsImEyIiwiYjIiLCJjMiIsImlzWmVyb0EiLCJpc1plcm9CIiwicmVzdWx0cyIsIkluZmluaXR5IiwicmVzdWx0IiwiZ2V0SW50ZXJzZWN0aW9uUG9pbnRzIiwibGluZTEiLCJsaW5lMiIsImlzTGltaXQiLCJpc1BvaW50T25MaW5lIiwibWluTWF4cyIsIm9yZGVyIiwibWluTWF4IiwiYm90dG9tIiwicmlnaHQiLCJmaWx0ZXIiLCJwb2ludFgiLCJwb2ludFkiLCJzbGljZSIsImdldE92ZXJsYXBQb2ludEluZm9zIiwicG9pbnRzMSIsInBvaW50czIiLCJ0YXJnZXRQb2ludHMxIiwidGFyZ2V0UG9pbnRzMiIsInJldmVyc2UiLCJsaW5lczEiLCJsaW5lczIiLCJsaW5lYXJDb25zdGFudHNMaXN0MSIsImxpbmVhckNvbnN0YW50c0xpc3QyIiwib3ZlcmxhcEluZm9zIiwibGluZVBvaW50SW5mb3MiLCJpbnRlcnNlY3Rpb25Qb2ludHMiLCJpbmRleDEiLCJpbmRleDIiLCJzb3J0IiwiaXNOZXh0IiwiaW5kZXgiLCJzcGxpY2UiLCJwb2ludE1hcCIsImtleSIsImdldE92ZXJsYXBQb2ludHMiLCJpbmZvcyIsImlzQ29ubmVjdGVkTGluZSIsInByZXZJbmRleDEiLCJwcmV2SW5kZXgyIiwiX2IiLCJuZXh0SW5kZXgxIiwibmV4dEluZGV4MiIsImdldE92ZXJsYXBBcmVhcyIsImFyZWFzIiwiYXJlYSIsImluZm8iLCJmaW5kUmV2ZXJzZWRBcmVhcyIsImlzRmlyc3QiLCJuZXh0SW5kZXgiLCJuZXh0UG9pbnRzMSIsIl9sb29wXzEiLCJuZXh0QXJlYSIsImFyZWFQb2ludCIsIm5leHRQb2ludDIiLCJwb2ludDJJbmRleCIsImluZGV4T2YiLCJzdGF0ZV8xIiwiZmluZENvbm5lY3RlZEFyZWFzIiwiZ2V0VW5vdmVybGFwQXJlYXMiLCJvdmVybGFwQXJlYXMiLCJ1bm92ZXJsYXBBcmVhcyIsIm92ZXJsYXBBcmVhIiwibmV4dE92ZXJsYXBBcmVhIiwiY29ubmVjdGVkQXJlYXMiLCJmaXJzdENvbm5lY3RlZEFyZWEiLCJsYXN0UG9pbnRfMSIsImZpcnN0UG9pbnQiLCJmaXJzdEluZGV4IiwiZ2V0T3ZlcmxhcFNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/overlap-area/dist/overlap-area.esm.js\n");

/***/ })

};
;