"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-moveable";
exports.ids = ["vendor-chunks/react-moveable"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-moveable/dist/moveable.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-moveable/dist/moveable.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Clippable: () => (/* binding */ Clippable),\n/* harmony export */   DIRECTIONS: () => (/* binding */ DIRECTIONS),\n/* harmony export */   Draggable: () => (/* binding */ Draggable),\n/* harmony export */   EdgeDraggable: () => (/* binding */ edgeDraggable),\n/* harmony export */   InitialMoveable: () => (/* binding */ InitialMoveable),\n/* harmony export */   MOVEABLE_ABLES: () => (/* binding */ MOVEABLE_ABLES),\n/* harmony export */   MOVEABLE_EVENTS: () => (/* binding */ MOVEABLE_EVENTS),\n/* harmony export */   MOVEABLE_METHODS: () => (/* binding */ MOVEABLE_METHODS),\n/* harmony export */   MOVEABLE_PROPS: () => (/* binding */ MOVEABLE_PROPS),\n/* harmony export */   Pinchable: () => (/* binding */ Pinchable),\n/* harmony export */   Resizable: () => (/* binding */ Resizable),\n/* harmony export */   Rotatable: () => (/* binding */ Rotatable),\n/* harmony export */   Roundable: () => (/* binding */ Roundable),\n/* harmony export */   Scalable: () => (/* binding */ Scalable),\n/* harmony export */   Snappable: () => (/* binding */ Snappable),\n/* harmony export */   Warpable: () => (/* binding */ Warpable),\n/* harmony export */   calculateElementPosition: () => (/* binding */ calculateElementPosition),\n/* harmony export */   \"default\": () => (/* binding */ Moveable),\n/* harmony export */   getElementInfo: () => (/* binding */ getElementInfo),\n/* harmony export */   makeAble: () => (/* binding */ makeAble),\n/* harmony export */   makeMoveable: () => (/* binding */ makeMoveable)\n/* harmony export */ });\n/* harmony import */ var _egjs_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @egjs/agent */ \"(ssr)/./node_modules/@egjs/agent/dist/agent.esm.js\");\n/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! framework-utils */ \"(ssr)/./node_modules/framework-utils/dist/utils.esm.js\");\n/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @daybrush/utils */ \"(ssr)/./node_modules/@daybrush/utils/dist/utils.esm.js\");\n/* harmony import */ var _scena_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scena/matrix */ \"(ssr)/./node_modules/@scena/matrix/dist/matrix.esm.js\");\n/* harmony import */ var css_to_mat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! css-to-mat */ \"(ssr)/./node_modules/css-to-mat/dist/css-to-mat.esm.js\");\n/* harmony import */ var _egjs_children_differ__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @egjs/children-differ */ \"(ssr)/./node_modules/@egjs/children-differ/dist/children-differ.esm.js\");\n/* harmony import */ var _scena_dragscroll__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @scena/dragscroll */ \"(ssr)/./node_modules/@scena/dragscroll/dist/dragscroll.esm.js\");\n/* harmony import */ var overlap_area__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! overlap-area */ \"(ssr)/./node_modules/overlap-area/dist/overlap-area.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var gesto__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gesto */ \"(ssr)/./node_modules/gesto/dist/gesto.esm.js\");\n/* harmony import */ var react_css_styled__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-css-styled */ \"(ssr)/./node_modules/react-css-styled/dist/styled.esm.js\");\n/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @scena/event-emitter */ \"(ssr)/./node_modules/@scena/event-emitter/dist/event-emitter.esm.js\");\n/* harmony import */ var _egjs_list_differ__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @egjs/list-differ */ \"(ssr)/./node_modules/@egjs/list-differ/dist/list-differ.esm.js\");\n/*\nCopyright (c) 2019 Daybrush\nname: react-moveable\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/moveable/blob/master/packages/react-moveable\nversion: 0.56.0\n*/ \n\n\n\n\n\n\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction makeAble(name, able) {\n    return __assign({\n        events: [],\n        props: [],\n        name: name\n    }, able);\n}\nvar DIRECTIONS4 = [\n    \"n\",\n    \"w\",\n    \"s\",\n    \"e\"\n];\nvar DIRECTIONS = [\n    \"n\",\n    \"w\",\n    \"s\",\n    \"e\",\n    \"nw\",\n    \"ne\",\n    \"sw\",\n    \"se\"\n];\nfunction getSVGCursor(scale, degree) {\n    return 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"'.concat(32 * scale, 'px\" height=\"').concat(32 * scale, 'px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(').concat(degree, 'deg);transform-origin: 16px 16px\"></path></svg>');\n}\nfunction getCursorCSS(degree) {\n    var x1 = getSVGCursor(1, degree);\n    // const x2 = getSVGCursor(2, degree);\n    var degree45 = Math.round(degree / 45) * 45 % 180;\n    var defaultCursor = \"ns-resize\";\n    if (degree45 === 135) {\n        defaultCursor = \"nwse-resize\";\n    } else if (degree45 === 45) {\n        defaultCursor = \"nesw-resize\";\n    } else if (degree45 === 90) {\n        defaultCursor = \"ew-resize\";\n    }\n    // tslint:disable-next-line: max-line-length\n    return \"cursor:\".concat(defaultCursor, \";cursor: url('\").concat(x1, \"') 16 16, \").concat(defaultCursor, \";\");\n}\nvar agent = (0,_egjs_agent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\nvar IS_WEBKIT = agent.browser.webkit;\nvar IS_WEBKIT605 = IS_WEBKIT && function() {\n    var navi =  true ? {\n        userAgent: \"\"\n    } : 0;\n    var res = /applewebkit\\/([^\\s]+)/g.exec(navi.userAgent.toLowerCase());\n    return res ? parseFloat(res[1]) < 605 : false;\n}();\nvar browserName = agent.browser.name;\nvar browserVersion = parseInt(agent.browser.version, 10);\nvar IS_CHROME = browserName === \"chrome\";\nvar IS_CHROMIUM = agent.browser.chromium;\nvar chromiumVersion = parseInt(agent.browser.chromiumVersion, 10) || 0;\nvar IS_CHROMIUM109 = IS_CHROME && browserVersion >= 109 || IS_CHROMIUM && chromiumVersion >= 109;\nvar IS_FIREFOX = browserName === \"firefox\";\nvar IS_SAFARI_ABOVE15 = parseInt(agent.browser.webkitVersion, 10) >= 612 || browserVersion >= 15;\nvar PREFIX = \"moveable-\";\nvar directionCSS = DIRECTIONS.map(function(dir) {\n    var top = \"\";\n    var left = \"\";\n    var originX = \"center\";\n    var originY = \"center\";\n    var offset = \"calc(var(--moveable-control-padding, 20) * -1px)\";\n    if (dir.indexOf(\"n\") > -1) {\n        top = \"top: \".concat(offset, \";\");\n        originY = \"bottom\";\n    }\n    if (dir.indexOf(\"s\") > -1) {\n        top = \"top: 0px;\";\n        originY = \"top\";\n    }\n    if (dir.indexOf(\"w\") > -1) {\n        left = \"left: \".concat(offset, \";\");\n        originX = \"right\";\n    }\n    if (dir.indexOf(\"e\") > -1) {\n        left = \"left: 0px;\";\n        originX = \"left\";\n    }\n    return '.around-control[data-direction*=\"'.concat(dir, '\"] {\\n        ').concat(left).concat(top, \"\\n        transform-origin: \").concat(originX, \" \").concat(originY, \";\\n    }\");\n}).join(\"\\n\");\nvar MOVEABLE_CSS = \"\\n{\\nposition: absolute;\\nwidth: 1px;\\nheight: 1px;\\nleft: 0;\\ntop: 0;\\nz-index: 3000;\\n--moveable-color: #4af;\\n--zoom: 1;\\n--zoompx: 1px;\\n--moveable-line-padding: 0;\\n--moveable-control-padding: 0;\\nwill-change: transform;\\noutline: 1px solid transparent;\\n}\\n.control-box {\\nz-index: 0;\\n}\\n.line, .control {\\nposition: absolute;\\nleft: 0;\\ntop: 0;\\nwill-change: transform;\\n}\\n.control {\\nwidth: 14px;\\nheight: 14px;\\nborder-radius: 50%;\\nborder: 2px solid #fff;\\nbox-sizing: border-box;\\nbackground: #4af;\\nbackground: var(--moveable-color);\\nmargin-top: -7px;\\nmargin-left: -7px;\\nborder: 2px solid #fff;\\nz-index: 10;\\n}\\n.around-control {\\nposition: absolute;\\nwill-change: transform;\\nwidth: calc(var(--moveable-control-padding, 20) * 1px);\\nheight: calc(var(--moveable-control-padding, 20) * 1px);\\nleft: calc(var(--moveable-control-padding, 20) * -0.5px);\\ntop: calc(var(--moveable-control-padding, 20) * -0.5px);\\nbox-sizing: border-box;\\nbackground: transparent;\\nz-index: 8;\\ncursor: alias;\\ntransform-origin: center center;\\n}\\n\".concat(directionCSS, \"\\n.padding {\\nposition: absolute;\\ntop: 0px;\\nleft: 0px;\\nwidth: 100px;\\nheight: 100px;\\ntransform-origin: 0 0;\\n}\\n.line {\\nwidth: 1px;\\nheight: 1px;\\nbackground: #4af;\\nbackground: var(--moveable-color);\\ntransform-origin: 0px 50%;\\n}\\n.line.edge {\\nz-index: 1;\\nbackground: transparent;\\n}\\n.line.dashed {\\nbox-sizing: border-box;\\nbackground: transparent;\\n}\\n.line.dashed.horizontal {\\nborder-top: 1px dashed #4af;\\nborder-top-color: #4af;\\nborder-top-color: var(--moveable-color);\\n}\\n.line.dashed.vertical {\\nborder-left: 1px dashed #4af;\\nborder-left-color: #4af;\\nborder-left-color: var(--moveable-color);\\n}\\n.line.vertical {\\ntransform: translateX(-50%);\\n}\\n.line.horizontal {\\ntransform: translateY(-50%);\\n}\\n.line.vertical.bold {\\nwidth: 2px;\\n}\\n.line.horizontal.bold {\\nheight: 2px;\\n}\\n\\n.control.origin {\\nborder-color: #f55;\\nbackground: #fff;\\nwidth: 12px;\\nheight: 12px;\\nmargin-top: -6px;\\nmargin-left: -6px;\\npointer-events: none;\\n}\\n\").concat([\n    0,\n    15,\n    30,\n    45,\n    60,\n    75,\n    90,\n    105,\n    120,\n    135,\n    150,\n    165\n].map(function(degree) {\n    return '\\n.direction[data-rotation=\"'.concat(degree, '\"], :global .view-control-rotation').concat(degree, \" {\\n\").concat(getCursorCSS(degree), \"\\n}\\n\");\n}).join(\"\\n\"), '\\n\\n.line.direction:before {\\ncontent: \"\";\\nposition: absolute;\\nwidth: 100%;\\nheight: calc(var(--moveable-line-padding, 0) * 1px);\\nbottom: 0;\\nleft: 0;\\n}\\n.group {\\nz-index: -1;\\n}\\n.area {\\nposition: absolute;\\n}\\n.area-pieces {\\nposition: absolute;\\ntop: 0;\\nleft: 0;\\ndisplay: none;\\n}\\n.area.avoid, .area.pass {\\npointer-events: none;\\n}\\n.area.avoid+.area-pieces {\\ndisplay: block;\\n}\\n.area-piece {\\nposition: absolute;\\n}\\n\\n').concat(IS_WEBKIT605 ? ':global svg *:before {\\ncontent:\"\";\\ntransform-origin: inherit;\\n}' : \"\", \"\\n\");\nvar NEARBY_POS = [\n    [\n        0,\n        1,\n        2\n    ],\n    [\n        1,\n        0,\n        3\n    ],\n    [\n        2,\n        0,\n        3\n    ],\n    [\n        3,\n        1,\n        2\n    ]\n];\nvar FLOAT_POINT_NUM = 0.0001;\nvar TINY_NUM = 0.0000001;\nvar MIN_SCALE = 0.000000001;\nvar MAX_NUM = Math.pow(10, 10);\nvar MIN_NUM = -MAX_NUM;\nvar DIRECTION_REGION_TO_DIRECTION = {\n    n: [\n        0,\n        -1\n    ],\n    e: [\n        1,\n        0\n    ],\n    s: [\n        0,\n        1\n    ],\n    w: [\n        -1,\n        0\n    ],\n    nw: [\n        -1,\n        -1\n    ],\n    ne: [\n        1,\n        -1\n    ],\n    sw: [\n        -1,\n        1\n    ],\n    se: [\n        1,\n        1\n    ]\n};\nvar DIRECTION_INDEXES = {\n    n: [\n        0,\n        1\n    ],\n    e: [\n        1,\n        3\n    ],\n    s: [\n        3,\n        2\n    ],\n    w: [\n        2,\n        0\n    ],\n    nw: [\n        0\n    ],\n    ne: [\n        1\n    ],\n    sw: [\n        2\n    ],\n    se: [\n        3\n    ]\n};\nvar DIRECTION_ROTATIONS = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135\n};\nvar MOVEABLE_METHODS = [\n    \"isMoveableElement\",\n    \"updateRect\",\n    \"updateTarget\",\n    \"destroy\",\n    \"dragStart\",\n    \"isInside\",\n    \"hitTest\",\n    \"setState\",\n    \"getRect\",\n    \"request\",\n    \"isDragging\",\n    \"getManager\",\n    \"forceUpdate\",\n    \"waitToChangeTarget\",\n    \"updateSelectors\",\n    \"getTargets\",\n    \"stopDrag\",\n    \"getControlBoxElement\",\n    \"getMoveables\",\n    \"getDragElement\"\n];\nfunction setCustomDrag(e, state, delta, isPinch, isConvert, ableName) {\n    var _a, _b;\n    if (ableName === void 0) {\n        ableName = \"draggable\";\n    }\n    var result = (_b = (_a = state.gestos[ableName]) === null || _a === void 0 ? void 0 : _a.move(delta, e.inputEvent)) !== null && _b !== void 0 ? _b : {};\n    var datas = result.originalDatas || result.datas;\n    var ableDatas = datas[ableName] || (datas[ableName] = {});\n    return __assign(__assign({}, isConvert ? convertDragDist(state, result) : result), {\n        isPinch: !!isPinch,\n        parentEvent: true,\n        datas: ableDatas,\n        originalDatas: e.originalDatas\n    });\n}\nvar CustomGesto = /*#__PURE__*/ function() {\n    function CustomGesto(ableName) {\n        var _a;\n        if (ableName === void 0) {\n            ableName = \"draggable\";\n        }\n        this.ableName = ableName;\n        this.prevX = 0;\n        this.prevY = 0;\n        this.startX = 0;\n        this.startY = 0;\n        this.isDrag = false;\n        this.isFlag = false;\n        this.datas = {\n            draggable: {}\n        };\n        this.datas = (_a = {}, _a[ableName] = {}, _a);\n    }\n    CustomGesto.prototype.dragStart = function(client, e) {\n        this.isDrag = false;\n        this.isFlag = false;\n        var originalDatas = e.originalDatas;\n        this.datas = originalDatas;\n        if (!originalDatas[this.ableName]) {\n            originalDatas[this.ableName] = {};\n        }\n        return __assign(__assign({}, this.move(client, e.inputEvent)), {\n            type: \"dragstart\"\n        });\n    };\n    CustomGesto.prototype.drag = function(client, inputEvent) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY\n        ], inputEvent);\n    };\n    CustomGesto.prototype.move = function(delta, inputEvent) {\n        var clientX;\n        var clientY;\n        var isFirstDrag = false;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n            clientX = delta[0];\n            clientY = delta[1];\n            this.isFlag = true;\n        } else {\n            var isPrevDrag = this.isDrag;\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n            if (delta[0] || delta[1]) {\n                this.isDrag = true;\n            }\n            if (!isPrevDrag && this.isDrag) {\n                isFirstDrag = true;\n            }\n        }\n        this.prevX = clientX;\n        this.prevY = clientY;\n        return {\n            type: \"drag\",\n            clientX: clientX,\n            clientY: clientY,\n            inputEvent: inputEvent,\n            isFirstDrag: isFirstDrag,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas[this.ableName],\n            originalDatas: this.datas,\n            parentEvent: true,\n            parentGesto: this\n        };\n    };\n    return CustomGesto;\n}();\nfunction calculateElementPosition(matrix, origin, width, height) {\n    var is3d = matrix.length === 16;\n    var n = is3d ? 4 : 3;\n    var poses = calculatePoses(matrix, width, height, n);\n    var _a = __read(poses, 4), _b = __read(_a[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a[1], 2), x2 = _c[0], y2 = _c[1], _d = __read(_a[2], 2), x3 = _d[0], y3 = _d[1], _e = __read(_a[3], 2), x4 = _e[0], y4 = _e[1];\n    var _f = __read(calculatePosition(matrix, origin, n), 2), originX = _f[0], originY = _f[1];\n    var left = Math.min(x1, x2, x3, x4);\n    var top = Math.min(y1, y2, y3, y4);\n    var right = Math.max(x1, x2, x3, x4);\n    var bottom = Math.max(y1, y2, y3, y4);\n    x1 = x1 - left || 0;\n    x2 = x2 - left || 0;\n    x3 = x3 - left || 0;\n    x4 = x4 - left || 0;\n    y1 = y1 - top || 0;\n    y2 = y2 - top || 0;\n    y3 = y3 - top || 0;\n    y4 = y4 - top || 0;\n    originX = originX - left || 0;\n    originY = originY - top || 0;\n    var sx = matrix[0];\n    var sy = matrix[n + 1];\n    var direction = sign(sx * sy);\n    return {\n        left: left,\n        top: top,\n        right: right,\n        bottom: bottom,\n        origin: [\n            originX,\n            originY\n        ],\n        pos1: [\n            x1,\n            y1\n        ],\n        pos2: [\n            x2,\n            y2\n        ],\n        pos3: [\n            x3,\n            y3\n        ],\n        pos4: [\n            x4,\n            y4\n        ],\n        direction: direction\n    };\n}\nfunction calculatePointerDist(moveable, e) {\n    var clientX = e.clientX, clientY = e.clientY, datas = e.datas;\n    var _a = moveable.state, moveableClientRect = _a.moveableClientRect, rootMatrix = _a.rootMatrix, is3d = _a.is3d, pos1 = _a.pos1;\n    var left = moveableClientRect.left, top = moveableClientRect.top;\n    var n = is3d ? 4 : 3;\n    var _b = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculateInversePosition(rootMatrix, [\n        clientX - left,\n        clientY - top\n    ], n), pos1), 2), posX = _b[0], posY = _b[1];\n    var _c = __read(getDragDist({\n        datas: datas,\n        distX: posX,\n        distY: posY\n    }), 2), distX = _c[0], distY = _c[1];\n    return [\n        distX,\n        distY\n    ];\n}\nfunction setDragStart(moveable, _a) {\n    var datas = _a.datas;\n    var _b = moveable.state, allMatrix = _b.allMatrix, beforeMatrix = _b.beforeMatrix, is3d = _b.is3d, left = _b.left, top = _b.top, origin = _b.origin, offsetMatrix = _b.offsetMatrix, targetMatrix = _b.targetMatrix, transformOrigin = _b.transformOrigin;\n    var n = is3d ? 4 : 3;\n    datas.is3d = is3d;\n    datas.matrix = allMatrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(allMatrix, n);\n    datas.inverseBeforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(beforeMatrix, n);\n    datas.absoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)([\n        left,\n        top\n    ], origin), n);\n    datas.startDragBeforeDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nfunction getTransformDirection(e) {\n    return calculateElementPosition(e.datas.beforeTransform, [\n        50,\n        50\n    ], 100, 100).direction;\n}\nfunction resolveTransformEvent(moveable, event, functionName) {\n    var datas = event.datas, originalDatas = event.originalDatas.beforeRenderable;\n    var index = datas.transformIndex;\n    var nextTransforms = originalDatas.nextTransforms;\n    var length = nextTransforms.length;\n    var nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;\n    var nextIndex = -1;\n    if (index === -1) {\n        // translate => rotate => scale\n        if (functionName === \"translate\") {\n            nextIndex = 0;\n        } else if (functionName === \"rotate\") {\n            nextIndex = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(nextTransforms, function(text) {\n                return text.match(/scale\\(/g);\n            });\n        }\n        if (nextIndex === -1) {\n            nextIndex = nextTransforms.length;\n        }\n        datas.transformIndex = nextIndex;\n    } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(nextTransformAppendedIndexes, function(info) {\n        return info.index === index && info.functionName === functionName;\n    })) {\n        nextIndex = index;\n    } else {\n        nextIndex = index + nextTransformAppendedIndexes.filter(function(info) {\n            return info.index < index;\n        }).length;\n    }\n    var result = convertTransformInfo(nextTransforms, moveable.state, nextIndex);\n    var targetFunction = result.targetFunction;\n    var matFunctionName = functionName === \"rotate\" ? \"rotateZ\" : functionName;\n    datas.beforeFunctionTexts = result.beforeFunctionTexts;\n    datas.afterFunctionTexts = result.afterFunctionTexts;\n    datas.beforeTransform = result.beforeFunctionMatrix;\n    datas.beforeTransform2 = result.beforeFunctionMatrix2;\n    datas.targetTansform = result.targetFunctionMatrix;\n    datas.afterTransform = result.afterFunctionMatrix;\n    datas.afterTransform2 = result.afterFunctionMatrix2;\n    datas.targetAllTransform = result.allFunctionMatrix;\n    if (targetFunction.functionName === matFunctionName) {\n        datas.afterFunctionTexts.splice(0, 1);\n        datas.isAppendTransform = false;\n    } else if (length > nextIndex) {\n        datas.isAppendTransform = true;\n        originalDatas.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], __read(nextTransformAppendedIndexes), false), [\n            {\n                functionName: functionName,\n                index: nextIndex,\n                isAppend: true\n            }\n        ], false);\n    }\n}\nfunction convertTransformFormat(datas, value, dist) {\n    return \"\".concat(datas.beforeFunctionTexts.join(\" \"), \" \").concat(datas.isAppendTransform ? dist : value, \" \").concat(datas.afterFunctionTexts.join(\" \"));\n}\nfunction getTransformDist(_a) {\n    var datas = _a.datas, distX = _a.distX, distY = _a.distY;\n    var _b = __read(getBeforeDragDist({\n        datas: datas,\n        distX: distX,\n        distY: distY\n    }), 2), bx = _b[0], by = _b[1];\n    // B * [tx, ty] * A = [bx, by] * targetMatrix;\n    // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];\n    var res = getTransfromMatrix(datas, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.fromTranslation)([\n        bx,\n        by\n    ], 4));\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(res, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)([\n        0,\n        0,\n        0\n    ], 4), 4);\n}\nfunction getTransfromMatrix(datas, targetMatrix, isAfter) {\n    var beforeTransform = datas.beforeTransform, afterTransform = datas.afterTransform, beforeTransform2 = datas.beforeTransform2, afterTransform2 = datas.afterTransform2, targetAllTransform = datas.targetAllTransform;\n    // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)\n    // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1\n    // nextTargetMatrix = (targetMatrix * targetAllTransform)\n    var nextTargetMatrix = isAfter ? (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetAllTransform, targetMatrix, 4) : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetMatrix, targetAllTransform, 4);\n    // res1 = B-1 * nextTargetMatrix\n    var res1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4);\n    // res3 = res2 * A-1\n    var afterTargetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(res1, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(isAfter ? afterTransform2 : afterTransform, 4), 4);\n    return afterTargetMatrix;\n}\nfunction getBeforeDragDist(_a) {\n    var datas = _a.datas, distX = _a.distX, distY = _a.distY;\n    // TT = BT\n    var inverseBeforeMatrix = datas.inverseBeforeMatrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, absoluteOrigin = datas.absoluteOrigin;\n    var n = is3d ? 4 : 3;\n    // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])\n    // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(inverseBeforeMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(absoluteOrigin, [\n        distX,\n        distY\n    ]), n), startDragBeforeDist);\n}\nfunction getDragDist(_a, isBefore) {\n    var datas = _a.datas, distX = _a.distX, distY = _a.distY;\n    var inverseBeforeMatrix = datas.inverseBeforeMatrix, inverseMatrix = datas.inverseMatrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, startDragDist = datas.startDragDist, absoluteOrigin = datas.absoluteOrigin;\n    var n = is3d ? 4 : 3;\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(isBefore ? inverseBeforeMatrix : inverseMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(absoluteOrigin, [\n        distX,\n        distY\n    ]), n), isBefore ? startDragBeforeDist : startDragDist);\n}\nfunction getInverseDragDist(_a, isBefore) {\n    var datas = _a.datas, distX = _a.distX, distY = _a.distY;\n    var beforeMatrix = datas.beforeMatrix, matrix = datas.matrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, startDragDist = datas.startDragDist, absoluteOrigin = datas.absoluteOrigin;\n    var n = is3d ? 4 : 3;\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(isBefore ? beforeMatrix : matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(isBefore ? startDragBeforeDist : startDragDist, [\n        distX,\n        distY\n    ]), n), absoluteOrigin);\n}\nfunction calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {\n    if (prevWidth === void 0) {\n        prevWidth = width;\n    }\n    if (prevHeight === void 0) {\n        prevHeight = height;\n    }\n    if (prevOrigin === void 0) {\n        prevOrigin = [\n            0,\n            0\n        ];\n    }\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map(function(pos, i) {\n        var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitUnit)(pos), value = _a.value, unit = _a.unit;\n        var prevSize = i ? prevHeight : prevWidth;\n        var size = i ? height : width;\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n            var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nfunction getPosIndexesByDirection(direction) {\n    var indexes = [];\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nfunction getPosesByDirection(poses, direction) {\n    /*\r\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\r\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\r\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\r\n    */ return getPosIndexesByDirection(direction).map(function(index) {\n        return poses[index];\n    });\n}\nfunction getPosBySingleDirection(poses, direction) {\n    var ratio = (direction + 1) / 2;\n    return [\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.dot)(poses[0][0], poses[1][0], ratio, 1 - ratio),\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.dot)(poses[0][1], poses[1][1], ratio, 1 - ratio)\n    ];\n}\nfunction getPosByDirection(poses, direction) {\n    var top = getPosBySingleDirection([\n        poses[0],\n        poses[1]\n    ], direction[0]);\n    var bottom = getPosBySingleDirection([\n        poses[2],\n        poses[3]\n    ], direction[0]);\n    return getPosBySingleDirection([\n        top,\n        bottom\n    ], direction[1]);\n}\nfunction getDist(startPos, matrix, width, height, n, fixedDirection) {\n    var poses = calculatePoses(matrix, width, height, n);\n    var fixedPos = getPosByDirection(poses, fixedDirection);\n    var distX = startPos[0] - fixedPos[0];\n    var distY = startPos[1] - fixedPos[1];\n    return [\n        distX,\n        distY\n    ];\n}\nfunction getNextMatrix(offsetMatrix, targetMatrix, origin, n) {\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);\n}\nfunction getNextTransformMatrix(state, datas, transform, isAllTransform) {\n    var transformOrigin = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d;\n    var n = is3d ? 4 : 3;\n    var targetTransform;\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(transform)) {\n        var beforeTransform = datas.beforeTransform, afterTransform = datas.afterTransform;\n        if (isAllTransform) {\n            targetTransform = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)((0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)(transform), 4, n);\n        } else {\n            targetTransform = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(beforeTransform, (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)([\n                transform\n            ]), 4), afterTransform, 4), 4, n);\n        }\n    } else {\n        targetTransform = transform;\n    }\n    return getNextMatrix(offsetMatrix, targetTransform, transformOrigin, n);\n}\nfunction scaleMatrix(state, scale) {\n    var transformOrigin = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d, targetMatrix = state.targetMatrix, targetAllTransform = state.targetAllTransform;\n    var n = is3d ? 4 : 3;\n    return getNextMatrix(offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetAllTransform || targetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createScaleMatrix)(scale, n), n), transformOrigin, n);\n}\nfunction fillTransformStartEvent(moveable, e) {\n    var originalDatas = getBeforeRenderableDatas(e);\n    return {\n        setTransform: function(transform, index) {\n            if (index === void 0) {\n                index = -1;\n            }\n            originalDatas.startTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(transform);\n            setTransformIndex(moveable, e, index);\n        },\n        setTransformIndex: function(index) {\n            setTransformIndex(moveable, e, index);\n        }\n    };\n}\nfunction setDefaultTransformIndex(moveable, e, property) {\n    var originalDatas = getBeforeRenderableDatas(e);\n    var startTransforms = originalDatas.startTransforms;\n    setTransformIndex(moveable, e, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(startTransforms, function(func) {\n        return func.indexOf(\"\".concat(property, \"(\")) === 0;\n    }));\n}\nfunction setTransformIndex(moveable, e, index) {\n    var originalDatas = getBeforeRenderableDatas(e);\n    var datas = e.datas;\n    datas.transformIndex = index;\n    if (index === -1) {\n        return;\n    }\n    var transform = originalDatas.startTransforms[index];\n    if (!transform) {\n        return;\n    }\n    var state = moveable.state;\n    var info = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)([\n        transform\n    ], {\n        \"x%\": function(v) {\n            return v / 100 * state.offsetWidth;\n        },\n        \"y%\": function(v) {\n            return v / 100 * state.offsetHeight;\n        }\n    });\n    datas.startValue = info[0].functionValue;\n}\nfunction fillOriginalTransform(e, transform) {\n    var originalDatas = getBeforeRenderableDatas(e);\n    originalDatas.nextTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(transform);\n// originalDatas.nextTargetMatrix = parseMat(transform);\n}\nfunction getBeforeRenderableDatas(e) {\n    return e.originalDatas.beforeRenderable;\n}\nfunction getNextTransforms(e) {\n    var originalDatas = e.originalDatas.beforeRenderable;\n    return originalDatas.nextTransforms;\n}\nfunction getNextTransformText(e) {\n    return (getNextTransforms(e) || []).join(\" \");\n}\nfunction getNextStyle(e) {\n    return getBeforeRenderableDatas(e).nextStyle;\n}\nfunction fillTransformEvent(moveable, nextTransform, delta, isPinch, e) {\n    fillOriginalTransform(e, nextTransform);\n    var drag = Draggable.drag(moveable, setCustomDrag(e, moveable.state, delta, isPinch, false));\n    var afterTransform = drag ? drag.transform : nextTransform;\n    return __assign(__assign({\n        transform: nextTransform,\n        drag: drag\n    }, fillCSSObject({\n        transform: afterTransform\n    }, e)), {\n        afterTransform: afterTransform\n    });\n}\nfunction getTranslateFixedPosition(moveable, transform, fixedDirection, fixedOffset, datas, isAllTransform) {\n    var nextMatrix = getNextTransformMatrix(moveable.state, datas, transform, isAllTransform);\n    var nextFixedPosition = getDirectionOffset(moveable, fixedDirection, fixedOffset, nextMatrix);\n    return nextFixedPosition;\n}\nfunction getTranslateDist(moveable, transform, fixedDirection, fixedPosition, fixedOffset, datas, isAllTransform) {\n    var nextFixedPosition = getTranslateFixedPosition(moveable, transform, fixedDirection, fixedOffset, datas, isAllTransform);\n    var state = moveable.state;\n    var left = state.left, top = state.top;\n    var groupable = moveable.props.groupable;\n    var groupLeft = groupable ? left : 0;\n    var groupTop = groupable ? top : 0;\n    var dist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedPosition, nextFixedPosition);\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, [\n        groupLeft,\n        groupTop\n    ]);\n}\nfunction getScaleDist(moveable, transform, fixedDirection, fixedPosition, fixedOffset, datas, isAllTransform) {\n    var dist = getTranslateDist(moveable, transform, fixedDirection, fixedPosition, fixedOffset, datas, isAllTransform);\n    return dist;\n}\nfunction getDirectionByPos(pos, width, height) {\n    return [\n        width ? -1 + pos[0] / (width / 2) : 0,\n        height ? -1 + pos[1] / (height / 2) : 0\n    ];\n}\nfunction getDirectionOffset(moveable, fixedDirection, fixedOffset, nextMatrix) {\n    if (nextMatrix === void 0) {\n        nextMatrix = moveable.state.allMatrix;\n    }\n    var _a = moveable.state, width = _a.width, height = _a.height, is3d = _a.is3d;\n    var n = is3d ? 4 : 3;\n    var fixedOffsetPosition = [\n        width / 2 * (1 + fixedDirection[0]) + fixedOffset[0],\n        height / 2 * (1 + fixedDirection[1]) + fixedOffset[1]\n    ];\n    return calculatePosition(nextMatrix, fixedOffsetPosition, n);\n}\nfunction getRotateDist(moveable, rotateDist, datas) {\n    var fixedDirection = datas.fixedDirection;\n    var fixedPosition = datas.fixedPosition;\n    var fixedOffset = datas.fixedOffset;\n    return getTranslateDist(moveable, \"rotate(\".concat(rotateDist, \"deg)\"), fixedDirection, fixedPosition, fixedOffset, datas);\n}\nfunction getResizeDist(moveable, width, height, fixedPosition, transformOrigin, datas) {\n    var groupable = moveable.props.groupable;\n    var state = moveable.state;\n    var prevOrigin = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d, prevWidth = state.width, prevHeight = state.height, left = state.left, top = state.top;\n    var fixedDirection = datas.fixedDirection;\n    var targetMatrix = datas.nextTargetMatrix || state.targetMatrix;\n    var n = is3d ? 4 : 3;\n    var nextOrigin = calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);\n    var groupLeft = groupable ? left : 0;\n    var groupTop = groupable ? top : 0;\n    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    var dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, [\n        groupLeft,\n        groupTop\n    ]);\n}\nfunction getAbsolutePosition(moveable, direction) {\n    return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);\n}\nfunction getGestoData(moveable, ableName) {\n    var targetGesto = moveable.targetGesto;\n    var controlGesto = moveable.controlGesto;\n    var data;\n    if (targetGesto === null || targetGesto === void 0 ? void 0 : targetGesto.isFlag()) {\n        data = targetGesto.getEventData()[ableName];\n    }\n    if (!data && (controlGesto === null || controlGesto === void 0 ? void 0 : controlGesto.isFlag())) {\n        data = controlGesto.getEventData()[ableName];\n    }\n    return data || {};\n}\nfunction getShadowRoot(parentElement) {\n    if (parentElement && parentElement.getRootNode) {\n        var rootNode = parentElement.getRootNode();\n        if (rootNode.nodeType === 11) {\n            return rootNode;\n        }\n    }\n    return;\n}\nfunction getIndividualTransforms(getStyle) {\n    var scale = getStyle(\"scale\");\n    var rotate = getStyle(\"rotate\");\n    var translate = getStyle(\"translate\");\n    var individualTransforms = [];\n    if (translate && translate !== \"0px\" && translate !== \"none\") {\n        individualTransforms.push(\"translate(\".concat(translate.split(/\\s+/).join(\",\"), \")\"));\n    }\n    if (rotate && rotate !== \"1\" && rotate !== \"none\") {\n        individualTransforms.push(\"rotate(\".concat(rotate, \")\"));\n    }\n    if (scale && scale !== \"1\" && scale !== \"none\") {\n        individualTransforms.push(\"scale(\".concat(scale.split(/\\s+/).join(\",\"), \")\"));\n    }\n    return individualTransforms;\n}\nfunction getMatrixStackInfo(target, container, checkContainer) {\n    var el = target;\n    var matrixes = [];\n    var documentElement = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentElement)(target) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(target);\n    var requestEnd = !checkContainer && target === container || target === documentElement;\n    var isEnd = requestEnd;\n    var is3d = false;\n    var n = 3;\n    var transformOrigin;\n    var targetTransformOrigin;\n    var targetMatrix;\n    var hasFixed = false;\n    var offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n    var zoom = 1;\n    while(el && !isEnd){\n        isEnd = requestEnd;\n        var getStyle = getCachedStyle(el);\n        var position = getStyle(\"position\");\n        var transform = getElementTransform(el);\n        var isFixed = position === \"fixed\";\n        var individualTransforms = getIndividualTransforms(getStyle);\n        var matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertCSStoMatrix)(getTransformMatrix(transform));\n        var offsetParent = void 0;\n        var isOffsetEnd = false;\n        var isStatic = false;\n        var parentClientLeft = 0;\n        var parentClientTop = 0;\n        var fixedClientLeft = 0;\n        var fixedClientTop = 0;\n        var fixedInfo = {\n            hasTransform: false,\n            fixedContainer: null\n        };\n        if (isFixed) {\n            hasFixed = true;\n            fixedInfo = getPositionFixedInfo(el);\n            offsetContainer = fixedInfo.fixedContainer;\n        }\n        // convert 3 to 4\n        var length_1 = matrix.length;\n        if (!is3d && (length_1 === 16 || individualTransforms.length)) {\n            is3d = true;\n            n = 4;\n            convert3DMatrixes(matrixes);\n            if (targetMatrix) {\n                targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 3, 4);\n            }\n        }\n        if (is3d && length_1 === 9) {\n            matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(matrix, 3, 4);\n        }\n        var _a = getOffsetPosInfo(el, target), tagName = _a.tagName, hasOffset = _a.hasOffset, isSVG = _a.isSVG, origin_1 = _a.origin, targetOrigin = _a.targetOrigin, offsetPos = _a.offset;\n        var _b = __read(offsetPos, 2), offsetLeft = _b[0], offsetTop = _b[1];\n        // no target with svg\n        if (tagName === \"svg\" && !el.ownerSVGElement && targetMatrix) {\n            // scale matrix for svg's SVGElements.\n            matrixes.push({\n                type: \"target\",\n                target: el,\n                matrix: getSVGMatrix(el, n)\n            });\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n)\n            });\n        }\n        var targetZoom = parseFloat(getStyle(\"zoom\")) || 1;\n        if (isFixed) {\n            offsetParent = fixedInfo.fixedContainer;\n            isOffsetEnd = true;\n        } else {\n            var offsetInfo = getOffsetInfo(el, container, false, true, getStyle);\n            var offsetZoom = offsetInfo.offsetZoom;\n            offsetParent = offsetInfo.offsetParent;\n            isOffsetEnd = offsetInfo.isEnd;\n            isStatic = offsetInfo.isStatic;\n            zoom *= offsetZoom;\n            if ((offsetInfo.isCustomElement || offsetZoom !== 1) && isStatic) {\n                offsetLeft -= offsetParent.offsetLeft;\n                offsetTop -= offsetParent.offsetTop;\n            } else if (IS_FIREFOX || IS_CHROMIUM109) {\n                var parentSlotElement = offsetInfo.parentSlotElement;\n                if (parentSlotElement) {\n                    var customOffsetParent = offsetParent;\n                    var customOffsetLeft = 0;\n                    var customOffsetTop = 0;\n                    while(customOffsetParent){\n                        if (!getShadowRoot(customOffsetParent)) {\n                            break;\n                        }\n                        customOffsetLeft += customOffsetParent.offsetLeft;\n                        customOffsetTop += customOffsetParent.offsetTop;\n                        customOffsetParent = customOffsetParent.offsetParent;\n                    }\n                    offsetLeft -= customOffsetLeft;\n                    offsetTop -= customOffsetTop;\n                }\n            }\n        }\n        if (IS_WEBKIT && !IS_SAFARI_ABOVE15 && hasOffset && !isSVG && isStatic && (position === \"relative\" || position === \"static\")) {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n            requestEnd = requestEnd || isOffsetEnd;\n        }\n        if (isFixed) {\n            if (hasOffset && fixedInfo.hasTransform) {\n                // border\n                fixedClientLeft = offsetParent.clientLeft;\n                fixedClientTop = offsetParent.clientTop;\n            }\n        } else {\n            if (hasOffset && offsetContainer !== offsetParent) {\n                // border\n                parentClientLeft = offsetParent.clientLeft;\n                parentClientTop = offsetParent.clientTop;\n            }\n            if (hasOffset && offsetParent === documentElement) {\n                var margin = getBodyOffset(el, false);\n                offsetLeft += margin[0];\n                offsetTop += margin[1];\n            }\n        }\n        matrixes.push({\n            type: \"target\",\n            target: el,\n            matrix: getAbsoluteMatrix(matrix, n, origin_1)\n        });\n        if (individualTransforms.length) {\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n)\n            });\n            matrixes.push({\n                type: \"target\",\n                target: el,\n                matrix: getAbsoluteMatrix((0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)(individualTransforms), n, origin_1)\n            });\n        }\n        if (hasOffset) {\n            var isElementTarget = el === target;\n            var scrollLeft = isElementTarget ? 0 : el.scrollLeft;\n            var scrollTop = isElementTarget ? 0 : el.scrollTop;\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)([\n                    offsetLeft - scrollLeft + parentClientLeft - fixedClientLeft,\n                    offsetTop - scrollTop + parentClientTop - fixedClientTop\n                ], n)\n            });\n        } else {\n            // svg\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                origin: origin_1\n            });\n        }\n        // transform   zoom  (0, 0)   matrix .\n        if (targetZoom !== 1) {\n            matrixes.push({\n                type: \"zoom\",\n                target: el,\n                matrix: getAbsoluteMatrix((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createScaleMatrix)([\n                    targetZoom,\n                    targetZoom\n                ], n), n, [\n                    0,\n                    0\n                ])\n            });\n        }\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin_1;\n        }\n        if (!targetTransformOrigin) {\n            targetTransformOrigin = targetOrigin;\n        }\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            requestEnd = isOffsetEnd;\n        }\n        if (!checkContainer || el === documentElement) {\n            isEnd = requestEnd;\n        }\n    }\n    if (!targetMatrix) {\n        targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\n    }\n    if (!transformOrigin) {\n        transformOrigin = [\n            0,\n            0\n        ];\n    }\n    if (!targetTransformOrigin) {\n        targetTransformOrigin = [\n            0,\n            0\n        ];\n    }\n    return {\n        zoom: zoom,\n        offsetContainer: offsetContainer,\n        matrixes: matrixes,\n        targetMatrix: targetMatrix,\n        transformOrigin: transformOrigin,\n        targetOrigin: targetTransformOrigin,\n        is3d: is3d,\n        hasFixed: hasFixed\n    };\n}\nvar cacheStyleMap = null;\nvar clientRectStyleMap = null;\nvar matrixContainerInfos = null;\nfunction setStoreCache(useCache) {\n    if (useCache) {\n        if (window.Map) {\n            cacheStyleMap = new Map();\n            clientRectStyleMap = new Map();\n        }\n        matrixContainerInfos = [];\n    } else {\n        cacheStyleMap = null;\n        matrixContainerInfos = null;\n        clientRectStyleMap = null;\n    }\n}\nfunction getCachedClientRect(el) {\n    var clientRect = clientRectStyleMap === null || clientRectStyleMap === void 0 ? void 0 : clientRectStyleMap.get(el);\n    if (clientRect) {\n        return clientRect;\n    }\n    var nextClientRect = getClientRect(el, true);\n    if (clientRectStyleMap) {\n        clientRectStyleMap.set(el, nextClientRect);\n    }\n    return nextClientRect;\n}\nfunction getCachedMatrixContainerInfo(target, container) {\n    if (matrixContainerInfos) {\n        var result_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(matrixContainerInfos, function(info) {\n            return info[0][0] == target && info[0][1] == container;\n        });\n        if (result_1) {\n            return result_1[1];\n        }\n    }\n    var result = getMatrixStackInfo(target, container, true);\n    if (matrixContainerInfos) {\n        matrixContainerInfos.push([\n            [\n                target,\n                container\n            ],\n            result\n        ]);\n    }\n    return result;\n}\nfunction getCachedStyle(element) {\n    var cache = cacheStyleMap === null || cacheStyleMap === void 0 ? void 0 : cacheStyleMap.get(element);\n    if (!cache) {\n        var nextStyle_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)(element).getComputedStyle(element);\n        if (!cacheStyleMap) {\n            return function(property) {\n                return nextStyle_1[property];\n            };\n        }\n        cache = {\n            style: nextStyle_1,\n            cached: {}\n        };\n        cacheStyleMap.set(element, cache);\n    }\n    var cached = cache.cached;\n    var style = cache.style;\n    return function(property) {\n        if (!(property in cached)) {\n            cached[property] = style[property];\n        }\n        return cached[property];\n    };\n}\nfunction fillChildEvents(moveable, name, e) {\n    var datas = e.originalDatas;\n    datas.groupable = datas.groupable || {};\n    var groupableDatas = datas.groupable;\n    groupableDatas.childDatas = groupableDatas.childDatas || [];\n    var childDatas = groupableDatas.childDatas;\n    return moveable.moveables.map(function(_, i) {\n        childDatas[i] = childDatas[i] || {};\n        childDatas[i][name] = childDatas[i][name] || {};\n        return __assign(__assign({}, e), {\n            isRequestChild: true,\n            datas: childDatas[i][name],\n            originalDatas: childDatas[i]\n        });\n    });\n}\nfunction triggerChildGesto(moveable, able, type, delta, e, isConvert, ableName) {\n    var isStart = !!type.match(/Start$/g);\n    var isEnd = !!type.match(/End$/g);\n    var isPinch = e.isPinch;\n    var datas = e.datas;\n    var events = fillChildEvents(moveable, able.name, e);\n    var moveables = moveable.moveables;\n    var childEvents = [];\n    var eventParams = events.map(function(ev, i) {\n        var childMoveable = moveables[i];\n        var state = childMoveable.state;\n        var gestos = state.gestos;\n        var childEvent = ev;\n        if (isStart) {\n            childEvent = new CustomGesto(ableName).dragStart(delta, ev);\n            childEvents.push(childEvent);\n        } else {\n            if (!gestos[ableName]) {\n                gestos[ableName] = datas.childGestos[i];\n            }\n            if (!gestos[ableName]) {\n                return;\n            }\n            childEvent = setCustomDrag(ev, state, delta, isPinch, isConvert, ableName);\n            childEvents.push(childEvent);\n        }\n        var result = able[type](childMoveable, __assign(__assign({}, childEvent), {\n            parentFlag: true\n        }));\n        if (isEnd) {\n            gestos[ableName] = null;\n        }\n        return result;\n    });\n    if (isStart) {\n        datas.childGestos = moveables.map(function(child) {\n            return child.state.gestos[ableName];\n        });\n    }\n    return {\n        eventParams: eventParams,\n        childEvents: childEvents\n    };\n}\nfunction triggerChildAbles(moveable, able, type, e, eachEvent, callback) {\n    if (eachEvent === void 0) {\n        eachEvent = function(_, ev) {\n            return ev;\n        };\n    }\n    var isEnd = !!type.match(/End$/g);\n    var events = fillChildEvents(moveable, able.name, e);\n    var moveables = moveable.moveables;\n    var childs = events.map(function(ev, i) {\n        var childMoveable = moveables[i];\n        var childEvent = ev;\n        childEvent = eachEvent(childMoveable, ev);\n        var result = able[type](childMoveable, __assign(__assign({}, childEvent), {\n            parentFlag: true\n        }));\n        result && callback && callback(childMoveable, ev, result, i);\n        if (isEnd) {\n            childMoveable.state.gestos = {};\n        }\n        return result;\n    });\n    return childs;\n}\nfunction startChildDist(moveable, child, parentDatas, childEvent) {\n    var fixedDirection = parentDatas.fixedDirection;\n    var fixedPosition = parentDatas.fixedPosition;\n    var startPositions = childEvent.datas.startPositions || getAbsolutePosesByState(child.state);\n    var pos = getPosByDirection(startPositions, fixedDirection);\n    var _a = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createRotateMatrix)(-moveable.rotation / 180 * Math.PI, 3), [\n        pos[0] - fixedPosition[0],\n        pos[1] - fixedPosition[1],\n        1\n    ], 3), 2), originalX = _a[0], originalY = _a[1];\n    childEvent.datas.originalX = originalX;\n    childEvent.datas.originalY = originalY;\n    return childEvent;\n}\nfunction renderDirectionControlsByInfos(moveable, ableName, renderDirections, React) {\n    var _a = moveable.getState(), renderPoses = _a.renderPoses, rotationRad = _a.rotation, direction = _a.direction;\n    var zoom = getProps(moveable.props, ableName).zoom;\n    var degRotation = absDegree(rotationRad / Math.PI * 180);\n    var directionMap = {};\n    var renderState = moveable.renderState;\n    if (!renderState.renderDirectionMap) {\n        renderState.renderDirectionMap = {};\n    }\n    var renderDirectionMap = renderState.renderDirectionMap;\n    renderDirections.forEach(function(_a) {\n        var dir = _a.dir;\n        directionMap[dir] = true;\n    });\n    var directionSign = sign(direction);\n    return renderDirections.map(function(_a) {\n        var data = _a.data, classNames = _a.classNames, dir = _a.dir;\n        var indexes = DIRECTION_INDEXES[dir];\n        if (!indexes || !directionMap[dir]) {\n            return null;\n        }\n        renderDirectionMap[dir] = true;\n        var directionRotation = ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(degRotation, 15) + directionSign * DIRECTION_ROTATIONS[dir] + 720) % 180;\n        var dataAttrs = {};\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(data).forEach(function(name) {\n            dataAttrs[\"data-\".concat(name)] = data[name];\n        });\n        return React.createElement(\"div\", __assign({\n            className: prefix.apply(void 0, __spreadArray([\n                \"control\",\n                \"direction\",\n                dir,\n                ableName\n            ], __read(classNames), false)),\n            \"data-rotation\": directionRotation,\n            \"data-direction\": dir\n        }, dataAttrs, {\n            key: \"direction-\".concat(dir),\n            style: getControlTransform.apply(void 0, __spreadArray([\n                rotationRad,\n                zoom\n            ], __read(indexes.map(function(index) {\n                return renderPoses[index];\n            })), false))\n        }));\n    });\n}\nfunction renderDirectionControls(moveable, defaultDirections, ableName, React) {\n    var _a = getProps(moveable.props, ableName), _b = _a.renderDirections, directions = _b === void 0 ? defaultDirections : _b, displayAroundControls = _a.displayAroundControls;\n    if (!directions) {\n        return [];\n    }\n    var renderDirections = directions === true ? DIRECTIONS : directions;\n    return __spreadArray(__spreadArray([], __read(displayAroundControls ? renderAroundControls(moveable, React, ableName, renderDirections) : []), false), __read(renderDirectionControlsByInfos(moveable, ableName, renderDirections.map(function(dir) {\n        return {\n            data: {},\n            classNames: [],\n            dir: dir\n        };\n    }), React)), false);\n}\nfunction renderLine(React, direction, pos1, pos2, zoom, key) {\n    var classNames = [];\n    for(var _i = 6; _i < arguments.length; _i++){\n        classNames[_i - 6] = arguments[_i];\n    }\n    var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(pos1, pos2);\n    var rotation = direction ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(rad / Math.PI * 180, 15) % 180 : -1;\n    return React.createElement(\"div\", {\n        key: \"line-\".concat(key),\n        className: prefix.apply(void 0, __spreadArray([\n            \"line\",\n            \"direction\",\n            direction ? \"edge\" : \"\",\n            direction\n        ], __read(classNames), false)),\n        \"data-rotation\": rotation,\n        \"data-line-key\": key,\n        \"data-direction\": direction,\n        style: getLineStyle(pos1, pos2, zoom, rad)\n    });\n}\nfunction renderEdgeLines(React, ableName, edge, poses, zoom) {\n    var directions = edge === true ? DIRECTIONS4 : edge;\n    return directions.map(function(direction, i) {\n        var _a = __read(DIRECTION_INDEXES[direction], 2), index1 = _a[0], index2 = _a[1];\n        if (index2 == null) {\n            return;\n        }\n        return renderLine(React, direction, poses[index1], poses[index2], zoom, \"\".concat(ableName, \"Edge\").concat(i), ableName);\n    }).filter(Boolean);\n}\nfunction getRenderDirections(ableName) {\n    return function(moveable, React) {\n        var edge = getProps(moveable.props, ableName).edge;\n        if (edge && (edge === true || edge.length)) {\n            return __spreadArray(__spreadArray([], __read(renderEdgeLines(React, ableName, edge, moveable.getState().renderPoses, moveable.props.zoom)), false), __read(renderDiagonalDirections(moveable, ableName, React)), false);\n        }\n        return renderAllDirections(moveable, ableName, React);\n    };\n}\nfunction renderAllDirections(moveable, ableName, React) {\n    return renderDirectionControls(moveable, DIRECTIONS, ableName, React);\n}\nfunction renderDiagonalDirections(moveable, ableName, React) {\n    return renderDirectionControls(moveable, [\n        \"nw\",\n        \"ne\",\n        \"sw\",\n        \"se\"\n    ], ableName, React);\n}\nfunction renderAroundControls(moveable, React, ableName, renderDirections) {\n    var renderState = moveable.renderState;\n    if (!renderState.renderDirectionMap) {\n        renderState.renderDirectionMap = {};\n    }\n    var _a = moveable.getState(), renderPoses = _a.renderPoses, rotationRad = _a.rotation, direction = _a.direction;\n    var renderDirectionMap = renderState.renderDirectionMap;\n    var zoom = moveable.props.zoom;\n    var directionSign = sign(direction);\n    var degRotation = rotationRad / Math.PI * 180;\n    return (renderDirections || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(renderDirectionMap)).map(function(dir) {\n        var indexes = DIRECTION_INDEXES[dir];\n        if (!indexes) {\n            return null;\n        }\n        var directionRotation = ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(degRotation, 15) + directionSign * DIRECTION_ROTATIONS[dir] + 720) % 180;\n        var classNames = [\n            \"around-control\"\n        ];\n        if (ableName) {\n            classNames.push(\"direction\", ableName);\n        }\n        return React.createElement(\"div\", {\n            className: prefix.apply(void 0, __spreadArray([], __read(classNames), false)),\n            \"data-rotation\": directionRotation,\n            \"data-direction\": dir,\n            key: \"direction-around-\".concat(dir),\n            style: getControlTransform.apply(void 0, __spreadArray([\n                rotationRad,\n                zoom\n            ], __read(indexes.map(function(index) {\n                return renderPoses[index];\n            })), false))\n        });\n    });\n}\nfunction checkBoundPoses(bounds, verticalPoses, horizontalPoses) {\n    var _a = bounds || {}, _b = _a.position, position = _b === void 0 ? \"client\" : _b, _c = _a.left, left = _c === void 0 ? -Infinity : _c, _d = _a.top, top = _d === void 0 ? -Infinity : _d, _e = _a.right, right = _e === void 0 ? Infinity : _e, _f = _a.bottom, bottom = _f === void 0 ? Infinity : _f;\n    var nextBounds = {\n        position: position,\n        left: left,\n        top: top,\n        right: right,\n        bottom: bottom\n    };\n    return {\n        vertical: checkBounds(nextBounds, verticalPoses, true),\n        horizontal: checkBounds(nextBounds, horizontalPoses, false)\n    };\n}\nfunction getBounds(moveable, externalBounds) {\n    var _a = moveable.state, _b = _a.containerClientRect, containerHeight = _b.clientHeight, containerWidth = _b.clientWidth, clientLeft = _b.clientLeft, clientTop = _b.clientTop, _c = _a.snapOffset, snapOffsetLeft = _c.left, snapOffsetTop = _c.top, snapOffsetRight = _c.right, snapOffsetBottom = _c.bottom;\n    var bounds = externalBounds || moveable.props.bounds || {};\n    var position = bounds.position || \"client\";\n    var isCSS = position === \"css\";\n    var _d = bounds.left, left = _d === void 0 ? -Infinity : _d, _e = bounds.top, top = _e === void 0 ? -Infinity : _e;\n    var _f = bounds.right, right = _f === void 0 ? isCSS ? -Infinity : Infinity : _f, _g = bounds.bottom, bottom = _g === void 0 ? isCSS ? -Infinity : Infinity : _g;\n    if (isCSS) {\n        right = containerWidth + snapOffsetRight - snapOffsetLeft - right;\n        bottom = containerHeight + snapOffsetBottom - snapOffsetTop - bottom;\n    }\n    return {\n        left: left + snapOffsetLeft - clientLeft,\n        right: right + snapOffsetLeft - clientLeft,\n        top: top + snapOffsetTop - clientTop,\n        bottom: bottom + snapOffsetTop - clientTop\n    };\n}\nfunction checkBoundKeepRatio(moveable, startPos, endPos) {\n    var _a = getBounds(moveable), left = _a.left, top = _a.top, right = _a.right, bottom = _a.bottom;\n    var _b = __read(endPos, 2), endX = _b[0], endY = _b[1];\n    var _c = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(endPos, startPos), 2), dx = _c[0], dy = _c[1];\n    if (abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    var isBottom = dy > 0;\n    var isRight = dx > 0;\n    var verticalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0\n    };\n    var horizontalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo\n        };\n    } else if (dx === 0) {\n        if (isBottom) {\n            if (bottom < endY) {\n                horizontalInfo.pos = bottom;\n                horizontalInfo.offset = endY - bottom;\n            }\n        } else {\n            if (top > endY) {\n                horizontalInfo.pos = top;\n                horizontalInfo.offset = endY - top;\n            }\n        }\n    } else if (dy === 0) {\n        if (isRight) {\n            if (right < endX) {\n                verticalInfo.pos = right;\n                verticalInfo.offset = endX - right;\n            }\n        } else {\n            if (left > endX) {\n                verticalInfo.pos = left;\n                verticalInfo.offset = endX - left;\n            }\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        var a = dy / dx;\n        var b = endPos[1] - a * endX;\n        var y = 0;\n        var x = 0;\n        var isBound = false;\n        if (isRight && right <= endX) {\n            y = a * right + b;\n            x = right;\n            isBound = true;\n        } else if (!isRight && endX <= left) {\n            y = a * left + b;\n            x = left;\n            isBound = true;\n        }\n        if (isBound) {\n            if (y < top || y > bottom) {\n                isBound = false;\n            }\n        }\n        if (!isBound) {\n            if (isBottom && bottom <= endY) {\n                y = bottom;\n                x = (y - b) / a;\n                isBound = true;\n            } else if (!isBottom && endY <= top) {\n                y = top;\n                x = (y - b) / a;\n                isBound = true;\n            }\n        }\n        if (isBound) {\n            verticalInfo.isBound = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n            horizontalInfo.isBound = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo\n    };\n}\nfunction checkBounds(bounds, poses, isVertical) {\n    // 0   [100 - 200]  300\n    var startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n    var endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n    // 450\n    var minPos = Math.min.apply(Math, __spreadArray([], __read(poses), false));\n    var maxPos = Math.max.apply(Math, __spreadArray([], __read(poses), false));\n    var boundInfos = [];\n    if (startBoundPos + 1 > minPos) {\n        boundInfos.push({\n            direction: \"start\",\n            isBound: true,\n            offset: minPos - startBoundPos,\n            pos: startBoundPos\n        });\n    }\n    if (endBoundPos - 1 < maxPos) {\n        boundInfos.push({\n            direction: \"end\",\n            isBound: true,\n            offset: maxPos - endBoundPos,\n            pos: endBoundPos\n        });\n    }\n    if (!boundInfos.length) {\n        boundInfos.push({\n            isBound: false,\n            offset: 0,\n            pos: 0\n        });\n    }\n    return boundInfos.sort(function(a, b) {\n        return abs(b.offset) - abs(a.offset);\n    });\n}\nfunction isBoundRotate$1(relativePoses, boundRect, rad) {\n    var nextPoses = rad ? relativePoses.map(function(pos) {\n        return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad);\n    }) : relativePoses;\n    return nextPoses.some(function(pos) {\n        return pos[0] < boundRect.left && abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && abs(pos[1] - boundRect.bottom) > 0.1;\n    });\n}\nfunction boundRotate(vec, boundPos, index) {\n    var r = getDistSize(vec);\n    var nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n    return [\n        nextPos,\n        -nextPos\n    ].sort(function(a, b) {\n        return abs(a - vec[index ? 0 : 1]) - abs(b - vec[index ? 0 : 1]);\n    }).map(function(pos) {\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([\n            0,\n            0\n        ], index ? [\n            pos,\n            boundPos\n        ] : [\n            boundPos,\n            pos\n        ]);\n    });\n}\nfunction checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {\n    if (!moveable.props.bounds) {\n        return [];\n    }\n    var rad = rotation * Math.PI / 180;\n    var _a = getBounds(moveable), left = _a.left, top = _a.top, right = _a.right, bottom = _a.bottom;\n    var relativeLeft = left - origin[0];\n    var relativeRight = right - origin[0];\n    var relativeTop = top - origin[1];\n    var relativeBottom = bottom - origin[1];\n    var boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom\n    };\n    if (!isBoundRotate$1(nextPoses, boundRect, 0)) {\n        return [];\n    }\n    var result = [];\n    [\n        [\n            relativeLeft,\n            0\n        ],\n        [\n            relativeRight,\n            0\n        ],\n        [\n            relativeTop,\n            1\n        ],\n        [\n            relativeBottom,\n            1\n        ]\n    ].forEach(function(_a) {\n        var _b = __read(_a, 2), boundPos = _b[0], index = _b[1];\n        nextPoses.forEach(function(nextPos) {\n            var relativeRad1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([\n                0,\n                0\n            ], nextPos);\n            result.push.apply(result, __spreadArray([], __read(boundRotate(nextPos, boundPos, index).map(function(relativeRad2) {\n                return rad + relativeRad2 - relativeRad1;\n            }).filter(function(nextRad) {\n                return !isBoundRotate$1(prevPoses, boundRect, nextRad);\n            }).map(function(nextRad) {\n                return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(nextRad * 180 / Math.PI, TINY_NUM);\n            })), false));\n        });\n    });\n    return result;\n}\nvar VERTICAL_NAMES = [\n    \"left\",\n    \"right\",\n    \"center\"\n];\nvar HORIZONTAL_NAMES = [\n    \"top\",\n    \"bottom\",\n    \"middle\"\n];\nvar SNAP_SKIP_NAMES_MAP = {\n    \"left\": \"start\",\n    \"right\": \"end\",\n    \"center\": \"center\",\n    \"top\": \"start\",\n    \"bottom\": \"end\",\n    \"middle\": \"center\"\n};\nvar VERTICAL_NAMES_MAP = {\n    start: \"left\",\n    end: \"right\",\n    center: \"center\"\n};\nvar HORIZONTAL_NAMES_MAP = {\n    start: \"top\",\n    end: \"bottom\",\n    center: \"middle\"\n};\nfunction getInitialBounds() {\n    return {\n        left: false,\n        top: false,\n        right: false,\n        bottom: false\n    };\n}\nfunction hasGuidelines(moveable, ableName) {\n    var _a = moveable.props, snappable = _a.snappable, bounds = _a.bounds, innerBounds = _a.innerBounds, verticalGuidelines = _a.verticalGuidelines, horizontalGuidelines = _a.horizontalGuidelines, snapGridWidth = _a.snapGridWidth, snapGridHeight = _a.snapGridHeight, _b = moveable.state, guidelines = _b.guidelines, enableSnap = _b.enableSnap;\n    if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {\n        return false;\n    }\n    if (snapGridWidth || snapGridHeight || bounds || innerBounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {\n        return true;\n    }\n    return false;\n}\nfunction getSnapDirections(snapDirections) {\n    if (snapDirections === false) {\n        return {};\n    } else if (snapDirections === true || !snapDirections) {\n        return {\n            left: true,\n            right: true,\n            top: true,\n            bottom: true\n        };\n    }\n    return snapDirections;\n}\nfunction mapSnapDirectionPoses(snapDirections, snapPoses) {\n    var nextSnapDirections = getSnapDirections(snapDirections);\n    var nextSnapPoses = {};\n    for(var name_1 in nextSnapDirections){\n        if (name_1 in snapPoses && nextSnapDirections[name_1]) {\n            nextSnapPoses[name_1] = snapPoses[name_1];\n        }\n    }\n    return nextSnapPoses;\n}\nfunction splitSnapDirectionPoses(snapDirections, snapPoses) {\n    var nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);\n    var horizontalNames = HORIZONTAL_NAMES.filter(function(name) {\n        return name in nextSnapPoses;\n    });\n    var verticalNames = VERTICAL_NAMES.filter(function(name) {\n        return name in nextSnapPoses;\n    });\n    return {\n        horizontalNames: horizontalNames,\n        verticalNames: verticalNames,\n        horizontal: horizontalNames.map(function(name) {\n            return nextSnapPoses[name];\n        }),\n        vertical: verticalNames.map(function(name) {\n            return nextSnapPoses[name];\n        })\n    };\n}\nfunction calculateContainerPos(rootMatrix, containerRect, n) {\n    var clientPos = calculatePosition(rootMatrix, [\n        containerRect.clientLeft,\n        containerRect.clientTop\n    ], n);\n    return [\n        containerRect.left + clientPos[0],\n        containerRect.top + clientPos[1]\n    ];\n}\nfunction solveLineConstants(_a) {\n    var _b = __read(_a, 2), point1 = _b[0], point2 = _b[1];\n    var dx = point2[0] - point1[0];\n    var dy = point2[1] - point1[1];\n    if (Math.abs(dx) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\n        dy = 0;\n    }\n    // b > 0\n    // ax + by + c = 0\n    var a = 0;\n    var b = 0;\n    var c = 0;\n    if (!dx) {\n        // -x + 1 = 0\n        a = -1;\n        c = point1[0];\n    } else if (!dy) {\n        // y - 1 = 0\n        b = 1;\n        c = -point1[1];\n    } else {\n        // y = -a(x - x1) + y1\n        // ax + y + a * x1 - y1 = 0\n        a = -dy / dx;\n        b = 1;\n        c = a * point1[0] - point1[1];\n    }\n    return [\n        a,\n        b,\n        c\n    ].map(function(v) {\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(v, _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM);\n    });\n}\nvar NAME_snapRotationThreshold = \"snapRotationThreshold\";\nvar NAME_snapRotationDegrees = \"snapRotationDegrees\";\nvar NAME_snapHorizontalThreshold = \"snapHorizontalThreshold\";\nvar NAME_snapVerticalThreshold = \"snapVerticalThreshold\";\nfunction checkMoveableSnapPoses(moveable, posesX, posesY, dirXs, dirYs, customSnapVerticalThreshold, customSnapHorizontalThreshold) {\n    var _a;\n    if (dirXs === void 0) {\n        dirXs = [];\n    }\n    if (dirYs === void 0) {\n        dirYs = [];\n    }\n    var props = moveable.props;\n    var snapThresholdMultiples = ((_a = moveable.state.snapThresholdInfo) === null || _a === void 0 ? void 0 : _a.multiples) || [\n        1,\n        1\n    ];\n    var snapHorizontalThreshold = selectValue(customSnapHorizontalThreshold, props[NAME_snapHorizontalThreshold], 5);\n    var snapVerticalThreshold = selectValue(customSnapVerticalThreshold, props[NAME_snapVerticalThreshold], 5);\n    return checkSnapPoses(moveable.state.guidelines, posesX, posesY, dirXs, dirYs, snapHorizontalThreshold, snapVerticalThreshold, snapThresholdMultiples);\n}\nfunction checkSnapPoses(guidelines, posesX, posesY, dirXs, dirYs, snapHorizontalThreshold, snapVerticalThreshold, multiples) {\n    return {\n        vertical: checkSnap(guidelines, \"vertical\", posesX, snapVerticalThreshold * multiples[0], dirXs),\n        horizontal: checkSnap(guidelines, \"horizontal\", posesY, snapHorizontalThreshold * multiples[1], dirYs)\n    };\n}\nfunction checkSnapKeepRatio(moveable, startPos, endPos) {\n    var _a = __read(endPos, 2), endX = _a[0], endY = _a[1];\n    var _b = __read(startPos, 2), startX = _b[0], startY = _b[1];\n    var _c = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(endPos, startPos), 2), dx = _c[0], dy = _c[1];\n    var isBottom = dy > 0;\n    var isRight = dx > 0;\n    dx = getTinyDist(dx);\n    dy = getTinyDist(dy);\n    var verticalInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0\n    };\n    var horizontalInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo\n        };\n    }\n    var _d = checkMoveableSnapPoses(moveable, dx ? [\n        endX\n    ] : [], dy ? [\n        endY\n    ] : [], [], [], undefined, undefined), verticalSnapInfo = _d.vertical, horizontalSnapInfo = _d.horizontal;\n    verticalSnapInfo.posInfos.filter(function(_a) {\n        var pos = _a.pos;\n        return isRight ? pos >= startX : pos <= startX;\n    });\n    horizontalSnapInfo.posInfos.filter(function(_a) {\n        var pos = _a.pos;\n        return isBottom ? pos >= startY : pos <= startY;\n    });\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n    var _e = getNearestSnapGuidelineInfo(verticalSnapInfo), isVerticalSnap = _e.isSnap, verticalGuideline = _e.guideline;\n    var _f = getNearestSnapGuidelineInfo(horizontalSnapInfo), isHorizontalSnap = _f.isSnap, horizontalGuideline = _f.guideline;\n    var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;\n    var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;\n    if (dx === 0) {\n        if (isHorizontalSnap) {\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = horizontalGuideline.pos[1];\n            horizontalInfo.offset = endY - horizontalInfo.pos;\n        }\n    } else if (dy === 0) {\n        if (isVerticalSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = verticalPos;\n            verticalInfo.offset = endX - verticalPos;\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        var a = dy / dx;\n        var b = endPos[1] - a * endX;\n        var y = 0;\n        var x = 0;\n        var isSnap = false;\n        if (isVerticalSnap) {\n            x = verticalPos;\n            y = a * x + b;\n            isSnap = true;\n        } else if (isHorizontalSnap) {\n            y = horizontalPos;\n            x = (y - b) / a;\n            isSnap = true;\n        }\n        if (isSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo\n    };\n}\nfunction getStringDirection(dir) {\n    var stringDirection = \"\";\n    if (dir === -1 || dir === \"top\" || dir === \"left\") {\n        stringDirection = \"start\";\n    } else if (dir === 0 || dir === \"center\" || dir === \"middle\") {\n        stringDirection = \"center\";\n    } else if (dir === 1 || dir === \"right\" || dir === \"bottom\") {\n        stringDirection = \"end\";\n    }\n    return stringDirection;\n}\nfunction checkSnaps(moveable, rect, customSnapVerticalThreshold, customSnapHorizontalThreshold) {\n    var poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);\n    var result = checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal, poses.verticalNames.map(function(name) {\n        return getStringDirection(name);\n    }), poses.horizontalNames.map(function(name) {\n        return getStringDirection(name);\n    }), customSnapVerticalThreshold, customSnapHorizontalThreshold);\n    var horizontalDirection = getStringDirection(poses.horizontalNames[result.horizontal.index]);\n    var verticalDirection = getStringDirection(poses.verticalNames[result.vertical.index]);\n    return {\n        vertical: __assign(__assign({}, result.vertical), {\n            direction: verticalDirection\n        }),\n        horizontal: __assign(__assign({}, result.horizontal), {\n            direction: horizontalDirection\n        })\n    };\n}\nfunction getNearestSnapGuidelineInfo(snapInfo) {\n    var isSnap = snapInfo.isSnap;\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null\n        };\n    }\n    var posInfo = snapInfo.posInfos[0];\n    var guidelineInfo = posInfo.guidelineInfos[0];\n    var offset = guidelineInfo.offset;\n    var dist = guidelineInfo.dist;\n    var guideline = guidelineInfo.guideline;\n    return {\n        isSnap: isSnap,\n        offset: offset,\n        dist: dist,\n        pos: posInfo.pos,\n        guideline: guideline\n    };\n}\nfunction checkSnap(guidelines, targetType, targetPoses, snapThreshold, dirs) {\n    var _a, _b;\n    if (dirs === void 0) {\n        dirs = [];\n    }\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            index: -1,\n            direction: \"\",\n            posInfos: []\n        };\n    }\n    var isVertical = targetType === \"vertical\";\n    var posType = isVertical ? 0 : 1;\n    var snapPosInfos = targetPoses.map(function(targetPos, index) {\n        var direction = dirs[index] || \"\";\n        var guidelineInfos = guidelines.map(function(guideline) {\n            var pos = guideline.pos;\n            var offset = targetPos - pos[posType];\n            return {\n                offset: offset,\n                dist: abs(offset),\n                guideline: guideline,\n                direction: direction\n            };\n        }).filter(function(_a) {\n            var guideline = _a.guideline, dist = _a.dist;\n            var type = guideline.type;\n            if (type !== targetType || dist > snapThreshold) {\n                return false;\n            }\n            return true;\n        }).sort(function(a, b) {\n            return a.dist - b.dist;\n        });\n        return {\n            pos: targetPos,\n            index: index,\n            guidelineInfos: guidelineInfos,\n            direction: direction\n        };\n    }).filter(function(snapPosInfo) {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort(function(a, b) {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n    var isSnap = snapPosInfos.length > 0;\n    return {\n        isSnap: isSnap,\n        index: isSnap ? snapPosInfos[0].index : -1,\n        direction: (_b = (_a = snapPosInfos[0]) === null || _a === void 0 ? void 0 : _a.direction) !== null && _b !== void 0 ? _b : \"\",\n        posInfos: snapPosInfos\n    };\n}\nfunction getSnapInfosByDirection(moveable, // pos1 pos2 pos3 pos4\nposes, snapDirection, customSnapVerticalThreshold, customSnapHorizontalThreshold) {\n    var dirs = [];\n    if (snapDirection[0] && snapDirection[1]) {\n        dirs = [\n            snapDirection,\n            [\n                -snapDirection[0],\n                snapDirection[1]\n            ],\n            [\n                snapDirection[0],\n                -snapDirection[1]\n            ]\n        ];\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        [\n            [\n                -1,\n                -1\n            ],\n            [\n                1,\n                -1\n            ],\n            [\n                1,\n                1\n            ],\n            [\n                -1,\n                1\n            ]\n        ].forEach(function(dir, i, arr) {\n            var nextDir = arr[i + 1] || arr[0];\n            dirs.push(dir);\n            dirs.push([\n                (dir[0] + nextDir[0]) / 2,\n                (dir[1] + nextDir[1]) / 2\n            ]);\n        });\n    } else {\n        if (moveable.props.keepRatio) {\n            dirs.push([\n                -1,\n                -1\n            ], [\n                -1,\n                1\n            ], [\n                1,\n                -1\n            ], [\n                1,\n                1\n            ], snapDirection);\n        } else {\n            dirs.push.apply(dirs, __spreadArray([], __read(getPosesByDirection([\n                [\n                    -1,\n                    -1\n                ],\n                [\n                    1,\n                    -1\n                ],\n                [\n                    -1,\n                    -1\n                ],\n                [\n                    1,\n                    1\n                ]\n            ], snapDirection)), false));\n            if (dirs.length > 1) {\n                dirs.push([\n                    (dirs[0][0] + dirs[1][0]) / 2,\n                    (dirs[0][1] + dirs[1][1]) / 2\n                ]);\n            }\n        }\n    }\n    var nextPoses = dirs.map(function(dir) {\n        return getPosByDirection(poses, dir);\n    });\n    var xs = nextPoses.map(function(pos) {\n        return pos[0];\n    });\n    var ys = nextPoses.map(function(pos) {\n        return pos[1];\n    });\n    var result = checkMoveableSnapPoses(moveable, xs, ys, dirs.map(function(dir) {\n        return getStringDirection(dir[0]);\n    }), dirs.map(function(dir) {\n        return getStringDirection(dir[1]);\n    }), customSnapVerticalThreshold, customSnapHorizontalThreshold);\n    var verticalDirection = getStringDirection(dirs.map(function(dir) {\n        return dir[0];\n    })[result.vertical.index]);\n    var horizontalDirection = getStringDirection(dirs.map(function(dir) {\n        return dir[1];\n    })[result.horizontal.index]);\n    return {\n        vertical: __assign(__assign({}, result.vertical), {\n            direction: verticalDirection\n        }),\n        horizontal: __assign(__assign({}, result.horizontal), {\n            direction: horizontalDirection\n        })\n    };\n}\nfunction checkSnapBoundPriority(a, b) {\n    var aDist = abs(a.offset);\n    var bDist = abs(b.offset);\n    if (a.isBound && b.isBound) {\n        return bDist - aDist;\n    } else if (a.isBound) {\n        return -1;\n    } else if (b.isBound) {\n        return 1;\n    } else if (a.isSnap && b.isSnap) {\n        return bDist - aDist;\n    } else if (a.isSnap) {\n        return -1;\n    } else if (b.isSnap) {\n        return 1;\n    } else if (aDist < TINY_NUM) {\n        return 1;\n    } else if (bDist < TINY_NUM) {\n        return -1;\n    }\n    return aDist - bDist;\n}\nfunction getNearOffsetInfo(offsets, index) {\n    return offsets.slice().sort(function(a, b) {\n        var aSign = a.sign[index];\n        var bSign = b.sign[index];\n        var aOffset = a.offset[index];\n        var bOffset = b.offset[index];\n        // -1 The positions of a and b do not change.\n        // 1 The positions of a and b are reversed.\n        if (!aSign) {\n            return 1;\n        } else if (!bSign) {\n            return -1;\n        }\n        return checkSnapBoundPriority({\n            isBound: a.isBound,\n            isSnap: a.isSnap,\n            offset: aOffset\n        }, {\n            isBound: b.isBound,\n            isSnap: b.isSnap,\n            offset: bOffset\n        });\n    })[0];\n}\nfunction getCheckSnapDirections(direction, fixedDirection, keepRatio) {\n    var directions = [];\n    // const fixedDirection = [-direction[0], -direction[1]];\n    if (keepRatio) {\n        if (abs(fixedDirection[0]) !== 1 || abs(fixedDirection[1]) !== 1) {\n            directions.push([\n                fixedDirection,\n                [\n                    -1,\n                    -1\n                ]\n            ], [\n                fixedDirection,\n                [\n                    -1,\n                    1\n                ]\n            ], [\n                fixedDirection,\n                [\n                    1,\n                    -1\n                ]\n            ], [\n                fixedDirection,\n                [\n                    1,\n                    1\n                ]\n            ]);\n        } else {\n            directions.push([\n                fixedDirection,\n                [\n                    direction[0],\n                    -direction[1]\n                ]\n            ], [\n                fixedDirection,\n                [\n                    -direction[0],\n                    direction[1]\n                ]\n            ]);\n        }\n        directions.push([\n            fixedDirection,\n            direction\n        ]);\n    } else {\n        if (direction[0] && direction[1] || !direction[0] && !direction[1]) {\n            var endDirection_1 = direction[0] ? direction : [\n                1,\n                1\n            ];\n            [\n                1,\n                -1\n            ].forEach(function(signX) {\n                [\n                    1,\n                    -1\n                ].forEach(function(signY) {\n                    var nextDirection = [\n                        signX * endDirection_1[0],\n                        signY * endDirection_1[1]\n                    ];\n                    if (fixedDirection[0] === nextDirection[0] && fixedDirection[1] === nextDirection[1]) {\n                        return;\n                    }\n                    directions.push([\n                        fixedDirection,\n                        nextDirection\n                    ]);\n                });\n            });\n        } else if (direction[0]) {\n            var signs = abs(fixedDirection[0]) === 1 ? [\n                1\n            ] : [\n                1,\n                -1\n            ];\n            signs.forEach(function(sign) {\n                directions.push([\n                    [\n                        fixedDirection[0],\n                        -1\n                    ],\n                    [\n                        sign * direction[0],\n                        -1\n                    ]\n                ], [\n                    [\n                        fixedDirection[0],\n                        0\n                    ],\n                    [\n                        sign * direction[0],\n                        0\n                    ]\n                ], [\n                    [\n                        fixedDirection[0],\n                        1\n                    ],\n                    [\n                        sign * direction[0],\n                        1\n                    ]\n                ]);\n            });\n        } else if (direction[1]) {\n            var signs = abs(fixedDirection[1]) === 1 ? [\n                1\n            ] : [\n                1,\n                -1\n            ];\n            signs.forEach(function(sign) {\n                directions.push([\n                    [\n                        -1,\n                        fixedDirection[1]\n                    ],\n                    [\n                        -1,\n                        sign * direction[1]\n                    ]\n                ], [\n                    [\n                        0,\n                        fixedDirection[1]\n                    ],\n                    [\n                        0,\n                        sign * direction[1]\n                    ]\n                ], [\n                    [\n                        1,\n                        fixedDirection[1]\n                    ],\n                    [\n                        1,\n                        sign * direction[1]\n                    ]\n                ]);\n            });\n        }\n    }\n    return directions;\n}\nfunction isStartLine(dot, line) {\n    // l    o     => true\n    // o    l    => false\n    var cx = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.average)([\n        line[0][0],\n        line[1][0]\n    ]);\n    var cy = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.average)([\n        line[0][1],\n        line[1][1]\n    ]);\n    return {\n        vertical: cx <= dot[0],\n        horizontal: cy <= dot[1]\n    };\n}\nfunction hitTestLine(dot, _a) {\n    var _b = __read(_a, 2), pos1 = _b[0], pos2 = _b[1];\n    var dx = pos2[0] - pos1[0];\n    var dy = pos2[1] - pos1[1];\n    if (abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    var test1;\n    var test2;\n    if (!dx) {\n        test1 = pos1[0];\n        test2 = dot[0];\n    } else if (!dy) {\n        test1 = pos1[1];\n        test2 = dot[1];\n    } else {\n        var a = dy / dx;\n        // y = a * (x - pos1) + pos1\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\n        test2 = dot[1];\n    }\n    return test1 - test2;\n}\nfunction isSameStartLine(dots, line, centerSign, error) {\n    if (error === void 0) {\n        error = TINY_NUM;\n    }\n    return dots.every(function(dot) {\n        var value = hitTestLine(dot, line);\n        var sign = value <= 0;\n        return sign === centerSign || abs(value) <= error;\n    });\n}\nfunction checkInnerBoundDot(pos, start, end, isStart, threshold) {\n    if (threshold === void 0) {\n        threshold = 0;\n    }\n    if (isStart && start - threshold <= pos || !isStart && pos <= end + threshold) {\n        // false 402 565 602 => 37 ([0, 37])\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\n        // true 400 410 600 => 10 ([10, 0])\n        return {\n            isBound: true,\n            offset: isStart ? start - pos : end - pos\n        };\n    }\n    return {\n        isBound: false,\n        offset: 0\n    };\n}\nfunction checkInnerBound(moveable, _a) {\n    var line = _a.line, centerSign = _a.centerSign, verticalSign = _a.verticalSign, horizontalSign = _a.horizontalSign, lineConstants = _a.lineConstants;\n    var bounds = moveable.props.innerBounds;\n    if (!bounds) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [\n                0,\n                0\n            ]\n        };\n    }\n    var left = bounds.left, top = bounds.top, width = bounds.width, height = bounds.height;\n    var leftLine = [\n        [\n            left,\n            top\n        ],\n        [\n            left,\n            top + height\n        ]\n    ];\n    var topLine = [\n        [\n            left,\n            top\n        ],\n        [\n            left + width,\n            top\n        ]\n    ];\n    var rightLine = [\n        [\n            left + width,\n            top\n        ],\n        [\n            left + width,\n            top + height\n        ]\n    ];\n    var bottomLine = [\n        [\n            left,\n            top + height\n        ],\n        [\n            left + width,\n            top + height\n        ]\n    ];\n    if (isSameStartLine([\n        [\n            left,\n            top\n        ],\n        [\n            left + width,\n            top\n        ],\n        [\n            left,\n            top + height\n        ],\n        [\n            left + width,\n            top + height\n        ]\n    ], line, centerSign)) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [\n                0,\n                0\n            ]\n        };\n    }\n    // test vertical\n    var topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, verticalSign);\n    var bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, verticalSign);\n    // test horizontal\n    var leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, horizontalSign);\n    var rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, horizontalSign);\n    var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n    var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n    var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n    var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n    var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n    var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n    var offset = [\n        0,\n        0\n    ];\n    var isBound = false;\n    var isAllBound = false;\n    if (abs(horizontalOffset) < abs(verticalOffset)) {\n        offset = [\n            verticalOffset,\n            0\n        ];\n        isBound = isVerticalBound;\n        isAllBound = isAllVerticalBound;\n    } else {\n        offset = [\n            0,\n            horizontalOffset\n        ];\n        isBound = isHorizontalBound;\n        isAllBound = isAllHorizontalBound;\n    }\n    return {\n        isAllBound: isAllBound,\n        isVerticalBound: isVerticalBound,\n        isHorizontalBound: isHorizontalBound,\n        isBound: isBound,\n        offset: offset\n    };\n}\nfunction checkLineBoundCollision(line, _a, boundLine, isStart, threshold, isRender) {\n    var _b = __read(_a, 2), a = _b[0], b = _b[1];\n    var dot1 = line[0];\n    // const dot2 = line[1];\n    var boundDot1 = boundLine[0];\n    var boundDot2 = boundLine[1];\n    // const dy1 = getTinyDist(dot2[1] - dot1[1]);\n    // const dx1 = getTinyDist(dot2[0] - dot1[0]);\n    var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n    var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\n    var hasDx = b;\n    var hasDy = a;\n    var slope = -a / b;\n    // lineConstants\n    // ax + by + c = 0\n    // dx2 or dy2 is zero\n    if (!dx2) {\n        // vertical\n        // by + c = 0\n        if (isRender && !hasDy) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0\n            };\n        } else if (hasDx) {\n            // ax + by + c = 0\n            // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n            var y = slope * (boundDot1[0] - dot1[0]) + dot1[1];\n            // boundDot1[1] <= y  <= boundDot2[1]\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n        } else {\n            // ax + c = 0\n            var offset = boundDot1[0] - dot1[0];\n            var isBound = abs(offset) <= (threshold || 0);\n            return {\n                isBound: isBound,\n                offset: isBound ? offset : 0\n            };\n        }\n    } else if (!dy2) {\n        // horizontal\n        if (isRender && !hasDx) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0\n            };\n        } else if (hasDy) {\n            // y = a * (x - x1) + y1\n            // x = (y - y1) / a + x1\n            // const a = dy1 / dx1;\n            // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n            var x = (boundDot1[1] - dot1[1]) / slope + dot1[0];\n            // boundDot1[0] <= x && x <= boundDot2[0]\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n        } else {\n            var offset = boundDot1[1] - dot1[1];\n            var isBound = abs(offset) <= (threshold || 0);\n            return {\n                isBound: isBound,\n                offset: isBound ? offset : 0\n            };\n        }\n    }\n    return {\n        isBound: false,\n        offset: 0\n    };\n}\nfunction getInnerBoundInfo(moveable, lineInfos, datas) {\n    return lineInfos.map(function(info) {\n        var _a = checkInnerBound(moveable, info), isBound = _a.isBound, offset = _a.offset, isVerticalBound = _a.isVerticalBound, isHorizontalBound = _a.isHorizontalBound;\n        var multiple = info.multiple;\n        var sizeOffset = getDragDist({\n            datas: datas,\n            distX: offset[0],\n            distY: offset[1]\n        }).map(function(size, i) {\n            return size * (multiple[i] ? 2 / multiple[i] : 0);\n        });\n        return {\n            sign: multiple,\n            isBound: isBound,\n            isVerticalBound: isVerticalBound,\n            isHorizontalBound: isHorizontalBound,\n            isSnap: false,\n            offset: sizeOffset\n        };\n    });\n}\nfunction getInnerBoundDragInfo(moveable, poses, datas) {\n    var _a;\n    var lines = getCheckInnerBoundLineInfos(moveable, poses, [\n        0,\n        0\n    ], false).map(function(info) {\n        return __assign(__assign({}, info), {\n            multiple: info.multiple.map(function(dir) {\n                return abs(dir) * 2;\n            })\n        });\n    });\n    var innerBoundInfo = getInnerBoundInfo(moveable, lines, datas);\n    var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n    var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n    var verticalOffset = 0;\n    var horizontalOffset = 0;\n    var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n    var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n    if (isVerticalBound || isHorizontalBound) {\n        _a = __read(getInverseDragDist({\n            datas: datas,\n            distX: -widthOffsetInfo.offset[0],\n            distY: -heightOffsetInfo.offset[1]\n        }), 2), verticalOffset = _a[0], horizontalOffset = _a[1];\n    }\n    return {\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalOffset\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalOffset\n        }\n    };\n}\nfunction getCheckSnapLineDirections(direction, keepRatio) {\n    var lineDirections = [];\n    var x = direction[0];\n    var y = direction[1];\n    if (x && y) {\n        lineDirections.push([\n            [\n                0,\n                y * 2\n            ],\n            direction,\n            [\n                -x,\n                y\n            ]\n        ], [\n            [\n                x * 2,\n                0\n            ],\n            direction,\n            [\n                x,\n                -y\n            ]\n        ]);\n    } else if (x) {\n        // vertcal\n        lineDirections.push([\n            [\n                x * 2,\n                0\n            ],\n            [\n                x,\n                1\n            ],\n            [\n                x,\n                -1\n            ]\n        ]);\n        if (keepRatio) {\n            lineDirections.push([\n                [\n                    0,\n                    -1\n                ],\n                [\n                    x,\n                    -1\n                ],\n                [\n                    -x,\n                    -1\n                ]\n            ], [\n                [\n                    0,\n                    1\n                ],\n                [\n                    x,\n                    1\n                ],\n                [\n                    -x,\n                    1\n                ]\n            ]);\n        }\n    } else if (y) {\n        // horizontal\n        lineDirections.push([\n            [\n                0,\n                y * 2\n            ],\n            [\n                1,\n                y\n            ],\n            [\n                -1,\n                y\n            ]\n        ]);\n        if (keepRatio) {\n            lineDirections.push([\n                [\n                    -1,\n                    0\n                ],\n                [\n                    -1,\n                    y\n                ],\n                [\n                    -1,\n                    -y\n                ]\n            ], [\n                [\n                    1,\n                    0\n                ],\n                [\n                    1,\n                    y\n                ],\n                [\n                    1,\n                    -y\n                ]\n            ]);\n        }\n    } else {\n        // [0, 0] to all direction\n        lineDirections.push([\n            [\n                -1,\n                0\n            ],\n            [\n                -1,\n                -1\n            ],\n            [\n                -1,\n                1\n            ]\n        ], [\n            [\n                1,\n                0\n            ],\n            [\n                1,\n                -1\n            ],\n            [\n                1,\n                1\n            ]\n        ], [\n            [\n                0,\n                -1\n            ],\n            [\n                -1,\n                -1\n            ],\n            [\n                1,\n                -1\n            ]\n        ], [\n            [\n                0,\n                1\n            ],\n            [\n                -1,\n                1\n            ],\n            [\n                1,\n                1\n            ]\n        ]);\n    }\n    return lineDirections;\n}\nfunction getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio) {\n    var _a = moveable.state, allMatrix = _a.allMatrix, is3d = _a.is3d;\n    var virtualPoses = calculatePoses(allMatrix, 100, 100, is3d ? 4 : 3);\n    var center = getPosByDirection(virtualPoses, [\n        0,\n        0\n    ]);\n    return getCheckSnapLineDirections(direction, keepRatio).map(function(_a) {\n        var _b = __read(_a, 3), multiple = _b[0], dir1 = _b[1], dir2 = _b[2];\n        var virtualLine = [\n            getPosByDirection(virtualPoses, dir1),\n            getPosByDirection(virtualPoses, dir2)\n        ];\n        var lineConstants = solveLineConstants(virtualLine);\n        var _c = isStartLine(center, virtualLine), verticalSign = _c.vertical, horizontalSign = _c.horizontal;\n        var centerSign = hitTestLine(center, virtualLine) <= 0;\n        return {\n            multiple: multiple,\n            centerSign: centerSign,\n            verticalSign: verticalSign,\n            horizontalSign: horizontalSign,\n            lineConstants: lineConstants,\n            line: [\n                getPosByDirection(poses, dir1),\n                getPosByDirection(poses, dir2)\n            ]\n        };\n    });\n}\nfunction isBoundRotate(relativePoses, boundDots, center, rad) {\n    var nextPoses = rad ? relativePoses.map(function(pos) {\n        return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad);\n    }) : relativePoses;\n    return [\n        [\n            nextPoses[0],\n            nextPoses[1]\n        ],\n        [\n            nextPoses[1],\n            nextPoses[3]\n        ],\n        [\n            nextPoses[3],\n            nextPoses[2]\n        ],\n        [\n            nextPoses[2],\n            nextPoses[0]\n        ]\n    ].some(function(line) {\n        var centerSign = hitTestLine(center, line) <= 0;\n        return !isSameStartLine(boundDots, line, centerSign);\n    });\n}\nfunction getDistPointLine(_a) {\n    // x = 0, y = 0\n    // d = (ax + by + c) / root(a2 + b2)\n    var _b = __read(_a, 2), pos1 = _b[0], pos2 = _b[1];\n    var dx = pos2[0] - pos1[0];\n    var dy = pos2[1] - pos1[1];\n    if (!dx) {\n        return abs(pos1[0]);\n    }\n    if (!dy) {\n        return abs(pos1[1]);\n    }\n    // y - y1 = a(x - x1)\n    // 0 = ax -y + -a * x1 + y1\n    var a = dy / dx;\n    return abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine(_a) {\n    var _b = __read(_a, 2), pos1 = _b[0], pos2 = _b[1];\n    var dx = pos2[0] - pos1[0];\n    var dy = pos2[1] - pos1[1];\n    if (!dx) {\n        return [\n            pos1[0],\n            0\n        ];\n    }\n    if (!dy) {\n        return [\n            0,\n            pos1[1]\n        ];\n    }\n    var a = dy / dx;\n    // y - y1 = a (x  - x1)\n    // y = ax - a * x1 + y1\n    var b = -a * pos1[0] + pos1[1];\n    // y = ax + b = -1/a x\n    // x = -b / (a + 1 / a)\n    // y = b / (1 + 1 / a^2)\n    return [\n        -b / (a + 1 / a),\n        b / (a * a + 1)\n    ];\n}\nfunction checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {\n    var bounds = moveable.props.innerBounds;\n    var rad = rotation * Math.PI / 180;\n    if (!bounds) {\n        return [];\n    }\n    var left = bounds.left, top = bounds.top, width = bounds.width, height = bounds.height;\n    var relativeLeft = left - origin[0];\n    var relativeRight = left + width - origin[0];\n    var relativeTop = top - origin[1];\n    var relativeBottom = top + height - origin[1];\n    var dots = [\n        [\n            relativeLeft,\n            relativeTop\n        ],\n        [\n            relativeRight,\n            relativeTop\n        ],\n        [\n            relativeLeft,\n            relativeBottom\n        ],\n        [\n            relativeRight,\n            relativeBottom\n        ]\n    ];\n    var center = getPosByDirection(nextPoses, [\n        0,\n        0\n    ]);\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\n        return [];\n    }\n    var result = [];\n    var dotInfos = dots.map(function(dot) {\n        return [\n            getDistSize(dot),\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([\n                0,\n                0\n            ], dot)\n        ];\n    });\n    [\n        [\n            nextPoses[0],\n            nextPoses[1]\n        ],\n        [\n            nextPoses[1],\n            nextPoses[3]\n        ],\n        [\n            nextPoses[3],\n            nextPoses[2]\n        ],\n        [\n            nextPoses[2],\n            nextPoses[0]\n        ]\n    ].forEach(function(line) {\n        var lineRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([\n            0,\n            0\n        ], solveReverseLine(line));\n        var lineDist = getDistPointLine(line);\n        result.push.apply(result, __spreadArray([], __read(dotInfos.filter(function(_a) {\n            var _b = __read(_a, 1), dotDist = _b[0];\n            return dotDist && lineDist <= dotDist;\n        }).map(function(_a) {\n            var _b = __read(_a, 2), dotDist = _b[0], dotRad = _b[1];\n            var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n            var nextRad1 = dotRad + distRad;\n            var nextRad2 = dotRad - distRad;\n            return [\n                rad + nextRad1 - lineRad,\n                rad + nextRad2 - lineRad\n            ];\n        }).reduce(function(prev, cur) {\n            prev.push.apply(prev, __spreadArray([], __read(cur), false));\n            return prev;\n        }, []).filter(function(nextRad) {\n            return !isBoundRotate(prevPoses, dots, center, nextRad);\n        }).map(function(nextRad) {\n            return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(nextRad * 180 / Math.PI, TINY_NUM);\n        })), false));\n    });\n    return result;\n}\nfunction checkInnerBoundPoses(moveable) {\n    var innerBounds = moveable.props.innerBounds;\n    var boundMap = getInitialBounds();\n    if (!innerBounds) {\n        return {\n            boundMap: boundMap,\n            vertical: [],\n            horizontal: []\n        };\n    }\n    var _a = moveable.getRect(), pos1 = _a.pos1, pos2 = _a.pos2, pos3 = _a.pos3, pos4 = _a.pos4;\n    var poses = [\n        pos1,\n        pos2,\n        pos3,\n        pos4\n    ];\n    var center = getPosByDirection(poses, [\n        0,\n        0\n    ]);\n    var left = innerBounds.left, top = innerBounds.top, width = innerBounds.width, height = innerBounds.height;\n    var leftLine = [\n        [\n            left,\n            top\n        ],\n        [\n            left,\n            top + height\n        ]\n    ];\n    var topLine = [\n        [\n            left,\n            top\n        ],\n        [\n            left + width,\n            top\n        ]\n    ];\n    var rightLine = [\n        [\n            left + width,\n            top\n        ],\n        [\n            left + width,\n            top + height\n        ]\n    ];\n    var bottomLine = [\n        [\n            left,\n            top + height\n        ],\n        [\n            left + width,\n            top + height\n        ]\n    ];\n    var lineInfos = getCheckInnerBoundLineInfos(moveable, poses, [\n        0,\n        0\n    ], false);\n    var horizontalPoses = [];\n    var verticalPoses = [];\n    lineInfos.forEach(function(lineInfo) {\n        var line = lineInfo.line, lineConstants = lineInfo.lineConstants;\n        var _a = isStartLine(center, line), isHorizontalStart = _a.horizontal, isVerticalStart = _a.vertical;\n        // test vertical\n        var topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, isVerticalStart, 1, true);\n        var bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, isVerticalStart, 1, true);\n        // test horizontal\n        var leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, isHorizontalStart, 1, true);\n        var rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, isHorizontalStart, 1, true);\n        if (topBoundInfo.isBound && !boundMap.top) {\n            horizontalPoses.push(top);\n            boundMap.top = true;\n        }\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\n            horizontalPoses.push(top + height);\n            boundMap.bottom = true;\n        }\n        if (leftBoundInfo.isBound && !boundMap.left) {\n            verticalPoses.push(left);\n            boundMap.left = true;\n        }\n        if (rightBoundInfo.isBound && !boundMap.right) {\n            verticalPoses.push(left + width);\n            boundMap.right = true;\n        }\n    });\n    return {\n        boundMap: boundMap,\n        horizontal: horizontalPoses,\n        vertical: verticalPoses\n    };\n}\nfunction solveEquation(pos1, pos2, snapOffset, isVertical) {\n    var dx = pos2[0] - pos1[0];\n    var dy = pos2[1] - pos1[1];\n    if (abs(dx) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\n        dx = 0;\n    }\n    if (abs(dy) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [\n                0,\n                snapOffset\n            ];\n        }\n        return [\n            0,\n            0\n        ];\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [\n                snapOffset,\n                0\n            ];\n        }\n        return [\n            0,\n            0\n        ];\n    }\n    // y = ax + b\n    var a = dy / dx;\n    var b = pos1[1] - a * pos1[0];\n    if (isVertical) {\n        // y = a * x + b\n        var y = a * (pos2[0] + snapOffset) + b;\n        return [\n            snapOffset,\n            y - pos2[1]\n        ];\n    } else {\n        // x = (y - b) / a\n        var x = (pos2[1] + snapOffset - b) / a;\n        return [\n            x - pos2[0],\n            snapOffset\n        ];\n    }\n}\nfunction solveNextOffset(pos1, pos2, offset, isVertical, datas) {\n    var sizeOffset = solveEquation(pos1, pos2, offset, isVertical);\n    if (!sizeOffset) {\n        return {\n            isOutside: false,\n            offset: [\n                0,\n                0\n            ]\n        };\n    }\n    var size = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(pos1, pos2);\n    var dist1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(sizeOffset, pos1);\n    var dist2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(sizeOffset, pos2);\n    var isOutside = dist1 > size || dist2 > size;\n    var _a = __read(getDragDist({\n        datas: datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1]\n    }), 2), widthOffset = _a[0], heightOffset = _a[1];\n    return {\n        offset: [\n            widthOffset,\n            heightOffset\n        ],\n        isOutside: isOutside\n    };\n}\nfunction getSnapBound(boundInfo, snapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\n    }\n    return 0;\n}\nfunction checkThrottleDragRotate(throttleDragRotate, _a, _b, _c, _d) {\n    var _e = __read(_a, 2), distX = _e[0], distY = _e[1];\n    var _f = __read(_b, 2), isVerticalBound = _f[0], isHorizontalBound = _f[1];\n    var _g = __read(_c, 2), isVerticalSnap = _g[0], isHorizontalSnap = _g[1];\n    var _h = __read(_d, 2), verticalOffset = _h[0], horizontalOffset = _h[1];\n    var offsetX = -verticalOffset;\n    var offsetY = -horizontalOffset;\n    if (throttleDragRotate && distX && distY) {\n        offsetX = 0;\n        offsetY = 0;\n        var adjustPoses = [];\n        if (isVerticalBound && isHorizontalBound) {\n            adjustPoses.push([\n                0,\n                horizontalOffset\n            ], [\n                verticalOffset,\n                0\n            ]);\n        } else if (isVerticalBound) {\n            adjustPoses.push([\n                verticalOffset,\n                0\n            ]);\n        } else if (isHorizontalBound) {\n            adjustPoses.push([\n                0,\n                horizontalOffset\n            ]);\n        } else if (isVerticalSnap && isHorizontalSnap) {\n            adjustPoses.push([\n                0,\n                horizontalOffset\n            ], [\n                verticalOffset,\n                0\n            ]);\n        } else if (isVerticalSnap) {\n            adjustPoses.push([\n                verticalOffset,\n                0\n            ]);\n        } else if (isHorizontalSnap) {\n            adjustPoses.push([\n                0,\n                horizontalOffset\n            ]);\n        }\n        if (adjustPoses.length) {\n            adjustPoses.sort(function(a, b) {\n                return getDistSize((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([\n                    distX,\n                    distY\n                ], a)) - getDistSize((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([\n                    distX,\n                    distY\n                ], b));\n            });\n            var adjustPos = adjustPoses[0];\n            if (adjustPos[0] && abs(distX) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\n                offsetX = -adjustPos[0];\n                offsetY = distY * abs(distX + offsetX) / abs(distX) - distY;\n            } else if (adjustPos[1] && abs(distY) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\n                var prevDistY = distY;\n                offsetY = -adjustPos[1];\n                offsetX = distX * abs(distY + offsetY) / abs(prevDistY) - distX;\n            }\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n                if (abs(offsetX) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM && abs(offsetX) < abs(verticalOffset)) {\n                    var scale = abs(verticalOffset) / abs(offsetX);\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else if (abs(offsetY) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM && abs(offsetY) < abs(horizontalOffset)) {\n                    var scale = abs(horizontalOffset) / abs(offsetY);\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else {\n                    offsetX = maxOffset(-verticalOffset, offsetX);\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\n                }\n            }\n        }\n    } else {\n        offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n        offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n    }\n    return [\n        offsetX,\n        offsetY\n    ];\n}\nfunction checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, ignoreSnap, datas) {\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0\n            },\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0\n            }\n        ];\n    }\n    var poses = getAbsolutePoses(datas.absolutePoses, [\n        distX,\n        distY\n    ]);\n    var _a = getRect(poses), left = _a.left, right = _a.right, top = _a.top, bottom = _a.bottom;\n    var boundPoses = {\n        horizontal: poses.map(function(pos) {\n            return pos[1];\n        }),\n        vertical: poses.map(function(pos) {\n            return pos[0];\n        })\n    };\n    var snapDirections = getSnapDirections(moveable.props.snapDirections);\n    var snapPoses = splitSnapDirectionPoses(snapDirections, {\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom,\n        center: (left + right) / 2,\n        middle: (top + bottom) / 2\n    });\n    var _b = checkMoveableSnapBounds(moveable, ignoreSnap, snapPoses, boundPoses), verticalSnapBoundInfo = _b.vertical, horizontalSnapBoundInfo = _b.horizontal;\n    var _c = getInnerBoundDragInfo(moveable, poses, datas), verticalInnerBoundInfo = _c.vertical, horizontalInnerBoundInfo = _c.horizontal;\n    var isVerticalSnap = verticalSnapBoundInfo.isSnap;\n    var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n    var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n    var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n    var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);\n    var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);\n    var _d = __read(checkThrottleDragRotate(throttleDragRotate, [\n        distX,\n        distY\n    ], [\n        isVerticalBound,\n        isHorizontalBound\n    ], [\n        isVerticalSnap,\n        isHorizontalSnap\n    ], [\n        verticalOffset,\n        horizontalOffset\n    ]), 2), offsetX = _d[0], offsetY = _d[1];\n    return [\n        {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            offset: offsetX\n        },\n        {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            offset: offsetY\n        }\n    ];\n}\nfunction checkMoveableSnapBounds(moveable, ignoreSnap, poses, boundPoses) {\n    if (boundPoses === void 0) {\n        boundPoses = poses;\n    }\n    var _a = checkBoundPoses(getBounds(moveable), boundPoses.vertical, boundPoses.horizontal), horizontalBoundInfos = _a.horizontal, verticalBoundInfos = _a.vertical;\n    var _b = ignoreSnap ? {\n        horizontal: {\n            isSnap: false,\n            index: -1\n        },\n        vertical: {\n            isSnap: false,\n            index: -1\n        }\n    } : checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal, undefined, undefined, undefined, undefined), horizontalSnapInfo = _b.horizontal, verticalSnapInfo = _b.vertical;\n    var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);\n    var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);\n    var horizontalDist = abs(horizontalOffset);\n    var verticalDist = abs(verticalOffset);\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo\n        }\n    };\n}\nfunction checkSnapBounds(guideines, bounds, posesX, posesY, snapHorizontalThreshold, snapVerticalThreshold, multiples) {\n    if (multiples === void 0) {\n        multiples = [\n            1,\n            1\n        ];\n    }\n    var _a = checkBoundPoses(bounds, posesX, posesY), horizontalBoundInfos = _a.horizontal, verticalBoundInfos = _a.vertical;\n    // options.isRequest ? {\n    //     horizontal: { isSnap: false, index: -1 } as SnapInfo,\n    //     vertical: { isSnap: false, index: -1 } as SnapInfo,\n    // } :\n    var _b = checkSnapPoses(guideines, posesX, posesY, [], [], snapHorizontalThreshold, snapVerticalThreshold, multiples), horizontalSnapInfo = _b.horizontal, verticalSnapInfo = _b.vertical;\n    var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);\n    var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);\n    var horizontalDist = abs(horizontalOffset);\n    var verticalDist = abs(verticalOffset);\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo\n        }\n    };\n}\nfunction checkSnapRightLine(startPos, endPos, snapBoundInfo, keepRatio) {\n    var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(startPos, endPos) / Math.PI * 180;\n    var _a = snapBoundInfo.vertical, isVerticalBound = _a.isBound, isVerticalSnap = _a.isSnap, verticalDist = _a.dist, _b = snapBoundInfo.horizontal, isHorizontalBound = _b.isBound, isHorizontalSnap = _b.isSnap, horizontalDist = _b.dist;\n    var rad180 = rad % 180;\n    var isHorizontalLine = rad180 < 3 || rad180 > 177;\n    var isVerticalLine = rad180 > 87 && rad180 < 93;\n    if (horizontalDist < verticalDist) {\n        if (isVerticalBound || isVerticalSnap && !isVerticalLine && (!keepRatio || !isHorizontalLine)) {\n            return \"vertical\";\n        }\n    }\n    if (isHorizontalBound || isHorizontalSnap && !isHorizontalLine && (!keepRatio || !isVerticalLine)) {\n        return \"horizontal\";\n    }\n    return \"\";\n}\nfunction getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {\n    return directions.map(function(_a) {\n        var _b = __read(_a, 2), startDirection = _b[0], endDirection = _b[1];\n        var otherStartPos = getPosByDirection(poses, startDirection);\n        var otherEndPos = getPosByDirection(poses, endDirection);\n        var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest) : checkMoveableSnapBounds(moveable, isRequest, {\n            vertical: [\n                otherEndPos[0]\n            ],\n            horizontal: [\n                otherEndPos[1]\n            ]\n        });\n        var _c = snapBoundInfo.horizontal, // dist: otherHorizontalDist,\n        otherHorizontalOffset = _c.offset, isOtherHorizontalBound = _c.isBound, isOtherHorizontalSnap = _c.isSnap, _d = snapBoundInfo.vertical, // dist: otherVerticalDist,\n        otherVerticalOffset = _d.offset, isOtherVerticalBound = _d.isBound, isOtherVerticalSnap = _d.isSnap;\n        var multiple = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(endDirection, startDirection);\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\n            return {\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n                sign: multiple,\n                offset: [\n                    0,\n                    0\n                ]\n            };\n        }\n        var snapLine = checkSnapRightLine(otherStartPos, otherEndPos, snapBoundInfo, keepRatio);\n        if (!snapLine) {\n            return {\n                sign: multiple,\n                isBound: false,\n                isSnap: false,\n                offset: [\n                    0,\n                    0\n                ]\n            };\n        }\n        var isVertical = snapLine === \"vertical\";\n        var sizeOffset = [\n            0,\n            0\n        ];\n        if (!keepRatio && abs(endDirection[0]) === 1 && abs(endDirection[1]) === 1 && startDirection[0] !== endDirection[0] && startDirection[1] !== endDirection[1]) {\n            sizeOffset = getDragDist({\n                datas: datas,\n                distX: -otherVerticalOffset,\n                distY: -otherHorizontalOffset\n            });\n        } else {\n            sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).offset;\n        }\n        sizeOffset = sizeOffset.map(function(size, i) {\n            return size * (multiple[i] ? 2 / multiple[i] : 0);\n        });\n        return {\n            sign: multiple,\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n            offset: sizeOffset\n        };\n    });\n}\nfunction getSnapBoundOffset(boundInfo, snapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return snapInfo.offset;\n    }\n    return 0;\n}\nfunction checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {\n    var _a = checkBoundKeepRatio(moveable, startPos, endPos), horizontalBoundInfo = _a.horizontal, verticalBoundInfo = _a.vertical;\n    var _b = isRequest ? {\n        horizontal: {\n            isSnap: false\n        },\n        vertical: {\n            isSnap: false\n        }\n    } : checkSnapKeepRatio(moveable, startPos, endPos), horizontalSnapInfo = _b.horizontal, verticalSnapInfo = _b.vertical;\n    var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);\n    var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);\n    var horizontalDist = abs(horizontalOffset);\n    var verticalDist = abs(verticalOffset);\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist\n        }\n    };\n}\nfunction checkMaxBounds(moveable, poses, direction, fixedPosition, datas) {\n    var fixedDirection = [\n        -direction[0],\n        -direction[1]\n    ];\n    var _a = moveable.state, width = _a.width, height = _a.height;\n    var bounds = moveable.props.bounds;\n    var maxWidth = Infinity;\n    var maxHeight = Infinity;\n    if (bounds) {\n        var directions = [\n            [\n                direction[0],\n                -direction[1]\n            ],\n            [\n                -direction[0],\n                direction[1]\n            ]\n        ];\n        var _b = bounds.left, left_1 = _b === void 0 ? -Infinity : _b, _c = bounds.top, top_1 = _c === void 0 ? -Infinity : _c, _d = bounds.right, right_1 = _d === void 0 ? Infinity : _d, _e = bounds.bottom, bottom_1 = _e === void 0 ? Infinity : _e;\n        directions.forEach(function(otherDirection) {\n            var isCheckVertical = otherDirection[0] !== fixedDirection[0];\n            var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n            var otherPos = getPosByDirection(poses, otherDirection);\n            var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(fixedPosition, otherPos) * 360 / Math.PI;\n            if (isCheckHorizontal) {\n                var nextOtherPos = otherPos.slice();\n                if (abs(deg - 360) < 2 || abs(deg - 180) < 2) {\n                    nextOtherPos[1] = fixedPosition[1];\n                }\n                var _a = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas), _b = __read(_a.offset, 2), heightOffset = _b[1], isHeightOutside = _a.isOutside;\n                if (!isNaN(heightOffset)) {\n                    maxHeight = height + (isHeightOutside ? 1 : -1) * abs(heightOffset);\n                }\n            }\n            if (isCheckVertical) {\n                var nextOtherPos = otherPos.slice();\n                if (abs(deg - 90) < 2 || abs(deg - 270) < 2) {\n                    nextOtherPos[0] = fixedPosition[0];\n                }\n                var _c = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas), _d = __read(_c.offset, 1), widthOffset = _d[0], isWidthOutside = _c.isOutside;\n                if (!isNaN(widthOffset)) {\n                    maxWidth = width + (isWidthOutside ? 1 : -1) * abs(widthOffset);\n                }\n            }\n        });\n    }\n    return {\n        maxWidth: maxWidth,\n        maxHeight: maxHeight\n    };\n}\n/**\r\n * @namespace Draggable\r\n * @memberof Moveable\r\n * @description Draggable refers to the ability to drag and move targets.\r\n */ var Draggable = {\n    name: \"draggable\",\n    props: [\n        \"draggable\",\n        \"throttleDrag\",\n        \"throttleDragRotate\",\n        \"hideThrottleDragRotateLine\",\n        \"startDragRotate\",\n        \"edgeDraggable\"\n    ],\n    events: [\n        \"dragStart\",\n        \"drag\",\n        \"dragEnd\",\n        \"dragGroupStart\",\n        \"dragGroup\",\n        \"dragGroupEnd\"\n    ],\n    requestStyle: function() {\n        return [\n            \"left\",\n            \"top\",\n            \"right\",\n            \"bottom\"\n        ];\n    },\n    requestChildStyle: function() {\n        return [\n            \"left\",\n            \"top\",\n            \"right\",\n            \"bottom\"\n        ];\n    },\n    render: function(moveable, React) {\n        var _a = moveable.props, hideThrottleDragRotateLine = _a.hideThrottleDragRotateLine, throttleDragRotate = _a.throttleDragRotate, zoom = _a.zoom;\n        var _b = moveable.getState(), dragInfo = _b.dragInfo, beforeOrigin = _b.beforeOrigin;\n        if (hideThrottleDragRotateLine || !throttleDragRotate || !dragInfo) {\n            return [];\n        }\n        var dist = dragInfo.dist;\n        if (!dist[0] && !dist[1]) {\n            return [];\n        }\n        var width = getDistSize(dist);\n        var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(dist, [\n            0,\n            0\n        ]);\n        return [\n            React.createElement(\"div\", {\n                className: prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\"),\n                key: \"dragRotateGuideline\",\n                style: {\n                    width: \"\".concat(width, \"px\"),\n                    transform: \"translate(\".concat(beforeOrigin[0], \"px, \").concat(beforeOrigin[1], \"px) rotate(\").concat(rad, \"rad) scaleY(\").concat(zoom, \")\")\n                }\n            })\n        ];\n    },\n    dragStart: function(moveable, e) {\n        var datas = e.datas, parentEvent = e.parentEvent, parentGesto = e.parentGesto;\n        var state = moveable.state;\n        var gestos = state.gestos, style = state.style;\n        if (gestos.draggable) {\n            return false;\n        }\n        gestos.draggable = parentGesto || moveable.targetGesto;\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.startValue = [\n            0,\n            0\n        ];\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(moveable, e, \"translate\");\n        startCheckSnapDrag(moveable, datas);\n        datas.prevDist = [\n            0,\n            0\n        ];\n        datas.prevBeforeDist = [\n            0,\n            0\n        ];\n        datas.isDrag = false;\n        datas.deltaOffset = [\n            0,\n            0\n        ];\n        var params = fillParams(moveable, e, __assign({\n            set: function(translate) {\n                datas.startValue = translate;\n            }\n        }, fillTransformStartEvent(moveable, e)));\n        var result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [\n                    0,\n                    0\n                ]\n            };\n        } else {\n            gestos.draggable = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag: function(moveable, e) {\n        if (!e) {\n            return;\n        }\n        resolveTransformEvent(moveable, e, \"translate\");\n        var datas = e.datas, parentEvent = e.parentEvent, parentFlag = e.parentFlag, isPinch = e.isPinch, deltaOffset = e.deltaOffset, useSnap = e.useSnap, isRequest = e.isRequest, isGroup = e.isGroup, parentThrottleDrag = e.parentThrottleDrag;\n        var distX = e.distX, distY = e.distY;\n        var isDrag = datas.isDrag, prevDist = datas.prevDist, prevBeforeDist = datas.prevBeforeDist, startValue = datas.startValue;\n        if (!isDrag) {\n            return;\n        }\n        if (deltaOffset) {\n            distX += deltaOffset[0];\n            distY += deltaOffset[1];\n        }\n        var props = moveable.props;\n        var parentMoveable = props.parentMoveable;\n        var throttleDrag = isGroup ? 0 : props.throttleDrag || parentThrottleDrag || 0;\n        var throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;\n        var dragRotateRad = 0;\n        var isVerticalSnap = false;\n        var isVerticalBound = false;\n        var isHorizontalSnap = false;\n        var isHorizontalBound = false;\n        if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n            var startDragRotate = props.startDragRotate || 0;\n            var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(startDragRotate + (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([\n                0,\n                0\n            ], [\n                distX,\n                distY\n            ]) * 180 / Math.PI, throttleDragRotate) - startDragRotate;\n            var ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n            var rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n            var r = getDistSize([\n                rx,\n                ry\n            ]);\n            dragRotateRad = deg * Math.PI / 180;\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n        if (!isPinch && !parentEvent && !parentFlag) {\n            var _a = __read(checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, !useSnap && isRequest || deltaOffset, datas), 2), verticalInfo = _a[0], horizontalInfo = _a[1];\n            isVerticalSnap = verticalInfo.isSnap;\n            isVerticalBound = verticalInfo.isBound;\n            isHorizontalSnap = horizontalInfo.isSnap;\n            isHorizontalBound = horizontalInfo.isBound;\n            var verticalOffset = verticalInfo.offset;\n            var horizontalOffset = horizontalInfo.offset;\n            distX += verticalOffset;\n            distY += horizontalOffset;\n        }\n        var beforeTranslate = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(getBeforeDragDist({\n            datas: datas,\n            distX: distX,\n            distY: distY\n        }), startValue);\n        var translate = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(getTransformDist({\n            datas: datas,\n            distX: distX,\n            distY: distY\n        }), startValue);\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttleArray)(translate, TINY_NUM);\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttleArray)(beforeTranslate, TINY_NUM);\n        if (!throttleDragRotate) {\n            if (!isVerticalSnap && !isVerticalBound) {\n                translate[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(translate[0], throttleDrag);\n                beforeTranslate[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(beforeTranslate[0], throttleDrag);\n            }\n            if (!isHorizontalSnap && !isHorizontalBound) {\n                translate[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(translate[1], throttleDrag);\n                beforeTranslate[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(beforeTranslate[1], throttleDrag);\n            }\n        }\n        var beforeDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(beforeTranslate, startValue);\n        var dist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(translate, startValue);\n        var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, prevDist);\n        var beforeDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(beforeDist, prevBeforeDist);\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n        datas.passDelta = delta; //distX - (datas.passDistX || 0);\n        // datas.passDeltaY = distY - (datas.passDistY || 0);\n        datas.passDist = dist; //distX;\n        // datas.passDistY = distY;\n        var left = datas.left + beforeDist[0];\n        var top = datas.top + beforeDist[1];\n        var right = datas.right - beforeDist[0];\n        var bottom = datas.bottom - beforeDist[1];\n        var nextTransform = convertTransformFormat(datas, \"translate(\".concat(translate[0], \"px, \").concat(translate[1], \"px)\"), \"translate(\".concat(dist[0], \"px, \").concat(dist[1], \"px)\"));\n        fillOriginalTransform(e, nextTransform);\n        moveable.state.dragInfo.dist = parentEvent ? [\n            0,\n            0\n        ] : dist;\n        if (!parentEvent && !parentMoveable && delta.every(function(num) {\n            return !num;\n        }) && beforeDelta.some(function(num) {\n            return !num;\n        })) {\n            return;\n        }\n        var _b = moveable.state, width = _b.width, height = _b.height;\n        var params = fillParams(moveable, e, __assign({\n            transform: nextTransform,\n            dist: dist,\n            delta: delta,\n            translate: translate,\n            beforeDist: beforeDist,\n            beforeDelta: beforeDelta,\n            beforeTranslate: beforeTranslate,\n            left: left,\n            top: top,\n            right: right,\n            bottom: bottom,\n            width: width,\n            height: height,\n            isPinch: isPinch\n        }, fillCSSObject({\n            transform: nextTransform\n        }, e)));\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragAfter: function(moveable, e) {\n        var datas = e.datas;\n        var deltaOffset = datas.deltaOffset;\n        if (deltaOffset[0] || deltaOffset[1]) {\n            datas.deltaOffset = [\n                0,\n                0\n            ];\n            return this.drag(moveable, __assign(__assign({}, e), {\n                deltaOffset: deltaOffset\n            }));\n        }\n        return false;\n    },\n    dragEnd: function(moveable, e) {\n        var parentEvent = e.parentEvent, datas = e.datas;\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        var param = fillEndParams(moveable, e, {});\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", param);\n        return param;\n    },\n    dragGroupStart: function(moveable, e) {\n        var _a, _b;\n        var datas = e.datas, clientX = e.clientX, clientY = e.clientY;\n        var params = this.dragStart(moveable, e);\n        if (!params) {\n            return false;\n        }\n        var _c = triggerChildGesto(moveable, this, \"dragStart\", [\n            clientX || 0,\n            clientY || 0\n        ], e, false, \"draggable\"), childEvents = _c.childEvents, eventParams = _c.eventParams;\n        var nextParams = __assign(__assign({}, params), {\n            targets: moveable.props.targets,\n            events: eventParams\n        });\n        var result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n        datas.isDrag = result !== false;\n        // find data.startValue and based on first child moveable\n        var startValue = (_b = (_a = childEvents[0]) === null || _a === void 0 ? void 0 : _a.datas.startValue) !== null && _b !== void 0 ? _b : [\n            0,\n            0\n        ];\n        datas.throttleOffset = [\n            startValue[0] % 1,\n            startValue[1] % 1\n        ];\n        return datas.isDrag ? params : false;\n    },\n    dragGroup: function(moveable, e) {\n        var datas = e.datas;\n        if (!datas.isDrag) {\n            return;\n        }\n        var params = this.drag(moveable, __assign(__assign({}, e), {\n            parentThrottleDrag: moveable.props.throttleDrag\n        }));\n        var passDelta = e.datas.passDelta;\n        var eventParams = triggerChildGesto(moveable, this, \"drag\", passDelta, e, false, \"draggable\").eventParams;\n        if (!params) {\n            return;\n        }\n        var nextParams = __assign({\n            targets: moveable.props.targets,\n            events: eventParams\n        }, params);\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd: function(moveable, e) {\n        var isDrag = e.isDrag, datas = e.datas;\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        var eventParams = triggerChildGesto(moveable, this, \"dragEnd\", [\n            0,\n            0\n        ], e, false, \"draggable\").eventParams;\n        triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams(moveable, e, {\n            targets: moveable.props.targets,\n            events: eventParams\n        }));\n        return isDrag;\n    },\n    /**\r\n     * @method Moveable.Draggable#request\r\n     * @param {object} [e] - the draggable's request parameter\r\n     * @param {number} [e.x] - x position\r\n     * @param {number} [e.y] - y position\r\n     * @param {number} [e.deltaX] - X number to move\r\n     * @param {number} [e.deltaY] - Y number to move\r\n     * @return {Moveable.Requester} Moveable Requester\r\n     * @example\r\n\n     * // Instantly Request (requestStart - request - requestEnd)\r\n     * // Use Relative Value\r\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\r\n     * // Use Absolute Value\r\n     * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\r\n     *\r\n     * // requestStart\r\n     * const requester = moveable.request(\"draggable\");\r\n     *\r\n     * // request\r\n     * // Use Relative Value\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * // Use Absolute Value\r\n     * moveable.request(\"draggable\", { x: 200, y: 100 });\r\n     * moveable.request(\"draggable\", { x: 220, y: 100 });\r\n     * moveable.request(\"draggable\", { x: 240, y: 100 });\r\n     *\r\n     * // requestEnd\r\n     * requester.requestEnd();\r\n     */ request: function(moveable) {\n        var datas = {};\n        var rect = moveable.getRect();\n        var distX = 0;\n        var distY = 0;\n        var useSnap = false;\n        return {\n            isControl: false,\n            requestStart: function(e) {\n                useSnap = e.useSnap;\n                return {\n                    datas: datas,\n                    useSnap: useSnap\n                };\n            },\n            request: function(e) {\n                if (\"x\" in e) {\n                    distX = e.x - rect.left;\n                } else if (\"deltaX\" in e) {\n                    distX += e.deltaX;\n                }\n                if (\"y\" in e) {\n                    distY = e.y - rect.top;\n                } else if (\"deltaY\" in e) {\n                    distY += e.deltaY;\n                }\n                return {\n                    datas: datas,\n                    distX: distX,\n                    distY: distY,\n                    useSnap: useSnap\n                };\n            },\n            requestEnd: function() {\n                return {\n                    datas: datas,\n                    isDrag: true,\n                    useSnap: useSnap\n                };\n            }\n        };\n    },\n    unset: function(moveable) {\n        moveable.state.gestos.draggable = null;\n        moveable.state.dragInfo = null;\n    }\n};\n/**\r\n * Whether or not target can be dragged. (default: false)\r\n * @name Moveable.Draggable#draggable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.draggable = true;\r\n */ /**\r\n * throttle of x, y when drag.\r\n * @name Moveable.Draggable#throttleDrag\r\n * @default 0\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.throttleDrag = 1;\r\n */ /**\r\n* throttle of angle of x, y when drag.\r\n* @name Moveable.Draggable#throttleDragRotate\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body);\r\n*\r\n* moveable.throttleDragRotate = 45;\r\n*/ /**\r\n* start angle of throttleDragRotate of x, y when drag.\r\n* @name Moveable.Draggable#startDragRotate\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body);\r\n*\r\n* // 45, 135, 225, 315\r\n* moveable.throttleDragRotate = 90;\r\n* moveable.startDragRotate = 45;\r\n*/ /**\r\n * When the drag starts, the dragStart event is called.\r\n * @memberof Moveable.Draggable\r\n * @event dragStart\r\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { draggable: true });\r\n * moveable.on(\"dragStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */ /**\r\n * When dragging, the drag event is called.\r\n * @memberof Moveable.Draggable\r\n * @event drag\r\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { draggable: true });\r\n * moveable.on(\"drag\", ({ target, transform }) => {\r\n *     target.style.transform = transform;\r\n * });\r\n */ /**\r\n * When the drag finishes, the dragEnd event is called.\r\n * @memberof Moveable.Draggable\r\n * @event dragEnd\r\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { draggable: true });\r\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\r\n *     console.log(target, isDrag);\r\n * });\r\n */ /**\r\n* When the group drag starts, the `dragGroupStart` event is called.\r\n* @memberof Moveable.Draggable\r\n* @event dragGroupStart\r\n* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     draggable: true\r\n* });\r\n* moveable.on(\"dragGroupStart\", ({ targets }) => {\r\n*     console.log(\"onDragGroupStart\", targets);\r\n* });\r\n*/ /**\r\n* When the group drag, the `dragGroup` event is called.\r\n* @memberof Moveable.Draggable\r\n* @event dragGroup\r\n* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     draggable: true\r\n* });\r\n* moveable.on(\"dragGroup\", ({ targets, events }) => {\r\n*     console.log(\"onDragGroup\", targets);\r\n*     events.forEach(ev => {\r\n*          // drag event\r\n*          console.log(\"onDrag left, top\", ev.left, ev.top);\r\n*          // ev.target!.style.left = `${ev.left}px`;\r\n*          // ev.target!.style.top = `${ev.top}px`;\r\n*          console.log(\"onDrag translate\", ev.dist);\r\n*          ev.target!.style.transform = ev.transform;)\r\n*     });\r\n* });\r\n*/ /**\r\n * When the group drag finishes, the `dragGroupEnd` event is called.\r\n * @memberof Moveable.Draggable\r\n * @event dragGroupEnd\r\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     draggable: true\r\n * });\r\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\r\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\r\n * });\r\n */ function getFixedDirectionInfo(startPositions, fixedDirection) {\n    var fixedPosition = getPosByDirection(startPositions, fixedDirection);\n    var fixedOffset = [\n        0,\n        0\n    ];\n    return {\n        fixedPosition: fixedPosition,\n        fixedDirection: fixedDirection,\n        fixedOffset: fixedOffset\n    };\n}\nfunction getOffsetFixedDirectionInfo(state, fixedDirection) {\n    // for start\n    var allMatrix = state.allMatrix, is3d = state.is3d, width = state.width, height = state.height;\n    var n = is3d ? 4 : 3;\n    var nextFixedOffset = [\n        width / 2 * (1 + fixedDirection[0]),\n        height / 2 * (1 + fixedDirection[1])\n    ];\n    var fixedPosition = calculatePosition(allMatrix, nextFixedOffset, n);\n    var fixedOffset = [\n        0,\n        0\n    ];\n    return {\n        fixedPosition: fixedPosition,\n        fixedDirection: fixedDirection,\n        fixedOffset: fixedOffset\n    };\n}\nfunction getOffsetFixedPositionInfo(state, offsetFixedPosition) {\n    // for start\n    var allMatrix = state.allMatrix, is3d = state.is3d, width = state.width, height = state.height;\n    var n = is3d ? 4 : 3;\n    var fixedDirection = getDirectionByPos(offsetFixedPosition, width, height);\n    var nextFixedPosition = calculatePosition(allMatrix, offsetFixedPosition, n);\n    var fixedOffset = [\n        width ? 0 : offsetFixedPosition[0],\n        height ? 0 : offsetFixedPosition[1]\n    ];\n    return {\n        fixedPosition: nextFixedPosition,\n        fixedDirection: fixedDirection,\n        fixedOffset: fixedOffset\n    };\n}\n/**\r\n * @namespace Resizable\r\n * @memberof Moveable\r\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\r\n */ var directionCondition$2 = getDirectionCondition(\"resizable\");\nvar Resizable = {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: [\n        \"resizable\",\n        \"throttleResize\",\n        \"renderDirections\",\n        \"displayAroundControls\",\n        \"keepRatio\",\n        \"resizeFormat\",\n        \"keepRatioFinally\",\n        \"edge\",\n        \"checkResizableError\"\n    ],\n    events: [\n        \"resizeStart\",\n        \"beforeResize\",\n        \"resize\",\n        \"resizeEnd\",\n        \"resizeGroupStart\",\n        \"beforeResizeGroup\",\n        \"resizeGroup\",\n        \"resizeGroupEnd\"\n    ],\n    render: getRenderDirections(\"resizable\"),\n    dragControlCondition: directionCondition$2,\n    viewClassName: getDirectionViewClassName(\"resizable\"),\n    dragControlStart: function(moveable, e) {\n        var _a;\n        var inputEvent = e.inputEvent, isPinch = e.isPinch, isGroup = e.isGroup, parentDirection = e.parentDirection, parentGesto = e.parentGesto, datas = e.datas, parentFixedDirection = e.parentFixedDirection, parentEvent = e.parentEvent;\n        var direction = getTotalDirection(parentDirection, isPinch, inputEvent, datas);\n        var state = moveable.state;\n        var target = state.target, width = state.width, height = state.height, gestos = state.gestos;\n        if (!direction || !target) {\n            return false;\n        }\n        if (gestos.resizable) {\n            return false;\n        }\n        gestos.resizable = parentGesto || moveable.controlGesto;\n        !isPinch && setDragStart(moveable, e);\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n        datas.minSize = [\n            0,\n            0\n        ];\n        datas.startWidth = state.inlineCSSWidth || state.cssWidth;\n        datas.startHeight = state.inlineCSSHeight || state.cssHeight;\n        datas.maxSize = [\n            Infinity,\n            Infinity\n        ];\n        if (!isGroup) {\n            datas.minSize = [\n                state.minOffsetWidth,\n                state.minOffsetHeight\n            ];\n            datas.maxSize = [\n                state.maxOffsetWidth,\n                state.maxOffsetHeight\n            ];\n        }\n        var transformOrigin = moveable.props.transformOrigin || \"% %\";\n        datas.transformOrigin = transformOrigin && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(transformOrigin) ? transformOrigin.split(\" \") : transformOrigin;\n        datas.startOffsetMatrix = state.offsetMatrix;\n        datas.startTransformOrigin = state.transformOrigin;\n        datas.isWidth = (_a = e === null || e === void 0 ? void 0 : e.parentIsWidth) !== null && _a !== void 0 ? _a : !direction[0] && !direction[1] || direction[0] || !direction[1];\n        function setRatio(ratio) {\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n        }\n        datas.startPositions = getAbsolutePosesByState(moveable.state);\n        function setFixedDirection(fixedDirection) {\n            var result = getFixedDirectionInfo(datas.startPositions, fixedDirection);\n            datas.fixedDirection = result.fixedDirection;\n            datas.fixedPosition = result.fixedPosition;\n            datas.fixedOffset = result.fixedOffset;\n        }\n        function setFixedPosition(fixedPosition) {\n            var result = getOffsetFixedPositionInfo(moveable.state, fixedPosition);\n            datas.fixedDirection = result.fixedDirection;\n            datas.fixedPosition = result.fixedPosition;\n            datas.fixedOffset = result.fixedOffset;\n        }\n        function setMin(minSize) {\n            datas.minSize = [\n                (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(minSize[0]), 0) || 0,\n                (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(minSize[1]), 0) || 0\n            ];\n        }\n        function setMax(maxSize) {\n            var nextMaxSize = [\n                maxSize[0] || Infinity,\n                maxSize[1] || Infinity\n            ];\n            if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(nextMaxSize[0]) || isFinite(nextMaxSize[0])) {\n                nextMaxSize[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(nextMaxSize[0]), 0) || Infinity;\n            }\n            if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(nextMaxSize[1]) || isFinite(nextMaxSize[1])) {\n                nextMaxSize[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(nextMaxSize[1]), 0) || Infinity;\n            }\n            datas.maxSize = nextMaxSize;\n        }\n        setRatio(width / height);\n        setFixedDirection(parentFixedDirection || [\n            -direction[0],\n            -direction[1]\n        ]);\n        datas.setFixedDirection = setFixedDirection;\n        datas.setFixedPosition = setFixedPosition;\n        datas.setMin = setMin;\n        datas.setMax = setMax;\n        var params = fillParams(moveable, e, {\n            direction: direction,\n            startRatio: datas.ratio,\n            set: function(_a) {\n                var _b = __read(_a, 2), startWidth = _b[0], startHeight = _b[1];\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setMin: setMin,\n            setMax: setMax,\n            setRatio: setRatio,\n            setFixedDirection: setFixedDirection,\n            setFixedPosition: setFixedPosition,\n            setOrigin: function(origin) {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([\n                0,\n                0\n            ], e))\n        });\n        var result = parentEvent || triggerEvent(moveable, \"onResizeStart\", params);\n        datas.startFixedDirection = datas.fixedDirection;\n        datas.startFixedPosition = datas.fixedPosition;\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction: direction\n            };\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl: function(moveable, e) {\n        var _a;\n        var datas = e.datas, parentFlag = e.parentFlag, isPinch = e.isPinch, parentKeepRatio = e.parentKeepRatio, dragClient = e.dragClient, parentDist = e.parentDist, useSnap = e.useSnap, isRequest = e.isRequest, isGroup = e.isGroup, parentEvent = e.parentEvent, resolveMatrix = e.resolveMatrix;\n        var isResize = datas.isResize, transformOrigin = datas.transformOrigin, startWidth = datas.startWidth, startHeight = datas.startHeight, prevWidth = datas.prevWidth, prevHeight = datas.prevHeight, minSize = datas.minSize, maxSize = datas.maxSize, ratio = datas.ratio, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, isWidth = datas.isWidth;\n        if (!isResize) {\n            return;\n        }\n        if (resolveMatrix) {\n            var is3d = moveable.state.is3d;\n            var startOffsetMatrix = datas.startOffsetMatrix, startTransformOrigin = datas.startTransformOrigin;\n            var n = is3d ? 4 : 3;\n            var targetMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)(getNextTransforms(e));\n            var targetN = Math.sqrt(targetMatrix.length);\n            if (n !== targetN) {\n                targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, targetN, n);\n            }\n            var nextAllMatrix = getNextMatrix(startOffsetMatrix, targetMatrix, startTransformOrigin, n);\n            var poses = calculatePoses(nextAllMatrix, startOffsetWidth, startOffsetHeight, n);\n            datas.startPositions = poses;\n            datas.nextTargetMatrix = targetMatrix;\n            datas.nextAllMatrix = nextAllMatrix;\n        }\n        var props = getProps(moveable.props, \"resizable\");\n        var resizeFormat = props.resizeFormat, _b = props.throttleResize, throttleResize = _b === void 0 ? parentFlag ? 0 : 1 : _b, parentMoveable = props.parentMoveable, keepRatioFinally = props.keepRatioFinally;\n        var direction = datas.direction;\n        var sizeDirection = direction;\n        var distWidth = 0;\n        var distHeight = 0;\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [\n                1,\n                1\n            ];\n        }\n        var keepRatio = ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio) || false;\n        function getNextBoundingSize() {\n            var fixedDirection = datas.fixedDirection;\n            var nextSize = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\n            distWidth = nextSize.distWidth;\n            distHeight = nextSize.distHeight;\n            var nextWidth = sizeDirection[0] - fixedDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n            var nextHeight = sizeDirection[1] - fixedDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n                if (isWidth) {\n                    nextHeight = nextWidth / ratio;\n                } else {\n                    nextWidth = nextHeight * ratio;\n                }\n            }\n            return [\n                nextWidth,\n                nextHeight\n            ];\n        }\n        var _c = __read(getNextBoundingSize(), 2), boundingWidth = _c[0], boundingHeight = _c[1];\n        if (!parentEvent) {\n            datas.setFixedDirection(datas.fixedDirection);\n            triggerEvent(moveable, \"onBeforeResize\", fillParams(moveable, e, {\n                startFixedDirection: datas.startFixedDirection,\n                startFixedPosition: datas.startFixedPosition,\n                setFixedDirection: function(nextFixedDirection) {\n                    var _a;\n                    datas.setFixedDirection(nextFixedDirection);\n                    _a = __read(getNextBoundingSize(), 2), boundingWidth = _a[0], boundingHeight = _a[1];\n                    return [\n                        boundingWidth,\n                        boundingHeight\n                    ];\n                },\n                setFixedPosition: function(nextFixedPosition) {\n                    var _a;\n                    datas.setFixedPosition(nextFixedPosition);\n                    _a = __read(getNextBoundingSize(), 2), boundingWidth = _a[0], boundingHeight = _a[1];\n                    return [\n                        boundingWidth,\n                        boundingHeight\n                    ];\n                },\n                boundingWidth: boundingWidth,\n                boundingHeight: boundingHeight,\n                setSize: function(size) {\n                    var _a;\n                    _a = __read(size, 2), boundingWidth = _a[0], boundingHeight = _a[1];\n                }\n            }, true));\n        }\n        var fixedPosition = dragClient;\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsolutePosition(moveable, [\n                    0,\n                    0\n                ]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n        var snapDist = [\n            0,\n            0\n        ];\n        if (!isPinch) {\n            snapDist = checkSnapResize(moveable, boundingWidth, boundingHeight, direction, fixedPosition, !useSnap && isRequest, datas);\n        }\n        if (parentDist) {\n            !parentDist[0] && (snapDist[0] = 0);\n            !parentDist[1] && (snapDist[1] = 0);\n        }\n        function computeSize() {\n            var _a;\n            if (resizeFormat) {\n                _a = __read(resizeFormat([\n                    boundingWidth,\n                    boundingHeight\n                ]), 2), boundingWidth = _a[0], boundingHeight = _a[1];\n            }\n            boundingWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(boundingWidth, throttleResize);\n            boundingHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(boundingHeight, throttleResize);\n        }\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (abs(snapDist[0]) > abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n            var isNoSnap = !snapDist[0] && !snapDist[1];\n            if (isNoSnap) {\n                // pre-compute before maintaining the ratio\n                computeSize();\n            }\n            if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {\n                boundingWidth += snapDist[0];\n                boundingHeight = boundingWidth / ratio;\n            } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {\n                boundingHeight += snapDist[1];\n                boundingWidth = boundingHeight * ratio;\n            }\n        } else {\n            boundingWidth += snapDist[0];\n            boundingHeight += snapDist[1];\n            boundingWidth = Math.max(0, boundingWidth);\n            boundingHeight = Math.max(0, boundingHeight);\n        }\n        _a = __read((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.calculateBoundSize)([\n            boundingWidth,\n            boundingHeight\n        ], minSize, maxSize, keepRatio ? ratio : false), 2), boundingWidth = _a[0], boundingHeight = _a[1];\n        computeSize();\n        if (keepRatio && (isGroup || keepRatioFinally)) {\n            if (isWidth) {\n                boundingHeight = boundingWidth / ratio;\n            } else {\n                boundingWidth = boundingHeight * ratio;\n            }\n        }\n        distWidth = boundingWidth - startOffsetWidth;\n        distHeight = boundingHeight - startOffsetHeight;\n        var delta = [\n            distWidth - prevWidth,\n            distHeight - prevHeight\n        ];\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n        var inverseDelta = getResizeDist(moveable, boundingWidth, boundingHeight, fixedPosition, transformOrigin, datas);\n        if (!parentMoveable && delta.every(function(num) {\n            return !num;\n        }) && inverseDelta.every(function(num) {\n            return !num;\n        })) {\n            return;\n        }\n        var drag = Draggable.drag(moveable, setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false, \"draggable\"));\n        var transform = drag.transform;\n        var nextWidth = startWidth + distWidth;\n        var nextHeight = startHeight + distHeight;\n        var params = fillParams(moveable, e, __assign({\n            width: nextWidth,\n            height: nextHeight,\n            offsetWidth: Math.round(boundingWidth),\n            offsetHeight: Math.round(boundingHeight),\n            startRatio: ratio,\n            boundingWidth: boundingWidth,\n            boundingHeight: boundingHeight,\n            direction: direction,\n            dist: [\n                distWidth,\n                distHeight\n            ],\n            delta: delta,\n            isPinch: !!isPinch,\n            drag: drag\n        }, fillAfterTransform({\n            style: {\n                width: \"\".concat(nextWidth, \"px\"),\n                height: \"\".concat(nextHeight, \"px\")\n            },\n            transform: transform\n        }, drag, e)));\n        !parentEvent && triggerEvent(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter: function(moveable, e) {\n        var datas = e.datas;\n        var isResize = datas.isResize, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, prevWidth = datas.prevWidth, prevHeight = datas.prevHeight;\n        if (!isResize || moveable.props.checkResizableError === false) {\n            return;\n        }\n        var _a = moveable.state, width = _a.width, height = _a.height;\n        var errorWidth = width - (startOffsetWidth + prevWidth);\n        var errorHeight = height - (startOffsetHeight + prevHeight);\n        var isErrorWidth = abs(errorWidth) > 3;\n        var isErrorHeight = abs(errorHeight) > 3;\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            return this.dragControl(moveable, e);\n        }\n    },\n    dragControlEnd: function(moveable, e) {\n        var datas = e.datas, parentEvent = e.parentEvent;\n        if (!datas.isResize) {\n            return;\n        }\n        datas.isResize = false;\n        var params = fillEndParams(moveable, e, {});\n        !parentEvent && triggerEvent(moveable, \"onResizeEnd\", params);\n        return params;\n    },\n    dragGroupControlCondition: directionCondition$2,\n    dragGroupControlStart: function(moveable, e) {\n        var datas = e.datas;\n        var params = this.dragControlStart(moveable, __assign(__assign({}, e), {\n            isGroup: true\n        }));\n        if (!params) {\n            return false;\n        }\n        var originalEvents = fillChildEvents(moveable, \"resizable\", e);\n        var parentStartOffsetWidth = datas.startOffsetWidth, parentStartOffsetHeight = datas.startOffsetHeight;\n        function updateGroupMin() {\n            var originalMinSize = datas.minSize;\n            originalEvents.forEach(function(ev) {\n                var _a = ev.datas, childMinSize = _a.minSize, childStartOffsetWidth = _a.startOffsetWidth, childStartOffsetHeight = _a.startOffsetHeight;\n                var parentMinWidth = parentStartOffsetWidth * (childStartOffsetWidth ? childMinSize[0] / childStartOffsetWidth : 0);\n                var parentMinHeight = parentStartOffsetHeight * (childStartOffsetHeight ? childMinSize[1] / childStartOffsetHeight : 0);\n                originalMinSize[0] = Math.max(originalMinSize[0], parentMinWidth);\n                originalMinSize[1] = Math.max(originalMinSize[1], parentMinHeight);\n            });\n        }\n        function updateGroupMax() {\n            var originalMaxSize = datas.maxSize;\n            originalEvents.forEach(function(ev) {\n                var _a = ev.datas, childMaxSize = _a.maxSize, childStartOffsetWidth = _a.startOffsetWidth, childStartOffsetHeight = _a.startOffsetHeight;\n                var parentMaxWidth = parentStartOffsetWidth * (childStartOffsetWidth ? childMaxSize[0] / childStartOffsetWidth : 0);\n                var parentMaxHeight = parentStartOffsetHeight * (childStartOffsetHeight ? childMaxSize[1] / childStartOffsetHeight : 0);\n                originalMaxSize[0] = Math.min(originalMaxSize[0], parentMaxWidth);\n                originalMaxSize[1] = Math.min(originalMaxSize[1], parentMaxHeight);\n            });\n        }\n        var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function(child, ev) {\n            return startChildDist(moveable, child, datas, ev);\n        });\n        updateGroupMin();\n        updateGroupMax();\n        var setFixedDirection = function(fixedDirection) {\n            params.setFixedDirection(fixedDirection);\n            events.forEach(function(ev, i) {\n                ev.setFixedDirection(fixedDirection);\n                startChildDist(moveable, ev.moveable, datas, originalEvents[i]);\n            });\n        };\n        datas.setFixedDirection = setFixedDirection;\n        var nextParams = __assign(__assign({}, params), {\n            targets: moveable.props.targets,\n            events: events.map(function(ev) {\n                return __assign(__assign({}, ev), {\n                    setMin: function(minSize) {\n                        ev.setMin(minSize);\n                        updateGroupMin();\n                    },\n                    setMax: function(maxSize) {\n                        ev.setMax(maxSize);\n                        updateGroupMax();\n                    }\n                });\n            }),\n            setFixedDirection: setFixedDirection,\n            setMin: function(minSize) {\n                params.setMin(minSize);\n                updateGroupMin();\n            },\n            setMax: function(maxSize) {\n                params.setMax(maxSize);\n                updateGroupMax();\n            }\n        });\n        var result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl: function(moveable, e) {\n        var datas = e.datas;\n        if (!datas.isResize) {\n            return;\n        }\n        var props = getProps(moveable.props, \"resizable\");\n        catchEvent(moveable, \"onBeforeResize\", function(parentEvent) {\n            triggerEvent(moveable, \"onBeforeResizeGroup\", fillParams(moveable, e, __assign(__assign({}, parentEvent), {\n                targets: props.targets\n            }), true));\n        });\n        var params = this.dragControl(moveable, __assign(__assign({}, e), {\n            isGroup: true\n        }));\n        if (!params) {\n            return;\n        }\n        var boundingWidth = params.boundingWidth, boundingHeight = params.boundingHeight, dist = params.dist;\n        var keepRatio = props.keepRatio;\n        var parentScale = [\n            boundingWidth / (boundingWidth - dist[0]),\n            boundingHeight / (boundingHeight - dist[1])\n        ];\n        var fixedPosition = datas.fixedPosition;\n        var events = triggerChildAbles(moveable, this, \"dragControl\", e, function(_, ev) {\n            var _a = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createRotateMatrix)(moveable.rotation / 180 * Math.PI, 3), [\n                ev.datas.originalX * parentScale[0],\n                ev.datas.originalY * parentScale[1],\n                1\n            ], 3), 2), clientX = _a[0], clientY = _a[1];\n            return __assign(__assign({}, ev), {\n                parentDist: null,\n                parentScale: parentScale,\n                dragClient: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(fixedPosition, [\n                    clientX,\n                    clientY\n                ]),\n                parentKeepRatio: keepRatio\n            });\n        });\n        var nextParams = __assign({\n            targets: props.targets,\n            events: events\n        }, params);\n        triggerEvent(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd: function(moveable, e) {\n        var isDrag = e.isDrag, datas = e.datas;\n        if (!datas.isResize) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        var events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n        var nextParams = fillEndParams(moveable, e, {\n            targets: moveable.props.targets,\n            events: events\n        });\n        triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\r\n     * @method Moveable.Resizable#request\r\n     * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter\r\n     * @return {Moveable.Requester} Moveable Requester\r\n     * @example\r\n\n     * // Instantly Request (requestStart - request - requestEnd)\r\n     * // Use Relative Value\r\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\r\n     *\r\n     * // Use Absolute Value\r\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\r\n     *\r\n     * // requestStart\r\n     * const requester = moveable.request(\"resizable\");\r\n     *\r\n     * // request\r\n     * // Use Relative Value\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     *\r\n     * // Use Absolute Value\r\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\r\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\r\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\r\n     *\r\n     * // requestEnd\r\n     * requester.requestEnd();\r\n     */ request: function(moveable) {\n        var datas = {};\n        var distWidth = 0;\n        var distHeight = 0;\n        var useSnap = false;\n        var rect = moveable.getRect();\n        return {\n            isControl: true,\n            requestStart: function(e) {\n                var _a;\n                useSnap = e.useSnap;\n                return {\n                    datas: datas,\n                    parentDirection: e.direction || [\n                        1,\n                        1\n                    ],\n                    parentIsWidth: (_a = e === null || e === void 0 ? void 0 : e.horizontal) !== null && _a !== void 0 ? _a : true,\n                    useSnap: useSnap\n                };\n            },\n            request: function(e) {\n                if (\"offsetWidth\" in e) {\n                    distWidth = e.offsetWidth - rect.offsetWidth;\n                } else if (\"deltaWidth\" in e) {\n                    distWidth += e.deltaWidth;\n                }\n                if (\"offsetHeight\" in e) {\n                    distHeight = e.offsetHeight - rect.offsetHeight;\n                } else if (\"deltaHeight\" in e) {\n                    distHeight += e.deltaHeight;\n                }\n                return {\n                    datas: datas,\n                    parentDist: [\n                        distWidth,\n                        distHeight\n                    ],\n                    parentKeepRatio: e.keepRatio,\n                    useSnap: useSnap\n                };\n            },\n            requestEnd: function() {\n                return {\n                    datas: datas,\n                    isDrag: true,\n                    useSnap: useSnap\n                };\n            }\n        };\n    },\n    unset: function(moveable) {\n        moveable.state.gestos.resizable = null;\n    }\n};\n/**\r\n * Whether or not target can be resized.\r\n * @name Moveable.Resizable#resizable\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     resizable: false,\r\n * });\r\n *\r\n * moveable.resizable = true;\r\n */ /**\r\n * throttle of width, height when resize. If throttleResize is set to less than 1, the target may shake.\r\n * @name Moveable.Resizable#throttleResize\r\n * @default 1\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   resizable: true,\r\n *   throttleResize: 1,\r\n * });\r\n *\r\n * moveable.throttleResize = 0;\r\n */ /**\r\n * When resize or scale, keeps a ratio of the width, height.\r\n * @name Moveable.Resizable#keepRatio\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   resizable: true,\r\n * });\r\n *\r\n * moveable.keepRatio = true;\r\n */ /**\r\n * Set directions to show the control box.\r\n * @name Moveable.Resizable#renderDirections\r\n * @default [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"]\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   resizable: true,\r\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\r\n * });\r\n *\r\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\r\n */ /**\r\n * Function to convert size for resize\r\n * @name Moveable.Resizable#resizeFormat\r\n * @default oneself\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   resizable: true,\r\n *   resizeFormat: v => v,\r\n * });\r\n *\r\n * moveable.resizeFormat = (size: number[]) => ([Math.trunc(size[0]), Math.trunc(size[1])];\r\n */ /**\r\n * When the resize starts, the resizeStart event is called.\r\n * @memberof Moveable.Resizable\r\n * @event resizeStart\r\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { resizable: true });\r\n * moveable.on(\"resizeStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */ /**\r\n * When resizing, `beforeResize` is called before `resize` occurs. In `beforeResize`, you can get and set the pre-value before resizing.\r\n * @memberof Moveable.Resizable\r\n * @event beforeResize\r\n * @param {Moveable.Resizable.OnBeforeResize} - Parameters for the `beforeResize` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { resizable: true });\r\n * moveable.on(\"beforeResize\", ({ setFixedDirection }) => {\r\n *     if (shiftKey) {\r\n *        setFixedDirection([0, 0]);\r\n *     }\r\n * });\r\n * moveable.on(\"resize\", ({ target, width, height, drag }) => {\r\n *     target.style.width = `${width}px`;\r\n *     target.style.height = `${height}px`;\r\n *     target.style.transform = drag.transform;\r\n * });\r\n */ /**\r\n * When resizing, the resize event is called.\r\n * @memberof Moveable.Resizable\r\n * @event resize\r\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { resizable: true });\r\n * moveable.on(\"resize\", ({ target, width, height }) => {\r\n *     target.style.width = `${e.width}px`;\r\n *     target.style.height = `${e.height}px`;\r\n * });\r\n */ /**\r\n * When the resize finishes, the resizeEnd event is called.\r\n * @memberof Moveable.Resizable\r\n * @event resizeEnd\r\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { resizable: true });\r\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\r\n *     console.log(target, isDrag);\r\n * });\r\n */ /**\r\n* When the group resize starts, the `resizeGroupStart` event is called.\r\n* @memberof Moveable.Resizable\r\n* @event resizeGroupStart\r\n* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     resizable: true\r\n* });\r\n* moveable.on(\"resizeGroupStart\", ({ targets }) => {\r\n*     console.log(\"onResizeGroupStart\", targets);\r\n* });\r\n*/ /**\r\n* When the group resize, the `resizeGroup` event is called.\r\n* @memberof Moveable.Resizable\r\n* @event resizeGroup\r\n* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     resizable: true\r\n* });\r\n* moveable.on(\"resizeGroup\", ({ targets, events }) => {\r\n*     console.log(\"onResizeGroup\", targets);\r\n*     events.forEach(ev => {\r\n*         const offset = [\r\n*             direction[0] < 0 ? -ev.delta[0] : 0,\r\n*             direction[1] < 0 ? -ev.delta[1] : 0,\r\n*         ];\r\n*         // ev.drag is a drag event that occurs when the group resize.\r\n*         const left = offset[0] + ev.drag.beforeDist[0];\r\n*         const top = offset[1] + ev.drag.beforeDist[1];\r\n*         const width = ev.width;\r\n*         const top = ev.top;\r\n*     });\r\n* });\r\n*/ /**\r\n * When the group resize finishes, the `resizeGroupEnd` event is called.\r\n * @memberof Moveable.Resizable\r\n * @event resizeGroupEnd\r\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     resizable: true\r\n * });\r\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\r\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\r\n * });\r\n */ /**\r\n * @namespace Rotatable\r\n * @memberof Moveable\r\n * @description Rotatable indicates whether the target can be rotated.\r\n */ function setRotateStartInfo(moveable, datas, clientX, clientY, rect) {\n    var groupable = moveable.props.groupable;\n    var state = moveable.state;\n    var n = state.is3d ? 4 : 3;\n    var origin = datas.origin;\n    var nextOrigin = calculatePosition(moveable.state.rootMatrix, // TO-DO #710\n    (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([\n        origin[0],\n        origin[1]\n    ], groupable ? [\n        0,\n        0\n    ] : [\n        state.left,\n        state.top\n    ]), n);\n    var startAbsoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)([\n        rect.left,\n        rect.top\n    ], nextOrigin);\n    datas.startAbsoluteOrigin = startAbsoluteOrigin;\n    datas.prevDeg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(startAbsoluteOrigin, [\n        clientX,\n        clientY\n    ]) / Math.PI * 180;\n    datas.defaultDeg = datas.prevDeg;\n    datas.prevSnapDeg = 0;\n    datas.loop = 0;\n    datas.startDist = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(startAbsoluteOrigin, [\n        clientX,\n        clientY\n    ]);\n}\nfunction getAbsoluteDist(deg, direction, datas) {\n    var defaultDeg = datas.defaultDeg, prevDeg = datas.prevDeg;\n    var normalizedPrevDeg = prevDeg % 360;\n    var loop = Math.floor(prevDeg / 360);\n    if (normalizedPrevDeg < 0) {\n        normalizedPrevDeg += 360;\n    }\n    if (normalizedPrevDeg > deg && normalizedPrevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++loop;\n    } else if (normalizedPrevDeg < deg && normalizedPrevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --loop;\n    }\n    var dist = direction * (loop * 360 + deg - defaultDeg);\n    datas.prevDeg = defaultDeg + dist;\n    return dist;\n}\nfunction getAbsoluteDistByClient(clientX, clientY, direction, datas) {\n    return getAbsoluteDist((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(datas.startAbsoluteOrigin, [\n        clientX,\n        clientY\n    ]) / Math.PI * 180, direction, datas);\n}\nfunction getRotateInfo(moveable, moveableRect, datas, dist, startValue, checkSnap) {\n    var _a = moveable.props.throttleRotate, throttleRotate = _a === void 0 ? 0 : _a;\n    var prevSnapDeg = datas.prevSnapDeg;\n    var snapRotation = 0;\n    var isSnap = false;\n    if (checkSnap) {\n        var result = checkSnapRotate(moveable, moveableRect, dist, startValue + dist);\n        isSnap = result.isSnap;\n        snapRotation = startValue + result.dist;\n    }\n    if (!isSnap) {\n        snapRotation = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(startValue + dist, throttleRotate);\n    }\n    var snapDeg = snapRotation - startValue;\n    datas.prevSnapDeg = snapDeg;\n    return [\n        snapDeg - prevSnapDeg,\n        snapDeg,\n        snapRotation\n    ];\n}\nfunction getRotationPositions(rotationPosition, _a, direction) {\n    var _b = __read(_a, 4), pos1 = _b[0], pos2 = _b[1], pos3 = _b[2], pos4 = _b[3];\n    if (rotationPosition === \"none\") {\n        return [];\n    }\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(rotationPosition)) {\n        return rotationPosition.map(function(child) {\n            return getRotationPositions(child, [\n                pos1,\n                pos2,\n                pos3,\n                pos4\n            ], direction)[0];\n        });\n    }\n    var _c = __read((rotationPosition || \"top\").split(\"-\"), 2), dir1 = _c[0], dir2 = _c[1];\n    var radPoses = [\n        pos1,\n        pos2\n    ];\n    if (dir1 === \"left\") {\n        radPoses = [\n            pos3,\n            pos1\n        ];\n    } else if (dir1 === \"right\") {\n        radPoses = [\n            pos2,\n            pos4\n        ];\n    } else if (dir1 === \"bottom\") {\n        radPoses = [\n            pos4,\n            pos3\n        ];\n    }\n    var pos = [\n        (radPoses[0][0] + radPoses[1][0]) / 2,\n        (radPoses[0][1] + radPoses[1][1]) / 2\n    ];\n    var rad = getRotationRad(radPoses, direction);\n    if (dir2) {\n        var isStart = dir2 === \"top\" || dir2 === \"left\";\n        var isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n        pos = radPoses[isStart && !isReverse || !isStart && isReverse ? 0 : 1];\n    }\n    return [\n        [\n            pos,\n            rad\n        ]\n    ];\n}\nfunction dragControlCondition(moveable, e) {\n    if (e.isRequest) {\n        return e.requestAble === \"rotatable\";\n    }\n    var target = e.inputEvent.target;\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"rotation-control\")) || moveable.props.rotateAroundControls && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"around-control\")) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"control\")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"rotatable\"))) {\n        return true;\n    }\n    var rotationTarget = moveable.props.rotationTarget;\n    if (rotationTarget) {\n        return getRefTargets(rotationTarget, true).some(function(element) {\n            if (!element) {\n                return false;\n            }\n            return target === element || target.contains(element);\n        });\n    }\n    return false;\n}\nvar css = \".rotation {\\nposition: absolute;\\nheight: 40px;\\nwidth: 1px;\\ntransform-origin: 50% 100%;\\nheight: calc(40px * var(--zoom));\\ntop: auto;\\nleft: 0;\\nbottom: 100%;\\nwill-change: transform;\\n}\\n.rotation .rotation-line {\\ndisplay: block;\\nwidth: 100%;\\nheight: 100%;\\ntransform-origin: 50% 50%;\\n}\\n.rotation .rotation-control {\\nborder-color: #4af;\\nborder-color: var(--moveable-color);\\nbackground:#fff;\\ncursor: alias;\\n}\\n:global .view-rotation-dragging, .rotatable.direction.control {\\ncursor: alias;\\n}\\n.rotatable.direction.control.move {\\ncursor: move;\\n}\\n\";\nvar Rotatable = {\n    name: \"rotatable\",\n    canPinch: true,\n    props: [\n        \"rotatable\",\n        \"rotationPosition\",\n        \"throttleRotate\",\n        \"renderDirections\",\n        \"rotationTarget\",\n        \"rotateAroundControls\",\n        \"edge\",\n        \"resolveAblesWithRotatable\",\n        \"displayAroundControls\"\n    ],\n    events: [\n        \"rotateStart\",\n        \"beforeRotate\",\n        \"rotate\",\n        \"rotateEnd\",\n        \"rotateGroupStart\",\n        \"beforeRotateGroup\",\n        \"rotateGroup\",\n        \"rotateGroupEnd\"\n    ],\n    css: [\n        css\n    ],\n    viewClassName: function(moveable) {\n        if (!moveable.isDragging(\"rotatable\")) {\n            return \"\";\n        }\n        return prefix(\"view-rotation-dragging\");\n    },\n    render: function(moveable, React) {\n        var _a = getProps(moveable.props, \"rotatable\"), rotatable = _a.rotatable, rotationPosition = _a.rotationPosition, zoom = _a.zoom, renderDirections = _a.renderDirections, rotateAroundControls = _a.rotateAroundControls, resolveAblesWithRotatable = _a.resolveAblesWithRotatable;\n        var _b = moveable.getState(), renderPoses = _b.renderPoses, direction = _b.direction;\n        if (!rotatable) {\n            return null;\n        }\n        var positions = getRotationPositions(rotationPosition, renderPoses, direction);\n        var jsxs = [];\n        positions.forEach(function(_a, i) {\n            var _b = __read(_a, 2), pos = _b[0], rad = _b[1];\n            jsxs.push(React.createElement(\"div\", {\n                key: \"rotation\".concat(i),\n                className: prefix(\"rotation\"),\n                style: {\n                    // tslint:disable-next-line: max-line-length\n                    transform: \"translate(-50%) translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) rotate(\").concat(rad, \"rad)\")\n                }\n            }, React.createElement(\"div\", {\n                className: prefix(\"line rotation-line\"),\n                style: {\n                    transform: \"scaleX(\".concat(zoom, \")\")\n                }\n            }), React.createElement(\"div\", {\n                className: prefix(\"control rotation-control\"),\n                style: {\n                    transform: \"translate(0.5px) scale(\".concat(zoom, \")\")\n                }\n            })));\n        });\n        if (renderDirections) {\n            var ables = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(resolveAblesWithRotatable || {});\n            var resolveMap_1 = {};\n            ables.forEach(function(name) {\n                resolveAblesWithRotatable[name].forEach(function(direction) {\n                    resolveMap_1[direction] = name;\n                });\n            });\n            var directionControlInfos = [];\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(renderDirections)) {\n                directionControlInfos = renderDirections.map(function(dir) {\n                    var able = resolveMap_1[dir];\n                    return {\n                        data: able ? {\n                            resolve: able\n                        } : {},\n                        classNames: able ? [\n                            \"move\"\n                        ] : [],\n                        dir: dir\n                    };\n                });\n            }\n            jsxs.push.apply(jsxs, __spreadArray([], __read(renderDirectionControlsByInfos(moveable, \"rotatable\", directionControlInfos, React)), false));\n        }\n        if (rotateAroundControls) {\n            jsxs.push.apply(jsxs, __spreadArray([], __read(renderAroundControls(moveable, React)), false));\n        }\n        return jsxs;\n    },\n    dragControlCondition: dragControlCondition,\n    dragControlStart: function(moveable, e) {\n        var _a;\n        var _b;\n        var datas = e.datas, clientX = e.clientX, clientY = e.clientY, parentRotate = e.parentRotate, parentFlag = e.parentFlag, isPinch = e.isPinch, isRequest = e.isRequest;\n        var state = moveable.state;\n        var target = state.target, left = state.left, top = state.top, direction = state.direction, beforeDirection = state.beforeDirection, targetTransform = state.targetTransform, moveableClientRect = state.moveableClientRect, offsetMatrix = state.offsetMatrix, targetMatrix = state.targetMatrix, allMatrix = state.allMatrix, width = state.width, height = state.height;\n        if (!isRequest && !target) {\n            return false;\n        }\n        var rect = moveable.getRect();\n        datas.rect = rect;\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n        var setFixedPosition = function(fixedPosition) {\n            var result = getOffsetFixedPositionInfo(moveable.state, fixedPosition);\n            datas.fixedDirection = result.fixedDirection;\n            datas.fixedOffset = result.fixedOffset;\n            datas.fixedPosition = result.fixedPosition;\n            if (resizeStart) {\n                resizeStart.setFixedPosition(fixedPosition);\n            }\n        };\n        var setFixedDirection = function(fixedDirection) {\n            var result = getOffsetFixedDirectionInfo(moveable.state, fixedDirection);\n            datas.fixedDirection = result.fixedDirection;\n            datas.fixedOffset = result.fixedOffset;\n            datas.fixedPosition = result.fixedPosition;\n            if (resizeStart) {\n                resizeStart.setFixedDirection(fixedDirection);\n            }\n        };\n        var startClientX = clientX;\n        var startClientY = clientY;\n        if (isRequest || isPinch || parentFlag) {\n            var externalRotate = parentRotate || 0;\n            datas.beforeInfo = {\n                origin: rect.beforeOrigin,\n                prevDeg: externalRotate,\n                defaultDeg: externalRotate,\n                prevSnapDeg: 0,\n                startDist: 0\n            };\n            datas.afterInfo = __assign(__assign({}, datas.beforeInfo), {\n                origin: rect.origin\n            });\n            datas.absoluteInfo = __assign(__assign({}, datas.beforeInfo), {\n                origin: rect.origin,\n                startValue: externalRotate\n            });\n        } else {\n            var inputTarget = (_b = e.inputEvent) === null || _b === void 0 ? void 0 : _b.target;\n            if (inputTarget) {\n                var regionDirection = inputTarget.getAttribute(\"data-direction\") || \"\";\n                var controlDirection = DIRECTION_REGION_TO_DIRECTION[regionDirection];\n                if (controlDirection) {\n                    datas.isControl = true;\n                    datas.isAroundControl = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(inputTarget, prefix(\"around-control\"));\n                    datas.controlDirection = controlDirection;\n                    var resolve = inputTarget.getAttribute(\"data-resolve\");\n                    if (resolve) {\n                        datas.resolveAble = resolve;\n                    }\n                    var clientPoses = calculateMoveableClientPositions(state.rootMatrix, state.renderPoses, moveableClientRect);\n                    _a = __read(getPosByDirection(clientPoses, controlDirection), 2), startClientX = _a[0], startClientY = _a[1];\n                }\n            }\n            datas.beforeInfo = {\n                origin: rect.beforeOrigin\n            };\n            datas.afterInfo = {\n                origin: rect.origin\n            };\n            datas.absoluteInfo = {\n                origin: rect.origin,\n                startValue: rect.rotation\n            };\n            var originalFixedPosition_1 = setFixedPosition;\n            setFixedPosition = function(fixedPosition) {\n                var n = state.is3d ? 4 : 3;\n                var _a = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.getOrigin)(targetMatrix, n), fixedPosition), 2), originX = _a[0], originY = _a[1];\n                var fixedBeforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)([\n                    originX,\n                    originY\n                ], n));\n                var fixedAfterOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(allMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)([\n                    fixedPosition[0],\n                    fixedPosition[1]\n                ], n));\n                originalFixedPosition_1(fixedPosition);\n                var posDelta = state.posDelta;\n                datas.beforeInfo.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedBeforeOrigin, posDelta);\n                datas.afterInfo.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedAfterOrigin, posDelta);\n                datas.absoluteInfo.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedAfterOrigin, posDelta);\n                setRotateStartInfo(moveable, datas.beforeInfo, startClientX, startClientY, moveableClientRect);\n                setRotateStartInfo(moveable, datas.afterInfo, startClientX, startClientY, moveableClientRect);\n                setRotateStartInfo(moveable, datas.absoluteInfo, startClientX, startClientY, moveableClientRect);\n            };\n            setFixedDirection = function(fixedDirection) {\n                var fixedPosition = getPosByDirection([\n                    [\n                        0,\n                        0\n                    ],\n                    [\n                        width,\n                        0\n                    ],\n                    [\n                        0,\n                        height\n                    ],\n                    [\n                        width,\n                        height\n                    ]\n                ], fixedDirection);\n                setFixedPosition(fixedPosition);\n            };\n        }\n        datas.startClientX = startClientX;\n        datas.startClientY = startClientY;\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startValue = 0;\n        datas.datas = {};\n        setDefaultTransformIndex(moveable, e, \"rotate\");\n        var dragStart = false;\n        var resizeStart = false;\n        if (datas.isControl && datas.resolveAble) {\n            var resolveAble = datas.resolveAble;\n            if (resolveAble === \"resizable\") {\n                resizeStart = Resizable.dragControlStart(moveable, __assign(__assign({}, new CustomGesto(\"resizable\").dragStart([\n                    0,\n                    0\n                ], e)), {\n                    parentPosition: datas.controlPosition,\n                    parentFixedPosition: datas.fixedPosition\n                }));\n            }\n        }\n        if (!resizeStart) {\n            dragStart = Draggable.dragStart(moveable, new CustomGesto().dragStart([\n                0,\n                0\n            ], e));\n        }\n        setFixedPosition(getTotalOrigin(moveable));\n        var params = fillParams(moveable, e, __assign(__assign({\n            set: function(rotatation) {\n                datas.startValue = rotatation * Math.PI / 180;\n            },\n            setFixedDirection: setFixedDirection,\n            setFixedPosition: setFixedPosition\n        }, fillTransformStartEvent(moveable, e)), {\n            dragStart: dragStart,\n            resizeStart: resizeStart\n        }));\n        var result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n        state.snapRenderInfo = {\n            request: e.isRequest\n        };\n        return datas.isRotate ? params : false;\n    },\n    dragControl: function(moveable, e) {\n        var _a, _b, _c;\n        var datas = e.datas, clientDistX = e.clientDistX, clientDistY = e.clientDistY, parentRotate = e.parentRotate, parentFlag = e.parentFlag, isPinch = e.isPinch, groupDelta = e.groupDelta, resolveMatrix = e.resolveMatrix;\n        var beforeDirection = datas.beforeDirection, beforeInfo = datas.beforeInfo, afterInfo = datas.afterInfo, absoluteInfo = datas.absoluteInfo, isRotate = datas.isRotate, startValue = datas.startValue, rect = datas.rect, startClientX = datas.startClientX, startClientY = datas.startClientY;\n        if (!isRotate) {\n            return;\n        }\n        resolveTransformEvent(moveable, e, \"rotate\");\n        var targetDirection = getTransformDirection(e);\n        var direction = beforeDirection * targetDirection;\n        var parentMoveable = moveable.props.parentMoveable;\n        var beforeDelta = 0;\n        var beforeDist;\n        var beforeRotation;\n        var delta = 0;\n        var dist;\n        var rotation;\n        var absoluteDelta = 0;\n        var absoluteDist;\n        var absoluteRotation;\n        var startRotation = 180 / Math.PI * startValue;\n        var absoluteStartRotation = absoluteInfo.startValue;\n        var isSnap = false;\n        var nextClientX = startClientX + clientDistX;\n        var nextClientY = startClientY + clientDistY;\n        if (!parentFlag && \"parentDist\" in e) {\n            var parentDist = e.parentDist;\n            beforeDist = parentDist;\n            dist = parentDist;\n            absoluteDist = parentDist;\n        } else if (isPinch || parentFlag) {\n            beforeDist = getAbsoluteDist(parentRotate, beforeDirection, beforeInfo);\n            dist = getAbsoluteDist(parentRotate, direction, afterInfo);\n            absoluteDist = getAbsoluteDist(parentRotate, direction, absoluteInfo);\n        } else {\n            beforeDist = getAbsoluteDistByClient(nextClientX, nextClientY, beforeDirection, beforeInfo);\n            dist = getAbsoluteDistByClient(nextClientX, nextClientY, direction, afterInfo);\n            absoluteDist = getAbsoluteDistByClient(nextClientX, nextClientY, direction, absoluteInfo);\n            isSnap = true;\n        }\n        beforeRotation = startRotation + beforeDist;\n        rotation = startRotation + dist;\n        absoluteRotation = absoluteStartRotation + absoluteDist;\n        triggerEvent(moveable, \"onBeforeRotate\", fillParams(moveable, e, {\n            beforeRotation: beforeRotation,\n            rotation: rotation,\n            absoluteRotation: absoluteRotation,\n            setRotation: function(nextRotation) {\n                dist = nextRotation - startRotation;\n                beforeDist = dist;\n                absoluteDist = dist;\n            }\n        }, true));\n        _a = __read(getRotateInfo(moveable, rect, beforeInfo, beforeDist, startRotation, isSnap), 3), beforeDelta = _a[0], beforeDist = _a[1], beforeRotation = _a[2];\n        _b = __read(getRotateInfo(moveable, rect, afterInfo, dist, startRotation, isSnap), 3), delta = _b[0], dist = _b[1], rotation = _b[2];\n        _c = __read(getRotateInfo(moveable, rect, absoluteInfo, absoluteDist, absoluteStartRotation, isSnap), 3), absoluteDelta = _c[0], absoluteDist = _c[1], absoluteRotation = _c[2];\n        if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable && !resolveMatrix) {\n            return;\n        }\n        var nextTransform = convertTransformFormat(datas, \"rotate(\".concat(rotation, \"deg)\"), \"rotate(\".concat(dist, \"deg)\"));\n        if (resolveMatrix) {\n            datas.fixedPosition = getTranslateFixedPosition(moveable, datas.targetAllTransform, datas.fixedDirection, datas.fixedOffset, datas);\n        }\n        var inverseDist = getRotateDist(moveable, dist, datas);\n        var inverseDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(groupDelta || [\n            0,\n            0\n        ], inverseDist), datas.prevInverseDist || [\n            0,\n            0\n        ]);\n        datas.prevInverseDist = inverseDist;\n        datas.requestValue = null;\n        var dragEvent = fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e);\n        var transformEvent = dragEvent;\n        var parentDistance = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)([\n            nextClientX,\n            nextClientY\n        ], absoluteInfo.startAbsoluteOrigin) - absoluteInfo.startDist;\n        var resize = undefined;\n        if (datas.resolveAble === \"resizable\") {\n            var resizeEvent = Resizable.dragControl(moveable, __assign(__assign({}, setCustomDrag(e, moveable.state, [\n                e.deltaX,\n                e.deltaY\n            ], !!isPinch, false, \"resizable\")), {\n                resolveMatrix: true,\n                parentDistance: parentDistance\n            }));\n            if (resizeEvent) {\n                resize = resizeEvent;\n                transformEvent = fillAfterTransform(transformEvent, resizeEvent, e);\n            }\n        }\n        var params = fillParams(moveable, e, __assign(__assign({\n            delta: delta,\n            dist: dist,\n            rotate: rotation,\n            rotation: rotation,\n            beforeDist: beforeDist,\n            beforeDelta: beforeDelta,\n            beforeRotate: beforeRotation,\n            beforeRotation: beforeRotation,\n            absoluteDist: absoluteDist,\n            absoluteDelta: absoluteDelta,\n            absoluteRotate: absoluteRotation,\n            absoluteRotation: absoluteRotation,\n            isPinch: !!isPinch,\n            resize: resize\n        }, dragEvent), transformEvent));\n        triggerEvent(moveable, \"onRotate\", params);\n        return params;\n    },\n    dragControlEnd: function(moveable, e) {\n        var datas = e.datas;\n        if (!datas.isRotate) {\n            return;\n        }\n        datas.isRotate = false;\n        var params = fillEndParams(moveable, e, {});\n        triggerEvent(moveable, \"onRotateEnd\", params);\n        return params;\n    },\n    dragGroupControlCondition: dragControlCondition,\n    dragGroupControlStart: function(moveable, e) {\n        var datas = e.datas;\n        var _a = moveable.state, parentLeft = _a.left, parentTop = _a.top, parentBeforeOrigin = _a.beforeOrigin;\n        var params = this.dragControlStart(moveable, e);\n        if (!params) {\n            return false;\n        }\n        params.set(datas.beforeDirection * moveable.rotation);\n        var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function(child, ev) {\n            var _a = child.state, left = _a.left, top = _a.top, beforeOrigin = _a.beforeOrigin;\n            var childClient = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([\n                left,\n                top\n            ], [\n                parentLeft,\n                parentTop\n            ]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(beforeOrigin, parentBeforeOrigin));\n            ev.datas.startGroupClient = childClient;\n            ev.datas.groupClient = childClient;\n            return __assign(__assign({}, ev), {\n                parentRotate: 0\n            });\n        });\n        var nextParams = __assign(__assign({}, params), {\n            targets: moveable.props.targets,\n            events: events\n        });\n        var result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n        datas.isRotate = result !== false;\n        return datas.isRotate ? params : false;\n    },\n    dragGroupControl: function(moveable, e) {\n        var datas = e.datas;\n        if (!datas.isRotate) {\n            return;\n        }\n        catchEvent(moveable, \"onBeforeRotate\", function(parentEvent) {\n            triggerEvent(moveable, \"onBeforeRotateGroup\", fillParams(moveable, e, __assign(__assign({}, parentEvent), {\n                targets: moveable.props.targets\n            }), true));\n        });\n        var params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n        var direction = datas.beforeDirection;\n        var parentRotate = params.beforeDist;\n        var rad = parentRotate / 180 * Math.PI;\n        var events = triggerChildAbles(moveable, this, \"dragControl\", e, function(_, ev) {\n            var startGroupClient = ev.datas.startGroupClient;\n            var _a = __read(ev.datas.groupClient, 2), prevClientX = _a[0], prevClientY = _a[1];\n            var _b = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(startGroupClient, rad * direction), 2), clientX = _b[0], clientY = _b[1];\n            var delta = [\n                clientX - prevClientX,\n                clientY - prevClientY\n            ];\n            ev.datas.groupClient = [\n                clientX,\n                clientY\n            ];\n            return __assign(__assign({}, ev), {\n                parentRotate: parentRotate,\n                groupDelta: delta\n            });\n        });\n        moveable.rotation = direction * params.beforeRotation;\n        var nextParams = __assign({\n            targets: moveable.props.targets,\n            events: events,\n            set: function(rotation) {\n                moveable.rotation = rotation;\n            },\n            setGroupRotation: function(rotation) {\n                moveable.rotation = rotation;\n            }\n        }, params);\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd: function(moveable, e) {\n        var isDrag = e.isDrag, datas = e.datas;\n        if (!datas.isRotate) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        var events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n        var nextParams = fillEndParams(moveable, e, {\n            targets: moveable.props.targets,\n            events: events\n        });\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\r\n     * @method Moveable.Rotatable#request\r\n     * @param {object} [e] - the Resizable's request parameter\r\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\r\n     * @param {number} [e.rotate=0] - absolute number of moveable's rotation\r\n     * @return {Moveable.Requester} Moveable Requester\r\n     * @example\r\n\n     * // Instantly Request (requestStart - request - requestEnd)\r\n     * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\r\n     *\r\n     * * moveable.request(\"rotatable\", { rotate: 10 }, true);\r\n     *\r\n     * // requestStart\r\n     * const requester = moveable.request(\"rotatable\");\r\n     *\r\n     * // request\r\n     * requester.request({ deltaRotate: 10 });\r\n     * requester.request({ deltaRotate: 10 });\r\n     * requester.request({ deltaRotate: 10 });\r\n     *\r\n     * requester.request({ rotate: 10 });\r\n     * requester.request({ rotate: 20 });\r\n     * requester.request({ rotate: 30 });\r\n     *\r\n     * // requestEnd\r\n     * requester.requestEnd();\r\n     */ request: function(moveable) {\n        var datas = {};\n        var distRotate = 0;\n        var startRotation = moveable.getRotation();\n        return {\n            isControl: true,\n            requestStart: function() {\n                return {\n                    datas: datas\n                };\n            },\n            request: function(e) {\n                if (\"deltaRotate\" in e) {\n                    distRotate += e.deltaRotate;\n                } else if (\"rotate\" in e) {\n                    distRotate = e.rotate - startRotation;\n                }\n                return {\n                    datas: datas,\n                    parentDist: distRotate\n                };\n            },\n            requestEnd: function() {\n                return {\n                    datas: datas,\n                    isDrag: true\n                };\n            }\n        };\n    }\n};\n/**\r\n * Whether or not target can be rotated. (default: false)\r\n * @name Moveable.Rotatable#rotatable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.rotatable = true;\r\n */ /**\r\n * You can specify the position of the rotation. (default: \"top\")\r\n * @name Moveable.Rotatable#rotationPosition\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   rotationPosition: \"top\",\r\n * });\r\n *\r\n * moveable.rotationPosition = \"bottom\"\r\n */ /**\r\n * throttle of angle(degree) when rotate.\r\n * @name Moveable.Rotatable#throttleRotate\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.throttleRotate = 1;\r\n */ /**\r\n * When the rotate starts, the rotateStart event is called.\r\n * @memberof Moveable.Rotatable\r\n * @event rotateStart\r\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { rotatable: true });\r\n * moveable.on(\"rotateStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */ /**\r\n* When rotating, the rotate event is called.\r\n* @memberof Moveable.Rotatable\r\n* @event rotate\r\n* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, { rotatable: true });\r\n* moveable.on(\"rotate\", ({ target, transform, dist }) => {\r\n*     target.style.transform = transform;\r\n* });\r\n*/ /**\r\n * When the rotate finishes, the rotateEnd event is called.\r\n * @memberof Moveable.Rotatable\r\n * @event rotateEnd\r\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { rotatable: true });\r\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\r\n *     console.log(target, isDrag);\r\n * });\r\n */ /**\r\n * When the group rotate starts, the `rotateGroupStart` event is called.\r\n * @memberof Moveable.Rotatable\r\n * @event rotateGroupStart\r\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     rotatable: true\r\n * });\r\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\r\n *     console.log(\"onRotateGroupStart\", targets);\r\n * });\r\n */ /**\r\n* When the group rotate, the `rotateGroup` event is called.\r\n* @memberof Moveable.Rotatable\r\n* @event rotateGroup\r\n* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     rotatable: true\r\n* });\r\n* moveable.on(\"rotateGroup\", ({ targets, events }) => {\r\n*     console.log(\"onRotateGroup\", targets);\r\n*     events.forEach(ev => {\r\n*         const target = ev.target;\r\n*         // ev.drag is a drag event that occurs when the group rotate.\r\n*         const left = ev.drag.beforeDist[0];\r\n*         const top = ev.drag.beforeDist[1];\r\n*         const deg = ev.beforeDist;\r\n*     });\r\n* });\r\n*/ /**\r\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\r\n * @memberof Moveable.Rotatable\r\n * @event rotateGroupEnd\r\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     rotatable: true\r\n * });\r\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\r\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\r\n * });\r\n */ function renderGuideline(info, React) {\n    var _a;\n    var direction = info.direction, classNames = info.classNames, size = info.size, pos = info.pos, zoom = info.zoom, key = info.key;\n    var isHorizontal = direction === \"horizontal\";\n    var scaleType = isHorizontal ? \"Y\" : \"X\";\n    // const scaleType2 = isHorizontal ? \"Y\" : \"X\";\n    return React.createElement(\"div\", {\n        key: key,\n        className: classNames.join(\" \"),\n        style: (_a = {}, _a[isHorizontal ? \"width\" : \"height\"] = \"\".concat(size), _a.transform = \"translate(\".concat(pos[0], \", \").concat(pos[1], \") translate\").concat(scaleType, \"(-50%) scale\").concat(scaleType, \"(\").concat(zoom, \")\"), _a)\n    });\n}\nfunction renderInnerGuideline(info, React) {\n    return renderGuideline(__assign(__assign({}, info), {\n        classNames: __spreadArray([\n            prefix(\"line\", \"guideline\", info.direction)\n        ], __read(info.classNames), false).filter(function(className) {\n            return className;\n        }),\n        size: info.size || \"\".concat(info.sizeValue, \"px\"),\n        pos: info.pos || info.posValue.map(function(v) {\n            return \"\".concat((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(v, 0.1), \"px\");\n        })\n    }), React);\n}\nfunction renderSnapPoses(moveable, direction, snapPoses, minPos, targetPos, size, index, React) {\n    var zoom = moveable.props.zoom;\n    return snapPoses.map(function(_a, i) {\n        var type = _a.type, pos = _a.pos;\n        var renderPos = [\n            0,\n            0\n        ];\n        renderPos[index] = minPos;\n        renderPos[index ? 0 : 1] = -targetPos + pos;\n        return renderInnerGuideline({\n            key: \"\".concat(direction, \"TargetGuideline\").concat(i),\n            classNames: [\n                prefix(\"target\", \"bold\", type)\n            ],\n            posValue: renderPos,\n            sizeValue: size,\n            zoom: zoom,\n            direction: direction\n        }, React);\n    });\n}\nfunction renderGuidelines(moveable, type, guidelines, targetPos, targetRect, React) {\n    var _a = moveable.props, zoom = _a.zoom, isDisplayInnerSnapDigit = _a.isDisplayInnerSnapDigit;\n    var mainNames = type === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    var targetStart = targetRect[mainNames.start];\n    var targetEnd = targetRect[mainNames.end];\n    return guidelines.filter(function(_a) {\n        var hide = _a.hide, elementRect = _a.elementRect;\n        if (hide) {\n            return false;\n        }\n        if (isDisplayInnerSnapDigit && elementRect) {\n            // inner\n            var rect = elementRect.rect;\n            if (rect[mainNames.start] <= targetStart && targetEnd <= rect[mainNames.end]) {\n                return false;\n            }\n        }\n        return true;\n    }).map(function(guideline, i) {\n        var pos = guideline.pos, size = guideline.size, element = guideline.element, className = guideline.className;\n        var renderPos = [\n            -targetPos[0] + pos[0],\n            -targetPos[1] + pos[1]\n        ];\n        return renderInnerGuideline({\n            key: \"\".concat(type, \"-default-guideline-\").concat(i),\n            classNames: element ? [\n                prefix(\"bold\"),\n                className\n            ] : [\n                prefix(\"normal\"),\n                className\n            ],\n            direction: type,\n            posValue: renderPos,\n            sizeValue: size,\n            zoom: zoom\n        }, React);\n    });\n}\nfunction renderDigitLine(moveable, type, lineType, index, gap, renderPos, className, React) {\n    var _a;\n    var _b = moveable.props, _c = _b.snapDigit, snapDigit = _c === void 0 ? 0 : _c, _d = _b.isDisplaySnapDigit, isDisplaySnapDigit = _d === void 0 ? true : _d, _e = _b.snapDistFormat, snapDistFormat = _e === void 0 ? function(v, type) {\n        // Type can be used render different values.\n        if (type === \"vertical\") {\n            return v;\n        }\n        return v;\n    } : _e, zoom = _b.zoom;\n    var scaleType = type === \"horizontal\" ? \"X\" : \"Y\";\n    var sizeName = type === \"vertical\" ? \"height\" : \"width\";\n    var absGap = Math.abs(gap);\n    var snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;\n    return React.createElement(\"div\", {\n        key: \"\".concat(type, \"-\").concat(lineType, \"-guideline-\").concat(index),\n        className: prefix(\"guideline-group\", type),\n        style: (_a = {\n            left: \"\".concat(renderPos[0], \"px\"),\n            top: \"\".concat(renderPos[1], \"px\")\n        }, _a[sizeName] = \"\".concat(absGap, \"px\"), _a)\n    }, renderInnerGuideline({\n        direction: type,\n        classNames: [\n            prefix(lineType),\n            className\n        ],\n        size: \"100%\",\n        posValue: [\n            0,\n            0\n        ],\n        sizeValue: absGap,\n        zoom: zoom\n    }, React), React.createElement(\"div\", {\n        className: prefix(\"size-value\", \"gap\"),\n        style: {\n            transform: \"translate\".concat(scaleType, \"(-50%) scale(\").concat(zoom, \")\")\n        }\n    }, snapSize > 0 ? snapDistFormat(snapSize, type) : \"\"));\n}\nfunction groupByElementGuidelines(type, guidelines, targetRect, isDisplayInnerSnapDigit) {\n    var index = type === \"vertical\" ? 0 : 1;\n    var otherIndex = type === \"vertical\" ? 1 : 0;\n    var names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    var targetStart = targetRect[names.start];\n    var targetEnd = targetRect[names.end];\n    return groupBy(guidelines, function(guideline) {\n        return guideline.pos[index];\n    }).map(function(nextGuidelines) {\n        var start = [];\n        var end = [];\n        var inner = [];\n        nextGuidelines.forEach(function(guideline) {\n            var _a, _b;\n            var element = guideline.element;\n            var rect = guideline.elementRect.rect;\n            if (rect[names.end] < targetStart) {\n                start.push(guideline);\n            } else if (targetEnd < rect[names.start]) {\n                end.push(guideline);\n            } else if (rect[names.start] <= targetStart && targetEnd <= rect[names.end] && isDisplayInnerSnapDigit) {\n                var pos = guideline.pos;\n                var elementRect1 = {\n                    element: element,\n                    rect: __assign(__assign({}, rect), (_a = {}, _a[names.end] = rect[names.start], _a))\n                };\n                var elementRect2 = {\n                    element: element,\n                    rect: __assign(__assign({}, rect), (_b = {}, _b[names.start] = rect[names.end], _b))\n                };\n                var nextPos1 = [\n                    0,\n                    0\n                ];\n                var nextPos2 = [\n                    0,\n                    0\n                ];\n                nextPos1[index] = pos[index];\n                nextPos1[otherIndex] = pos[otherIndex];\n                nextPos2[index] = pos[index];\n                nextPos2[otherIndex] = pos[otherIndex] + guideline.size;\n                start.push({\n                    type: type,\n                    pos: nextPos1,\n                    size: 0,\n                    elementRect: elementRect1,\n                    direction: \"\",\n                    elementDirection: \"end\"\n                });\n                end.push({\n                    type: type,\n                    pos: nextPos2,\n                    size: 0,\n                    elementRect: elementRect2,\n                    direction: \"\",\n                    elementDirection: \"start\"\n                });\n            // inner.push(guideline);\n            }\n        });\n        start.sort(function(a, b) {\n            return b.pos[otherIndex] - a.pos[otherIndex];\n        });\n        end.sort(function(a, b) {\n            return a.pos[otherIndex] - b.pos[otherIndex];\n        });\n        return {\n            total: nextGuidelines,\n            start: start,\n            end: end,\n            inner: inner\n        };\n    });\n}\nfunction renderDashedGuidelines(moveable, guidelines, targetPos, targetRect, React) {\n    var isDisplayInnerSnapDigit = moveable.props.isDisplayInnerSnapDigit;\n    var rendered = [];\n    [\n        \"vertical\",\n        \"horizontal\"\n    ].forEach(function(type) {\n        var nextGuidelines = guidelines.filter(function(guideline) {\n            return guideline.type === type;\n        });\n        var index = type === \"vertical\" ? 1 : 0;\n        var otherIndex = index ? 0 : 1;\n        var groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit);\n        var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n        var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n        var targetStart = targetRect[mainNames.start];\n        var targetEnd = targetRect[mainNames.end];\n        groups.forEach(function(_a) {\n            var total = _a.total, start = _a.start, end = _a.end, inner = _a.inner;\n            var sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start];\n            var prevRect = targetRect;\n            start.forEach(function(guideline) {\n                var nextRect = guideline.elementRect.rect;\n                var size = prevRect[mainNames.start] - nextRect[mainNames.end];\n                if (size > 0) {\n                    var renderPos = [\n                        0,\n                        0\n                    ];\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.start] - targetStart - size;\n                    renderPos[otherIndex] = sidePos;\n                    rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size, renderPos, guideline.className, React));\n                }\n                prevRect = nextRect;\n            });\n            prevRect = targetRect;\n            end.forEach(function(guideline) {\n                var nextRect = guideline.elementRect.rect;\n                var size = nextRect[mainNames.start] - prevRect[mainNames.end];\n                if (size > 0) {\n                    var renderPos = [\n                        0,\n                        0\n                    ];\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.end] - targetStart;\n                    renderPos[otherIndex] = sidePos;\n                    rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size, renderPos, guideline.className, React));\n                }\n                prevRect = nextRect;\n            });\n            inner.forEach(function(guideline) {\n                var nextRect = guideline.elementRect.rect;\n                var size1 = targetStart - nextRect[mainNames.start];\n                var size2 = nextRect[mainNames.end] - targetEnd;\n                var renderPos1 = [\n                    0,\n                    0\n                ];\n                var renderPos2 = [\n                    0,\n                    0\n                ];\n                renderPos1[index] = targetPos[index] - size1;\n                renderPos1[otherIndex] = sidePos;\n                renderPos2[index] = targetPos[index] + targetEnd - targetStart;\n                renderPos2[otherIndex] = sidePos;\n                rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size1, renderPos1, guideline.className, React));\n                rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size2, renderPos2, guideline.className, React));\n            });\n        });\n    });\n    return rendered;\n}\nfunction renderGapGuidelines(moveable, guidelines, targetPos, targetRect, React) {\n    var rendered = [];\n    [\n        \"horizontal\",\n        \"vertical\"\n    ].forEach(function(type) {\n        var nextGuidelines = guidelines.filter(function(guideline) {\n            return guideline.type === type;\n        }).slice(0, 1);\n        var index = type === \"vertical\" ? 0 : 1;\n        var otherIndex = index ? 0 : 1;\n        var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n        var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n        var targetStart = targetRect[mainNames.start];\n        var targetEnd = targetRect[mainNames.end];\n        var targetSideStart = targetRect[sideNames.start];\n        var targetSideEnd = targetRect[sideNames.end];\n        nextGuidelines.forEach(function(_a) {\n            var gap = _a.gap, gapRects = _a.gapRects;\n            var sideStartPos = Math.max.apply(Math, __spreadArray([\n                targetSideStart\n            ], __read(gapRects.map(function(_a) {\n                var rect = _a.rect;\n                return rect[sideNames.start];\n            })), false));\n            var sideEndPos = Math.min.apply(Math, __spreadArray([\n                targetSideEnd\n            ], __read(gapRects.map(function(_a) {\n                var rect = _a.rect;\n                return rect[sideNames.end];\n            })), false));\n            var sideCenterPos = (sideStartPos + sideEndPos) / 2;\n            if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd) / 2) {\n                return;\n            }\n            gapRects.forEach(function(_a) {\n                var rect = _a.rect, className = _a.className;\n                var renderPos = [\n                    targetPos[0],\n                    targetPos[1]\n                ];\n                if (rect[mainNames.end] < targetStart) {\n                    renderPos[index] += rect[mainNames.end] - targetStart;\n                } else if (targetEnd < rect[mainNames.start]) {\n                    renderPos[index] += rect[mainNames.start] - targetStart - gap;\n                } else {\n                    return;\n                }\n                renderPos[otherIndex] += sideCenterPos - targetSideStart;\n                rendered.push(renderDigitLine(moveable, index ? \"vertical\" : \"horizontal\", \"gap\", rendered.length, gap, renderPos, className, React));\n            });\n        });\n    });\n    return rendered;\n}\nfunction getTotalGuidelines(moveable) {\n    var _a, _b;\n    var state = moveable.state;\n    var containerClientRect = state.containerClientRect, hasFixed = state.hasFixed;\n    var overflow = containerClientRect.overflow, containerHeight = containerClientRect.scrollHeight, containerWidth = containerClientRect.scrollWidth, containerClientHeight = containerClientRect.clientHeight, containerClientWidth = containerClientRect.clientWidth, clientLeft = containerClientRect.clientLeft, clientTop = containerClientRect.clientTop;\n    var _c = moveable.props, _d = _c.snapGap, snapGap = _d === void 0 ? true : _d, verticalGuidelines = _c.verticalGuidelines, horizontalGuidelines = _c.horizontalGuidelines, _e = _c.snapThreshold, snapThreshold = _e === void 0 ? 5 : _e, _f = _c.maxSnapElementGuidelineDistance, maxSnapElementGuidelineDistance = _f === void 0 ? Infinity : _f, isDisplayGridGuidelines = _c.isDisplayGridGuidelines;\n    var _g = getRect(getAbsolutePosesByState(moveable.state)), top = _g.top, left = _g.left, bottom = _g.bottom, right = _g.right;\n    var targetRect = {\n        top: top,\n        left: left,\n        bottom: bottom,\n        right: right,\n        center: (left + right) / 2,\n        middle: (top + bottom) / 2\n    };\n    var elementGuidelines = getElementGuidelines(moveable);\n    var totalGuidelines = __spreadArray([], __read(elementGuidelines), false);\n    var snapThresholdMultiples = ((_b = (_a = state.snapThresholdInfo) === null || _a === void 0 ? void 0 : _a.multiples) !== null && _b !== void 0 ? _b : [\n        1,\n        1\n    ]).map(function(n) {\n        return n * snapThreshold;\n    });\n    if (snapGap) {\n        totalGuidelines.push.apply(totalGuidelines, __spreadArray([], __read(getGapGuidelines(moveable, targetRect, snapThresholdMultiples)), false));\n    }\n    var snapOffset = __assign({}, state.snapOffset || {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0\n    });\n    totalGuidelines.push.apply(totalGuidelines, __spreadArray([], __read(getGridGuidelines(moveable, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset, isDisplayGridGuidelines)), false));\n    if (hasFixed) {\n        var left_1 = containerClientRect.left, top_1 = containerClientRect.top;\n        snapOffset.left += left_1;\n        snapOffset.top += top_1;\n        snapOffset.right += left_1;\n        snapOffset.bottom += top_1;\n    }\n    totalGuidelines.push.apply(totalGuidelines, __spreadArray([], __read(getDefaultGuidelines(horizontalGuidelines || false, verticalGuidelines || false, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset)), false));\n    totalGuidelines = totalGuidelines.filter(function(_a) {\n        var element = _a.element, elementRect = _a.elementRect, type = _a.type;\n        if (!element || !elementRect) {\n            return true;\n        }\n        var rect = elementRect.rect;\n        return checkBetweenRects(targetRect, rect, type, maxSnapElementGuidelineDistance);\n    });\n    return totalGuidelines;\n}\nfunction getGapGuidelines(moveable, targetRect, snapThresholds) {\n    var _a = moveable.props, _b = _a.maxSnapElementGuidelineDistance, maxSnapElementGuidelineDistance = _b === void 0 ? Infinity : _b, _c = _a.maxSnapElementGapDistance, maxSnapElementGapDistance = _c === void 0 ? Infinity : _c;\n    var elementRects = moveable.state.elementRects;\n    var gapGuidelines = [];\n    [\n        [\n            \"vertical\",\n            VERTICAL_NAMES_MAP,\n            HORIZONTAL_NAMES_MAP\n        ],\n        [\n            \"horizontal\",\n            HORIZONTAL_NAMES_MAP,\n            VERTICAL_NAMES_MAP\n        ]\n    ].forEach(function(_a) {\n        var _b = __read(_a, 3), type = _b[0], mainNames = _b[1], sideNames = _b[2];\n        var targetStart = targetRect[mainNames.start];\n        var targetEnd = targetRect[mainNames.end];\n        var targetCenter = targetRect[mainNames.center];\n        var targetStart2 = targetRect[sideNames.start];\n        var targetEnd2 = targetRect[sideNames.end];\n        // element : moveable\n        var snapThresholdMap = {\n            left: snapThresholds[0],\n            top: snapThresholds[1]\n        };\n        function getDist(elementRect) {\n            var rect = elementRect.rect;\n            var snapThreshold = snapThresholdMap[mainNames.start];\n            if (rect[mainNames.end] < targetStart + snapThreshold) {\n                return targetStart - rect[mainNames.end];\n            } else if (targetEnd - snapThreshold < rect[mainNames.start]) {\n                return rect[mainNames.start] - targetEnd;\n            } else {\n                return -1;\n            }\n        }\n        var nextElementRects = elementRects.filter(function(elementRect) {\n            var rect = elementRect.rect;\n            if (rect[sideNames.start] > targetEnd2 || rect[sideNames.end] < targetStart2) {\n                return false;\n            }\n            return getDist(elementRect) > 0;\n        }).sort(function(a, b) {\n            return getDist(a) - getDist(b);\n        });\n        var groups = [];\n        nextElementRects.forEach(function(snapRect1) {\n            nextElementRects.forEach(function(snapRect2) {\n                if (snapRect1 === snapRect2) {\n                    return;\n                }\n                var rect1 = snapRect1.rect;\n                var rect2 = snapRect2.rect;\n                var rect1Start = rect1[sideNames.start];\n                var rect1End = rect1[sideNames.end];\n                var rect2Start = rect2[sideNames.start];\n                var rect2End = rect2[sideNames.end];\n                if (rect1Start > rect2End || rect2Start > rect1End) {\n                    return;\n                }\n                groups.push([\n                    snapRect1,\n                    snapRect2\n                ]);\n            });\n        });\n        groups.forEach(function(_a) {\n            var _b = __read(_a, 2), snapRect1 = _b[0], snapRect2 = _b[1];\n            var rect1 = snapRect1.rect;\n            var rect2 = snapRect2.rect;\n            var rect1Start = rect1[mainNames.start];\n            var rect1End = rect1[mainNames.end];\n            var rect2Start = rect2[mainNames.start];\n            var rect2End = rect2[mainNames.end];\n            var snapThreshold = snapThresholdMap[mainNames.start];\n            var gap = 0;\n            var pos = 0;\n            var isStart = false;\n            var isCenter = false;\n            var isEnd = false;\n            if (rect1End <= targetStart && targetEnd <= rect2Start) {\n                // (l)element1(r) : (l)target(r) : (l)element2(r)\n                isCenter = true;\n                gap = (rect2Start - rect1End - (targetEnd - targetStart)) / 2;\n                pos = rect1End + gap + (targetEnd - targetStart) / 2;\n                if (abs(pos - targetCenter) > snapThreshold) {\n                    return;\n                }\n            } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {\n                // (l)element1(r) : (l)element2(r) : (l)target\n                isStart = true;\n                gap = rect2Start - rect1End;\n                pos = rect2End + gap;\n                if (abs(pos - targetStart) > snapThreshold) {\n                    return;\n                }\n            } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {\n                // target(r) : (l)element1(r) : (l)element2(r)\n                isEnd = true;\n                gap = rect2Start - rect1End;\n                pos = rect1Start - gap;\n                if (abs(pos - targetEnd) > snapThreshold) {\n                    return;\n                }\n            } else {\n                return;\n            }\n            if (!gap) {\n                return;\n            }\n            if (!checkBetweenRects(targetRect, rect2, type, maxSnapElementGuidelineDistance)) {\n                return;\n            }\n            if (gap > maxSnapElementGapDistance) {\n                return;\n            }\n            gapGuidelines.push({\n                type: type,\n                pos: type === \"vertical\" ? [\n                    pos,\n                    0\n                ] : [\n                    0,\n                    pos\n                ],\n                element: snapRect2.element,\n                size: 0,\n                className: snapRect2.className,\n                isStart: isStart,\n                isCenter: isCenter,\n                isEnd: isEnd,\n                gap: gap,\n                hide: true,\n                gapRects: [\n                    snapRect1,\n                    snapRect2\n                ],\n                direction: \"\",\n                elementDirection: \"\"\n            });\n        });\n    });\n    return gapGuidelines;\n}\nfunction startGridGroupGuidelines(moveable, clientLeft, clientTop, snapOffset) {\n    var _a, _b;\n    var props = moveable.props;\n    var state = moveable.state;\n    var snapGridAll = props.snapGridAll;\n    var _c = props.snapGridWidth, snapGridWidth = _c === void 0 ? 0 : _c, _d = props.snapGridHeight, snapGridHeight = _d === void 0 ? 0 : _d;\n    var snapRenderInfo = state.snapRenderInfo;\n    var hasDirection = snapRenderInfo && (((_a = snapRenderInfo.direction) === null || _a === void 0 ? void 0 : _a[0]) || ((_b = snapRenderInfo.direction) === null || _b === void 0 ? void 0 : _b[1]));\n    var moveables = moveable.moveables;\n    // snap group's all child to grid.\n    if (snapGridAll && moveables && hasDirection && (snapGridWidth || snapGridHeight)) {\n        if (state.snapThresholdInfo) {\n            return;\n        }\n        state.snapThresholdInfo = {\n            multiples: [\n                1,\n                1\n            ],\n            offset: [\n                0,\n                0\n            ]\n        };\n        var rect_1 = moveable.getRect();\n        var children_1 = rect_1.children;\n        var direction = snapRenderInfo.direction;\n        if (children_1) {\n            var result = direction.map(function(dir, i) {\n                var _a = i === 0 ? {\n                    snapSize: snapGridWidth,\n                    posName: \"left\",\n                    sizeName: \"width\",\n                    clientOffset: snapOffset.left - clientLeft\n                } : {\n                    snapSize: snapGridHeight,\n                    posName: \"top\",\n                    sizeName: \"height\",\n                    clientOffset: snapOffset.top - clientTop\n                }, snapSize = _a.snapSize, posName = _a.posName, sizeName = _a.sizeName, clientOffset = _a.clientOffset;\n                if (!snapSize) {\n                    return {\n                        dir: dir,\n                        multiple: 1,\n                        snapSize: snapSize,\n                        snapOffset: 0\n                    };\n                }\n                var rectSize = rect_1[sizeName];\n                var rectPos = rect_1[posName];\n                //     ?\n                var childSizes = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.flat)(children_1.map(function(child) {\n                    return [\n                        child[posName] - rectPos,\n                        child[sizeName],\n                        rectSize - child[sizeName] - child[posName] + rectPos\n                    ];\n                })).filter(function(v) {\n                    return v;\n                }).sort(function(a, b) {\n                    return a - b;\n                });\n                var firstChildSize = childSizes[0];\n                var childSnapSizes = childSizes.map(function(size) {\n                    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(size / firstChildSize, 0.1) * snapSize;\n                });\n                var n = 1;\n                var rectRatio = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(rectSize / firstChildSize, 0.1);\n                for(n = 1; n <= 10; ++n){\n                    if (childSnapSizes.every(function(childSize) {\n                        return childSize * n % 1 === 0;\n                    })) {\n                        break;\n                    }\n                }\n                // dir 1 (fixed -1)\n                // dir 0 (fixed 0)\n                // dir -1 (fixed 1)\n                var ratio = (-dir + 1) / 2;\n                var offsetPos = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.dot)(rectPos - clientOffset, rectPos - clientOffset + rectSize, ratio, 1 - ratio);\n                return {\n                    multiple: rectRatio * n,\n                    dir: dir,\n                    snapSize: snapSize,\n                    snapOffset: Math.round(offsetPos / snapSize)\n                };\n            });\n            var multiples = result.map(function(r) {\n                return r.multiple || 1;\n            });\n            state.snapThresholdInfo.multiples = multiples;\n            state.snapThresholdInfo.offset = result.map(function(r) {\n                return r.snapOffset;\n            });\n            result.forEach(function(r, i) {\n                if (r.snapSize) ;\n            });\n        }\n    } else {\n        state.snapThresholdInfo = null;\n    }\n}\nfunction getGridGuidelines(moveable, containerWidth, containerHeight, clientLeft, clientTop, snapOffset, isDisplayGridGuidelines) {\n    if (clientLeft === void 0) {\n        clientLeft = 0;\n    }\n    if (clientTop === void 0) {\n        clientTop = 0;\n    }\n    var props = moveable.props;\n    var state = moveable.state;\n    var _a = props.snapGridWidth, snapGridWidth = _a === void 0 ? 0 : _a, _b = props.snapGridHeight, snapGridHeight = _b === void 0 ? 0 : _b;\n    var guidelines = [];\n    var snapOffsetLeft = snapOffset.left, snapOffsetTop = snapOffset.top;\n    var startOffset = [\n        0,\n        0\n    ];\n    startGridGroupGuidelines(moveable, clientLeft, clientTop, snapOffset);\n    var snapThresholdInfo = state.snapThresholdInfo;\n    var defaultSnapGridWidth = snapGridWidth;\n    var defaultSnapGridHeight = snapGridHeight;\n    if (snapThresholdInfo) {\n        snapGridWidth *= snapThresholdInfo.multiples[0] || 1;\n        snapGridHeight *= snapThresholdInfo.multiples[1] || 1;\n        startOffset = snapThresholdInfo.offset;\n    }\n    if (snapGridHeight) {\n        var pushGuideline = function(pos) {\n            guidelines.push({\n                type: \"horizontal\",\n                pos: [\n                    snapOffsetLeft,\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(startOffset[1] * defaultSnapGridHeight + pos - clientTop + snapOffsetTop, 0.1)\n                ],\n                className: prefix(\"grid-guideline\"),\n                size: containerWidth,\n                hide: !isDisplayGridGuidelines,\n                direction: \"\",\n                grid: true\n            });\n        };\n        for(var pos = 0; pos <= containerHeight * 2; pos += snapGridHeight){\n            pushGuideline(pos);\n        }\n        for(var pos = -snapGridHeight; pos >= -containerHeight; pos -= snapGridHeight){\n            pushGuideline(pos);\n        }\n    }\n    if (snapGridWidth) {\n        var pushGuideline = function(pos) {\n            guidelines.push({\n                type: \"vertical\",\n                pos: [\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(startOffset[0] * defaultSnapGridWidth + pos - clientLeft + snapOffsetLeft, 0.1),\n                    snapOffsetTop\n                ],\n                className: prefix(\"grid-guideline\"),\n                size: containerHeight,\n                hide: !isDisplayGridGuidelines,\n                direction: \"\",\n                grid: true\n            });\n        };\n        for(var pos = 0; pos <= containerWidth * 2; pos += snapGridWidth){\n            pushGuideline(pos);\n        }\n        for(var pos = -snapGridWidth; pos >= -containerWidth; pos -= snapGridWidth){\n            pushGuideline(pos);\n        }\n    }\n    return guidelines;\n}\nfunction checkBetweenRects(rect1, rect2, type, distance) {\n    if (type === \"horizontal\") {\n        return abs(rect1.right - rect2.left) <= distance || abs(rect1.left - rect2.right) <= distance || rect1.left <= rect2.right && rect2.left <= rect1.right;\n    } else if (type === \"vertical\") {\n        return abs(rect1.bottom - rect2.top) <= distance || abs(rect1.top - rect2.bottom) <= distance || rect1.top <= rect2.bottom && rect2.top <= rect1.bottom;\n    }\n    return true;\n}\nfunction getElementGuidelines(moveable) {\n    var state = moveable.state;\n    var _a = moveable.props.elementGuidelines, elementGuidelines = _a === void 0 ? [] : _a;\n    if (!elementGuidelines.length) {\n        state.elementRects = [];\n        return [];\n    }\n    var prevValues = (state.elementRects || []).filter(function(snapRect) {\n        return !snapRect.refresh;\n    });\n    var nextElementGuidelines = elementGuidelines.map(function(el) {\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(el) && \"element\" in el) {\n            return __assign(__assign({}, el), {\n                element: getRefTarget(el.element, true)\n            });\n        }\n        return {\n            element: getRefTarget(el, true)\n        };\n    }).filter(function(value) {\n        return value.element;\n    });\n    var _b = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_5__.diff)(prevValues.map(function(v) {\n        return v.element;\n    }), nextElementGuidelines.map(function(v) {\n        return v.element;\n    })), maintained = _b.maintained, added = _b.added;\n    var nextValues = [];\n    maintained.forEach(function(_a) {\n        var _b = __read(_a, 2), prevIndex = _b[0], nextIndex = _b[1];\n        nextValues[nextIndex] = prevValues[prevIndex];\n    });\n    getSnapElementRects(moveable, added.map(function(index) {\n        return nextElementGuidelines[index];\n    })).map(function(rect, i) {\n        nextValues[added[i]] = rect;\n    });\n    state.elementRects = nextValues;\n    var elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);\n    var nextGuidelines = [];\n    nextValues.forEach(function(snapRect) {\n        var element = snapRect.element, _a = snapRect.top, topValue = _a === void 0 ? elementSnapDirections.top : _a, _b = snapRect.left, leftValue = _b === void 0 ? elementSnapDirections.left : _b, _c = snapRect.right, rightValue = _c === void 0 ? elementSnapDirections.right : _c, _d = snapRect.bottom, bottomValue = _d === void 0 ? elementSnapDirections.bottom : _d, _e = snapRect.center, centerValue = _e === void 0 ? elementSnapDirections.center : _e, _f = snapRect.middle, middleValue = _f === void 0 ? elementSnapDirections.middle : _f, className = snapRect.className, rect = snapRect.rect;\n        var _g = splitSnapDirectionPoses({\n            top: topValue,\n            right: rightValue,\n            left: leftValue,\n            bottom: bottomValue,\n            center: centerValue,\n            middle: middleValue\n        }, rect), horizontal = _g.horizontal, vertical = _g.vertical, horizontalNames = _g.horizontalNames, verticalNames = _g.verticalNames;\n        var rectTop = rect.top;\n        var rectLeft = rect.left;\n        var width = rect.right - rectLeft;\n        var height = rect.bottom - rectTop;\n        var sizes = [\n            width,\n            height\n        ];\n        vertical.forEach(function(pos, i) {\n            nextGuidelines.push({\n                type: \"vertical\",\n                element: element,\n                pos: [\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(pos, 0.1),\n                    rectTop\n                ],\n                size: height,\n                sizes: sizes,\n                className: className,\n                elementRect: snapRect,\n                elementDirection: SNAP_SKIP_NAMES_MAP[verticalNames[i]] || verticalNames[i],\n                direction: \"\"\n            });\n        });\n        horizontal.forEach(function(pos, i) {\n            nextGuidelines.push({\n                type: \"horizontal\",\n                element: element,\n                pos: [\n                    rectLeft,\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(pos, 0.1)\n                ],\n                size: width,\n                sizes: sizes,\n                className: className,\n                elementRect: snapRect,\n                elementDirection: SNAP_SKIP_NAMES_MAP[horizontalNames[i]] || horizontalNames[i],\n                direction: \"\"\n            });\n        });\n    });\n    return nextGuidelines;\n}\nfunction getObjectGuidelines(guidelines, containerSize) {\n    return guidelines ? guidelines.map(function(info) {\n        var posGuideline = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(info) ? info : {\n            pos: info\n        };\n        var pos = posGuideline.pos;\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(pos)) {\n            return posGuideline;\n        } else {\n            return __assign(__assign({}, posGuideline), {\n                pos: (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(pos, containerSize)\n            });\n        }\n    }) : [];\n}\nfunction getDefaultGuidelines(horizontalGuidelines, verticalGuidelines, width, height, clientLeft, clientTop, snapOffset) {\n    if (clientLeft === void 0) {\n        clientLeft = 0;\n    }\n    if (clientTop === void 0) {\n        clientTop = 0;\n    }\n    if (snapOffset === void 0) {\n        snapOffset = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n    }\n    var guidelines = [];\n    var snapOffsetLeft = snapOffset.left, snapOffsetTop = snapOffset.top, snapOffsetBottom = snapOffset.bottom, snapOffsetRight = snapOffset.right;\n    var snapWidth = width + snapOffsetRight - snapOffsetLeft;\n    var snapHeight = height + snapOffsetBottom - snapOffsetTop;\n    getObjectGuidelines(horizontalGuidelines, snapHeight).forEach(function(posInfo) {\n        guidelines.push({\n            type: \"horizontal\",\n            pos: [\n                snapOffsetLeft,\n                (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(posInfo.pos - clientTop + snapOffsetTop, 0.1)\n            ],\n            size: snapWidth,\n            className: posInfo.className,\n            direction: \"\"\n        });\n    });\n    getObjectGuidelines(verticalGuidelines, snapWidth).forEach(function(posInfo) {\n        guidelines.push({\n            type: \"vertical\",\n            pos: [\n                (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(posInfo.pos - clientLeft + snapOffsetLeft, 0.1),\n                snapOffsetTop\n            ],\n            size: snapHeight,\n            className: posInfo.className,\n            direction: \"\"\n        });\n    });\n    return guidelines;\n}\nfunction getSnapElementRects(moveable, values) {\n    if (!values.length) {\n        return [];\n    }\n    var groupable = moveable.props.groupable;\n    var state = moveable.state;\n    var containerClientRect = state.containerClientRect, // targetClientRect: {\n    //     top: clientTop,\n    //     left: clientLeft,\n    // },\n    rootMatrix = state.rootMatrix, is3d = state.is3d, offsetDelta = state.offsetDelta;\n    var n = is3d ? 4 : 3;\n    var _a = __read(calculateContainerPos(rootMatrix, containerClientRect, n), 2), containerLeft = _a[0], containerTop = _a[1];\n    // const poses = getAbsolutePosesByState(state);\n    // const {\n    //     minX: targetLeft,\n    //     minY: targetTop,\n    // } = getMinMaxs(poses);\n    // const [distLeft, distTop] = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [\n    //     clientLeft - containerLeft,\n    //     clientTop - containerTop,\n    // ], n)).map(pos => roundSign(pos));\n    var offsetLeft = groupable ? 0 : offsetDelta[0];\n    var offsetTop = groupable ? 0 : offsetDelta[1];\n    return values.map(function(value) {\n        var rect = value.element.getBoundingClientRect();\n        var left = rect.left - containerLeft - offsetLeft;\n        var top = rect.top - containerTop - offsetTop;\n        var bottom = top + rect.height;\n        var right = left + rect.width;\n        var _a = __read(calculateInversePosition(rootMatrix, [\n            left,\n            top\n        ], n), 2), elementLeft = _a[0], elementTop = _a[1];\n        var _b = __read(calculateInversePosition(rootMatrix, [\n            right,\n            bottom\n        ], n), 2), elementRight = _b[0], elementBottom = _b[1];\n        return __assign(__assign({}, value), {\n            rect: {\n                left: elementLeft,\n                right: elementRight,\n                top: elementTop,\n                bottom: elementBottom,\n                center: (elementLeft + elementRight) / 2,\n                middle: (elementTop + elementBottom) / 2\n            }\n        });\n    });\n}\nfunction checkSnapInfo(moveable) {\n    var state = moveable.state;\n    var container = state.container;\n    var snapContainer = moveable.props.snapContainer || container;\n    if (state.snapContainer === snapContainer && state.guidelines && state.guidelines.length) {\n        return false;\n    }\n    var containerClientRect = state.containerClientRect;\n    var snapOffset = {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0\n    };\n    if (container !== snapContainer) {\n        var snapContainerTarget = getRefTarget(snapContainer, true);\n        if (snapContainerTarget) {\n            var snapContainerRect = getClientRect(snapContainerTarget);\n            var offset1 = getDragDistByState(state, [\n                snapContainerRect.left - containerClientRect.left,\n                snapContainerRect.top - containerClientRect.top\n            ]);\n            var offset2 = getDragDistByState(state, [\n                snapContainerRect.right - containerClientRect.right,\n                snapContainerRect.bottom - containerClientRect.bottom\n            ]);\n            snapOffset.left = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(offset1[0], 0.00001);\n            snapOffset.top = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(offset1[1], 0.00001);\n            snapOffset.right = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(offset2[0], 0.00001);\n            snapOffset.bottom = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(offset2[1], 0.00001);\n        }\n    }\n    state.snapContainer = snapContainer;\n    state.snapOffset = snapOffset;\n    state.guidelines = getTotalGuidelines(moveable);\n    state.enableSnap = true;\n    return true;\n}\nfunction getNextFixedPoses(matrix, width, height, fixedDirection, fixedPos, is3d) {\n    var nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);\n    var nextFixedPos = getPosByDirection(nextPoses, fixedDirection);\n    return getAbsolutePoses(nextPoses, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedPos, nextFixedPos));\n}\nfunction normalized(value) {\n    return value ? value / abs(value) : 0;\n}\nfunction getSizeOffsetInfo(moveable, poses, direction, keepRatio, isRequest, datas) {\n    var fixedDirection = datas.fixedDirection;\n    var directions = getCheckSnapDirections(direction, fixedDirection, keepRatio);\n    var innerBoundLineInfos = getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio);\n    var offsets = __spreadArray(__spreadArray([], __read(getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas)), false), __read(getInnerBoundInfo(moveable, innerBoundLineInfos, datas)), false);\n    var widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n    var heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n    return {\n        width: {\n            isBound: widthOffsetInfo.isBound,\n            offset: widthOffsetInfo.offset[0]\n        },\n        height: {\n            isBound: heightOffsetInfo.isBound,\n            offset: heightOffsetInfo.offset[1]\n        }\n    };\n}\nfunction recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, isRequest, datas) {\n    var snapPos = getPosByDirection(poses, direction);\n    var _a = checkMoveableSnapBounds(moveable, isRequest, {\n        vertical: [\n            snapPos[0]\n        ],\n        horizontal: [\n            snapPos[1]\n        ]\n    }), horizontalOffset = _a.horizontal.offset, verticalOffset = _a.vertical.offset;\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(verticalOffset, FLOAT_POINT_NUM) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(horizontalOffset, FLOAT_POINT_NUM)) {\n        var _b = __read(getDragDist({\n            datas: datas,\n            distX: -verticalOffset,\n            distY: -horizontalOffset\n        }), 2), nextWidthOffset = _b[0], nextHeightOffset = _b[1];\n        var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);\n        var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);\n        return [\n            nextWidth - width,\n            nextHeight - height\n        ];\n    }\n    return [\n        0,\n        0\n    ];\n}\nfunction checkSizeDist(moveable, getNextPoses, width, height, direction, fixedPosition, isRequest, datas) {\n    var poses = getAbsolutePosesByState(moveable.state);\n    var keepRatio = moveable.props.keepRatio;\n    var widthOffset = 0;\n    var heightOffset = 0;\n    for(var i = 0; i < 2; ++i){\n        var nextPoses = getNextPoses(widthOffset, heightOffset);\n        var _a = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, isRequest, datas), widthOffsetInfo = _a.width, heightOffsetInfo = _a.height;\n        var isWidthBound = widthOffsetInfo.isBound;\n        var isHeightBound = heightOffsetInfo.isBound;\n        var nextWidthOffset = widthOffsetInfo.offset;\n        var nextHeightOffset = heightOffsetInfo.offset;\n        if (i === 1) {\n            if (!isWidthBound) {\n                nextWidthOffset = 0;\n            }\n            if (!isHeightBound) {\n                nextHeightOffset = 0;\n            }\n        }\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n            return [\n                0,\n                0\n            ];\n        }\n        if (keepRatio) {\n            var widthDist = abs(nextWidthOffset) * (width ? 1 / width : 1);\n            var heightDist = abs(nextHeightOffset) * (height ? 1 / height : 1);\n            var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist;\n            if (isGetWidthOffset) {\n                // width : height = ? : heightOffset\n                nextWidthOffset = width * nextHeightOffset / height;\n            } else {\n                // width : height = widthOffset : ?\n                nextHeightOffset = height * nextWidthOffset / width;\n            }\n        }\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n    if (!keepRatio && direction[0] && direction[1]) {\n        var _b = checkMaxBounds(moveable, poses, direction, fixedPosition, datas), maxWidth = _b.maxWidth, maxHeight = _b.maxHeight;\n        var _c = __read(recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset).map(function(pos) {\n            return pos.map(function(p) {\n                return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(p, FLOAT_POINT_NUM);\n            });\n        }), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, isRequest, datas), 2), nextWidthOffset = _c[0], nextHeightOffset = _c[1];\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n    return [\n        widthOffset,\n        heightOffset\n    ];\n}\nfunction absDegree(deg) {\n    if (deg < 0) {\n        deg = deg % 360 + 360;\n    }\n    deg %= 360;\n    return deg;\n}\nfunction bumpDegree(baseDeg, snapDeg) {\n    // baseDeg -80\n    // snapDeg 270\n    // return -90\n    snapDeg = absDegree(snapDeg);\n    var count = Math.floor(baseDeg / 360);\n    var deg1 = count * 360 + 360 - snapDeg;\n    var deg2 = count * 360 + snapDeg;\n    return abs(baseDeg - deg1) < abs(baseDeg - deg2) ? deg1 : deg2;\n}\nfunction getMinDegreeDistance(deg1, deg2) {\n    deg1 = absDegree(deg1);\n    deg2 = absDegree(deg2);\n    var deg3 = absDegree(deg1 - deg2);\n    return Math.min(deg3, 360 - deg3);\n}\nfunction checkSnapRotate(moveable, rect, dist, rotation) {\n    var _a;\n    var props = moveable.props;\n    var snapRotationThreshold = (_a = props[NAME_snapRotationThreshold]) !== null && _a !== void 0 ? _a : 5;\n    var snapRotationDegrees = props[NAME_snapRotationDegrees];\n    if (hasGuidelines(moveable, \"rotatable\")) {\n        var pos1 = rect.pos1, pos2 = rect.pos2, pos3 = rect.pos3, pos4 = rect.pos4, origin2_1 = rect.origin;\n        var rad_1 = dist * Math.PI / 180;\n        var prevPoses = [\n            pos1,\n            pos2,\n            pos3,\n            pos4\n        ].map(function(pos) {\n            return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos, origin2_1);\n        });\n        var nextPoses = prevPoses.map(function(pos) {\n            return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad_1);\n        });\n        // console.log(moveable.state.left, moveable.state.top, moveable.state.origin);\n        // console.log(pos1, pos2, pos3, pos4, origin, rad, prevPoses, nextPoses);\n        var result = __spreadArray(__spreadArray([], __read(checkRotateBounds(moveable, prevPoses, nextPoses, origin2_1, dist)), false), __read(checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin2_1, dist)), false);\n        result.sort(function(a, b) {\n            return abs(a - dist) - abs(b - dist);\n        });\n        var isSnap = result.length > 0;\n        if (isSnap) {\n            return {\n                isSnap: isSnap,\n                dist: isSnap ? result[0] : dist\n            };\n        }\n    }\n    if ((snapRotationDegrees === null || snapRotationDegrees === void 0 ? void 0 : snapRotationDegrees.length) && snapRotationThreshold) {\n        var sorted = snapRotationDegrees.slice().sort(function(a, b) {\n            return getMinDegreeDistance(a, rotation) - getMinDegreeDistance(b, rotation);\n        });\n        var firstDegree = sorted[0];\n        if (getMinDegreeDistance(firstDegree, rotation) <= snapRotationThreshold) {\n            return {\n                isSnap: true,\n                dist: dist + bumpDegree(rotation, firstDegree) - rotation\n            };\n        }\n    }\n    return {\n        isSnap: false,\n        dist: dist\n    };\n}\nfunction checkSnapResize(moveable, width, height, direction, fixedPosition, isRequest, datas) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [\n            0,\n            0\n        ];\n    }\n    var fixedDirection = datas.fixedDirection, nextAllMatrix = datas.nextAllMatrix;\n    var _a = moveable.state, allMatrix = _a.allMatrix, is3d = _a.is3d;\n    return checkSizeDist(moveable, function(widthOffset, heightOffset) {\n        return getNextFixedPoses(nextAllMatrix || allMatrix, width + widthOffset, height + heightOffset, fixedDirection, fixedPosition, is3d);\n    }, width, height, direction, fixedPosition, isRequest, datas);\n}\nfunction checkSnapScale(moveable, scale, direction, isRequest, datas) {\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [\n            0,\n            0\n        ];\n    }\n    var startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, fixedPosition = datas.fixedPosition, fixedDirection = datas.fixedDirection, is3d = datas.is3d;\n    var sizeDist = checkSizeDist(moveable, function(widthOffset, heightOffset) {\n        return getNextFixedPoses(scaleMatrix(datas, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(scale, [\n            widthOffset / startOffsetWidth,\n            heightOffset / startOffsetHeight\n        ])), startOffsetWidth, startOffsetHeight, fixedDirection, fixedPosition, is3d);\n    }, startOffsetWidth, startOffsetHeight, direction, fixedPosition, isRequest, datas);\n    return [\n        sizeDist[0] / startOffsetWidth,\n        sizeDist[1] / startOffsetHeight\n    ];\n}\nfunction startCheckSnapDrag(moveable, datas) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\nfunction getSnapGuidelines(posInfos) {\n    var guidelines = [];\n    posInfos.forEach(function(posInfo) {\n        posInfo.guidelineInfos.forEach(function(_a) {\n            var guideline = _a.guideline;\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(guidelines, function(info) {\n                return info.guideline === guideline;\n            })) {\n                return;\n            }\n            guideline.direction = \"\";\n            guidelines.push({\n                guideline: guideline,\n                posInfo: posInfo\n            });\n        });\n    });\n    return guidelines.map(function(_a) {\n        var guideline = _a.guideline, posInfo = _a.posInfo;\n        return __assign(__assign({}, guideline), {\n            direction: posInfo.direction\n        });\n    });\n}\nfunction addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses, externalBounds) {\n    var _a = checkBoundPoses(getBounds(moveable, externalBounds), verticalPoses, horizontalPoses), verticalBoundInfos = _a.vertical, horizontalBoundInfos = _a.horizontal;\n    var boundMap = getInitialBounds();\n    verticalBoundInfos.forEach(function(info) {\n        if (info.isBound) {\n            if (info.direction === \"start\") {\n                boundMap.left = true;\n            }\n            if (info.direction === \"end\") {\n                boundMap.right = true;\n            }\n            verticalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos\n            });\n        }\n    });\n    horizontalBoundInfos.forEach(function(info) {\n        if (info.isBound) {\n            if (info.direction === \"start\") {\n                boundMap.top = true;\n            }\n            if (info.direction === \"end\") {\n                boundMap.bottom = true;\n            }\n            horizontalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos\n            });\n        }\n    });\n    var _b = checkInnerBoundPoses(moveable), innerBoundMap = _b.boundMap, verticalInnerBoundPoses = _b.vertical, horizontalInnerBoundPoses = _b.horizontal;\n    verticalInnerBoundPoses.forEach(function(innerPos) {\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(verticalSnapPoses, function(_a) {\n            var type = _a.type, pos = _a.pos;\n            return type === \"bounds\" && pos === innerPos;\n        }) >= 0) {\n            return;\n        }\n        verticalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos\n        });\n    });\n    horizontalInnerBoundPoses.forEach(function(innerPos) {\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(horizontalSnapPoses, function(_a) {\n            var type = _a.type, pos = _a.pos;\n            return type === \"bounds\" && pos === innerPos;\n        }) >= 0) {\n            return;\n        }\n        horizontalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos\n        });\n    });\n    return {\n        boundMap: boundMap,\n        innerBoundMap: innerBoundMap\n    };\n}\nvar directionCondition$1 = getDirectionCondition(\"\", [\n    \"resizable\",\n    \"scalable\"\n]);\n/**\r\n * @namespace Moveable.Snappable\r\n * @description Whether or not target can be snapped to the guideline. (default: false)\r\n * @sort 2\r\n */ var Snappable = {\n    name: \"snappable\",\n    dragRelation: \"strong\",\n    props: [\n        \"snappable\",\n        \"snapContainer\",\n        \"snapDirections\",\n        \"elementSnapDirections\",\n        \"snapGap\",\n        \"snapGridWidth\",\n        \"snapGridHeight\",\n        \"isDisplaySnapDigit\",\n        \"isDisplayInnerSnapDigit\",\n        \"isDisplayGridGuidelines\",\n        \"snapDigit\",\n        \"snapThreshold\",\n        \"snapRenderThreshold\",\n        \"snapGridAll\",\n        NAME_snapRotationThreshold,\n        NAME_snapRotationDegrees,\n        NAME_snapHorizontalThreshold,\n        NAME_snapVerticalThreshold,\n        \"horizontalGuidelines\",\n        \"verticalGuidelines\",\n        \"elementGuidelines\",\n        \"bounds\",\n        \"innerBounds\",\n        \"snapDistFormat\",\n        \"maxSnapElementGuidelineDistance\",\n        \"maxSnapElementGapDistance\"\n    ],\n    events: [\n        \"snap\",\n        \"bound\"\n    ],\n    css: [\n        \":host {\\n--bounds-color: #d66;\\n}\\n.guideline {\\npointer-events: none;\\nz-index: 2;\\n}\\n.guideline.bounds {\\nbackground: #d66;\\nbackground: var(--bounds-color);\\n}\\n.guideline-group {\\nposition: absolute;\\ntop: 0;\\nleft: 0;\\n}\\n.guideline-group .size-value {\\nposition: absolute;\\ncolor: #f55;\\nfont-size: 12px;\\nfont-size: calc(12px * var(--zoom));\\nfont-weight: bold;\\n}\\n.guideline-group.horizontal .size-value {\\ntransform-origin: 50% 100%;\\ntransform: translateX(-50%);\\nleft: 50%;\\nbottom: 5px;\\nbottom: calc(2px + 3px * var(--zoom));\\n}\\n.guideline-group.vertical .size-value {\\ntransform-origin: 0% 50%;\\ntop: 50%;\\ntransform: translateY(-50%);\\nleft: 5px;\\nleft: calc(2px + 3px * var(--zoom));\\n}\\n.guideline.gap {\\nbackground: #f55;\\n}\\n.size-value.gap {\\ncolor: #f55;\\n}\\n\"\n    ],\n    render: function(moveable, React) {\n        var state = moveable.state;\n        var targetTop = state.top, targetLeft = state.left, pos1 = state.pos1, pos2 = state.pos2, pos3 = state.pos3, pos4 = state.pos4, snapRenderInfo = state.snapRenderInfo;\n        var _a = moveable.props.snapRenderThreshold, snapRenderThreshold = _a === void 0 ? 1 : _a;\n        if (!snapRenderInfo || !snapRenderInfo.render || !hasGuidelines(moveable, \"\")) {\n            // reset store\n            watchValue(moveable, \"boundMap\", getInitialBounds(), function(v) {\n                return JSON.stringify(v);\n            });\n            watchValue(moveable, \"innerBoundMap\", getInitialBounds(), function(v) {\n                return JSON.stringify(v);\n            });\n            return [];\n        }\n        state.guidelines = getTotalGuidelines(moveable);\n        var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n        var externalPoses = snapRenderInfo.externalPoses || [];\n        var poses = getAbsolutePosesByState(moveable.state);\n        var verticalSnapPoses = [];\n        var horizontalSnapPoses = [];\n        var verticalGuidelines = [];\n        var horizontalGuidelines = [];\n        var snapInfos = [];\n        var _b = getRect(poses), width = _b.width, height = _b.height, top = _b.top, left = _b.left, bottom = _b.bottom, right = _b.right;\n        var targetRect = {\n            left: left,\n            right: right,\n            top: top,\n            bottom: bottom,\n            center: (left + right) / 2,\n            middle: (top + bottom) / 2\n        };\n        var hasExternalPoses = externalPoses.length > 0;\n        var externalRect = hasExternalPoses ? getRect(externalPoses) : {};\n        if (!snapRenderInfo.request) {\n            if (snapRenderInfo.direction) {\n                snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction, snapRenderThreshold, snapRenderThreshold));\n            }\n            if (snapRenderInfo.snap) {\n                var rect = getRect(poses);\n                if (snapRenderInfo.center) {\n                    rect.middle = (rect.top + rect.bottom) / 2;\n                    rect.center = (rect.left + rect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, rect, snapRenderThreshold, snapRenderThreshold));\n            }\n            if (hasExternalPoses) {\n                if (snapRenderInfo.center) {\n                    externalRect.middle = (externalRect.top + externalRect.bottom) / 2;\n                    externalRect.center = (externalRect.left + externalRect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, externalRect, snapRenderThreshold, snapRenderThreshold));\n            }\n            snapInfos.forEach(function(snapInfo) {\n                var verticalPosInfos = snapInfo.vertical.posInfos, horizontalPosInfos = snapInfo.horizontal.posInfos;\n                verticalSnapPoses.push.apply(verticalSnapPoses, __spreadArray([], __read(verticalPosInfos.filter(function(_a) {\n                    var guidelineInfos = _a.guidelineInfos;\n                    return guidelineInfos.some(function(_a) {\n                        var guideline = _a.guideline;\n                        return !guideline.hide;\n                    });\n                }).map(function(posInfo) {\n                    return {\n                        type: \"snap\",\n                        pos: posInfo.pos\n                    };\n                })), false));\n                horizontalSnapPoses.push.apply(horizontalSnapPoses, __spreadArray([], __read(horizontalPosInfos.filter(function(_a) {\n                    var guidelineInfos = _a.guidelineInfos;\n                    return guidelineInfos.some(function(_a) {\n                        var guideline = _a.guideline;\n                        return !guideline.hide;\n                    });\n                }).map(function(posInfo) {\n                    return {\n                        type: \"snap\",\n                        pos: posInfo.pos\n                    };\n                })), false));\n                verticalGuidelines.push.apply(verticalGuidelines, __spreadArray([], __read(getSnapGuidelines(verticalPosInfos)), false));\n                horizontalGuidelines.push.apply(horizontalGuidelines, __spreadArray([], __read(getSnapGuidelines(horizontalPosInfos)), false));\n            });\n        }\n        var _c = addBoundGuidelines(moveable, [\n            left,\n            right\n        ], [\n            top,\n            bottom\n        ], verticalSnapPoses, horizontalSnapPoses), boundMap = _c.boundMap, innerBoundMap = _c.innerBoundMap;\n        if (hasExternalPoses) {\n            addBoundGuidelines(moveable, [\n                externalRect.left,\n                externalRect.right\n            ], [\n                externalRect.top,\n                externalRect.bottom\n            ], verticalSnapPoses, horizontalSnapPoses, snapRenderInfo.externalBounds);\n        }\n        var allGuidelines = __spreadArray(__spreadArray([], __read(verticalGuidelines), false), __read(horizontalGuidelines), false);\n        var elementGuidelines = allGuidelines.filter(function(guideline) {\n            return guideline.element && !guideline.gapRects;\n        });\n        var gapGuidelines = allGuidelines.filter(function(guideline) {\n            return guideline.gapRects;\n        }).sort(function(a, b) {\n            return a.gap - b.gap;\n        });\n        triggerEvent(moveable, \"onSnap\", {\n            guidelines: allGuidelines.filter(function(_a) {\n                var element = _a.element;\n                return !element;\n            }),\n            elements: elementGuidelines,\n            gaps: gapGuidelines\n        }, true);\n        var nextBoundMap = watchValue(moveable, \"boundMap\", boundMap, function(v) {\n            return JSON.stringify(v);\n        }, getInitialBounds());\n        var nextInnerBoundMap = watchValue(moveable, \"innerBoundMap\", innerBoundMap, function(v) {\n            return JSON.stringify(v);\n        }, getInitialBounds());\n        if (boundMap === nextBoundMap || innerBoundMap === nextInnerBoundMap) {\n            triggerEvent(moveable, \"onBound\", {\n                bounds: boundMap,\n                innerBounds: innerBoundMap\n            }, true);\n        }\n        // verticalSnapPoses.\n        return __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(renderDashedGuidelines(moveable, elementGuidelines, [\n            minLeft,\n            minTop\n        ], targetRect, React)), false), __read(renderGapGuidelines(moveable, gapGuidelines, [\n            minLeft,\n            minTop\n        ], targetRect, React)), false), __read(renderGuidelines(moveable, \"horizontal\", horizontalGuidelines, [\n            targetLeft,\n            targetTop\n        ], targetRect, React)), false), __read(renderGuidelines(moveable, \"vertical\", verticalGuidelines, [\n            targetLeft,\n            targetTop\n        ], targetRect, React)), false), __read(renderSnapPoses(moveable, \"horizontal\", horizontalSnapPoses, minLeft, targetTop, width, 0, React)), false), __read(renderSnapPoses(moveable, \"vertical\", verticalSnapPoses, minTop, targetLeft, height, 1, React)), false);\n    },\n    dragStart: function(moveable, e) {\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true\n        };\n        checkSnapInfo(moveable);\n    },\n    drag: function(moveable) {\n        var state = moveable.state;\n        if (!checkSnapInfo(moveable)) {\n            state.guidelines = getTotalGuidelines(moveable);\n        }\n        if (state.snapRenderInfo) {\n            state.snapRenderInfo.render = true;\n        }\n    },\n    pinchStart: function(moveable) {\n        this.unset(moveable);\n    },\n    dragEnd: function(moveable) {\n        this.unset(moveable);\n    },\n    dragControlCondition: function(moveable, e) {\n        if (directionCondition$1(moveable, e) || dragControlCondition(moveable, e)) {\n            return true;\n        }\n        if (!e.isRequest && e.inputEvent) {\n            return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(e.inputEvent.target, prefix(\"snap-control\"));\n        }\n    },\n    dragControlStart: function(moveable) {\n        moveable.state.snapRenderInfo = null;\n        checkSnapInfo(moveable);\n    },\n    dragControl: function(moveable) {\n        this.drag(moveable);\n    },\n    dragControlEnd: function(moveable) {\n        this.unset(moveable);\n    },\n    dragGroupStart: function(moveable, e) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup: function(moveable) {\n        this.drag(moveable);\n    },\n    dragGroupEnd: function(moveable) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart: function(moveable) {\n        moveable.state.snapRenderInfo = null;\n        checkSnapInfo(moveable);\n    },\n    dragGroupControl: function(moveable) {\n        this.drag(moveable);\n    },\n    dragGroupControlEnd: function(moveable) {\n        this.unset(moveable);\n    },\n    unset: function(moveable) {\n        var state = moveable.state;\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n        state.elementRects = [];\n    }\n};\n/**\r\n * Whether or not target can be snapped to the guideline. (default: false)\r\n * @name Moveable.Snappable#snappable\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.snappable = true;\r\n */ /**\r\n *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)\r\n * @name Moveable.Snappable#snapContainer\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.querySelector(\".container\"));\r\n *\r\n * moveable.snapContainer = document.body;\r\n */ /**\r\n * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })\r\n * @name Moveable.Snappable#snapDirections\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   snappable: true,\r\n *   snapDirections: true,\r\n * });\r\n * // snap center\r\n * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\r\n */ /**\r\n * You can specify the snap directions of elements. (default: { left: true, ftrue, right: true, bottom: true })\r\n * @name Moveable.Snappable#elementSnapDirections\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   snappable: true,\r\n *   elementSnapDirections: true,\r\n * });\r\n * // snap center\r\n * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\r\n */ /**\r\n * When you drag, make the gap snap in the element guidelines. (default: true)\r\n * @name Moveable.Snappable#snapGap\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   snappable: true,\r\n *   snapElement: true,\r\n *   snapGap: true,\r\n * });\r\n *\r\n * moveable.snapGap = false;\r\n */ /**\r\n * Distance value that can snap to guidelines. (default: 5)\r\n * @name Moveable.Snappable#snapThreshold\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.snapThreshold = 5;\r\n */ /**\r\n * Add guidelines in the horizontal direction. (default: [])\r\n * @name Moveable.Snappable#horizontalGuidelines\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.horizontalGuidelines = [100, 200, 500];\r\n */ /**\r\n * Add guidelines in the vertical direction. (default: [])\r\n * @name Moveable.Snappable#verticalGuidelines\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.verticalGuidelines = [100, 200, 500];\r\n */ /**\r\n * Add guidelines for the element. (default: [])\r\n * @name Moveable.Snappable#elementGuidelines\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.elementGuidelines = [\r\n *   document.querySelector(\".element\"),\r\n * ];\r\n */ /**\r\n * You can set up boundaries.\r\n * @name Moveable.Snappable#bounds\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @default null\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\r\n */ /**\r\n * You can set up inner boundaries.\r\n * @name Moveable.Snappable#innerBounds\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @default null\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\r\n */ /**\r\n * snap distance digits (default: 0)\r\n * @name Moveable.Snappable#snapDigit\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.snapDigit = 0\r\n */ /**\r\n * If width size is greater than 0, you can vertical snap to the grid. (default: 0)\r\n * @name Moveable.Snappable#snapGridWidth\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.snapGridWidth = 5;\r\n */ /**\r\n * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)\r\n * @name Moveable.Snappable#snapGridHeight\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.snapGridHeight = 5;\r\n */ /**\r\n * Whether to show snap distance (default: true)\r\n * @name Moveable.Snappable#isDisplaySnapDigit\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.isDisplaySnapDigit = true;\r\n */ /**\r\n * Whether to show element inner snap distance (default: false)\r\n * @name Moveable.Snappable#isDisplayInnerSnapDigit\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.isDisplayInnerSnapDigit = true;\r\n */ /**\r\n * You can set the text format of the distance shown in the guidelines. (default: self)\r\n * @name Moveable.Snappable#snapDistFormat\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *  snappable: true,\r\n *  snapDistFormat: (v, type) => v,\r\n * });\r\n * moveable.snapDistFormat = (v, type) => `${v}px`;\r\n */ /**\r\n * When you drag or dragControl, the `snap` event is called.\r\n * @memberof Moveable.Snappable\r\n * @event snap\r\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     snappable: true\r\n * });\r\n * moveable.on(\"snap\", e => {\r\n *     console.log(\"onSnap\", e);\r\n * });\r\n */ function multiply2(pos1, pos2) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1]\n    ];\n}\nfunction prefix() {\n    var classNames = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        classNames[_i] = arguments[_i];\n    }\n    return framework_utils__WEBPACK_IMPORTED_MODULE_6__.prefixNames.apply(void 0, __spreadArray([\n        PREFIX\n    ], __read(classNames), false));\n}\nfunction defaultSync(fn) {\n    fn();\n}\nfunction getTransformMatrix(transform) {\n    if (!transform || transform === \"none\") {\n        return [\n            1,\n            0,\n            0,\n            1,\n            0,\n            0\n        ];\n    }\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(transform)) {\n        return transform;\n    }\n    return (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)(transform);\n}\nfunction getAbsoluteMatrix(matrix, n, origin) {\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(origin, n), matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(origin.map(function(a) {\n        return -a;\n    }), n));\n}\nfunction measureSVGSize(el, unit, isHorizontal) {\n    if (unit === \"%\") {\n        var viewBox = getSVGViewBox(el.ownerSVGElement);\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nfunction getBeforeTransformOrigin(el) {\n    var relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n    return relativeOrigin.map(function(o, i) {\n        var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitUnit)(o), value = _a.value, unit = _a.unit;\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nfunction getTransformOriginArray(transformOrigin) {\n    return transformOrigin ? transformOrigin.split(\" \") : [\n        \"0\",\n        \"0\"\n    ];\n}\nfunction getTransformOrigin(style) {\n    return getTransformOriginArray(style.transformOrigin);\n}\nfunction getElementTransform(target) {\n    var getStyle = getCachedStyle(target);\n    var computedTransform = getStyle(\"transform\");\n    if (computedTransform && computedTransform !== \"none\") {\n        return computedTransform;\n    }\n    if (\"transform\" in target) {\n        var list = target.transform;\n        var baseVal = list.baseVal;\n        if (!baseVal) {\n            return \"\";\n        }\n        var length_1 = baseVal.length;\n        if (!length_1) {\n            return \"\";\n        }\n        var matrixes = [];\n        var _loop_1 = function(i) {\n            var matrix = baseVal[i].matrix;\n            matrixes.push(\"matrix(\".concat([\n                \"a\",\n                \"b\",\n                \"c\",\n                \"d\",\n                \"e\",\n                \"f\"\n            ].map(function(chr) {\n                return matrix[chr];\n            }).join(\", \"), \")\"));\n        };\n        for(var i = 0; i < length_1; ++i){\n            _loop_1(i);\n        }\n        return matrixes.join(\" \");\n    }\n    return \"\";\n}\nfunction getOffsetInfo(el, lastParent, isParent, checkZoom, getTargetStyle) {\n    var _a, _b;\n    var documentElement = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentElement)(el) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(el);\n    var hasSlot = false;\n    var target;\n    var parentSlotElement;\n    if (!el || isParent) {\n        target = el;\n    } else {\n        var assignedSlotParentElement = (_a = el === null || el === void 0 ? void 0 : el.assignedSlot) === null || _a === void 0 ? void 0 : _a.parentElement;\n        var parentElement = el.parentElement;\n        if (assignedSlotParentElement) {\n            hasSlot = true;\n            parentSlotElement = parentElement;\n            target = assignedSlotParentElement;\n        } else {\n            target = parentElement;\n        }\n    }\n    var isCustomElement = false;\n    var isEnd = el === lastParent || target === lastParent;\n    var position = \"relative\";\n    var offsetZoom = 1;\n    var targetZoom = parseFloat(getTargetStyle === null || getTargetStyle === void 0 ? void 0 : getTargetStyle(\"zoom\")) || 1;\n    var targetPosition = getTargetStyle === null || getTargetStyle === void 0 ? void 0 : getTargetStyle(\"position\");\n    while(target && target !== documentElement){\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        var getStyle = getCachedStyle(target);\n        var tagName = target.tagName.toLowerCase();\n        var transform = getElementTransform(target);\n        var willChange = getStyle(\"willChange\");\n        var zoom = parseFloat(getStyle(\"zoom\")) || 1;\n        position = getStyle(\"position\");\n        if (checkZoom && zoom !== 1) {\n            offsetZoom = zoom;\n            break;\n        }\n        if (// offsetParent is the parentElement if the target's zoom is not 1 and not absolute.\n        !isParent && checkZoom && targetZoom !== 1 && targetPosition && targetPosition !== \"absolute\" || tagName === \"svg\" || tagName === \"foreignobject\" || position !== \"static\" || transform && transform !== \"none\" || willChange === \"transform\") {\n            break;\n        }\n        var slotParentNode = (_b = el === null || el === void 0 ? void 0 : el.assignedSlot) === null || _b === void 0 ? void 0 : _b.parentNode;\n        var targetParentNode = target.parentNode;\n        if (slotParentNode) {\n            hasSlot = true;\n            parentSlotElement = targetParentNode;\n        }\n        var parentNode = targetParentNode;\n        if (parentNode && parentNode.nodeType === 11) {\n            // Shadow Root\n            target = parentNode.host;\n            isCustomElement = true;\n            position = getCachedStyle(target)(\"position\");\n            break;\n        }\n        target = parentNode;\n        position = \"relative\";\n    }\n    return {\n        offsetZoom: offsetZoom,\n        hasSlot: hasSlot,\n        parentSlotElement: parentSlotElement,\n        isCustomElement: isCustomElement,\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === documentElement,\n        offsetParent: target || documentElement\n    };\n}\nfunction getOffsetPosInfo(el, target) {\n    var _a;\n    var tagName = el.tagName.toLowerCase();\n    var offsetLeft = el.offsetLeft;\n    var offsetTop = el.offsetTop;\n    var getStyle = getCachedStyle(el);\n    // svg\n    var isSVG = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(offsetLeft);\n    var hasOffset = !isSVG;\n    var origin;\n    var targetOrigin;\n    // inner svg element\n    if (!hasOffset && (tagName !== \"svg\" || el.ownerSVGElement)) {\n        origin = IS_WEBKIT605 ? getBeforeTransformOrigin(el) : getTransformOriginArray(getStyle(\"transformOrigin\")).map(function(pos) {\n            return parseFloat(pos);\n        });\n        targetOrigin = origin.slice();\n        hasOffset = true;\n        if (tagName === \"svg\") {\n            offsetLeft = 0;\n            offsetTop = 0;\n        } else {\n            _a = __read(getSVGGraphicsOffset(el, origin, el === target && target.tagName.toLowerCase() === \"g\"), 4), offsetLeft = _a[0], offsetTop = _a[1], origin[0] = _a[2], origin[1] = _a[3];\n        }\n    } else {\n        origin = getTransformOriginArray(getStyle(\"transformOrigin\")).map(function(pos) {\n            return parseFloat(pos);\n        });\n        targetOrigin = origin.slice();\n    // console.log(getStyle(\"transformOrigin\"), targetOrigin);\n    }\n    return {\n        tagName: tagName,\n        isSVG: isSVG,\n        hasOffset: hasOffset,\n        offset: [\n            offsetLeft || 0,\n            offsetTop || 0\n        ],\n        origin: origin,\n        targetOrigin: targetOrigin\n    };\n}\nfunction getBodyOffset(el, isSVG) {\n    var getStyle = getCachedStyle(el);\n    var getBodyStyle = getCachedStyle((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(el));\n    var bodyPosition = getBodyStyle(\"position\");\n    if (!isSVG && (!bodyPosition || bodyPosition === \"static\")) {\n        return [\n            0,\n            0\n        ];\n    }\n    var marginLeft = parseInt(getBodyStyle(\"marginLeft\"), 10);\n    var marginTop = parseInt(getBodyStyle(\"marginTop\"), 10);\n    if (getStyle(\"position\") === \"absolute\") {\n        if (getStyle(\"top\") !== \"auto\" || getStyle(\"bottom\") !== \"auto\") {\n            marginTop = 0;\n        }\n        if (getStyle(\"left\") !== \"auto\" || getStyle(\"right\") !== \"auto\") {\n            marginLeft = 0;\n        }\n    }\n    return [\n        marginLeft,\n        marginTop\n    ];\n}\nfunction convert3DMatrixes(matrixes) {\n    matrixes.forEach(function(info) {\n        var matrix = info.matrix;\n        if (matrix) {\n            info.matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(matrix, 3, 4);\n        }\n    });\n}\nfunction getPositionFixedInfo(el) {\n    var fixedContainer = el.parentElement;\n    var hasTransform = false;\n    var body = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(el);\n    while(fixedContainer){\n        var transform = getComputedStyle(fixedContainer).transform;\n        if (transform && transform !== \"none\") {\n            hasTransform = true;\n            break;\n        }\n        if (fixedContainer === body) {\n            break;\n        }\n        fixedContainer = fixedContainer.parentElement;\n    }\n    return {\n        fixedContainer: fixedContainer || body,\n        hasTransform: hasTransform\n    };\n}\nfunction makeMatrixCSS(matrix, is3d) {\n    if (is3d === void 0) {\n        is3d = matrix.length > 9;\n    }\n    return \"\".concat(is3d ? \"matrix3d\" : \"matrix\", \"(\").concat((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertMatrixtoCSS)(matrix, !is3d).join(\",\"), \")\");\n}\nfunction getSVGViewBox(el) {\n    var clientWidth = el.clientWidth;\n    var clientHeight = el.clientHeight;\n    if (!el) {\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            clientWidth: clientWidth,\n            clientHeight: clientHeight\n        };\n    }\n    var viewBox = el.viewBox;\n    var baseVal = viewBox && viewBox.baseVal || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    };\n    return {\n        x: baseVal.x,\n        y: baseVal.y,\n        width: baseVal.width || clientWidth,\n        height: baseVal.height || clientHeight,\n        clientWidth: clientWidth,\n        clientHeight: clientHeight\n    };\n}\nfunction getSVGMatrix(el, n) {\n    var _a;\n    var _b = getSVGViewBox(el), viewBoxWidth = _b.width, viewBoxHeight = _b.height, clientWidth = _b.clientWidth, clientHeight = _b.clientHeight;\n    var scaleX = clientWidth / viewBoxWidth;\n    var scaleY = clientHeight / viewBoxHeight;\n    var preserveAspectRatio = el.preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    var align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    var meetOrSlice = preserveAspectRatio.meetOrSlice;\n    var svgOrigin = [\n        0,\n        0\n    ];\n    var scale = [\n        scaleX,\n        scaleY\n    ];\n    var translate = [\n        0,\n        0\n    ];\n    if (align !== 1) {\n        var xAlign = (align - 2) % 3;\n        var yAlign = Math.floor((align - 2) / 3);\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n        var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n    var scaleMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createScaleMatrix)(scale, n);\n    _a = __read(translate, 2), scaleMatrix[n * (n - 1)] = _a[0], scaleMatrix[n * (n - 1) + 1] = _a[1];\n    return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);\n}\nfunction getSVGGraphicsOffset(el, origin, isGTarget) {\n    var tagName = el.tagName.toLowerCase();\n    if (!el.getBBox || !isGTarget && tagName === \"g\") {\n        return [\n            0,\n            0,\n            0,\n            0\n        ];\n    }\n    var getStyle = getCachedStyle(el);\n    var isFillBox = getStyle(\"transform-box\") === \"fill-box\";\n    var bbox = el.getBBox();\n    var viewBox = getSVGViewBox(el.ownerSVGElement);\n    var x = bbox.x;\n    var y = bbox.y;\n    // x, y 0  \n    if (tagName === \"foreignobject\" && !x && !y) {\n        x = parseFloat(el.getAttribute(\"x\")) || 0;\n        y = parseFloat(el.getAttribute(\"y\")) || 0;\n    }\n    var left = x - viewBox.x;\n    var top = y - viewBox.y;\n    var originX = isFillBox ? origin[0] : origin[0] - left;\n    var originY = isFillBox ? origin[1] : origin[1] - top;\n    // if (isFillBox) {\n    //     const bbox = (el as SVGGraphicsElement).getBBox();\n    //     const x = parseFloat(getStyle(\"x\")) || bbox.x;\n    //     const y = parseFloat(getStyle(\"y\")) || bbox.y;\n    //     const xScale = bbox.x / x;\n    //     const yScale = bbox.y / y;\n    //     console.log(x, y);\n    //     originX *= xScale;\n    //     originY *= yScale;\n    // }\n    return [\n        left,\n        top,\n        originX,\n        originY\n    ];\n}\nfunction calculatePosition(matrix, pos, n) {\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)(pos, n), n);\n}\nfunction calculatePoses(matrix, width, height, n) {\n    return [\n        [\n            0,\n            0\n        ],\n        [\n            width,\n            0\n        ],\n        [\n            0,\n            height\n        ],\n        [\n            width,\n            height\n        ]\n    ].map(function(pos) {\n        return calculatePosition(matrix, pos, n);\n    });\n}\nfunction getRect(poses) {\n    var posesX = poses.map(function(pos) {\n        return pos[0];\n    });\n    var posesY = poses.map(function(pos) {\n        return pos[1];\n    });\n    var left = Math.min.apply(Math, __spreadArray([], __read(posesX), false));\n    var top = Math.min.apply(Math, __spreadArray([], __read(posesY), false));\n    var right = Math.max.apply(Math, __spreadArray([], __read(posesX), false));\n    var bottom = Math.max.apply(Math, __spreadArray([], __read(posesY), false));\n    var rectWidth = right - left;\n    var rectHeight = bottom - top;\n    return {\n        left: left,\n        top: top,\n        right: right,\n        bottom: bottom,\n        width: rectWidth,\n        height: rectHeight\n    };\n}\nfunction calculateRect(matrix, width, height, n) {\n    var poses = calculatePoses(matrix, width, height, n);\n    return getRect(poses);\n}\nfunction getSVGOffset(offsetInfo, targetInfo, container, n, beforeMatrix) {\n    var _a;\n    var target = offsetInfo.target;\n    var origin = offsetInfo.origin;\n    var targetMatrix = targetInfo.matrix;\n    var _b = getSize(target), width = _b.offsetWidth, height = _b.offsetHeight;\n    var containerClientRect = container.getBoundingClientRect();\n    var margin = [\n        0,\n        0\n    ];\n    if (container === (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(container)) {\n        margin = getBodyOffset(target, true);\n    }\n    var rect = target.getBoundingClientRect();\n    var rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0) + margin[0];\n    var rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0) + margin[1];\n    var rectWidth = rect.width;\n    var rectHeight = rect.height;\n    var mat = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, beforeMatrix, targetMatrix);\n    var _c = calculateRect(mat, width, height, n), prevLeft = _c.left, prevTop = _c.top, prevWidth = _c.width, prevHeight = _c.height;\n    var posOrigin = calculatePosition(mat, origin, n);\n    var prevOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(posOrigin, [\n        prevLeft,\n        prevTop\n    ]);\n    var rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight\n    ];\n    var offset = [\n        0,\n        0\n    ];\n    var count = 0;\n    while(++count < 10){\n        var inverseBeforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(beforeMatrix, n);\n        _a = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(inverseBeforeMatrix, rectOrigin, n), calculatePosition(inverseBeforeMatrix, posOrigin, n)), 2), offset[0] = _a[0], offset[1] = _a[1];\n        var mat2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, beforeMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(offset, n), targetMatrix);\n        var _d = calculateRect(mat2, width, height, n), nextLeft = _d.left, nextTop = _d.top;\n        var distLeft = nextLeft - rectLeft;\n        var distTop = nextTop - rectTop;\n        if (abs(distLeft) < 2 && abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(function(p) {\n        return Math.round(p);\n    });\n}\nfunction calculateMoveableClientPositions(rootMatrix, poses, rootClientRect) {\n    var is3d = rootMatrix.length === 16;\n    var n = is3d ? 4 : 3;\n    var rootPoses = poses.map(function(pos) {\n        return calculatePosition(rootMatrix, pos, n);\n    });\n    var left = rootClientRect.left, top = rootClientRect.top;\n    return rootPoses.map(function(pos) {\n        return [\n            pos[0] + left,\n            pos[1] + top\n        ];\n    });\n}\nfunction getDistSize(vec) {\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nfunction getDiagonalSize(pos1, pos2) {\n    return getDistSize([\n        pos2[0] - pos1[0],\n        pos2[1] - pos1[1]\n    ]);\n}\nfunction getLineStyle(pos1, pos2, zoom, rad) {\n    if (zoom === void 0) {\n        zoom = 1;\n    }\n    if (rad === void 0) {\n        rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(pos1, pos2);\n    }\n    var width = getDiagonalSize(pos1, pos2);\n    return {\n        transform: \"translateY(-50%) translate(\".concat(pos1[0], \"px, \").concat(pos1[1], \"px) rotate(\").concat(rad, \"rad) scaleY(\").concat(zoom, \")\"),\n        width: \"\".concat(width, \"px\")\n    };\n}\nfunction getControlTransform(rotation, zoom) {\n    var poses = [];\n    for(var _i = 2; _i < arguments.length; _i++){\n        poses[_i - 2] = arguments[_i];\n    }\n    var length = poses.length;\n    var x = poses.reduce(function(prev, pos) {\n        return prev + pos[0];\n    }, 0) / length;\n    var y = poses.reduce(function(prev, pos) {\n        return prev + pos[1];\n    }, 0) / length;\n    return {\n        transform: \"translateZ(0px) translate(\".concat(x, \"px, \").concat(y, \"px) rotate(\").concat(rotation, \"rad) scale(\").concat(zoom, \")\")\n    };\n}\nfunction getProps(props, ableName) {\n    var self = props[ableName];\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(self)) {\n        return __assign(__assign({}, props), self);\n    }\n    return props;\n}\nfunction getSize(target) {\n    var hasOffset = target && !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(target.offsetWidth);\n    var offsetWidth = 0;\n    var offsetHeight = 0;\n    var clientWidth = 0;\n    var clientHeight = 0;\n    var cssWidth = 0;\n    var cssHeight = 0;\n    var contentWidth = 0;\n    var contentHeight = 0;\n    var minWidth = 0;\n    var minHeight = 0;\n    var minOffsetWidth = 0;\n    var minOffsetHeight = 0;\n    var maxWidth = Infinity;\n    var maxHeight = Infinity;\n    var maxOffsetWidth = Infinity;\n    var maxOffsetHeight = Infinity;\n    var inlineCSSWidth = 0;\n    var inlineCSSHeight = 0;\n    var svg = false;\n    if (target) {\n        if (!hasOffset && target.ownerSVGElement) {\n            // check svg elements\n            var bbox = target.getBBox();\n            svg = true;\n            offsetWidth = bbox.width;\n            offsetHeight = bbox.height;\n            cssWidth = offsetWidth;\n            cssHeight = offsetHeight;\n            contentWidth = offsetWidth;\n            contentHeight = offsetHeight;\n            clientWidth = offsetWidth;\n            clientHeight = offsetHeight;\n        } else {\n            // check html elements\n            var getStyle = getCachedStyle(target);\n            var targetStyle = target.style;\n            var boxSizing = getStyle(\"boxSizing\") === \"border-box\";\n            var borderLeft = parseFloat(getStyle(\"borderLeftWidth\")) || 0;\n            var borderRight = parseFloat(getStyle(\"borderRightWidth\")) || 0;\n            var borderTop = parseFloat(getStyle(\"borderTopWidth\")) || 0;\n            var borderBottom = parseFloat(getStyle(\"borderBottomWidth\")) || 0;\n            var paddingLeft = parseFloat(getStyle(\"paddingLeft\")) || 0;\n            var paddingRight = parseFloat(getStyle(\"paddingRight\")) || 0;\n            var paddingTop = parseFloat(getStyle(\"paddingTop\")) || 0;\n            var paddingBottom = parseFloat(getStyle(\"paddingBottom\")) || 0;\n            var horizontalPadding = paddingLeft + paddingRight;\n            var verticalPadding = paddingTop + paddingBottom;\n            var horizontalBorder = borderLeft + borderRight;\n            var verticalBorder = borderTop + borderBottom;\n            var horizontalOffset = horizontalPadding + horizontalBorder;\n            var verticalOffset = verticalPadding + verticalBorder;\n            var position = getStyle(\"position\");\n            var containerWidth = 0;\n            var containerHeight = 0;\n            // SVGSVGElement, HTMLElement\n            if (\"clientLeft\" in target) {\n                var parentElement = null;\n                if (position === \"absolute\") {\n                    var offsetInfo = getOffsetInfo(target, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(target));\n                    parentElement = offsetInfo.offsetParent;\n                } else {\n                    parentElement = target.parentElement;\n                }\n                if (parentElement) {\n                    var getParentStyle = getCachedStyle(parentElement);\n                    containerWidth = parseFloat(getParentStyle(\"width\"));\n                    containerHeight = parseFloat(getParentStyle(\"height\"));\n                }\n            }\n            minWidth = Math.max(horizontalPadding, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(getStyle(\"minWidth\"), containerWidth) || 0);\n            minHeight = Math.max(verticalPadding, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(getStyle(\"minHeight\"), containerHeight) || 0);\n            maxWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(getStyle(\"maxWidth\"), containerWidth);\n            maxHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(getStyle(\"maxHeight\"), containerHeight);\n            if (isNaN(maxWidth)) {\n                maxWidth = Infinity;\n            }\n            if (isNaN(maxHeight)) {\n                maxHeight = Infinity;\n            }\n            inlineCSSWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(targetStyle.width, 0) || 0;\n            inlineCSSHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(targetStyle.height, 0) || 0;\n            cssWidth = parseFloat(getStyle(\"width\")) || 0;\n            cssHeight = parseFloat(getStyle(\"height\")) || 0;\n            contentWidth = abs(cssWidth - inlineCSSWidth) < 1 ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.between)(minWidth, inlineCSSWidth || cssWidth, maxWidth) : cssWidth;\n            contentHeight = abs(cssHeight - inlineCSSHeight) < 1 ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.between)(minHeight, inlineCSSHeight || cssHeight, maxHeight) : cssHeight;\n            offsetWidth = contentWidth;\n            offsetHeight = contentHeight;\n            clientWidth = contentWidth;\n            clientHeight = contentHeight;\n            if (boxSizing) {\n                maxOffsetWidth = maxWidth;\n                maxOffsetHeight = maxHeight;\n                minOffsetWidth = minWidth;\n                minOffsetHeight = minHeight;\n                contentWidth = offsetWidth - horizontalOffset;\n                contentHeight = offsetHeight - verticalOffset;\n            } else {\n                maxOffsetWidth = maxWidth + horizontalOffset;\n                maxOffsetHeight = maxHeight + verticalOffset;\n                minOffsetWidth = minWidth + horizontalOffset;\n                minOffsetHeight = minHeight + verticalOffset;\n                offsetWidth = contentWidth + horizontalOffset;\n                offsetHeight = contentHeight + verticalOffset;\n            }\n            clientWidth = contentWidth + horizontalPadding;\n            clientHeight = contentHeight + verticalPadding;\n        }\n    }\n    return {\n        svg: svg,\n        offsetWidth: offsetWidth,\n        offsetHeight: offsetHeight,\n        clientWidth: clientWidth,\n        clientHeight: clientHeight,\n        contentWidth: contentWidth,\n        contentHeight: contentHeight,\n        inlineCSSWidth: inlineCSSWidth,\n        inlineCSSHeight: inlineCSSHeight,\n        cssWidth: cssWidth,\n        cssHeight: cssHeight,\n        minWidth: minWidth,\n        minHeight: minHeight,\n        maxWidth: maxWidth,\n        maxHeight: maxHeight,\n        minOffsetWidth: minOffsetWidth,\n        minOffsetHeight: minOffsetHeight,\n        maxOffsetWidth: maxOffsetWidth,\n        maxOffsetHeight: maxOffsetHeight\n    };\n}\nfunction getRotationRad(poses, direction) {\n    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\nfunction resetClientRect() {\n    return {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        right: 0,\n        bottom: 0,\n        clientLeft: 0,\n        clientTop: 0,\n        clientWidth: 0,\n        clientHeight: 0,\n        scrollWidth: 0,\n        scrollHeight: 0\n    };\n}\nfunction getExtendsRect(el, rect) {\n    var isRoot = el === (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(el) || el === (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentElement)(el);\n    var extendsRect = {\n        clientLeft: el.clientLeft,\n        clientTop: el.clientTop,\n        clientWidth: el.clientWidth,\n        clientHeight: el.clientHeight,\n        scrollWidth: el.scrollWidth,\n        scrollHeight: el.scrollHeight,\n        overflow: false\n    };\n    if (isRoot) {\n        extendsRect.clientHeight = Math.max(rect.height, extendsRect.clientHeight);\n        extendsRect.scrollHeight = Math.max(rect.height, extendsRect.scrollHeight);\n    }\n    extendsRect.overflow = getCachedStyle(el)(\"overflow\") !== \"visible\";\n    return __assign(__assign({}, rect), extendsRect);\n}\nfunction getClientRectByPosition(position, base, el, isExtends) {\n    var left = position.left, right = position.right, top = position.top, bottom = position.bottom;\n    var baseTop = base.top;\n    var baseLeft = base.left;\n    var rect = {\n        left: baseLeft + left,\n        top: baseTop + top,\n        right: baseLeft + right,\n        bottom: baseTop + bottom,\n        width: right - left,\n        height: bottom - top\n    };\n    if (el && isExtends) {\n        return getExtendsRect(el, rect);\n    }\n    return rect;\n}\nfunction getClientRect(el, isExtends) {\n    var left = 0;\n    var top = 0;\n    var width = 0;\n    var height = 0;\n    // let isRoot = false;\n    if (el) {\n        var clientRect = el.getBoundingClientRect();\n        left = clientRect.left;\n        top = clientRect.top;\n        width = clientRect.width;\n        height = clientRect.height;\n    }\n    var rect = {\n        left: left,\n        top: top,\n        width: width,\n        height: height,\n        right: left + width,\n        bottom: top + height\n    };\n    if (el && isExtends) {\n        return getExtendsRect(el, rect);\n    }\n    return rect;\n}\nfunction getTotalOrigin(moveable) {\n    var _a = moveable.props, groupable = _a.groupable, svgOrigin = _a.svgOrigin;\n    var _b = moveable.getState(), offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight, svg = _b.svg, transformOrigin = _b.transformOrigin;\n    if (!groupable && svg && svgOrigin) {\n        return convertTransformOriginArray(svgOrigin, offsetWidth, offsetHeight);\n    }\n    return transformOrigin;\n}\nfunction getTotalDirection(parentDirection, isPinch, inputEvent, datas) {\n    var direction;\n    if (parentDirection) {\n        direction = parentDirection;\n    } else if (isPinch) {\n        direction = [\n            0,\n            0\n        ];\n    } else {\n        var target = inputEvent.target;\n        direction = getDirection(target, datas);\n    }\n    return direction;\n}\nfunction getDirection(target, datas) {\n    if (!target) {\n        return;\n    }\n    var deg = target.getAttribute(\"data-rotation\") || \"\";\n    var direciton = target.getAttribute(\"data-direction\");\n    datas.deg = deg;\n    if (!direciton) {\n        return;\n    }\n    var dir = [\n        0,\n        0\n    ];\n    direciton.indexOf(\"w\") > -1 && (dir[0] = -1);\n    direciton.indexOf(\"e\") > -1 && (dir[0] = 1);\n    direciton.indexOf(\"n\") > -1 && (dir[1] = -1);\n    direciton.indexOf(\"s\") > -1 && (dir[1] = 1);\n    return dir;\n}\nfunction getAbsolutePoses(poses, dist) {\n    return [\n        (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[0]),\n        (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[1]),\n        (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[2]),\n        (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[3])\n    ];\n}\nfunction getAbsolutePosesByState(_a) {\n    var left = _a.left, top = _a.top, pos1 = _a.pos1, pos2 = _a.pos2, pos3 = _a.pos3, pos4 = _a.pos4;\n    return getAbsolutePoses([\n        pos1,\n        pos2,\n        pos3,\n        pos4\n    ], [\n        left,\n        top\n    ]);\n}\nfunction unsetAbles(self, isControl) {\n    self[isControl ? \"controlAbles\" : \"targetAbles\"].forEach(function(able) {\n        able.unset && able.unset(self);\n    });\n}\nfunction unsetGesto(self, isControl) {\n    var gestoName = isControl ? \"controlGesto\" : \"targetGesto\";\n    var gesto = self[gestoName];\n    if ((gesto === null || gesto === void 0 ? void 0 : gesto.isIdle()) === false) {\n        unsetAbles(self, isControl);\n    }\n    gesto === null || gesto === void 0 ? void 0 : gesto.unset();\n    self[gestoName] = null;\n}\nfunction fillCSSObject(style, resolvedEvent) {\n    if (resolvedEvent) {\n        var originalDatas = getBeforeRenderableDatas(resolvedEvent);\n        originalDatas.nextStyle = __assign(__assign({}, originalDatas.nextStyle), style);\n    }\n    return {\n        style: style,\n        cssText: (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(style).map(function(name) {\n            return \"\".concat((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.decamelize)(name, \"-\"), \": \").concat(style[name], \";\");\n        }).join(\"\")\n    };\n}\nfunction fillAfterTransform(prevEvent, nextEvent, resolvedEvent) {\n    var afterTransform = nextEvent.afterTransform || nextEvent.transform;\n    return __assign(__assign({}, fillCSSObject(__assign(__assign(__assign({}, prevEvent.style), nextEvent.style), {\n        transform: afterTransform\n    }), resolvedEvent)), {\n        afterTransform: afterTransform,\n        transform: prevEvent.transform\n    });\n}\nfunction fillParams(moveable, e, params, isBeforeEvent) {\n    var datas = e.datas;\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    var nextParams = __assign(__assign({}, params), {\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        moveable: moveable,\n        datas: datas.datas,\n        isRequest: e.isRequest,\n        isRequestChild: e.isRequestChild,\n        isFirstDrag: !!e.isFirstDrag,\n        isTrusted: e.isTrusted !== false,\n        stopAble: function() {\n            datas.isEventStart = false;\n        },\n        stopDrag: function() {\n            var _a;\n            (_a = e.stop) === null || _a === void 0 ? void 0 : _a.call(e);\n        }\n    });\n    if (!datas.isStartEvent) {\n        datas.isStartEvent = true;\n    } else if (!isBeforeEvent) {\n        datas.lastEvent = nextParams;\n    }\n    return nextParams;\n}\nfunction fillEndParams(moveable, e, params) {\n    var datas = e.datas;\n    var isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    return __assign(__assign({\n        isDrag: isDrag\n    }, params), {\n        moveable: moveable,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        lastEvent: datas.lastEvent,\n        isDouble: e.isDouble,\n        datas: datas.datas,\n        isFirstDrag: !!e.isFirstDrag\n    });\n}\nfunction catchEvent(moveable, name, callback) {\n    moveable._emitter.on(name, callback);\n}\nfunction triggerEvent(moveable, name, params, isManager, isRequest) {\n    return moveable.triggerEvent(name, params, isManager, isRequest);\n}\nfunction getComputedStyle(el, pseudoElt) {\n    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)(el).getComputedStyle(el, pseudoElt);\n}\nfunction filterAbles(ables, methods, triggerAblesSimultaneously) {\n    var enabledAbles = {};\n    var ableGroups = {};\n    return ables.filter(function(able) {\n        var name = able.name;\n        if (enabledAbles[name] || !methods.some(function(method) {\n            return able[method];\n        })) {\n            return false;\n        }\n        if (!triggerAblesSimultaneously && able.ableGroup) {\n            if (ableGroups[able.ableGroup]) {\n                return false;\n            }\n            ableGroups[able.ableGroup] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\nfunction equals(a1, a2) {\n    return a1 === a2 || a1 == null && a2 == null;\n}\nfunction selectValue() {\n    var values = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        values[_i] = arguments[_i];\n    }\n    var length = values.length - 1;\n    for(var i = 0; i < length; ++i){\n        var value = values[i];\n        if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(value)) {\n            return value;\n        }\n    }\n    return values[length];\n}\nfunction groupBy(arr, func) {\n    var groups = [];\n    var groupKeys = [];\n    arr.forEach(function(el, index) {\n        var groupKey = func(el, index, arr);\n        var keyIndex = groupKeys.indexOf(groupKey);\n        var group = groups[keyIndex] || [];\n        if (keyIndex === -1) {\n            groupKeys.push(groupKey);\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nfunction groupByMap(arr, func) {\n    var groups = [];\n    var groupKeys = {};\n    arr.forEach(function(el, index) {\n        var groupKey = func(el, index, arr);\n        var group = groupKeys[groupKey];\n        if (!group) {\n            group = [];\n            groupKeys[groupKey] = group;\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nfunction flat(arr) {\n    return arr.reduce(function(prev, cur) {\n        return prev.concat(cur);\n    }, []);\n}\nfunction maxOffset() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    args.sort(function(a, b) {\n        return abs(b) - abs(a);\n    });\n    return args[0];\n}\nfunction calculateInversePosition(matrix, pos, n) {\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(matrix, n), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)(pos, n), n);\n}\nfunction convertDragDist(state, e) {\n    var _a;\n    var is3d = state.is3d, rootMatrix = state.rootMatrix;\n    var n = is3d ? 4 : 3;\n    _a = __read(calculateInversePosition(rootMatrix, [\n        e.distX,\n        e.distY\n    ], n), 2), e.distX = _a[0], e.distY = _a[1];\n    return e;\n}\nfunction calculatePadding(matrix, pos, added, n) {\n    if (!added[0] && !added[1]) {\n        return pos;\n    }\n    var xAdded = calculatePosition(matrix, [\n        normalized(added[0] || 1),\n        0\n    ], n);\n    var yAdded = calculatePosition(matrix, [\n        0,\n        normalized(added[1] || 1)\n    ], n);\n    var nextAdded = calculatePosition(matrix, [\n        added[0] / getDistSize(xAdded),\n        added[1] / getDistSize(yAdded)\n    ], n);\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, nextAdded);\n}\nfunction convertCSSSize(value, size, isRelative) {\n    return isRelative ? \"\".concat(value / size * 100, \"%\") : \"\".concat(value, \"px\");\n}\nfunction getTinyDist(v) {\n    return abs(v) <= TINY_NUM ? 0 : v;\n}\nfunction getDirectionViewClassName(ableName) {\n    return function(moveable) {\n        if (!moveable.isDragging(ableName)) {\n            return \"\";\n        }\n        var data = getGestoData(moveable, ableName);\n        var deg = data.deg;\n        if (!deg) {\n            return \"\";\n        }\n        return prefix(\"view-control-rotation\".concat(deg));\n    };\n}\nfunction getDirectionCondition(ableName, checkAbles) {\n    if (checkAbles === void 0) {\n        checkAbles = [\n            ableName\n        ];\n    }\n    return function(moveable, e) {\n        if (e.isRequest) {\n            if (checkAbles.some(function(name) {\n                return e.requestAble === name;\n            })) {\n                return e.parentDirection;\n            } else {\n                return false;\n            }\n        }\n        var target = e.inputEvent.target;\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"direction\")) && (!ableName || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(ableName)));\n    };\n}\nfunction convertTransformInfo(transforms, state, index) {\n    var _a;\n    var matrixInfos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(transforms, {\n        \"x%\": function(v) {\n            return v / 100 * state.offsetWidth;\n        },\n        \"y%\": function(v) {\n            return v / 100 * state.offsetHeight;\n        }\n    });\n    var beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);\n    var beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);\n    var targetFunctionText = transforms[index] || \"\";\n    var afterFunctionTexts = index < 0 ? [] : transforms.slice(index);\n    var afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);\n    var beforeFunctions = matrixInfos.slice(0, index < 0 ? undefined : index);\n    var beforeFunctions2 = matrixInfos.slice(0, index < 0 ? undefined : index + 1);\n    var targetFunction = (_a = matrixInfos[index]) !== null && _a !== void 0 ? _a : (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)([\n        \"\"\n    ])[0];\n    var afterFunctions = index < 0 ? [] : matrixInfos.slice(index);\n    var afterFunctions2 = index < 0 ? [] : matrixInfos.slice(index + 1);\n    var targetFunctions = targetFunction ? [\n        targetFunction\n    ] : [];\n    var beforeFunctionMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(beforeFunctions);\n    var beforeFunctionMatrix2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(beforeFunctions2);\n    var afterFunctionMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(afterFunctions);\n    var afterFunctionMatrix2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(afterFunctions2);\n    var allFunctionMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(beforeFunctionMatrix, afterFunctionMatrix, 4);\n    return {\n        transforms: transforms,\n        beforeFunctionMatrix: beforeFunctionMatrix,\n        beforeFunctionMatrix2: beforeFunctionMatrix2,\n        targetFunctionMatrix: (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(targetFunctions),\n        afterFunctionMatrix: afterFunctionMatrix,\n        afterFunctionMatrix2: afterFunctionMatrix2,\n        allFunctionMatrix: allFunctionMatrix,\n        beforeFunctions: beforeFunctions,\n        beforeFunctions2: beforeFunctions2,\n        targetFunction: targetFunctions[0],\n        afterFunctions: afterFunctions,\n        afterFunctions2: afterFunctions2,\n        beforeFunctionTexts: beforeFunctionTexts,\n        beforeFunctionTexts2: beforeFunctionTexts2,\n        targetFunctionText: targetFunctionText,\n        afterFunctionTexts: afterFunctionTexts,\n        afterFunctionTexts2: afterFunctionTexts2\n    };\n}\nfunction isArrayFormat(arr) {\n    if (!arr || !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(arr)) {\n        return false;\n    }\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNode)(arr)) {\n        return false;\n    }\n    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(arr) || \"length\" in arr;\n}\nfunction getRefTarget(target, isSelector) {\n    if (!target) {\n        return null;\n    }\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNode)(target)) {\n        return target;\n    }\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(target)) {\n        if (isSelector) {\n            return document.querySelector(target);\n        }\n        return target;\n    }\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(target)) {\n        return target();\n    }\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isWindow)(target)) {\n        return target;\n    }\n    if (\"current\" in target) {\n        return target.current;\n    }\n    return target;\n}\nfunction getRefTargets(targets, isSelector) {\n    if (!targets) {\n        return [];\n    }\n    var userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [\n        targets\n    ];\n    return userTargets.reduce(function(prev, target) {\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(target) && isSelector) {\n            return __spreadArray(__spreadArray([], __read(prev), false), __read([].slice.call(document.querySelectorAll(target))), false);\n        }\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target)) {\n            prev.push(getRefTargets(target, isSelector));\n        } else {\n            prev.push(getRefTarget(target, isSelector));\n        }\n        return prev;\n    }, []);\n}\nfunction getAbsoluteRotation(pos1, pos2, direction) {\n    var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(pos1, pos2) / Math.PI * 180;\n    deg = direction >= 0 ? deg : 180 - deg;\n    deg = deg >= 0 ? deg : 360 + deg;\n    return deg;\n}\nfunction getDragDistByState(state, dist) {\n    var rootMatrix = state.rootMatrix, is3d = state.is3d;\n    var n = is3d ? 4 : 3;\n    var inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(rootMatrix, n);\n    if (!is3d) {\n        inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(inverseMatrix, 3, 4);\n    }\n    inverseMatrix[12] = 0;\n    inverseMatrix[13] = 0;\n    inverseMatrix[14] = 0;\n    return (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(inverseMatrix, dist);\n}\nfunction getSizeDistByDist(startSize, dist, ratio, direction, keepRatio) {\n    var _a = __read(startSize, 2), startOffsetWidth = _a[0], startOffsetHeight = _a[1];\n    var distWidth = 0;\n    var distHeight = 0;\n    if (keepRatio && startOffsetWidth && startOffsetHeight) {\n        var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([\n            0,\n            0\n        ], dist);\n        var standardRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([\n            0,\n            0\n        ], direction);\n        var size = getDistSize(dist);\n        var signSize = Math.cos(rad - standardRad) * size;\n        if (!direction[0]) {\n            // top, bottom\n            distHeight = signSize;\n            distWidth = distHeight * ratio;\n        } else if (!direction[1]) {\n            // left, right\n            distWidth = signSize;\n            distHeight = distWidth / ratio;\n        } else {\n            // two-way\n            var startWidthSize = direction[0] * startOffsetWidth;\n            var startHeightSize = direction[1] * startOffsetHeight;\n            var secondRad = Math.atan2(startWidthSize + dist[0], startHeightSize + dist[1]);\n            var firstRad = Math.atan2(startWidthSize, startHeightSize);\n            if (secondRad < 0) {\n                secondRad += Math.PI * 2;\n            }\n            if (firstRad < 0) {\n                firstRad += Math.PI * 2;\n            }\n            var rad_1 = 0;\n            if (abs(secondRad - firstRad) < Math.PI / 2 || abs(secondRad - firstRad) > Math.PI / 2 * 3) {\n                rad_1 = secondRad - firstRad;\n            } else {\n                firstRad += Math.PI;\n                rad_1 = secondRad - firstRad;\n            }\n            if (rad_1 > Math.PI * 2) {\n                rad_1 -= Math.PI * 2;\n            } else if (rad_1 > Math.PI) {\n                rad_1 = 2 * Math.PI - rad_1;\n            } else if (rad_1 < -Math.PI) {\n                rad_1 = -2 * Math.PI - rad_1;\n            }\n            //       180\n            // -1, -1,  // 1, -1\n            // 270            90\n            // -1, 1    // 1, 1\n            //       0\n            var distSize = getDistSize([\n                startWidthSize + dist[0],\n                startHeightSize + dist[1]\n            ]) * Math.cos(rad_1);\n            distWidth = distSize * Math.sin(firstRad) - startWidthSize;\n            distHeight = distSize * Math.cos(firstRad) - startHeightSize;\n            if (direction[0] < 0) {\n                distWidth *= -1;\n            }\n            if (direction[1] < 0) {\n                distHeight *= -1;\n            }\n        }\n    } else {\n        distWidth = direction[0] * dist[0];\n        distHeight = direction[1] * dist[1];\n    }\n    return [\n        distWidth,\n        distHeight\n    ];\n}\nfunction getOffsetSizeDist(sizeDirection, keepRatio, datas, e) {\n    var _a;\n    var ratio = datas.ratio, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight;\n    var distWidth = 0;\n    var distHeight = 0;\n    var distX = e.distX, distY = e.distY, pinchScale = e.pinchScale, parentDistance = e.parentDistance, parentDist = e.parentDist, parentScale = e.parentScale;\n    var startFixedDirection = datas.fixedDirection;\n    var directionsDists = [\n        0,\n        1\n    ].map(function(index) {\n        return abs(sizeDirection[index] - startFixedDirection[index]);\n    });\n    var directionRatios = [\n        0,\n        1\n    ].map(function(index) {\n        var dist = directionsDists[index];\n        if (dist !== 0) {\n            dist = 2 / dist;\n        }\n        return dist;\n    });\n    if (parentDist) {\n        distWidth = parentDist[0];\n        distHeight = parentDist[1];\n        if (keepRatio) {\n            if (!distWidth) {\n                distWidth = distHeight * ratio;\n            } else if (!distHeight) {\n                distHeight = distWidth / ratio;\n            }\n        }\n    } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(pinchScale)) {\n        distWidth = (pinchScale - 1) * startOffsetWidth;\n        distHeight = (pinchScale - 1) * startOffsetHeight;\n    } else if (parentScale) {\n        distWidth = (parentScale[0] - 1) * startOffsetWidth;\n        distHeight = (parentScale[1] - 1) * startOffsetHeight;\n    } else if (parentDistance) {\n        var scaleX = startOffsetWidth * directionsDists[0];\n        var scaleY = startOffsetHeight * directionsDists[1];\n        var ratioDistance = getDistSize([\n            scaleX,\n            scaleY\n        ]);\n        distWidth = parentDistance / ratioDistance * scaleX * directionRatios[0];\n        distHeight = parentDistance / ratioDistance * scaleY * directionRatios[1];\n    } else {\n        var dist_1 = getDragDist({\n            datas: datas,\n            distX: distX,\n            distY: distY\n        });\n        dist_1 = directionRatios.map(function(ratio, i) {\n            return dist_1[i] * ratio;\n        });\n        _a = __read(getSizeDistByDist([\n            startOffsetWidth,\n            startOffsetHeight\n        ], dist_1, ratio, sizeDirection, keepRatio), 2), distWidth = _a[0], distHeight = _a[1];\n    }\n    return {\n        // direction,\n        // sizeDirection,\n        distWidth: distWidth,\n        distHeight: distHeight\n    };\n}\nfunction convertTransformUnit(origin, xy) {\n    if (xy) {\n        if (origin === \"left\") {\n            return {\n                x: \"0%\",\n                y: \"50%\"\n            };\n        } else if (origin === \"top\") {\n            return {\n                x: \"50%\",\n                y: \"50%\"\n            };\n        } else if (origin === \"center\") {\n            return {\n                x: \"50%\",\n                y: \"50%\"\n            };\n        } else if (origin === \"right\") {\n            return {\n                x: \"100%\",\n                y: \"50%\"\n            };\n        } else if (origin === \"bottom\") {\n            return {\n                x: \"50%\",\n                y: \"100%\"\n            };\n        }\n        var _a = __read(origin.split(\" \"), 2), left = _a[0], right = _a[1];\n        var leftOrigin = convertTransformUnit(left || \"\");\n        var rightOrigin = convertTransformUnit(right || \"\");\n        var originObject = __assign(__assign({}, leftOrigin), rightOrigin);\n        var nextOriginObject = {\n            x: \"50%\",\n            y: \"50%\"\n        };\n        if (originObject.x) {\n            nextOriginObject.x = originObject.x;\n        }\n        if (originObject.y) {\n            nextOriginObject.y = originObject.y;\n        }\n        if (originObject.value) {\n            if (originObject.x && !originObject.y) {\n                nextOriginObject.y = originObject.value;\n            }\n            if (!originObject.x && originObject.y) {\n                nextOriginObject.x = originObject.value;\n            }\n        }\n        return nextOriginObject;\n    }\n    if (origin === \"left\") {\n        return {\n            x: \"0%\"\n        };\n    }\n    if (origin === \"right\") {\n        return {\n            x: \"100%\"\n        };\n    }\n    if (origin === \"top\") {\n        return {\n            y: \"0%\"\n        };\n    }\n    if (origin === \"bottom\") {\n        return {\n            y: \"100%\"\n        };\n    }\n    if (!origin) {\n        return {};\n    }\n    if (origin === \"center\") {\n        return {\n            value: \"50%\"\n        };\n    }\n    return {\n        value: origin\n    };\n}\nfunction convertTransformOriginArray(transformOrigin, width, height) {\n    var _a = convertTransformUnit(transformOrigin, true), x = _a.x, y = _a.y;\n    return [\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(x, width) || 0,\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(y, height) || 0\n    ];\n}\nfunction rotatePosesInfo(poses, origin, rad) {\n    var prevPoses = poses.map(function(pos) {\n        return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos, origin);\n    });\n    var nextPoses = prevPoses.map(function(pos) {\n        return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad);\n    });\n    return {\n        prev: prevPoses,\n        next: nextPoses,\n        result: nextPoses.map(function(pos) {\n            return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, origin);\n        })\n    };\n}\nfunction isDeepArrayEquals(arr1, arr2) {\n    return arr1.length === arr2.length && arr1.every(function(value1, i) {\n        var value2 = arr2[i];\n        var isArray1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(value1);\n        var isArray2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(value2);\n        if (isArray1 && isArray2) {\n            return isDeepArrayEquals(value1, value2);\n        } else if (!isArray1 && !isArray2) {\n            return value1 === value2;\n        }\n        return false;\n    });\n}\nfunction watchValue(moveable, property, nextValue, valueKey, defaultValue) {\n    var store = moveable._store;\n    var prevValue = store[property];\n    if (!(property in store)) {\n        if (defaultValue != null) {\n            store[property] = defaultValue;\n            prevValue = defaultValue;\n        } else {\n            store[property] = nextValue;\n            return nextValue;\n        }\n    }\n    if (prevValue === nextValue || valueKey(prevValue) === valueKey(nextValue)) {\n        return prevValue;\n    }\n    store[property] = nextValue;\n    return nextValue;\n}\nfunction sign(value) {\n    return value >= 0 ? 1 : -1;\n}\nfunction abs(value) {\n    return Math.abs(value);\n}\nfunction countEach(count, callback) {\n    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.counter)(count).map(function(index) {\n        return callback(index);\n    });\n}\nfunction getPaddingBox(padding) {\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(padding)) {\n        return {\n            top: padding,\n            left: padding,\n            right: padding,\n            bottom: padding\n        };\n    }\n    return {\n        left: padding.left || 0,\n        top: padding.top || 0,\n        right: padding.right || 0,\n        bottom: padding.bottom || 0\n    };\n}\n/**\r\n * @namespace Moveable.Pinchable\r\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\r\n */ var Pinchable = makeAble(\"pinchable\", {\n    props: [\n        \"pinchable\"\n    ],\n    events: [\n        \"pinchStart\",\n        \"pinch\",\n        \"pinchEnd\",\n        \"pinchGroupStart\",\n        \"pinchGroup\",\n        \"pinchGroupEnd\"\n    ],\n    dragStart: function() {\n        return true;\n    },\n    pinchStart: function(moveable, e) {\n        var datas = e.datas, targets = e.targets, angle = e.angle, originalDatas = e.originalDatas;\n        var _a = moveable.props, pinchable = _a.pinchable, ables = _a.ables;\n        if (!pinchable) {\n            return false;\n        }\n        var eventName = \"onPinch\".concat(targets ? \"Group\" : \"\", \"Start\");\n        var controlEventName = \"drag\".concat(targets ? \"Group\" : \"\", \"ControlStart\");\n        var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function(able) {\n            return pinchable.indexOf(able.name) > -1;\n        })).filter(function(able) {\n            return able.canPinch && able[controlEventName];\n        });\n        var params = fillParams(moveable, e, {});\n        if (targets) {\n            params.targets = targets;\n        }\n        var result = triggerEvent(moveable, eventName, params);\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n        var isPinch = datas.isPinch;\n        if (!isPinch) {\n            return false;\n        }\n        pinchAbles.forEach(function(able) {\n            originalDatas[able.name] = originalDatas[able.name] || {};\n            if (!able[controlEventName]) {\n                return;\n            }\n            var ableEvent = __assign(__assign({}, e), {\n                datas: originalDatas[able.name],\n                parentRotate: angle,\n                isPinch: true\n            });\n            able[controlEventName](moveable, ableEvent);\n        });\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            direction: [\n                0,\n                0\n            ]\n        };\n        return isPinch;\n    },\n    pinch: function(moveable, e) {\n        var datas = e.datas, pinchScale = e.scale, distance = e.distance, originalDatas = e.originalDatas, inputEvent = e.inputEvent, targets = e.targets, angle = e.angle;\n        if (!datas.isPinch) {\n            return;\n        }\n        var parentDistance = distance * (1 - 1 / pinchScale);\n        var params = fillParams(moveable, e, {});\n        if (targets) {\n            params.targets = targets;\n        }\n        var eventName = \"onPinch\".concat(targets ? \"Group\" : \"\");\n        triggerEvent(moveable, eventName, params);\n        var ables = datas.ables;\n        var controlEventName = \"drag\".concat(targets ? \"Group\" : \"\", \"Control\");\n        ables.forEach(function(able) {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName](moveable, __assign(__assign({}, e), {\n                datas: originalDatas[able.name],\n                inputEvent: inputEvent,\n                resolveMatrix: true,\n                pinchScale: pinchScale,\n                parentDistance: parentDistance,\n                parentRotate: angle,\n                isPinch: true\n            }));\n        });\n        return params;\n    },\n    pinchEnd: function(moveable, e) {\n        var datas = e.datas, isPinch = e.isPinch, inputEvent = e.inputEvent, targets = e.targets, originalDatas = e.originalDatas;\n        if (!datas.isPinch) {\n            return;\n        }\n        var eventName = \"onPinch\".concat(targets ? \"Group\" : \"\", \"End\");\n        var params = fillEndParams(moveable, e, {\n            isDrag: isPinch\n        });\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        var ables = datas.ables;\n        var controlEventName = \"drag\".concat(targets ? \"Group\" : \"\", \"ControlEnd\");\n        ables.forEach(function(able) {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName](moveable, __assign(__assign({}, e), {\n                isDrag: isPinch,\n                datas: originalDatas[able.name],\n                inputEvent: inputEvent,\n                isPinch: true\n            }));\n        });\n        return isPinch;\n    },\n    pinchGroupStart: function(moveable, e) {\n        return this.pinchStart(moveable, __assign(__assign({}, e), {\n            targets: moveable.props.targets\n        }));\n    },\n    pinchGroup: function(moveable, e) {\n        return this.pinch(moveable, __assign(__assign({}, e), {\n            targets: moveable.props.targets\n        }));\n    },\n    pinchGroupEnd: function(moveable, e) {\n        return this.pinchEnd(moveable, __assign(__assign({}, e), {\n            targets: moveable.props.targets\n        }));\n    }\n});\n/**\r\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\r\n * @name Moveable.Pinchable#pinchable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.pinchable = true;\r\n */ /**\r\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\r\n * @memberof Moveable.Pinchable\r\n * @event pinchStart\r\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     rotatable: true,\r\n *     scalable: true,\r\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\r\n * });\r\n * moveable.on(\"pinchStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"rotateStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"scaleStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */ /**\r\n * When pinching, the pinch event is called with part of scale, rotate, resize\r\n * @memberof Moveable.Pinchable\r\n * @event pinch\r\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     rotatable: true,\r\n *     scalable: true,\r\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\r\n * });\r\n * moveable.on(\"pinch\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"rotate\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"scale\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */ /**\r\n * When the pinch finishes, the pinchEnd event is called.\r\n * @memberof Moveable.Pinchable\r\n * @event pinchEnd\r\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     rotatable: true,\r\n *     scalable: true,\r\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\r\n * });\r\n * moveable.on(\"pinchEnd\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"rotateEnd\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"scaleEnd\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */ /**\r\n * When the group pinch starts, the `pinchGroupStart` event is called.\r\n * @memberof Moveable.Pinchable\r\n * @event pinchGroupStart\r\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     pinchable: true\r\n * });\r\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\r\n *     console.log(\"onPinchGroupStart\", targets);\r\n * });\r\n */ /**\r\n * When the group pinch, the `pinchGroup` event is called.\r\n * @memberof Moveable.Pinchable\r\n * @event pinchGroup\r\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     pinchable: true\r\n * });\r\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\r\n *     console.log(\"onPinchGroup\", targets);\r\n * });\r\n */ /**\r\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\r\n * @memberof Moveable.Pinchable\r\n * @event pinchGroupEnd\r\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     pinchable: true\r\n * });\r\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\r\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\r\n * });\r\n */ var directionCondition = getDirectionCondition(\"scalable\");\n/**\r\n * @namespace Scalable\r\n * @memberof Moveable\r\n * @description Scalable indicates whether the target's x and y can be scale of transform.\r\n */ var Scalable = {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: [\n        \"scalable\",\n        \"throttleScale\",\n        \"renderDirections\",\n        \"keepRatio\",\n        \"edge\",\n        \"displayAroundControls\"\n    ],\n    events: [\n        \"scaleStart\",\n        \"beforeScale\",\n        \"scale\",\n        \"scaleEnd\",\n        \"scaleGroupStart\",\n        \"beforeScaleGroup\",\n        \"scaleGroup\",\n        \"scaleGroupEnd\"\n    ],\n    render: getRenderDirections(\"scalable\"),\n    dragControlCondition: directionCondition,\n    viewClassName: getDirectionViewClassName(\"scalable\"),\n    dragControlStart: function(moveable, e) {\n        var datas = e.datas, isPinch = e.isPinch, inputEvent = e.inputEvent, parentDirection = e.parentDirection;\n        var direction = getTotalDirection(parentDirection, isPinch, inputEvent, datas);\n        var _a = moveable.state, width = _a.width, height = _a.height, targetTransform = _a.targetTransform, target = _a.target, pos1 = _a.pos1, pos2 = _a.pos2, pos4 = _a.pos4;\n        if (!direction || !target) {\n            return false;\n        }\n        if (!isPinch) {\n            setDragStart(moveable, e);\n        }\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [\n            1,\n            1\n        ];\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.startValue = [\n            1,\n            1\n        ];\n        // const scaleWidth = getDist(pos1, pos2);\n        // const scaleHeight = getDist(pos2, pos4);\n        var isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];\n        // datas.scaleWidth = scaleWidth;\n        // datas.scaleHeight = scaleHeight;\n        // datas.scaleXRatio = scaleWidth / width;\n        // datas.scaleYRatio = scaleHeight / height;\n        setDefaultTransformIndex(moveable, e, \"scale\");\n        datas.isWidth = isWidth;\n        function setRatio(ratio) {\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n        }\n        datas.startPositions = getAbsolutePosesByState(moveable.state);\n        function setFixedDirection(fixedDirection) {\n            var result = getFixedDirectionInfo(datas.startPositions, fixedDirection);\n            datas.fixedDirection = result.fixedDirection;\n            datas.fixedPosition = result.fixedPosition;\n            datas.fixedOffset = result.fixedOffset;\n        }\n        datas.setFixedDirection = setFixedDirection;\n        setRatio((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(pos1, pos2) / (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(pos2, pos4));\n        setFixedDirection([\n            -direction[0],\n            -direction[1]\n        ]);\n        var setMinScaleSize = function(min) {\n            datas.minScaleSize = min;\n        };\n        var setMaxScaleSize = function(max) {\n            datas.maxScaleSize = max;\n        };\n        // const setMinScale = (min: number[]) => {\n        // };\n        // const setMaxScale = (max: number[]) => {\n        // };\n        setMinScaleSize([\n            -Infinity,\n            -Infinity\n        ]);\n        setMaxScaleSize([\n            Infinity,\n            Infinity\n        ]);\n        var params = fillParams(moveable, e, __assign(__assign({\n            direction: direction,\n            set: function(scale) {\n                datas.startValue = scale;\n            },\n            setRatio: setRatio,\n            setFixedDirection: setFixedDirection,\n            setMinScaleSize: setMinScaleSize,\n            setMaxScaleSize: setMaxScaleSize\n        }, fillTransformStartEvent(moveable, e)), {\n            dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([\n                0,\n                0\n            ], e))\n        }));\n        var result = triggerEvent(moveable, \"onScaleStart\", params);\n        datas.startFixedDirection = datas.fixedDirection;\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction: direction\n            };\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl: function(moveable, e) {\n        resolveTransformEvent(moveable, e, \"scale\");\n        var datas = e.datas, parentKeepRatio = e.parentKeepRatio, parentFlag = e.parentFlag, isPinch = e.isPinch, dragClient = e.dragClient, isRequest = e.isRequest, useSnap = e.useSnap, resolveMatrix = e.resolveMatrix;\n        var prevDist = datas.prevDist, direction = datas.direction, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, isScale = datas.isScale, startValue = datas.startValue, isWidth = datas.isWidth, ratio = datas.ratio;\n        if (!isScale) {\n            return false;\n        }\n        var props = moveable.props;\n        var throttleScale = props.throttleScale, parentMoveable = props.parentMoveable;\n        var sizeDirection = direction;\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [\n                1,\n                1\n            ];\n        }\n        var keepRatio = ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio) || false;\n        var state = moveable.state;\n        var tempScaleValue = [\n            startValue[0],\n            startValue[1]\n        ];\n        function getNextScale() {\n            var _a = getOffsetSizeDist(sizeDirection, keepRatio, datas, e), distWidth = _a.distWidth, distHeight = _a.distHeight;\n            var distX = startOffsetWidth ? (startOffsetWidth + distWidth) / startOffsetWidth : 1;\n            var distY = startOffsetHeight ? (startOffsetHeight + distHeight) / startOffsetHeight : 1;\n            if (!startValue[0]) {\n                tempScaleValue[0] = distWidth / startOffsetWidth;\n            }\n            if (!startValue[1]) {\n                tempScaleValue[1] = distHeight / startOffsetHeight;\n            }\n            var scaleX = (sizeDirection[0] || keepRatio ? distX : 1) * tempScaleValue[0];\n            var scaleY = (sizeDirection[1] || keepRatio ? distY : 1) * tempScaleValue[1];\n            if (scaleX === 0) {\n                scaleX = sign(prevDist[0]) * MIN_SCALE;\n            }\n            if (scaleY === 0) {\n                scaleY = sign(prevDist[1]) * MIN_SCALE;\n            }\n            return [\n                scaleX,\n                scaleY\n            ];\n        }\n        var scale = getNextScale();\n        if (!isPinch && moveable.props.groupable) {\n            var snapRenderInfo = state.snapRenderInfo || {};\n            var stateDirection = snapRenderInfo.direction;\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapRenderInfo = {\n                    direction: direction,\n                    request: e.isRequest\n                };\n            }\n        }\n        triggerEvent(moveable, \"onBeforeScale\", fillParams(moveable, e, {\n            scale: scale,\n            setFixedDirection: function(nextFixedDirection) {\n                datas.setFixedDirection(nextFixedDirection);\n                scale = getNextScale();\n                return scale;\n            },\n            startFixedDirection: datas.startFixedDirection,\n            setScale: function(nextScale) {\n                scale = nextScale;\n            }\n        }, true));\n        var dist = [\n            scale[0] / tempScaleValue[0],\n            scale[1] / tempScaleValue[1]\n        ];\n        var fixedPosition = dragClient;\n        var snapDist = [\n            0,\n            0\n        ];\n        var distSign = sign(dist[0] * dist[1]);\n        var isSelfPinch = !dragClient && !parentFlag && isPinch;\n        if (isSelfPinch || resolveMatrix) {\n            fixedPosition = getTranslateFixedPosition(moveable, datas.targetAllTransform, [\n                0,\n                0\n            ], [\n                0,\n                0\n            ], datas);\n        } else if (!dragClient) {\n            fixedPosition = datas.fixedPosition;\n        }\n        if (!isPinch) {\n            snapDist = checkSnapScale(moveable, dist, direction, !useSnap && isRequest, datas);\n        }\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0] * startOffsetWidth) > Math.abs(snapDist[1] * startOffsetHeight)) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n            var isNoSnap = !snapDist[0] && !snapDist[1];\n            if (isNoSnap) {\n                // throttle scale value (not absolute scale size)\n                if (isWidth) {\n                    dist[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(dist[0] * tempScaleValue[0], throttleScale) / tempScaleValue[0];\n                } else {\n                    dist[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(dist[1] * tempScaleValue[1], throttleScale) / tempScaleValue[1];\n                }\n            }\n            if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {\n                dist[0] += snapDist[0];\n                var snapHeight = startOffsetWidth * dist[0] * tempScaleValue[0] / ratio;\n                dist[1] = sign(distSign * dist[0]) * abs(snapHeight / startOffsetHeight / tempScaleValue[1]);\n            } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {\n                dist[1] += snapDist[1];\n                var snapWidth = startOffsetHeight * dist[1] * tempScaleValue[1] * ratio;\n                dist[0] = sign(distSign * dist[1]) * abs(snapWidth / startOffsetWidth / tempScaleValue[0]);\n            }\n        } else {\n            dist[0] += snapDist[0];\n            dist[1] += snapDist[1];\n            if (!snapDist[0]) {\n                dist[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(dist[0] * tempScaleValue[0], throttleScale) / tempScaleValue[0];\n            }\n            if (!snapDist[1]) {\n                dist[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(dist[1] * tempScaleValue[1], throttleScale) / tempScaleValue[1];\n            }\n        }\n        if (dist[0] === 0) {\n            dist[0] = sign(prevDist[0]) * MIN_SCALE;\n        }\n        if (dist[1] === 0) {\n            dist[1] = sign(prevDist[1]) * MIN_SCALE;\n        }\n        scale = multiply2(dist, [\n            tempScaleValue[0],\n            tempScaleValue[1]\n        ]);\n        var startOffsetSize = [\n            startOffsetWidth,\n            startOffsetHeight\n        ];\n        var scaleSize = [\n            startOffsetWidth * scale[0],\n            startOffsetHeight * scale[1]\n        ];\n        scaleSize = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.calculateBoundSize)(scaleSize, datas.minScaleSize, datas.maxScaleSize, keepRatio ? ratio : false);\n        // if (keepRatio && (isGroup || keepRatioFinally)) {\n        //     if (isWidth) {\n        //         boundingHeight = boundingWidth / ratio;\n        //     } else {\n        //         boundingWidth = boundingHeight * ratio;\n        //     }\n        // }\n        scale = countEach(2, function(i) {\n            return startOffsetSize[i] ? scaleSize[i] / startOffsetSize[i] : scaleSize[i];\n        });\n        dist = countEach(2, function(i) {\n            return scale[i] / tempScaleValue[i];\n        });\n        var delta = countEach(2, function(i) {\n            return prevDist[i] ? dist[i] / prevDist[i] : dist[i];\n        });\n        var distText = \"scale(\".concat(dist.join(\", \"), \")\");\n        var scaleText = \"scale(\".concat(scale.join(\", \"), \")\");\n        var nextTransform = convertTransformFormat(datas, scaleText, distText);\n        var isZeroScale = !startValue[0] || !startValue[1];\n        var inverseDist = getScaleDist(moveable, isZeroScale ? scaleText : distText, datas.fixedDirection, fixedPosition, datas.fixedOffset, datas, isZeroScale);\n        var inverseDelta = isSelfPinch ? inverseDist : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(inverseDist, datas.prevInverseDist || [\n            0,\n            0\n        ]);\n        datas.prevDist = dist;\n        datas.prevInverseDist = inverseDist;\n        if (scale[0] === prevDist[0] && scale[1] === prevDist[1] && inverseDelta.every(function(num) {\n            return !num;\n        }) && !parentMoveable && !isSelfPinch) {\n            return false;\n        }\n        var params = fillParams(moveable, e, __assign({\n            offsetWidth: startOffsetWidth,\n            offsetHeight: startOffsetHeight,\n            direction: direction,\n            scale: scale,\n            dist: dist,\n            delta: delta,\n            isPinch: !!isPinch\n        }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));\n        triggerEvent(moveable, \"onScale\", params);\n        return params;\n    },\n    dragControlEnd: function(moveable, e) {\n        var datas = e.datas;\n        if (!datas.isScale) {\n            return false;\n        }\n        datas.isScale = false;\n        var scaleEndParam = fillEndParams(moveable, e, {});\n        triggerEvent(moveable, \"onScaleEnd\", scaleEndParam);\n        return scaleEndParam;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart: function(moveable, e) {\n        var datas = e.datas;\n        var params = this.dragControlStart(moveable, e);\n        if (!params) {\n            return false;\n        }\n        var originalEvents = fillChildEvents(moveable, \"resizable\", e);\n        datas.moveableScale = moveable.scale;\n        var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function(child, ev) {\n            return startChildDist(moveable, child, datas, ev);\n        });\n        var setFixedDirection = function(fixedDirection) {\n            params.setFixedDirection(fixedDirection);\n            events.forEach(function(ev, i) {\n                ev.setFixedDirection(fixedDirection);\n                startChildDist(moveable, ev.moveable, datas, originalEvents[i]);\n            });\n        };\n        datas.setFixedDirection = setFixedDirection;\n        var nextParams = __assign(__assign({}, params), {\n            targets: moveable.props.targets,\n            events: events,\n            setFixedDirection: setFixedDirection\n        });\n        var result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl: function(moveable, e) {\n        var datas = e.datas;\n        if (!datas.isScale) {\n            return;\n        }\n        catchEvent(moveable, \"onBeforeScale\", function(parentEvent) {\n            triggerEvent(moveable, \"onBeforeScaleGroup\", fillParams(moveable, e, __assign(__assign({}, parentEvent), {\n                targets: moveable.props.targets\n            }), true));\n        });\n        var params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n        var dist = params.dist;\n        var moveableScale = datas.moveableScale;\n        moveable.scale = [\n            dist[0] * moveableScale[0],\n            dist[1] * moveableScale[1]\n        ];\n        var keepRatio = moveable.props.keepRatio;\n        var fixedPosition = datas.fixedPosition;\n        var events = triggerChildAbles(moveable, this, \"dragControl\", e, function(_, ev) {\n            var _a = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createRotateMatrix)(moveable.rotation / 180 * Math.PI, 3), [\n                ev.datas.originalX * dist[0],\n                ev.datas.originalY * dist[1],\n                1\n            ], 3), 2), clientX = _a[0], clientY = _a[1];\n            return __assign(__assign({}, ev), {\n                parentDist: null,\n                parentScale: dist,\n                parentKeepRatio: keepRatio,\n                // recalculate child fixed position for parent group's dragging.\n                dragClient: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(fixedPosition, [\n                    clientX,\n                    clientY\n                ])\n            });\n        });\n        var nextParams = __assign({\n            targets: moveable.props.targets,\n            events: events\n        }, params);\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd: function(moveable, e) {\n        var isDrag = e.isDrag, datas = e.datas;\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        var events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n        var nextParams = fillEndParams(moveable, e, {\n            targets: moveable.props.targets,\n            events: events\n        });\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\r\n     * @method Moveable.Scalable#request\r\n     * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter\r\n     * @return {Moveable.Requester} Moveable Requester\r\n     * @example\r\n\n     * // Instantly Request (requestStart - request - requestEnd)\r\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\r\n     *\r\n     * // requestStart\r\n     * const requester = moveable.request(\"scalable\");\r\n     *\r\n     * // request\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     *\r\n     * // requestEnd\r\n     * requester.requestEnd();\r\n     */ request: function() {\n        var datas = {};\n        var distWidth = 0;\n        var distHeight = 0;\n        var useSnap = false;\n        return {\n            isControl: true,\n            requestStart: function(e) {\n                useSnap = e.useSnap;\n                return {\n                    datas: datas,\n                    parentDirection: e.direction || [\n                        1,\n                        1\n                    ],\n                    useSnap: useSnap\n                };\n            },\n            request: function(e) {\n                distWidth += e.deltaWidth;\n                distHeight += e.deltaHeight;\n                return {\n                    datas: datas,\n                    parentDist: [\n                        distWidth,\n                        distHeight\n                    ],\n                    parentKeepRatio: e.keepRatio,\n                    useSnap: useSnap\n                };\n            },\n            requestEnd: function() {\n                return {\n                    datas: datas,\n                    isDrag: true,\n                    useSnap: useSnap\n                };\n            }\n        };\n    }\n};\n/**\r\n * Whether or not target can scaled.\r\n *\r\n * @name Moveable.Scalable#scalable\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.scalable = true;\r\n */ /**\r\n * throttle of scaleX, scaleY when scale.\r\n * @name Moveable.Scalable#throttleScale\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.throttleScale = 0.1;\r\n */ /**\r\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\r\n * @name Moveable.Scalable#renderDirections\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     scalable: true,\r\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\r\n * });\r\n *\r\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\r\n */ /**\r\n * When resize or scale, keeps a ratio of the width, height. (default: false)\r\n * @name Moveable.Scalable#keepRatio\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     scalable: true,\r\n * });\r\n *\r\n * moveable.keepRatio = true;\r\n */ /**\r\n * When the scale starts, the scaleStart event is called.\r\n * @memberof Moveable.Scalable\r\n * @event scaleStart\r\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { scalable: true });\r\n * moveable.on(\"scaleStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */ /**\r\n * When scaling, `beforeScale` is called before `scale` occurs. In `beforeScale`, you can get and set the pre-value before scaling.\r\n * @memberof Moveable.Scalable\r\n * @event beforeScale\r\n * @param {Moveable.Scalable.OnBeforeScale} - Parameters for the `beforeScale` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { scalable: true });\r\n * moveable.on(\"beforeScale\", ({ setFixedDirection }) => {\r\n *     if (shiftKey) {\r\n *        setFixedDirection([0, 0]);\r\n *     }\r\n * });\r\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\r\n *     target.style.transform = transform;\r\n * });\r\n */ /**\r\n * When scaling, the `scale` event is called.\r\n * @memberof Moveable.Scalable\r\n * @event scale\r\n * @param {Moveable.Scalable.OnScale} - Parameters for the `scale` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { scalable: true });\r\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\r\n *     target.style.transform = transform;\r\n * });\r\n */ /**\r\n * When the scale finishes, the `scaleEnd` event is called.\r\n * @memberof Moveable.Scalable\r\n * @event scaleEnd\r\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the `scaleEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { scalable: true });\r\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\r\n *     console.log(target, isDrag);\r\n * });\r\n */ /**\r\n* When the group scale starts, the `scaleGroupStart` event is called.\r\n* @memberof Moveable.Scalable\r\n* @event scaleGroupStart\r\n* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     scalable: true\r\n* });\r\n* moveable.on(\"scaleGroupStart\", ({ targets }) => {\r\n*     console.log(\"onScaleGroupStart\", targets);\r\n* });\r\n*/ /**\r\n* When the group scale, the `scaleGroup` event is called.\r\n* @memberof Moveable.Scalable\r\n* @event scaleGroup\r\n* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     scalable: true\r\n* });\r\n* moveable.on(\"scaleGroup\", ({ targets, events }) => {\r\n*     console.log(\"onScaleGroup\", targets);\r\n*     events.forEach(ev => {\r\n*         const target = ev.target;\r\n*         // ev.drag is a drag event that occurs when the group scale.\r\n*         const left = ev.drag.beforeDist[0];\r\n*         const top = ev.drag.beforeDist[1];\r\n*         const scaleX = ev.scale[0];\r\n*         const scaleY = ev.scale[1];\r\n*     });\r\n* });\r\n*/ /**\r\n * When the group scale finishes, the `scaleGroupEnd` event is called.\r\n * @memberof Moveable.Scalable\r\n * @event scaleGroupEnd\r\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     scalable: true\r\n * });\r\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\r\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\r\n * });\r\n */ function getMiddleLinePos(pos1, pos2) {\n    return pos1.map(function(pos, i) {\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.dot)(pos, pos2[i], 1, 2);\n    });\n}\nfunction getTriangleRad(pos1, pos2, pos3) {\n    // pos1 Rad\n    var rad1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(pos1, pos2);\n    var rad2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(pos1, pos3);\n    var rad = rad2 - rad1;\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\nfunction isValidPos(poses1, poses2) {\n    var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    var pi = Math.PI;\n    if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {\n        return false;\n    }\n    return true;\n}\n/**\r\n * @namespace Moveable.Warpable\r\n * @description Warpable indicates whether the target can be warped(distorted, bented).\r\n */ var Warpable = {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    props: [\n        \"warpable\",\n        \"renderDirections\",\n        \"edge\",\n        \"displayAroundControls\"\n    ],\n    events: [\n        \"warpStart\",\n        \"warp\",\n        \"warpEnd\"\n    ],\n    viewClassName: getDirectionViewClassName(\"warpable\"),\n    render: function(moveable, React) {\n        var _a = moveable.props, resizable = _a.resizable, scalable = _a.scalable, warpable = _a.warpable, zoom = _a.zoom;\n        if (resizable || scalable || !warpable) {\n            return [];\n        }\n        var _b = moveable.state, pos1 = _b.pos1, pos2 = _b.pos2, pos3 = _b.pos3, pos4 = _b.pos4;\n        var linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        var linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        var linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        var linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        var linePosTo1 = getMiddleLinePos(pos3, pos4);\n        var linePosTo2 = getMiddleLinePos(pos4, pos3);\n        var linePosTo3 = getMiddleLinePos(pos2, pos4);\n        var linePosTo4 = getMiddleLinePos(pos4, pos2);\n        return __spreadArray([\n            React.createElement(\"div\", {\n                className: prefix(\"line\"),\n                key: \"middeLine1\",\n                style: getLineStyle(linePosFrom1, linePosTo1, zoom)\n            }),\n            React.createElement(\"div\", {\n                className: prefix(\"line\"),\n                key: \"middeLine2\",\n                style: getLineStyle(linePosFrom2, linePosTo2, zoom)\n            }),\n            React.createElement(\"div\", {\n                className: prefix(\"line\"),\n                key: \"middeLine3\",\n                style: getLineStyle(linePosFrom3, linePosTo3, zoom)\n            }),\n            React.createElement(\"div\", {\n                className: prefix(\"line\"),\n                key: \"middeLine4\",\n                style: getLineStyle(linePosFrom4, linePosTo4, zoom)\n            })\n        ], __read(renderAllDirections(moveable, \"warpable\", React)), false);\n    },\n    dragControlCondition: function(moveable, e) {\n        if (e.isRequest) {\n            return false;\n        }\n        var target = e.inputEvent.target;\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"direction\")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"warpable\"));\n    },\n    dragControlStart: function(moveable, e) {\n        var datas = e.datas, inputEvent = e.inputEvent;\n        var target = moveable.props.target;\n        var inputTarget = inputEvent.target;\n        var direction = getDirection(inputTarget, datas);\n        if (!direction || !target) {\n            return false;\n        }\n        var state = moveable.state;\n        var transformOrigin = state.transformOrigin, is3d = state.is3d, targetTransform = state.targetTransform, targetMatrix = state.targetMatrix, width = state.width, height = state.height, left = state.left, top = state.top;\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.ignoreDimension)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n        datas.poses = [\n            [\n                0,\n                0\n            ],\n            [\n                width,\n                0\n            ],\n            [\n                0,\n                height\n            ],\n            [\n                width,\n                height\n            ]\n        ].map(function(p) {\n            return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(p, transformOrigin);\n        });\n        datas.nextPoses = datas.poses.map(function(_a) {\n            var _b = __read(_a, 2), x = _b[0], y = _b[1];\n            return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(datas.warpTargetMatrix, [\n                x,\n                y,\n                0,\n                1\n            ], 4);\n        });\n        datas.startValue = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(4);\n        datas.prevMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(moveable, e, \"matrix3d\");\n        state.snapRenderInfo = {\n            request: e.isRequest,\n            direction: direction\n        };\n        var params = fillParams(moveable, e, __assign({\n            set: function(matrix) {\n                datas.startValue = matrix;\n            }\n        }, fillTransformStartEvent(moveable, e)));\n        var result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return datas.isWarp;\n    },\n    dragControl: function(moveable, e) {\n        var datas = e.datas, isRequest = e.isRequest;\n        var distX = e.distX, distY = e.distY;\n        var targetInverseMatrix = datas.targetInverseMatrix, prevMatrix = datas.prevMatrix, isWarp = datas.isWarp, startValue = datas.startValue, poses = datas.poses, posIndexes = datas.posIndexes, absolutePoses = datas.absolutePoses;\n        if (!isWarp) {\n            return false;\n        }\n        resolveTransformEvent(moveable, e, \"matrix3d\");\n        if (hasGuidelines(moveable, \"warpable\")) {\n            var selectedPoses = posIndexes.map(function(index) {\n                return absolutePoses[index];\n            });\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2\n                ]);\n            }\n            var _a = checkMoveableSnapBounds(moveable, isRequest, {\n                horizontal: selectedPoses.map(function(pos) {\n                    return pos[1] + distY;\n                }),\n                vertical: selectedPoses.map(function(pos) {\n                    return pos[0] + distX;\n                })\n            }), horizontalSnapInfo = _a.horizontal, verticalSnapInfo = _a.vertical;\n            distY -= horizontalSnapInfo.offset;\n            distX -= verticalSnapInfo.offset;\n        }\n        var dist = getDragDist({\n            datas: datas,\n            distX: distX,\n            distY: distY\n        }, true);\n        var nextPoses = datas.nextPoses.slice();\n        posIndexes.forEach(function(index) {\n            nextPoses[index] = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(nextPoses[index], dist);\n        });\n        if (!NEARBY_POS.every(function(nearByPoses) {\n            return isValidPos(nearByPoses.map(function(i) {\n                return poses[i];\n            }), nearByPoses.map(function(i) {\n                return nextPoses[i];\n            }));\n        })) {\n            return false;\n        }\n        var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createWarpMatrix)(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);\n        if (!h.length) {\n            return false;\n        }\n        // B * A * M\n        var afterMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetInverseMatrix, h, 4);\n        // B * M * A\n        var matrix = getTransfromMatrix(datas, afterMatrix, true);\n        var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(prevMatrix, 4), matrix, 4);\n        datas.prevMatrix = matrix;\n        var totalMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(startValue, matrix, 4);\n        var nextTransform = convertTransformFormat(datas, \"matrix3d(\".concat(totalMatrix.join(\", \"), \")\"), \"matrix3d(\".concat(matrix.join(\", \"), \")\"));\n        fillOriginalTransform(e, nextTransform);\n        triggerEvent(moveable, \"onWarp\", fillParams(moveable, e, __assign({\n            delta: delta,\n            matrix: totalMatrix,\n            dist: matrix,\n            multiply: _scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply,\n            transform: nextTransform\n        }, fillCSSObject({\n            transform: nextTransform\n        }, e))));\n        return true;\n    },\n    dragControlEnd: function(moveable, e) {\n        var datas = e.datas, isDrag = e.isDrag;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n        triggerEvent(moveable, \"onWarpEnd\", fillEndParams(moveable, e, {}));\n        return isDrag;\n    }\n};\n/**\r\n * Whether or not target can be warped. (default: false)\r\n * @name Moveable.Warpable#warpable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.warpable = true;\r\n */ /**\r\n* Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\r\n* @name Moveable.Warpable#renderDirections\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     warpable: true,\r\n*     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\r\n* });\r\n*\r\n* moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\r\n*/ /**\r\n* When the warp starts, the warpStart event is called.\r\n* @memberof Moveable.Warpable\r\n* @event warpStart\r\n* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, { warpable: true });\r\n* moveable.on(\"warpStart\", ({ target }) => {\r\n*     console.log(target);\r\n* });\r\n*/ /**\r\n * When warping, the warp event is called.\r\n * @memberof Moveable.Warpable\r\n * @event warp\r\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n * let matrix = [\r\n *  1, 0, 0, 0,\r\n *  0, 1, 0, 0,\r\n *  0, 0, 1, 0,\r\n *  0, 0, 0, 1,\r\n * ];\r\n * const moveable = new Moveable(document.body, { warpable: true });\r\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\r\n *    // target.style.transform = transform;\r\n *    matrix = multiply(matrix, delta);\r\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\r\n * });\r\n */ /**\r\n * When the warp finishes, the warpEnd event is called.\r\n * @memberof Moveable.Warpable\r\n * @event warpEnd\r\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { warpable: true });\r\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\r\n *     console.log(target, isDrag);\r\n * });\r\n */ var AREA_PIECES = /*#__PURE__*/ prefix(\"area-pieces\");\nvar AREA_PIECE = /*#__PURE__*/ prefix(\"area-piece\");\nvar AVOID = /*#__PURE__*/ prefix(\"avoid\");\nvar VIEW_DRAGGING = prefix(\"view-dragging\");\nfunction restoreStyle(moveable) {\n    var el = moveable.areaElement;\n    if (!el) {\n        return;\n    }\n    var _a = moveable.state, width = _a.width, height = _a.height;\n    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.removeClass)(el, AVOID);\n    el.style.cssText += \"left: 0px; top: 0px; width: \".concat(width, \"px; height: \").concat(height, \"px\");\n}\nfunction renderPieces(React) {\n    return React.createElement(\"div\", {\n        key: \"area_pieces\",\n        className: AREA_PIECES\n    }, React.createElement(\"div\", {\n        className: AREA_PIECE\n    }), React.createElement(\"div\", {\n        className: AREA_PIECE\n    }), React.createElement(\"div\", {\n        className: AREA_PIECE\n    }), React.createElement(\"div\", {\n        className: AREA_PIECE\n    }));\n}\nvar DragArea = {\n    name: \"dragArea\",\n    props: [\n        \"dragArea\",\n        \"passDragArea\"\n    ],\n    events: [\n        \"click\",\n        \"clickGroup\"\n    ],\n    render: function(moveable, React) {\n        var _a = moveable.props, target = _a.target, dragArea = _a.dragArea, groupable = _a.groupable, passDragArea = _a.passDragArea;\n        var _b = moveable.getState(), width = _b.width, height = _b.height, renderPoses = _b.renderPoses;\n        var className = passDragArea ? prefix(\"area\", \"pass\") : prefix(\"area\");\n        if (groupable) {\n            return [\n                React.createElement(\"div\", {\n                    key: \"area\",\n                    ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(moveable, \"areaElement\"),\n                    className: className\n                }),\n                renderPieces(React)\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createWarpMatrix)([\n            0,\n            0\n        ], [\n            width,\n            0\n        ], [\n            0,\n            height\n        ], [\n            width,\n            height\n        ], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);\n        var transform = h.length ? makeMatrixCSS(h, true) : \"none\";\n        return [\n            React.createElement(\"div\", {\n                key: \"area\",\n                ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(moveable, \"areaElement\"),\n                className: className,\n                style: {\n                    top: \"0px\",\n                    left: \"0px\",\n                    width: \"\".concat(width, \"px\"),\n                    height: \"\".concat(height, \"px\"),\n                    transformOrigin: \"0 0\",\n                    transform: transform\n                }\n            }),\n            renderPieces(React)\n        ];\n    },\n    dragStart: function(moveable, _a) {\n        var datas = _a.datas, clientX = _a.clientX, clientY = _a.clientY, inputEvent = _a.inputEvent;\n        if (!inputEvent) {\n            return false;\n        }\n        datas.isDragArea = false;\n        var areaElement = moveable.areaElement;\n        var state = moveable.state;\n        var moveableClientRect = state.moveableClientRect, renderPoses = state.renderPoses, rootMatrix = state.rootMatrix, is3d = state.is3d;\n        var left = moveableClientRect.left, top = moveableClientRect.top;\n        var _b = getRect(renderPoses), relativeLeft = _b.left, relativeTop = _b.top, width = _b.width, height = _b.height;\n        var n = is3d ? 4 : 3;\n        var _c = __read(calculateInversePosition(rootMatrix, [\n            clientX - left,\n            clientY - top\n        ], n), 2), posX = _c[0], posY = _c[1];\n        posX -= relativeLeft;\n        posY -= relativeTop;\n        var rects = [\n            {\n                left: relativeLeft,\n                top: relativeTop,\n                width: width,\n                height: posY - 10\n            },\n            {\n                left: relativeLeft,\n                top: relativeTop,\n                width: posX - 10,\n                height: height\n            },\n            {\n                left: relativeLeft,\n                top: relativeTop + posY + 10,\n                width: width,\n                height: height - posY - 10\n            },\n            {\n                left: relativeLeft + posX + 10,\n                top: relativeTop,\n                width: width - posX - 10,\n                height: height\n            }\n        ];\n        var children = [].slice.call(areaElement.nextElementSibling.children);\n        rects.forEach(function(rect, i) {\n            children[i].style.cssText = \"left: \".concat(rect.left, \"px;top: \").concat(rect.top, \"px; width: \").concat(rect.width, \"px; height: \").concat(rect.height, \"px;\");\n        });\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.addClass)(areaElement, AVOID);\n        state.disableNativeEvent = true;\n        return;\n    },\n    drag: function(moveable, _a) {\n        var datas = _a.datas, inputEvent = _a.inputEvent;\n        this.enableNativeEvent(moveable);\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd: function(moveable, e) {\n        this.enableNativeEvent(moveable);\n        var inputEvent = e.inputEvent, datas = e.datas;\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            restoreStyle(moveable);\n        }\n    },\n    dragGroupStart: function(moveable, e) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroup: function(moveable, e) {\n        return this.drag(moveable, e);\n    },\n    dragGroupEnd: function(moveable, e) {\n        return this.dragEnd(moveable, e);\n    },\n    unset: function(moveable) {\n        restoreStyle(moveable);\n        moveable.state.disableNativeEvent = false;\n    },\n    enableNativeEvent: function(moveable) {\n        var state = moveable.state;\n        if (state.disableNativeEvent) {\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.requestAnimationFrame)(function() {\n                state.disableNativeEvent = false;\n            });\n        }\n    }\n};\n/**\r\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)\r\n * @name Moveable#dragArea\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *  dragArea: false,\r\n * });\r\n */ /**\r\n * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)\r\n * @name Moveable#passDragArea\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *  dragArea: false,\r\n * });\r\n */ var Origin = makeAble(\"origin\", {\n    props: [\n        \"origin\",\n        \"svgOrigin\"\n    ],\n    render: function(moveable, React) {\n        var _a = moveable.props, zoom = _a.zoom, svgOrigin = _a.svgOrigin, groupable = _a.groupable;\n        var _b = moveable.getState(), beforeOrigin = _b.beforeOrigin, rotation = _b.rotation, svg = _b.svg, allMatrix = _b.allMatrix, is3d = _b.is3d, left = _b.left, top = _b.top, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n        var originStyle;\n        if (!groupable && svg && svgOrigin) {\n            var _c = __read(convertTransformOriginArray(svgOrigin, offsetWidth, offsetHeight), 2), originX = _c[0], originY = _c[1];\n            var n = is3d ? 4 : 3;\n            var result = calculatePosition(allMatrix, [\n                originX,\n                originY\n            ], n);\n            originStyle = getControlTransform(rotation, zoom, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(result, [\n                left,\n                top\n            ]));\n        } else {\n            originStyle = getControlTransform(rotation, zoom, beforeOrigin);\n        }\n        return [\n            React.createElement(\"div\", {\n                className: prefix(\"control\", \"origin\"),\n                style: originStyle,\n                key: \"beforeOrigin\"\n            })\n        ];\n    }\n});\n/**\r\n * Whether or not the origin controlbox will be visible or not (default: true)\r\n * @name Moveable#origin\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.origin = true;\r\n */ function getDefaultScrollPosition(e) {\n    var scrollContainer = e.scrollContainer;\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop\n    ];\n}\n/**\r\n * @namespace Moveable.Scrollable\r\n * @description Whether or not target can be scrolled to the scroll container (default: false)\r\n */ var Scrollable = {\n    name: \"scrollable\",\n    canPinch: true,\n    props: [\n        \"scrollable\",\n        \"scrollContainer\",\n        \"scrollThreshold\",\n        \"scrollThrottleTime\",\n        \"getScrollPosition\",\n        \"scrollOptions\"\n    ],\n    events: [\n        \"scroll\",\n        \"scrollGroup\"\n    ],\n    dragRelation: \"strong\",\n    dragStart: function(moveable, e) {\n        var props = moveable.props;\n        var _a = props.scrollContainer, scrollContainer = _a === void 0 ? moveable.getContainer() : _a, scrollOptions = props.scrollOptions;\n        var dragScroll = new _scena_dragscroll__WEBPACK_IMPORTED_MODULE_7__[\"default\"]();\n        var scrollContainerElement = getRefTarget(scrollContainer, true);\n        e.datas.dragScroll = dragScroll;\n        moveable.state.dragScroll = dragScroll;\n        var gestoName = e.isControl ? \"controlGesto\" : \"targetGesto\";\n        var targets = e.targets;\n        dragScroll.on(\"scroll\", function(_a) {\n            var container = _a.container, direction = _a.direction;\n            var params = fillParams(moveable, e, {\n                scrollContainer: container,\n                direction: direction\n            });\n            var eventName = targets ? \"onScrollGroup\" : \"onScroll\";\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", function(_a) {\n            var offsetX = _a.offsetX, offsetY = _a.offsetY, inputEvent = _a.inputEvent;\n            moveable[gestoName].scrollBy(offsetX, offsetY, inputEvent.inputEvent, false);\n        }).on(\"scrollDrag\", function(_a) {\n            var next = _a.next;\n            next(moveable[gestoName].getCurrentEvent());\n        });\n        dragScroll.dragStart(e, __assign({\n            container: scrollContainerElement\n        }, scrollOptions));\n    },\n    checkScroll: function(moveable, e) {\n        var dragScroll = e.datas.dragScroll;\n        if (!dragScroll) {\n            return;\n        }\n        var _a = moveable.props, _b = _a.scrollContainer, scrollContainer = _b === void 0 ? moveable.getContainer() : _b, _c = _a.scrollThreshold, scrollThreshold = _c === void 0 ? 0 : _c, _d = _a.scrollThrottleTime, scrollThrottleTime = _d === void 0 ? 0 : _d, _e = _a.getScrollPosition, getScrollPosition = _e === void 0 ? getDefaultScrollPosition : _e, scrollOptions = _a.scrollOptions;\n        dragScroll.drag(e, __assign({\n            container: scrollContainer,\n            threshold: scrollThreshold,\n            throttleTime: scrollThrottleTime,\n            getScrollPosition: function(ev) {\n                return getScrollPosition({\n                    scrollContainer: ev.container,\n                    direction: ev.direction\n                });\n            }\n        }, scrollOptions));\n        return true;\n    },\n    drag: function(moveable, e) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd: function(moveable, e) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragControlStart: function(moveable, e) {\n        return this.dragStart(moveable, __assign(__assign({}, e), {\n            isControl: true\n        }));\n    },\n    dragControl: function(moveable, e) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd: function(moveable, e) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupStart: function(moveable, e) {\n        return this.dragStart(moveable, __assign(__assign({}, e), {\n            targets: moveable.props.targets\n        }));\n    },\n    dragGroup: function(moveable, e) {\n        return this.drag(moveable, __assign(__assign({}, e), {\n            targets: moveable.props.targets\n        }));\n    },\n    dragGroupEnd: function(moveable, e) {\n        return this.dragEnd(moveable, __assign(__assign({}, e), {\n            targets: moveable.props.targets\n        }));\n    },\n    dragGroupControlStart: function(moveable, e) {\n        return this.dragStart(moveable, __assign(__assign({}, e), {\n            targets: moveable.props.targets,\n            isControl: true\n        }));\n    },\n    dragGroupControl: function(moveable, e) {\n        return this.drag(moveable, __assign(__assign({}, e), {\n            targets: moveable.props.targets\n        }));\n    },\n    dragGroupControEnd: function(moveable, e) {\n        return this.dragEnd(moveable, __assign(__assign({}, e), {\n            targets: moveable.props.targets\n        }));\n    },\n    unset: function(moveable) {\n        var _a;\n        var state = moveable.state;\n        (_a = state.dragScroll) === null || _a === void 0 ? void 0 : _a.dragEnd();\n        state.dragScroll = null;\n    }\n};\n/**\r\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\r\n * @memberof Moveable.Scrollable\r\n * @event scroll\r\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: document.querySelector(\".target\"),\r\n * });\r\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\r\n *   scrollContainer.scrollLeft += direction[0] * 10;\r\n *   scrollContainer.scrollTop += direction[1] * 10;\r\n * });\r\n */ /**\r\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\r\n * @memberof Moveable.Scrollable\r\n * @event scrollGroup\r\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n * });\r\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\r\n *   scrollContainer.scrollLeft += direction[0] * 10;\r\n *   scrollContainer.scrollTop += direction[1] * 10;\r\n * });\r\n */ var Default = {\n    name: \"\",\n    props: [\n        \"target\",\n        \"dragTargetSelf\",\n        \"dragTarget\",\n        \"dragContainer\",\n        \"container\",\n        \"warpSelf\",\n        \"rootContainer\",\n        \"useResizeObserver\",\n        \"useMutationObserver\",\n        \"zoom\",\n        \"dragFocusedInput\",\n        \"transformOrigin\",\n        \"ables\",\n        \"className\",\n        \"pinchThreshold\",\n        \"pinchOutside\",\n        \"triggerAblesSimultaneously\",\n        \"checkInput\",\n        \"cspNonce\",\n        \"translateZ\",\n        \"hideDefaultLines\",\n        \"props\",\n        \"flushSync\",\n        \"stopPropagation\",\n        \"preventClickEventOnDrag\",\n        \"preventClickDefault\",\n        \"viewContainer\",\n        \"persistData\",\n        \"useAccuratePosition\",\n        \"firstRenderState\",\n        \"linePadding\",\n        \"controlPadding\",\n        \"preventDefault\",\n        \"preventRightClick\",\n        \"preventWheelClick\",\n        \"requestStyles\"\n    ],\n    events: [\n        \"changeTargets\"\n    ]\n};\nvar Padding = makeAble(\"padding\", {\n    props: [\n        \"padding\"\n    ],\n    render: function(moveable, React) {\n        var props = moveable.props;\n        if (props.dragArea) {\n            return [];\n        }\n        var _a = getPaddingBox(props.padding || {}), left = _a.left, top = _a.top, right = _a.right, bottom = _a.bottom;\n        var _b = moveable.getState(), renderPoses = _b.renderPoses, pos1 = _b.pos1, pos2 = _b.pos2, pos3 = _b.pos3, pos4 = _b.pos4;\n        var poses = [\n            pos1,\n            pos2,\n            pos3,\n            pos4\n        ];\n        var paddingDirections = [];\n        if (left > 0) {\n            paddingDirections.push([\n                0,\n                2\n            ]);\n        }\n        if (top > 0) {\n            paddingDirections.push([\n                0,\n                1\n            ]);\n        }\n        if (right > 0) {\n            paddingDirections.push([\n                1,\n                3\n            ]);\n        }\n        if (bottom > 0) {\n            paddingDirections.push([\n                2,\n                3\n            ]);\n        }\n        return paddingDirections.map(function(_a, i) {\n            var _b = __read(_a, 2), dir1 = _b[0], dir2 = _b[1];\n            var paddingPos1 = poses[dir1];\n            var paddingPos2 = poses[dir2];\n            var paddingPos3 = renderPoses[dir1];\n            var paddingPos4 = renderPoses[dir2];\n            var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createWarpMatrix)([\n                0,\n                0\n            ], [\n                100,\n                0\n            ], [\n                0,\n                100\n            ], [\n                100,\n                100\n            ], paddingPos1, paddingPos2, paddingPos3, paddingPos4);\n            if (!h.length) {\n                return undefined;\n            }\n            return React.createElement(\"div\", {\n                key: \"padding\".concat(i),\n                className: prefix(\"padding\"),\n                style: {\n                    transform: makeMatrixCSS(h, true)\n                }\n            });\n        });\n    }\n});\n/**\r\n * Add padding around the target to increase the drag area.\r\n * @name Moveable#padding\r\n * @default null\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *  target: document.querySelector(\".target\"),\r\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\r\n * });\r\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\r\n * moveable.updateRect();\r\n */ var RADIUS_DIRECTIONS = [\n    \"nw\",\n    \"ne\",\n    \"se\",\n    \"sw\"\n];\nfunction calculateRatio(values, size) {\n    var sumSize = values[0] + values[1];\n    var sumRatio = sumSize > size ? size / sumSize : 1;\n    values[0] *= sumRatio;\n    values[1] = size - values[1] * sumRatio;\n    return values;\n}\nvar HORIZONTAL_RADIUS_ORDER = [\n    1,\n    2,\n    5,\n    6\n];\nvar VERTICAL_RADIUS_ORDER = [\n    0,\n    3,\n    4,\n    7\n];\nvar HORIZONTAL_RADIUS_DIRECTIONS = [\n    1,\n    -1,\n    -1,\n    1\n];\nvar VERTICAL_RADIUS_DIRECTIONS = [\n    1,\n    1,\n    -1,\n    -1\n];\nfunction getRadiusStyles(nextPoses, isRelative, width, height, left, top, right, bottom) {\n    if (left === void 0) {\n        left = 0;\n    }\n    if (top === void 0) {\n        top = 0;\n    }\n    if (right === void 0) {\n        right = width;\n    }\n    if (bottom === void 0) {\n        bottom = height;\n    }\n    var clipStyles = [];\n    var isVertical = false;\n    var radiusPoses = nextPoses.filter(function(pos) {\n        return !pos.virtual;\n    });\n    var raws = radiusPoses.map(function(posInfo) {\n        var horizontal = posInfo.horizontal, vertical = posInfo.vertical, pos = posInfo.pos;\n        if (vertical && !isVertical) {\n            isVertical = true;\n            clipStyles.push(\"/\");\n        }\n        if (isVertical) {\n            var rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\n            clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n            return rawPos;\n        } else {\n            var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\n            clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n            return rawPos;\n        }\n    });\n    return {\n        radiusPoses: radiusPoses,\n        styles: clipStyles,\n        raws: raws\n    };\n}\nfunction getRadiusRange(controlPoses) {\n    // [start, length]\n    var horizontalRange = [\n        0,\n        0\n    ];\n    var verticalRange = [\n        0,\n        0\n    ];\n    var length = controlPoses.length;\n    for(var i = 0; i < length; ++i){\n        var clipPose = controlPoses[i];\n        if (!clipPose.sub) {\n            continue;\n        }\n        if (clipPose.horizontal) {\n            if (horizontalRange[1] === 0) {\n                horizontalRange[0] = i;\n            }\n            horizontalRange[1] = i - horizontalRange[0] + 1;\n            verticalRange[0] = i + 1;\n        }\n        if (clipPose.vertical) {\n            if (verticalRange[1] === 0) {\n                verticalRange[0] = i;\n            }\n            verticalRange[1] = i - verticalRange[0] + 1;\n        }\n    }\n    return {\n        horizontalRange: horizontalRange,\n        verticalRange: verticalRange\n    };\n}\nfunction getRadiusValues(values, width, height, left, top, minCounts, full) {\n    var _a, _b, _c, _d;\n    if (minCounts === void 0) {\n        minCounts = [\n            0,\n            0\n        ];\n    }\n    if (full === void 0) {\n        full = false;\n    }\n    var splitIndex = values.indexOf(\"/\");\n    var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n    var horizontalValues = values.slice(0, splitLength);\n    var verticalValues = values.slice(splitLength + 1);\n    var horizontalValuesLength = horizontalValues.length;\n    var verticalValuesLength = verticalValues.length;\n    var hasVerticalValues = verticalValuesLength > 0;\n    var _e = __read(horizontalValues, 4), _f = _e[0], nwValue = _f === void 0 ? \"0px\" : _f, _g = _e[1], neValue = _g === void 0 ? nwValue : _g, _h = _e[2], seValue = _h === void 0 ? nwValue : _h, _j = _e[3], swValue = _j === void 0 ? neValue : _j;\n    var _k = __read(verticalValues, 4), _l = _k[0], wnValue = _l === void 0 ? nwValue : _l, _m = _k[1], enValue = _m === void 0 ? hasVerticalValues ? wnValue : neValue : _m, _o = _k[2], esValue = _o === void 0 ? hasVerticalValues ? wnValue : seValue : _o, _p = _k[3], wsValue = _p === void 0 ? hasVerticalValues ? enValue : swValue : _p;\n    var horizontalRawPoses = [\n        nwValue,\n        neValue,\n        seValue,\n        swValue\n    ].map(function(pos) {\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(pos, width);\n    });\n    var verticalRawPoses = [\n        wnValue,\n        enValue,\n        esValue,\n        wsValue\n    ].map(function(pos) {\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(pos, height);\n    });\n    var horizontalPoses = horizontalRawPoses.slice();\n    var verticalPoses = verticalRawPoses.slice();\n    _a = __read(calculateRatio([\n        horizontalPoses[0],\n        horizontalPoses[1]\n    ], width), 2), horizontalPoses[0] = _a[0], horizontalPoses[1] = _a[1];\n    _b = __read(calculateRatio([\n        horizontalPoses[3],\n        horizontalPoses[2]\n    ], width), 2), horizontalPoses[3] = _b[0], horizontalPoses[2] = _b[1];\n    _c = __read(calculateRatio([\n        verticalPoses[0],\n        verticalPoses[3]\n    ], height), 2), verticalPoses[0] = _c[0], verticalPoses[3] = _c[1];\n    _d = __read(calculateRatio([\n        verticalPoses[1],\n        verticalPoses[2]\n    ], height), 2), verticalPoses[1] = _d[0], verticalPoses[2] = _d[1];\n    var nextHorizontalPoses = full ? horizontalPoses : horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValuesLength));\n    var nextVerticalPoses = full ? verticalPoses : verticalPoses.slice(0, Math.max(minCounts[1], verticalValuesLength));\n    return __spreadArray(__spreadArray([], __read(nextHorizontalPoses.map(function(pos, i) {\n        var direction = RADIUS_DIRECTIONS[i];\n        return {\n            virtual: i >= horizontalValuesLength,\n            horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n            vertical: 0,\n            pos: [\n                left + pos,\n                top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)\n            ],\n            sub: true,\n            raw: horizontalRawPoses[i],\n            direction: direction\n        };\n    })), false), __read(nextVerticalPoses.map(function(pos, i) {\n        var direction = RADIUS_DIRECTIONS[i];\n        return {\n            virtual: i >= verticalValuesLength,\n            horizontal: 0,\n            vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n            pos: [\n                left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0),\n                top + pos\n            ],\n            sub: true,\n            raw: verticalRawPoses[i],\n            direction: direction\n        };\n    })), false);\n}\nfunction removeRadiusPos(controlPoses, poses, index, startIndex, length) {\n    if (length === void 0) {\n        length = poses.length;\n    }\n    var _a = getRadiusRange(controlPoses.slice(startIndex)), horizontalRange = _a.horizontalRange, verticalRange = _a.verticalRange;\n    var radiuslIndex = index - startIndex;\n    var deleteCount = 0;\n    if (radiuslIndex === 0) {\n        deleteCount = length;\n    } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n        deleteCount = horizontalRange[1] - radiuslIndex;\n    } else if (radiuslIndex >= verticalRange[0]) {\n        deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n    } else {\n        return;\n    }\n    controlPoses.splice(index, deleteCount);\n    poses.splice(index, deleteCount);\n}\nfunction addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right, bottom, left, top) {\n    if (left === void 0) {\n        left = 0;\n    }\n    if (top === void 0) {\n        top = 0;\n    }\n    var _a = getRadiusRange(controlPoses.slice(startIndex)), horizontalRange = _a.horizontalRange, verticalRange = _a.verticalRange;\n    if (horizontalIndex > -1) {\n        var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1 ? distX - left : right - distX;\n        for(var i = horizontalRange[1]; i <= horizontalIndex; ++i){\n            var y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n            var x = 0;\n            if (horizontalIndex === i) {\n                x = distX;\n            } else if (i === 0) {\n                x = left + radiusX;\n            } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n                x = right - (poses[startIndex][0] - left);\n            }\n            controlPoses.splice(startIndex + i, 0, {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [\n                    x,\n                    y\n                ]\n            });\n            poses.splice(startIndex + i, 0, [\n                x,\n                y\n            ]);\n            if (i === 0) {\n                break;\n            }\n        }\n    } else if (verticalIndex > -1) {\n        var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1 ? distY - top : bottom - distY;\n        if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n            var pos = [\n                left + radiusY,\n                top\n            ];\n            controlPoses.push({\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n                vertical: 0,\n                pos: pos\n            });\n            poses.push(pos);\n        }\n        var startVerticalIndex = verticalRange[0];\n        for(var i = verticalRange[1]; i <= verticalIndex; ++i){\n            var x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n            var y = 0;\n            if (verticalIndex === i) {\n                y = distY;\n            } else if (i === 0) {\n                y = top + radiusY;\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n                y = poses[startIndex + startVerticalIndex][1];\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n                y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n            }\n            controlPoses.push({\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [\n                    x,\n                    y\n                ]\n            });\n            poses.push([\n                x,\n                y\n            ]);\n            if (i === 0) {\n                break;\n            }\n        }\n    }\n}\nfunction splitRadiusPoses(controlPoses, raws) {\n    if (raws === void 0) {\n        raws = controlPoses.map(function(pos) {\n            return pos.raw;\n        });\n    }\n    var horizontals = controlPoses.map(function(pos, i) {\n        return pos.horizontal ? raws[i] : null;\n    }).filter(function(pos) {\n        return pos != null;\n    });\n    var verticals = controlPoses.map(function(pos, i) {\n        return pos.vertical ? raws[i] : null;\n    }).filter(function(pos) {\n        return pos != null;\n    });\n    return {\n        horizontals: horizontals,\n        verticals: verticals\n    };\n}\nvar CLIP_DIRECTIONS = [\n    [\n        0,\n        -1,\n        \"n\"\n    ],\n    [\n        1,\n        0,\n        \"e\"\n    ]\n];\nvar CLIP_RECT_DIRECTIONS = [\n    [\n        -1,\n        -1,\n        \"nw\"\n    ],\n    [\n        0,\n        -1,\n        \"n\"\n    ],\n    [\n        1,\n        -1,\n        \"ne\"\n    ],\n    [\n        1,\n        0,\n        \"e\"\n    ],\n    [\n        1,\n        1,\n        \"se\"\n    ],\n    [\n        0,\n        1,\n        \"s\"\n    ],\n    [\n        -1,\n        1,\n        \"sw\"\n    ],\n    [\n        -1,\n        0,\n        \"w\"\n    ]\n];\n// 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\nfunction getClipStyles(moveable, clipPath, poses) {\n    var clipRelative = moveable.props.clipRelative;\n    var _a = moveable.state, width = _a.width, height = _a.height;\n    var _b = clipPath, clipType = _b.type, clipPoses = _b.poses;\n    var isRect = clipType === \"rect\";\n    var isCircle = clipType === \"circle\";\n    if (clipType === \"polygon\") {\n        return poses.map(function(pos) {\n            return \"\".concat(convertCSSSize(pos[0], width, clipRelative), \" \").concat(convertCSSSize(pos[1], height, clipRelative));\n        });\n    } else if (isRect || clipType === \"inset\") {\n        var top_1 = poses[1][1];\n        var right = poses[3][0];\n        var left = poses[7][0];\n        var bottom = poses[5][1];\n        if (isRect) {\n            return [\n                top_1,\n                right,\n                bottom,\n                left\n            ].map(function(pos) {\n                return \"\".concat(pos, \"px\");\n            });\n        }\n        var clipStyles = [\n            top_1,\n            width - right,\n            height - bottom,\n            left\n        ].map(function(pos, i) {\n            return convertCSSSize(pos, i % 2 ? width : height, clipRelative);\n        });\n        if (poses.length > 8) {\n            var _c = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(poses[4], poses[0]), 2), subWidth = _c[0], subHeight = _c[1];\n            clipStyles.push.apply(clipStyles, __spreadArray([\n                \"round\"\n            ], __read(getRadiusStyles(clipPoses.slice(8).map(function(info, i) {\n                return __assign(__assign({}, info), {\n                    pos: poses[i]\n                });\n            }), clipRelative, subWidth, subHeight, left, top_1, right, bottom).styles), false));\n        }\n        return clipStyles;\n    } else if (isCircle || clipType === \"ellipse\") {\n        var center = poses[0];\n        var ry = convertCSSSize(abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);\n        var clipStyles = isCircle ? [\n            ry\n        ] : [\n            convertCSSSize(abs(poses[2][0] - center[0]), width, clipRelative),\n            ry\n        ];\n        clipStyles.push(\"at\", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));\n        return clipStyles;\n    }\n}\nfunction getRectPoses(top, right, bottom, left) {\n    var xs = [\n        left,\n        (left + right) / 2,\n        right\n    ];\n    var ys = [\n        top,\n        (top + bottom) / 2,\n        bottom\n    ];\n    return CLIP_RECT_DIRECTIONS.map(function(_a) {\n        var _b = __read(_a, 3), dirx = _b[0], diry = _b[1], dir = _b[2];\n        var x = xs[dirx + 1];\n        var y = ys[diry + 1];\n        return {\n            vertical: abs(diry),\n            horizontal: abs(dirx),\n            direction: dir,\n            pos: [\n                x,\n                y\n            ]\n        };\n    });\n}\nfunction getControlSize(controlPoses) {\n    var xRange = [\n        Infinity,\n        -Infinity\n    ];\n    var yRange = [\n        Infinity,\n        -Infinity\n    ];\n    controlPoses.forEach(function(_a) {\n        var pos = _a.pos;\n        xRange[0] = Math.min(xRange[0], pos[0]);\n        xRange[1] = Math.max(xRange[1], pos[0]);\n        yRange[0] = Math.min(yRange[0], pos[1]);\n        yRange[1] = Math.max(yRange[1], pos[1]);\n    });\n    return [\n        abs(xRange[1] - xRange[0]),\n        abs(yRange[1] - yRange[0])\n    ];\n}\nfunction getClipPath(target, width, height, defaultClip, customClip) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    if (!target) {\n        return;\n    }\n    var clipText = customClip;\n    if (!clipText) {\n        var getStyle = getCachedStyle(target);\n        var clipPath = getStyle(\"clipPath\");\n        clipText = clipPath !== \"none\" ? clipPath : getStyle(\"clip\");\n    }\n    if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n        clipText = defaultClip;\n        if (!clipText) {\n            return;\n        }\n    }\n    var _k = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitBracket)(clipText), _l = _k.prefix, clipPrefix = _l === void 0 ? clipText : _l, _m = _k.value, value = _m === void 0 ? \"\" : _m;\n    var isCircle = clipPrefix === \"circle\";\n    var splitter = \" \";\n    if (clipPrefix === \"polygon\") {\n        var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitComma)(value || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\n        splitter = \",\";\n        var poses = values.map(function(pos) {\n            var _a = __read(pos.split(\" \"), 2), xPos = _a[0], yPos = _a[1];\n            return {\n                vertical: 1,\n                horizontal: 1,\n                pos: [\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(xPos, width),\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(yPos, height)\n                ]\n            };\n        });\n        var minMaxs = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getMinMaxs)(poses.map(function(pos) {\n            return pos.pos;\n        }));\n        return {\n            type: clipPrefix,\n            clipText: clipText,\n            poses: poses,\n            splitter: splitter,\n            left: minMaxs.minX,\n            right: minMaxs.maxX,\n            top: minMaxs.minY,\n            bottom: minMaxs.maxY\n        };\n    } else if (isCircle || clipPrefix === \"ellipse\") {\n        var xPos = \"\";\n        var yPos = \"\";\n        var radiusX_1 = 0;\n        var radiusY_1 = 0;\n        var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(value);\n        if (isCircle) {\n            var radius = \"\";\n            _a = __read(values, 4), _b = _a[0], radius = _b === void 0 ? \"50%\" : _b, _c = _a[2], xPos = _c === void 0 ? \"50%\" : _c, _d = _a[3], yPos = _d === void 0 ? \"50%\" : _d;\n            radiusX_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(radius, Math.sqrt((width * width + height * height) / 2));\n            radiusY_1 = radiusX_1;\n        } else {\n            var xRadius = \"\";\n            var yRadius = \"\";\n            _e = __read(values, 5), _f = _e[0], xRadius = _f === void 0 ? \"50%\" : _f, _g = _e[1], yRadius = _g === void 0 ? \"50%\" : _g, _h = _e[3], xPos = _h === void 0 ? \"50%\" : _h, _j = _e[4], yPos = _j === void 0 ? \"50%\" : _j;\n            radiusX_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(xRadius, width);\n            radiusY_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(yRadius, height);\n        }\n        var centerPos_1 = [\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(xPos, width),\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(yPos, height)\n        ];\n        var poses = __spreadArray([\n            {\n                vertical: 1,\n                horizontal: 1,\n                pos: centerPos_1,\n                direction: \"nesw\"\n            }\n        ], __read(CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function(dir) {\n            return {\n                vertical: abs(dir[1]),\n                horizontal: dir[0],\n                direction: dir[2],\n                sub: true,\n                pos: [\n                    centerPos_1[0] + dir[0] * radiusX_1,\n                    centerPos_1[1] + dir[1] * radiusY_1\n                ]\n            };\n        })), false);\n        return {\n            type: clipPrefix,\n            clipText: clipText,\n            radiusX: radiusX_1,\n            radiusY: radiusY_1,\n            left: centerPos_1[0] - radiusX_1,\n            top: centerPos_1[1] - radiusY_1,\n            right: centerPos_1[0] + radiusX_1,\n            bottom: centerPos_1[1] + radiusY_1,\n            poses: poses,\n            splitter: splitter\n        };\n    } else if (clipPrefix === \"inset\") {\n        var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(value || \"0 0 0 0\");\n        var roundIndex = values.indexOf(\"round\");\n        var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\n        var radiusValues = values.slice(rectLength + 1);\n        var _o = __read(values.slice(0, rectLength), 4), topValue = _o[0], _p = _o[1], rightValue = _p === void 0 ? topValue : _p, _q = _o[2], bottomValue = _q === void 0 ? topValue : _q, _r = _o[3], leftValue = _r === void 0 ? rightValue : _r;\n        var _s = __read([\n            topValue,\n            bottomValue\n        ].map(function(pos) {\n            return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(pos, height);\n        }), 2), top_2 = _s[0], bottom = _s[1];\n        var _t = __read([\n            leftValue,\n            rightValue\n        ].map(function(pos) {\n            return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(pos, width);\n        }), 2), left = _t[0], right = _t[1];\n        var nextRight = width - right;\n        var nextBottom = height - bottom;\n        var radiusPoses = getRadiusValues(radiusValues, nextRight - left, nextBottom - top_2, left, top_2);\n        var poses = __spreadArray(__spreadArray([], __read(getRectPoses(top_2, nextRight, nextBottom, left)), false), __read(radiusPoses), false);\n        return {\n            type: \"inset\",\n            clipText: clipText,\n            poses: poses,\n            top: top_2,\n            left: left,\n            right: nextRight,\n            bottom: nextBottom,\n            radius: radiusValues,\n            splitter: splitter\n        };\n    } else if (clipPrefix === \"rect\") {\n        // top right bottom left\n        var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitComma)(value || \"0px, \".concat(width, \"px, \").concat(height, \"px, 0px\"));\n        splitter = \",\";\n        var _u = __read(values.map(function(pos) {\n            var posValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitUnit)(pos).value;\n            return posValue;\n        }), 4), top_3 = _u[0], right = _u[1], bottom = _u[2], left = _u[3];\n        var poses = getRectPoses(top_3, right, bottom, left);\n        return {\n            type: \"rect\",\n            clipText: clipText,\n            poses: poses,\n            top: top_3,\n            right: right,\n            bottom: bottom,\n            left: left,\n            values: values,\n            splitter: splitter\n        };\n    }\n    return;\n}\nfunction moveControlPos(controlPoses, index, dist, isRect, keepRatio) {\n    var _a = controlPoses[index], direction = _a.direction, sub = _a.sub;\n    var dists = controlPoses.map(function() {\n        return [\n            0,\n            0\n        ];\n    });\n    var directions = direction ? direction.split(\"\") : [];\n    if (isRect && index < 8) {\n        var verticalDirections = directions.filter(function(dir) {\n            return dir === \"w\" || dir === \"e\";\n        });\n        var horizontalDirections = directions.filter(function(dir) {\n            return dir === \"n\" || dir === \"s\";\n        });\n        var verticalDirection_1 = verticalDirections[0];\n        var horizontalDirection_1 = horizontalDirections[0];\n        dists[index] = dist;\n        var _b = __read(getControlSize(controlPoses), 2), width = _b[0], height = _b[1];\n        var ratio = width && height ? width / height : 0;\n        if (ratio && keepRatio) {\n            // 0 1 2\n            // 7   3\n            // 6 5 4\n            var fixedIndex = (index + 4) % 8;\n            var fixedPosition = controlPoses[fixedIndex].pos;\n            var sizeDirection = [\n                0,\n                0\n            ];\n            if (direction.indexOf(\"w\") > -1) {\n                sizeDirection[0] = -1;\n            } else if (direction.indexOf(\"e\") > -1) {\n                sizeDirection[0] = 1;\n            }\n            if (direction.indexOf(\"n\") > -1) {\n                sizeDirection[1] = -1;\n            } else if (direction.indexOf(\"s\") > -1) {\n                sizeDirection[1] = 1;\n            }\n            var nextDist = getSizeDistByDist([\n                width,\n                height\n            ], dist, ratio, sizeDirection, true);\n            var nextWidth = width + nextDist[0];\n            var nextHeight = height + nextDist[1];\n            var top_1 = fixedPosition[1];\n            var bottom = fixedPosition[1];\n            var left = fixedPosition[0];\n            var right = fixedPosition[0];\n            if (sizeDirection[0] === -1) {\n                left = right - nextWidth;\n            } else if (sizeDirection[0] === 1) {\n                right = left + nextWidth;\n            } else {\n                left = left - nextWidth / 2;\n                right = right + nextWidth / 2;\n            }\n            if (sizeDirection[1] === -1) {\n                top_1 = bottom - nextHeight;\n            } else if (sizeDirection[1] === 1) {\n                bottom = top_1 + nextHeight;\n            } else {\n                top_1 = bottom - nextHeight / 2;\n                bottom = top_1 + nextHeight;\n            }\n            var nextControlPoses_1 = getRectPoses(top_1, right, bottom, left);\n            controlPoses.forEach(function(controlPose, i) {\n                dists[i][0] = nextControlPoses_1[i].pos[0] - controlPose.pos[0];\n                dists[i][1] = nextControlPoses_1[i].pos[1] - controlPose.pos[1];\n            });\n        } else {\n            controlPoses.forEach(function(controlPose, i) {\n                var controlDir = controlPose.direction;\n                if (!controlDir) {\n                    return;\n                }\n                if (controlDir.indexOf(verticalDirection_1) > -1) {\n                    dists[i][0] = dist[0];\n                }\n                if (controlDir.indexOf(horizontalDirection_1) > -1) {\n                    dists[i][1] = dist[1];\n                }\n            });\n            if (verticalDirection_1) {\n                dists[1][0] = dist[0] / 2;\n                dists[5][0] = dist[0] / 2;\n            }\n            if (horizontalDirection_1) {\n                dists[3][1] = dist[1] / 2;\n                dists[7][1] = dist[1] / 2;\n            }\n        }\n    } else if (direction && !sub) {\n        directions.forEach(function(dir) {\n            var isVertical = dir === \"n\" || dir === \"s\";\n            controlPoses.forEach(function(controlPose, i) {\n                var dirDir = controlPose.direction, dirHorizontal = controlPose.horizontal, dirVertical = controlPose.vertical;\n                if (!dirDir || dirDir.indexOf(dir) === -1) {\n                    return;\n                }\n                dists[i] = [\n                    isVertical || !dirHorizontal ? 0 : dist[0],\n                    !isVertical || !dirVertical ? 0 : dist[1]\n                ];\n            });\n        });\n    } else {\n        dists[index] = dist;\n    }\n    return dists;\n}\nfunction addClipPath(moveable, e) {\n    var _a = __read(calculatePointerDist(moveable, e), 2), distX = _a[0], distY = _a[1];\n    var _b = e.datas, clipPath = _b.clipPath, clipIndex = _b.clipIndex;\n    var _c = clipPath, clipType = _c.type, clipPoses = _c.poses, splitter = _c.splitter;\n    var poses = clipPoses.map(function(pos) {\n        return pos.pos;\n    });\n    if (clipType === \"polygon\") {\n        poses.splice(clipIndex, 0, [\n            distX,\n            distY\n        ]);\n    } else if (clipType === \"inset\") {\n        var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(clipIndex);\n        var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(clipIndex);\n        var length_1 = clipPoses.length;\n        addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);\n        if (length_1 === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    var clipStyles = getClipStyles(moveable, clipPath, poses);\n    var clipStyle = \"\".concat(clipType, \"(\").concat(clipStyles.join(splitter), \")\");\n    triggerEvent(moveable, \"onClip\", fillParams(moveable, e, __assign({\n        clipEventType: \"added\",\n        clipType: clipType,\n        poses: poses,\n        clipStyles: clipStyles,\n        clipStyle: clipStyle,\n        distX: 0,\n        distY: 0\n    }, fillCSSObject({\n        clipPath: clipStyle\n    }, e))));\n}\nfunction removeClipPath(moveable, e) {\n    var _a = e.datas, clipPath = _a.clipPath, clipIndex = _a.clipIndex;\n    var _b = clipPath, clipType = _b.type, clipPoses = _b.poses, splitter = _b.splitter;\n    var poses = clipPoses.map(function(pos) {\n        return pos.pos;\n    });\n    var length = poses.length;\n    if (clipType === \"polygon\") {\n        clipPoses.splice(clipIndex, 1);\n        poses.splice(clipIndex, 1);\n    } else if (clipType === \"inset\") {\n        if (clipIndex < 8) {\n            return;\n        }\n        removeRadiusPos(clipPoses, poses, clipIndex, 8, length);\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    var clipStyles = getClipStyles(moveable, clipPath, poses);\n    var clipStyle = \"\".concat(clipType, \"(\").concat(clipStyles.join(splitter), \")\");\n    triggerEvent(moveable, \"onClip\", fillParams(moveable, e, __assign({\n        clipEventType: \"removed\",\n        clipType: clipType,\n        poses: poses,\n        clipStyles: clipStyles,\n        clipStyle: clipStyle,\n        distX: 0,\n        distY: 0\n    }, fillCSSObject({\n        clipPath: clipStyle\n    }, e))));\n}\n/**\r\n * @namespace Moveable.Clippable\r\n * @description Whether to clip the target.\r\n */ var Clippable = {\n    name: \"clippable\",\n    props: [\n        \"clippable\",\n        \"defaultClipPath\",\n        \"customClipPath\",\n        \"keepRatio\",\n        \"clipRelative\",\n        \"clipArea\",\n        \"dragWithClip\",\n        \"clipTargetBounds\",\n        \"clipVerticalGuidelines\",\n        \"clipHorizontalGuidelines\",\n        \"clipSnapThreshold\"\n    ],\n    events: [\n        \"clipStart\",\n        \"clip\",\n        \"clipEnd\"\n    ],\n    css: [\n        \".control.clip-control {\\nbackground: #6d6;\\ncursor: pointer;\\n}\\n.control.clip-control.clip-radius {\\nbackground: #d66;\\n}\\n.line.clip-line {\\nbackground: #6e6;\\ncursor: move;\\nz-index: 1;\\n}\\n.clip-area {\\nposition: absolute;\\ntop: 0;\\nleft: 0;\\n}\\n.clip-ellipse {\\nposition: absolute;\\ncursor: move;\\nborder: 1px solid #6d6;\\nborder: var(--zoompx) solid #6d6;\\nborder-radius: 50%;\\ntransform-origin: 0px 0px;\\n}\",\n        \":host {\\n--bounds-color: #d66;\\n}\",\n        \".guideline {\\npointer-events: none;\\nz-index: 2;\\n}\",\n        \".line.guideline.bounds {\\nbackground: #d66;\\nbackground: var(--bounds-color);\\n}\"\n    ],\n    render: function(moveable, React) {\n        var _a = moveable.props, customClipPath = _a.customClipPath, defaultClipPath = _a.defaultClipPath, clipArea = _a.clipArea, zoom = _a.zoom, groupable = _a.groupable;\n        var _b = moveable.getState(), target = _b.target, width = _b.width, height = _b.height, allMatrix = _b.allMatrix, is3d = _b.is3d, left = _b.left, top = _b.top, pos1 = _b.pos1, pos2 = _b.pos2, pos3 = _b.pos3, pos4 = _b.pos4, clipPathState = _b.clipPathState, snapBoundInfos = _b.snapBoundInfos, rotationRad = _b.rotation;\n        if (!target || groupable) {\n            return [];\n        }\n        var clipPath = getClipPath(target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\n        if (!clipPath) {\n            return [];\n        }\n        var n = is3d ? 4 : 3;\n        var type = clipPath.type;\n        var clipPoses = clipPath.poses;\n        var poses = clipPoses.map(function(pos) {\n            // return [x, y];\n            var calculatedPos = calculatePosition(allMatrix, pos.pos, n);\n            return [\n                calculatedPos[0] - left,\n                calculatedPos[1] - top\n            ];\n        });\n        var controls = [];\n        var lines = [];\n        var isRect = type === \"rect\";\n        var isInset = type === \"inset\";\n        var isPolygon = type === \"polygon\";\n        if (isRect || isInset || isPolygon) {\n            var linePoses_1 = isInset ? poses.slice(0, 8) : poses;\n            lines = linePoses_1.map(function(to, i) {\n                var from = i === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i - 1];\n                var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(from, to);\n                var dist = getDiagonalSize(from, to);\n                return React.createElement(\"div\", {\n                    key: \"clipLine\".concat(i),\n                    className: prefix(\"line\", \"clip-line\", \"snap-control\"),\n                    \"data-clip-index\": i,\n                    style: {\n                        width: \"\".concat(dist, \"px\"),\n                        transform: \"translate(\".concat(from[0], \"px, \").concat(from[1], \"px) rotate(\").concat(rad, \"rad) scaleY(\").concat(zoom, \")\")\n                    }\n                });\n            });\n        }\n        controls = poses.map(function(pos, i) {\n            return React.createElement(\"div\", {\n                key: \"clipControl\".concat(i),\n                className: prefix(\"control\", \"clip-control\", \"snap-control\"),\n                \"data-clip-index\": i,\n                style: {\n                    transform: \"translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) rotate(\").concat(rotationRad, \"rad) scale(\").concat(zoom, \")\")\n                }\n            });\n        });\n        if (isInset) {\n            controls.push.apply(controls, __spreadArray([], __read(poses.slice(8).map(function(pos, i) {\n                return React.createElement(\"div\", {\n                    key: \"clipRadiusControl\".concat(i),\n                    className: prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\"),\n                    \"data-clip-index\": 8 + i,\n                    style: {\n                        transform: \"translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) rotate(\").concat(rotationRad, \"rad) scale(\").concat(zoom, \")\")\n                    }\n                });\n            })), false));\n        }\n        if (type === \"circle\" || type === \"ellipse\") {\n            var clipLeft = clipPath.left, clipTop = clipPath.top, radiusX = clipPath.radiusX, radiusY = clipPath.radiusY;\n            var _c = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, [\n                clipLeft,\n                clipTop\n            ], n), calculatePosition(allMatrix, [\n                0,\n                0\n            ], n)), 2), distLeft = _c[0], distTop = _c[1];\n            var ellipseClipPath = \"none\";\n            if (!clipArea) {\n                var piece = Math.max(10, radiusX / 5, radiusY / 5);\n                var areaPoses = [];\n                for(var i = 0; i <= piece; ++i){\n                    var rad = Math.PI * 2 / piece * i;\n                    areaPoses.push([\n                        radiusX + (radiusX - zoom) * Math.cos(rad),\n                        radiusY + (radiusY - zoom) * Math.sin(rad)\n                    ]);\n                }\n                areaPoses.push([\n                    radiusX,\n                    -2\n                ]);\n                areaPoses.push([\n                    -2,\n                    -2\n                ]);\n                areaPoses.push([\n                    -2,\n                    radiusY * 2 + 2\n                ]);\n                areaPoses.push([\n                    radiusX * 2 + 2,\n                    radiusY * 2 + 2\n                ]);\n                areaPoses.push([\n                    radiusX * 2 + 2,\n                    -2\n                ]);\n                areaPoses.push([\n                    radiusX,\n                    -2\n                ]);\n                ellipseClipPath = \"polygon(\".concat(areaPoses.map(function(pos) {\n                    return \"\".concat(pos[0], \"px \").concat(pos[1], \"px\");\n                }).join(\", \"), \")\");\n            }\n            controls.push(React.createElement(\"div\", {\n                key: \"clipEllipse\",\n                className: prefix(\"clip-ellipse\", \"snap-control\"),\n                style: {\n                    width: \"\".concat(radiusX * 2, \"px\"),\n                    height: \"\".concat(radiusY * 2, \"px\"),\n                    clipPath: ellipseClipPath,\n                    transform: \"translate(\".concat(-left + distLeft, \"px, \").concat(-top + distTop, \"px) \").concat(makeMatrixCSS(allMatrix))\n                }\n            }));\n        }\n        if (clipArea) {\n            var _d = getRect(__spreadArray([\n                pos1,\n                pos2,\n                pos3,\n                pos4\n            ], __read(poses), false)), allWidth = _d.width, allHeight = _d.height, allLeft_1 = _d.left, allTop_1 = _d.top;\n            if (isPolygon || isRect || isInset) {\n                var areaPoses = isInset ? poses.slice(0, 8) : poses;\n                controls.push(React.createElement(\"div\", {\n                    key: \"clipArea\",\n                    className: prefix(\"clip-area\", \"snap-control\"),\n                    style: {\n                        width: \"\".concat(allWidth, \"px\"),\n                        height: \"\".concat(allHeight, \"px\"),\n                        transform: \"translate(\".concat(allLeft_1, \"px, \").concat(allTop_1, \"px)\"),\n                        clipPath: \"polygon(\".concat(areaPoses.map(function(pos) {\n                            return \"\".concat(pos[0] - allLeft_1, \"px \").concat(pos[1] - allTop_1, \"px\");\n                        }).join(\", \"), \")\")\n                    }\n                }));\n            }\n        }\n        if (snapBoundInfos) {\n            [\n                \"vertical\",\n                \"horizontal\"\n            ].forEach(function(directionType) {\n                var info = snapBoundInfos[directionType];\n                var isHorizontal = directionType === \"horizontal\";\n                if (info.isSnap) {\n                    lines.push.apply(lines, __spreadArray([], __read(info.snap.posInfos.map(function(_a, i) {\n                        var pos = _a.pos;\n                        var snapPos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [\n                            0,\n                            pos\n                        ] : [\n                            pos,\n                            0\n                        ], n), [\n                            left,\n                            top\n                        ]);\n                        var snapPos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [\n                            width,\n                            pos\n                        ] : [\n                            pos,\n                            height\n                        ], n), [\n                            left,\n                            top\n                        ]);\n                        return renderLine(React, \"\", snapPos1, snapPos2, zoom, \"clip\".concat(directionType, \"snap\").concat(i), \"guideline\");\n                    })), false));\n                }\n                if (info.isBound) {\n                    lines.push.apply(lines, __spreadArray([], __read(info.bounds.map(function(_a, i) {\n                        var pos = _a.pos;\n                        var snapPos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [\n                            0,\n                            pos\n                        ] : [\n                            pos,\n                            0\n                        ], n), [\n                            left,\n                            top\n                        ]);\n                        var snapPos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [\n                            width,\n                            pos\n                        ] : [\n                            pos,\n                            height\n                        ], n), [\n                            left,\n                            top\n                        ]);\n                        return renderLine(React, \"\", snapPos1, snapPos2, zoom, \"clip\".concat(directionType, \"bounds\").concat(i), \"guideline\", \"bounds\", \"bold\");\n                    })), false));\n                }\n            });\n        }\n        return __spreadArray(__spreadArray([], __read(controls), false), __read(lines), false);\n    },\n    dragControlCondition: function(moveable, e) {\n        return e.inputEvent && (e.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n    },\n    dragStart: function(moveable, e) {\n        var props = moveable.props;\n        var _a = props.dragWithClip, dragWithClip = _a === void 0 ? true : _a;\n        if (dragWithClip) {\n            return false;\n        }\n        return this.dragControlStart(moveable, e);\n    },\n    drag: function(moveable, e) {\n        return this.dragControl(moveable, __assign(__assign({}, e), {\n            isDragTarget: true\n        }));\n    },\n    dragEnd: function(moveable, e) {\n        return this.dragControlEnd(moveable, e);\n    },\n    dragControlStart: function(moveable, e) {\n        var state = moveable.state;\n        var _a = moveable.props, defaultClipPath = _a.defaultClipPath, customClipPath = _a.customClipPath;\n        var target = state.target, width = state.width, height = state.height;\n        var inputTarget = e.inputEvent ? e.inputEvent.target : null;\n        var className = inputTarget && inputTarget.getAttribute(\"class\") || \"\";\n        var datas = e.datas;\n        var clipPath = getClipPath(target, width, height, defaultClipPath || \"inset\", customClipPath);\n        if (!clipPath) {\n            return false;\n        }\n        var clipText = clipPath.clipText, type = clipPath.type, poses = clipPath.poses;\n        var result = triggerEvent(moveable, \"onClipStart\", fillParams(moveable, e, {\n            clipType: type,\n            clipStyle: clipText,\n            poses: poses.map(function(pos) {\n                return pos.pos;\n            })\n        }));\n        if (result === false) {\n            datas.isClipStart = false;\n            return false;\n        }\n        datas.isControl = className && className.indexOf(\"clip-control\") > -1;\n        datas.isLine = className.indexOf(\"clip-line\") > -1;\n        datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\n        datas.clipIndex = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\n        datas.clipPath = clipPath;\n        datas.isClipStart = true;\n        state.clipPathState = clipText;\n        setDragStart(moveable, e);\n        return true;\n    },\n    dragControl: function(moveable, e) {\n        var _a, _b, _c;\n        var datas = e.datas, originalDatas = e.originalDatas, isDragTarget = e.isDragTarget;\n        if (!datas.isClipStart) {\n            return false;\n        }\n        var _d = datas, isControl = _d.isControl, isLine = _d.isLine, isArea = _d.isArea, clipIndex = _d.clipIndex, clipPath = _d.clipPath;\n        if (!clipPath) {\n            return false;\n        }\n        var props = getProps(moveable.props, \"clippable\");\n        var keepRatio = props.keepRatio;\n        var distX = 0;\n        var distY = 0;\n        var originalDraggable = originalDatas.draggable;\n        var originalDist = getDragDist(e);\n        if (isDragTarget && originalDraggable) {\n            _a = __read(originalDraggable.prevBeforeDist, 2), distX = _a[0], distY = _a[1];\n        } else {\n            _b = __read(originalDist, 2), distX = _b[0], distY = _b[1];\n        }\n        var firstDist = [\n            distX,\n            distY\n        ];\n        var state = moveable.state;\n        var width = state.width, height = state.height;\n        var isDragWithTarget = !isArea && !isControl && !isLine;\n        var clipType = clipPath.type, clipPoses = clipPath.poses, splitter = clipPath.splitter;\n        var poses = clipPoses.map(function(pos) {\n            return pos.pos;\n        });\n        if (isDragWithTarget) {\n            distX = -distX;\n            distY = -distY;\n        }\n        var isAll = !isControl || clipPoses[clipIndex].direction === \"nesw\";\n        var isRect = clipType === \"inset\" || clipType === \"rect\";\n        var dists = clipPoses.map(function() {\n            return [\n                0,\n                0\n            ];\n        });\n        if (isControl && !isAll) {\n            var _e = clipPoses[clipIndex], horizontal = _e.horizontal, vertical = _e.vertical;\n            var dist = [\n                distX * abs(horizontal),\n                distY * abs(vertical)\n            ];\n            dists = moveControlPos(clipPoses, clipIndex, dist, isRect, keepRatio);\n        } else if (isAll) {\n            dists = poses.map(function() {\n                return [\n                    distX,\n                    distY\n                ];\n            });\n        }\n        var nextPoses = poses.map(function(pos, i) {\n            return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, dists[i]);\n        });\n        var guidePoses = __spreadArray([], __read(nextPoses), false);\n        state.snapBoundInfos = null;\n        var isCircle = clipPath.type === \"circle\";\n        var isEllipse = clipPath.type === \"ellipse\";\n        if (isCircle || isEllipse) {\n            var guideRect = getRect(nextPoses);\n            var ry = abs(guideRect.bottom - guideRect.top);\n            var rx = abs(isEllipse ? guideRect.right - guideRect.left : ry);\n            var bottom = nextPoses[0][1] + ry;\n            var left = nextPoses[0][0] - rx;\n            var right = nextPoses[0][0] + rx;\n            // right\n            if (isCircle) {\n                guidePoses.push([\n                    right,\n                    guideRect.bottom\n                ]);\n                dists.push([\n                    1,\n                    0\n                ]);\n            }\n            // bottom\n            guidePoses.push([\n                guideRect.left,\n                bottom\n            ]);\n            dists.push([\n                0,\n                1\n            ]);\n            // left\n            guidePoses.push([\n                left,\n                guideRect.bottom\n            ]);\n            dists.push([\n                1,\n                0\n            ]);\n        }\n        var guidelines = getDefaultGuidelines((props.clipHorizontalGuidelines || []).map(function(v) {\n            return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(v), height);\n        }), (props.clipVerticalGuidelines || []).map(function(v) {\n            return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(v), width);\n        }), width, height);\n        var guideXPoses = [];\n        var guideYPoses = [];\n        if (isCircle || isEllipse) {\n            guideXPoses = [\n                guidePoses[4][0],\n                guidePoses[2][0]\n            ];\n            guideYPoses = [\n                guidePoses[1][1],\n                guidePoses[3][1]\n            ];\n        } else if (isRect) {\n            var rectPoses = [\n                guidePoses[0],\n                guidePoses[2],\n                guidePoses[4],\n                guidePoses[6]\n            ];\n            var rectDists_1 = [\n                dists[0],\n                dists[2],\n                dists[4],\n                dists[6]\n            ];\n            guideXPoses = rectPoses.filter(function(_, i) {\n                return rectDists_1[i][0];\n            }).map(function(pos) {\n                return pos[0];\n            });\n            guideYPoses = rectPoses.filter(function(_, i) {\n                return rectDists_1[i][1];\n            }).map(function(pos) {\n                return pos[1];\n            });\n        } else {\n            guideXPoses = guidePoses.filter(function(_, i) {\n                return dists[i][0];\n            }).map(function(pos) {\n                return pos[0];\n            });\n            guideYPoses = guidePoses.filter(function(_, i) {\n                return dists[i][1];\n            }).map(function(pos) {\n                return pos[1];\n            });\n        }\n        var boundDelta = [\n            0,\n            0\n        ];\n        var _f = checkSnapBounds(guidelines, props.clipTargetBounds && {\n            left: 0,\n            top: 0,\n            right: width,\n            bottom: height\n        }, guideXPoses, guideYPoses, 5, 5), horizontalSnapInfo = _f.horizontal, verticalSnapInfo = _f.vertical;\n        var snapOffsetY = horizontalSnapInfo.offset;\n        var snapOffsetX = verticalSnapInfo.offset;\n        if (horizontalSnapInfo.isBound) {\n            boundDelta[1] += snapOffsetY;\n        }\n        if (verticalSnapInfo.isBound) {\n            boundDelta[0] += snapOffsetX;\n        }\n        if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {\n            var guideRect = getRect(nextPoses);\n            var cy = guideRect.bottom - guideRect.top;\n            var cx = isEllipse ? guideRect.right - guideRect.left : cy;\n            var distSnapX = verticalSnapInfo.isBound ? abs(snapOffsetX) : verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX;\n            var distSnapY = horizontalSnapInfo.isBound ? abs(snapOffsetY) : horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY;\n            cx -= distSnapX;\n            cy -= distSnapY;\n            if (isCircle) {\n                cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;\n                cx = cy;\n            }\n            var center = guidePoses[0];\n            guidePoses[1][1] = center[1] - cy;\n            guidePoses[2][0] = center[0] + cx;\n            guidePoses[3][1] = center[1] + cy;\n            guidePoses[4][0] = center[0] - cx;\n        } else if (isRect && keepRatio && isControl) {\n            var _g = __read(getControlSize(clipPoses), 2), width_1 = _g[0], height_1 = _g[1];\n            var ratio = width_1 && height_1 ? width_1 / height_1 : 0;\n            var clipPose = clipPoses[clipIndex];\n            var direction = clipPose.direction || \"\";\n            var top_2 = guidePoses[1][1];\n            var bottom = guidePoses[5][1];\n            var left = guidePoses[7][0];\n            var right = guidePoses[3][0];\n            if (abs(snapOffsetY) <= abs(snapOffsetX)) {\n                snapOffsetY = sign(snapOffsetY) * abs(snapOffsetX) / ratio;\n            } else {\n                snapOffsetX = sign(snapOffsetX) * abs(snapOffsetY) * ratio;\n            }\n            if (direction.indexOf(\"w\") > -1) {\n                left -= snapOffsetX;\n            } else if (direction.indexOf(\"e\") > -1) {\n                right -= snapOffsetX;\n            } else {\n                left += snapOffsetX / 2;\n                right -= snapOffsetX / 2;\n            }\n            if (direction.indexOf(\"n\") > -1) {\n                top_2 -= snapOffsetY;\n            } else if (direction.indexOf(\"s\") > -1) {\n                bottom -= snapOffsetY;\n            } else {\n                top_2 += snapOffsetY / 2;\n                bottom -= snapOffsetY / 2;\n            }\n            var nextControlPoses_2 = getRectPoses(top_2, right, bottom, left);\n            guidePoses.forEach(function(pos, i) {\n                var _a;\n                _a = __read(nextControlPoses_2[i].pos, 2), pos[0] = _a[0], pos[1] = _a[1];\n            });\n        } else {\n            guidePoses.forEach(function(pos, j) {\n                var dist = dists[j];\n                if (dist[0]) {\n                    pos[0] -= snapOffsetX;\n                }\n                if (dist[1]) {\n                    pos[1] -= snapOffsetY;\n                }\n            });\n        }\n        var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);\n        var clipStyle = \"\".concat(clipType, \"(\").concat(nextClipStyles.join(splitter), \")\");\n        state.clipPathState = clipStyle;\n        if (isCircle || isEllipse) {\n            guideXPoses = [\n                guidePoses[4][0],\n                guidePoses[2][0]\n            ];\n            guideYPoses = [\n                guidePoses[1][1],\n                guidePoses[3][1]\n            ];\n        } else if (isRect) {\n            var rectPoses = [\n                guidePoses[0],\n                guidePoses[2],\n                guidePoses[4],\n                guidePoses[6]\n            ];\n            guideXPoses = rectPoses.map(function(pos) {\n                return pos[0];\n            });\n            guideYPoses = rectPoses.map(function(pos) {\n                return pos[1];\n            });\n        } else {\n            guideXPoses = guidePoses.map(function(pos) {\n                return pos[0];\n            });\n            guideYPoses = guidePoses.map(function(pos) {\n                return pos[1];\n            });\n        }\n        state.snapBoundInfos = checkSnapBounds(guidelines, props.clipTargetBounds && {\n            left: 0,\n            top: 0,\n            right: width,\n            bottom: height\n        }, guideXPoses, guideYPoses, 1, 1);\n        if (originalDraggable) {\n            var is3d = state.is3d, allMatrix = state.allMatrix;\n            var n = is3d ? 4 : 3;\n            var dragDist = boundDelta;\n            if (isDragTarget) {\n                dragDist = [\n                    firstDist[0] + boundDelta[0] - originalDist[0],\n                    firstDist[1] + boundDelta[1] - originalDist[1]\n                ];\n            }\n            originalDraggable.deltaOffset = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(allMatrix, [\n                dragDist[0],\n                dragDist[1],\n                0,\n                0\n            ], n);\n        }\n        triggerEvent(moveable, \"onClip\", fillParams(moveable, e, __assign({\n            clipEventType: \"changed\",\n            clipType: clipType,\n            poses: nextPoses,\n            clipStyle: clipStyle,\n            clipStyles: nextClipStyles,\n            distX: distX,\n            distY: distY\n        }, fillCSSObject((_c = {}, _c[clipType === \"rect\" ? \"clip\" : \"clipPath\"] = clipStyle, _c), e))));\n        return true;\n    },\n    dragControlEnd: function(moveable, e) {\n        this.unset(moveable);\n        var isDrag = e.isDrag, datas = e.datas, isDouble = e.isDouble;\n        var isLine = datas.isLine, isClipStart = datas.isClipStart, isControl = datas.isControl;\n        if (!isClipStart) {\n            return false;\n        }\n        triggerEvent(moveable, \"onClipEnd\", fillEndParams(moveable, e, {}));\n        if (isDouble) {\n            if (isControl) {\n                removeClipPath(moveable, e);\n            } else if (isLine) {\n                // add\n                addClipPath(moveable, e);\n            }\n        }\n        return isDouble || isDrag;\n    },\n    unset: function(moveable) {\n        moveable.state.clipPathState = \"\";\n        moveable.state.snapBoundInfos = null;\n    }\n};\n/**\r\n * Whether to clip the target. (default: false)\r\n * @name Moveable.Clippable#clippable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\r\n * @name Moveable.Clippable#defaultClipPath\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\r\n * @name Moveable.Clippable#clipRelative\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\r\n * @name Moveable.Clippable#customClipPath\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * When dragging the target, the clip also moves. (default: true)\r\n * @name Moveable.Clippable#dragWithClip\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * You can drag the clip by setting clipArea.\r\n * @name Moveable.Clippable#clipArea\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n* Whether the clip is bound to the target.\r\n* @name Moveable.Clippable#clipTargetBounds\r\n* @default false\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     clippable: true,\r\n*     defaultClipPath: \"inset\",\r\n*     customClipPath: \"\",\r\n*     clipRelative: false,\r\n*     clipArea: false,\r\n*     dragWithClip: true,\r\n*     clipTargetBounds: true,\r\n* });\r\n* moveable.on(\"clipStart\", e => {\r\n*     console.log(e);\r\n* }).on(\"clip\", e => {\r\n*     if (e.clipType === \"rect\") {\r\n*         e.target.style.clip = e.clipStyle;\r\n*     } else {\r\n*         e.target.style.clipPath = e.clipStyle;\r\n*     }\r\n* }).on(\"clipEnd\", e => {\r\n*     console.log(e);\r\n* });\r\n*/ /**\r\n * Add clip guidelines in the vertical direction.\r\n * @name Moveable.Clippable#clipVerticalGuidelines\r\n * @default 0\r\n * @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     clippable: true,\r\n*     defaultClipPath: \"inset\",\r\n*     customClipPath: \"\",\r\n*     clipRelative: false,\r\n*     clipArea: false,\r\n*     dragWithClip: true,\r\n*     clipVerticalGuidelines: [0, 100, 200],\r\n*     clipHorizontalGuidelines: [0, 100, 200],\r\n*     clipSnapThreshold: 5,\r\n* });\r\n*/ /**\r\n* Add clip guidelines in the horizontal direction.\r\n* @name Moveable.Clippable#clipHorizontalGuidelines\r\n* @default []\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     clippable: true,\r\n*     defaultClipPath: \"inset\",\r\n*     customClipPath: \"\",\r\n*     clipRelative: false,\r\n*     clipArea: false,\r\n*     dragWithClip: true,\r\n*     clipVerticalGuidelines: [0, 100, 200],\r\n*     clipHorizontalGuidelines: [0, 100, 200],\r\n*     clipSnapThreshold: 5,\r\n* });\r\n*/ /**\r\n* istance value that can snap to clip guidelines.\r\n* @name Moveable.Clippable#clipSnapThreshold\r\n* @default 5\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     clippable: true,\r\n*     defaultClipPath: \"inset\",\r\n*     customClipPath: \"\",\r\n*     clipRelative: false,\r\n*     clipArea: false,\r\n*     dragWithClip: true,\r\n*     clipVerticalGuidelines: [0, 100, 200],\r\n*     clipHorizontalGuidelines: [0, 100, 200],\r\n*     clipSnapThreshold: 5,\r\n* });\r\n*/ /**\r\n * When drag start the clip area or controls, the `clipStart` event is called.\r\n * @memberof Moveable.Clippable\r\n * @event clipStart\r\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * When drag the clip area or controls, the `clip` event is called.\r\n * @memberof Moveable.Clippable\r\n * @event clip\r\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * When drag end the clip area or controls, the `clipEnd` event is called.\r\n * @memberof Moveable.Clippable\r\n * @event clipEnd\r\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * @namespace OriginDraggable\r\n * @memberof Moveable\r\n * @description Whether to drag origin (default: false)\r\n */ var OriginDraggable = {\n    name: \"originDraggable\",\n    props: [\n        \"originDraggable\",\n        \"originRelative\"\n    ],\n    events: [\n        \"dragOriginStart\",\n        \"dragOrigin\",\n        \"dragOriginEnd\"\n    ],\n    css: [\n        \":host[data-able-origindraggable] .control.origin {\\npointer-events: auto;\\n}\"\n    ],\n    dragControlCondition: function(_, e) {\n        if (e.isRequest) {\n            return e.requestAble === \"originDraggable\";\n        }\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(e.inputEvent.target, prefix(\"origin\"));\n    },\n    dragControlStart: function(moveable, e) {\n        var datas = e.datas;\n        setDragStart(moveable, e);\n        var params = fillParams(moveable, e, {\n            dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([\n                0,\n                0\n            ], e))\n        });\n        var result = triggerEvent(moveable, \"onDragOriginStart\", params);\n        datas.startOrigin = moveable.state.transformOrigin;\n        datas.startTargetOrigin = moveable.state.targetOrigin;\n        datas.prevOrigin = [\n            0,\n            0\n        ];\n        datas.isDragOrigin = true;\n        if (result === false) {\n            datas.isDragOrigin = false;\n            return false;\n        }\n        return params;\n    },\n    dragControl: function(moveable, e) {\n        var datas = e.datas, isPinch = e.isPinch, isRequest = e.isRequest;\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        var _a = __read(getDragDist(e), 2), distX = _a[0], distY = _a[1];\n        var state = moveable.state;\n        var width = state.width, height = state.height, offsetMatrix = state.offsetMatrix, targetMatrix = state.targetMatrix, is3d = state.is3d;\n        var _b = moveable.props.originRelative, originRelative = _b === void 0 ? true : _b;\n        var n = is3d ? 4 : 3;\n        var dist = [\n            distX,\n            distY\n        ];\n        if (isRequest) {\n            var distOrigin = e.distOrigin;\n            if (distOrigin[0] || distOrigin[1]) {\n                dist = distOrigin;\n            }\n        }\n        var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(datas.startOrigin, dist);\n        var targetOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(datas.startTargetOrigin, dist);\n        var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, datas.prevOrigin);\n        var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);\n        var rect = moveable.getRect();\n        var nextRect = getRect(calculatePoses(nextMatrix, width, height, n));\n        var dragDelta = [\n            rect.left - nextRect.left,\n            rect.top - nextRect.top\n        ];\n        datas.prevOrigin = dist;\n        var transformOrigin = [\n            convertCSSSize(targetOrigin[0], width, originRelative),\n            convertCSSSize(targetOrigin[1], height, originRelative)\n        ].join(\" \");\n        var result = Draggable.drag(moveable, setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false));\n        var params = fillParams(moveable, e, __assign(__assign({\n            width: width,\n            height: height,\n            origin: origin,\n            dist: dist,\n            delta: delta,\n            transformOrigin: transformOrigin,\n            drag: result\n        }, fillCSSObject({\n            transformOrigin: transformOrigin,\n            transform: result.transform\n        }, e)), {\n            afterTransform: result.transform\n        }));\n        triggerEvent(moveable, \"onDragOrigin\", params);\n        return params;\n    },\n    dragControlEnd: function(moveable, e) {\n        var datas = e.datas;\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        triggerEvent(moveable, \"onDragOriginEnd\", fillEndParams(moveable, e, {}));\n        return true;\n    },\n    dragGroupControlCondition: function(moveable, e) {\n        return this.dragControlCondition(moveable, e);\n    },\n    dragGroupControlStart: function(moveable, e) {\n        var params = this.dragControlStart(moveable, e);\n        if (!params) {\n            return false;\n        }\n        return true;\n    },\n    dragGroupControl: function(moveable, e) {\n        var params = this.dragControl(moveable, e);\n        if (!params) {\n            return false;\n        }\n        moveable.transformOrigin = params.transformOrigin;\n        return true;\n    },\n    /**\r\n    * @method Moveable.OriginDraggable#request\r\n    * @param {object} e - the OriginDraggable's request parameter\r\n    * @param {number} [e.x] - x position\r\n    * @param {number} [e.y] - y position\r\n    * @param {number} [e.deltaX] - x number to move\r\n    * @param {number} [e.deltaY] - y number to move\r\n    * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\r\n    * @param {array} [e.origin] - transform-origin position\r\n    * @param {number} [e.isInstant] - Whether to execute the request instantly\r\n    * @return {Moveable.Requester} Moveable Requester\r\n    * @example\r\n\n    * // Instantly Request (requestStart - request - requestEnd)\r\n    * // Use Relative Value\r\n    * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\r\n    * // Use Absolute Value\r\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\r\n    * // Use Transform Value\r\n    * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\r\n    * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\r\n    * // requestStart\r\n    * const requester = moveable.request(\"originDraggable\");\r\n    *\r\n    * // request\r\n    * // Use Relative Value\r\n    * requester.request({ deltaX: 10, deltaY: 10 });\r\n    * requester.request({ deltaX: 10, deltaY: 10 });\r\n    * requester.request({ deltaX: 10, deltaY: 10 });\r\n    * // Use Absolute Value\r\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 });\r\n    * moveable.request(\"originDraggable\", { x: 220, y: 100 });\r\n    * moveable.request(\"originDraggable\", { x: 240, y: 100 });\r\n    *\r\n    * // requestEnd\r\n    * requester.requestEnd();\r\n    */ request: function(moveable) {\n        var datas = {};\n        var rect = moveable.getRect();\n        var distX = 0;\n        var distY = 0;\n        var transformOrigin = rect.transformOrigin;\n        var distOrigin = [\n            0,\n            0\n        ];\n        return {\n            isControl: true,\n            requestStart: function() {\n                return {\n                    datas: datas\n                };\n            },\n            request: function(e) {\n                if (\"deltaOrigin\" in e) {\n                    distOrigin[0] += e.deltaOrigin[0];\n                    distOrigin[1] += e.deltaOrigin[1];\n                } else if (\"origin\" in e) {\n                    distOrigin[0] = e.origin[0] - transformOrigin[0];\n                    distOrigin[1] = e.origin[1] - transformOrigin[1];\n                } else {\n                    if (\"x\" in e) {\n                        distX = e.x - rect.left;\n                    } else if (\"deltaX\" in e) {\n                        distX += e.deltaX;\n                    }\n                    if (\"y\" in e) {\n                        distY = e.y - rect.top;\n                    } else if (\"deltaY\" in e) {\n                        distY += e.deltaY;\n                    }\n                }\n                return {\n                    datas: datas,\n                    distX: distX,\n                    distY: distY,\n                    distOrigin: distOrigin\n                };\n            },\n            requestEnd: function() {\n                return {\n                    datas: datas,\n                    isDrag: true\n                };\n            }\n        };\n    }\n};\n/**\r\n * Whether to drag origin (default: false)\r\n * @name Moveable.OriginDraggable#originDraggable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     originDraggable: true,\r\n * });\r\n * let translate = [0, 0];\r\n * moveable.on(\"dragOriginStart\", e => {\r\n *     e.dragStart && e.dragStart.set(translate);\r\n * }).on(\"dragOrigin\", e => {\r\n *     translate = e.drag.beforeTranslate;\r\n *     e.target.style.cssText\r\n *         = `transform-origin: ${e.transformOrigin};`\r\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\r\n * }).on(\"dragOriginEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * % Can be used instead of the absolute px (default: true)\r\n * @name Moveable.OriginDraggable#originRelative\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     originDraggable: true,\r\n *     originRelative: false,\r\n * });\r\n * moveable.originRelative = true;\r\n */ /**\r\n* When drag start the origin, the `dragOriginStart` event is called.\r\n* @memberof Moveable.OriginDraggable\r\n* @event dragOriginStart\r\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     originDraggable: true,\r\n* });\r\n* let translate = [0, 0];\r\n* moveable.on(\"dragOriginStart\", e => {\r\n*     e.dragStart && e.dragStart.set(translate);\r\n* }).on(\"dragOrigin\", e => {\r\n*     translate = e.drag.beforeTranslate;\r\n*     e.target.style.cssText\r\n*         = `transform-origin: ${e.transformOrigin};`\r\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\r\n* }).on(\"dragOriginEnd\", e => {\r\n*     console.log(e);\r\n* });\r\n*/ /**\r\n* When drag the origin, the `dragOrigin` event is called.\r\n* @memberof Moveable.OriginDraggable\r\n* @event dragOrigin\r\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     originDraggable: true,\r\n* });\r\n* let translate = [0, 0];\r\n* moveable.on(\"dragOriginStart\", e => {\r\n*     e.dragStart && e.dragStart.set(translate);\r\n* }).on(\"dragOrigin\", e => {\r\n*     translate = e.drag.beforeTranslate;\r\n*     e.target.style.cssText\r\n*         = `transform-origin: ${e.transformOrigin};`\r\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\r\n* }).on(\"dragOriginEnd\", e => {\r\n*     console.log(e);\r\n* });\r\n*/ /**\r\n* When drag end the origin, the `dragOriginEnd` event is called.\r\n* @memberof Moveable.OriginDraggable\r\n* @event dragOriginEnd\r\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     originDraggable: true,\r\n* });\r\n* let translate = [0, 0];\r\n* moveable.on(\"dragOriginStart\", e => {\r\n*     e.dragStart && e.dragStart.set(translate);\r\n* }).on(\"dragOrigin\", e => {\r\n*     translate = e.drag.beforeTranslate;\r\n*     e.target.style.cssText\r\n*         = `transform-origin: ${e.transformOrigin};`\r\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\r\n* }).on(\"dragOriginEnd\", e => {\r\n*     console.log(e);\r\n* });\r\n*/ function addBorderRadiusByLine(controlPoses, lineIndex, distX, distY) {\n    // lineIndex\n    // 0 top\n    // 1 right\n    // 2 bottom\n    // 3 left\n    var horizontalsLength = controlPoses.filter(function(_a) {\n        var virtual = _a.virtual, horizontal = _a.horizontal;\n        return horizontal && !virtual;\n    }).length;\n    var verticalsLength = controlPoses.filter(function(_a) {\n        var virtual = _a.virtual, vertical = _a.vertical;\n        return vertical && !virtual;\n    }).length;\n    var controlIndex = -1;\n    //top\n    if (lineIndex === 0) {\n        if (horizontalsLength === 0) {\n            controlIndex = 0;\n        } else if (horizontalsLength === 1) {\n            controlIndex = 1;\n        }\n    }\n    // bottom\n    if (lineIndex === 2) {\n        if (horizontalsLength <= 2) {\n            controlIndex = 2;\n        } else if (horizontalsLength <= 3) {\n            controlIndex = 3;\n        }\n    }\n    // left\n    if (lineIndex === 3) {\n        if (verticalsLength === 0) {\n            controlIndex = 4;\n        } else if (verticalsLength < 4) {\n            controlIndex = 7;\n        }\n    }\n    // right\n    if (lineIndex === 1) {\n        if (verticalsLength <= 1) {\n            controlIndex = 5;\n        } else if (verticalsLength <= 2) {\n            controlIndex = 6;\n        }\n    }\n    if (controlIndex === -1 || !controlPoses[controlIndex].virtual) {\n        return;\n    }\n    var controlPoseInfo = controlPoses[controlIndex];\n    addBorderRadius(controlPoses, controlIndex);\n    if (controlIndex < 4) {\n        controlPoseInfo.pos[0] = distX;\n    } else {\n        controlPoseInfo.pos[1] = distY;\n    }\n}\nfunction addBorderRadius(controlPoses, index) {\n    if (index < 4) {\n        controlPoses.slice(0, index + 1).forEach(function(info) {\n            info.virtual = false;\n        });\n    } else {\n        if (controlPoses[0].virtual) {\n            controlPoses[0].virtual = false;\n        }\n        controlPoses.slice(4, index + 1).forEach(function(info) {\n            info.virtual = false;\n        });\n    }\n}\nfunction removeBorderRadius(controlPoses, index) {\n    if (index < 4) {\n        controlPoses.slice(index, 4).forEach(function(info) {\n            info.virtual = true;\n        });\n    } else {\n        controlPoses.slice(index).forEach(function(info) {\n            info.virtual = true;\n        });\n    }\n}\nfunction getBorderRadius(borderRadius, width, height, minCounts, full) {\n    if (minCounts === void 0) {\n        minCounts = [\n            0,\n            0\n        ];\n    }\n    var values = [];\n    if (!borderRadius || borderRadius === \"0px\") {\n        values = [];\n    } else {\n        values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(borderRadius);\n    }\n    return getRadiusValues(values, width, height, 0, 0, minCounts, full);\n}\nfunction triggerRoundEvent(moveable, e, dist, delta, nextPoses) {\n    var state = moveable.state;\n    var width = state.width, height = state.height;\n    var _a = getRadiusStyles(nextPoses, moveable.props.roundRelative, width, height), raws = _a.raws, styles = _a.styles, radiusPoses = _a.radiusPoses;\n    var _b = splitRadiusPoses(radiusPoses, raws), horizontals = _b.horizontals, verticals = _b.verticals;\n    var borderRadius = styles.join(\" \");\n    state.borderRadiusState = borderRadius;\n    var params = fillParams(moveable, e, __assign({\n        horizontals: horizontals,\n        verticals: verticals,\n        borderRadius: borderRadius,\n        width: width,\n        height: height,\n        delta: delta,\n        dist: dist\n    }, fillCSSObject({\n        borderRadius: borderRadius\n    }, e)));\n    triggerEvent(moveable, \"onRound\", params);\n    return params;\n}\nfunction getStyleBorderRadius(moveable) {\n    var _a, _b;\n    var style = moveable.getState().style;\n    var borderRadius = style.borderRadius || \"\";\n    if (!borderRadius && moveable.props.groupable) {\n        var firstMoveable = moveable.moveables[0];\n        var firstTarget = moveable.getTargets()[0];\n        if (firstTarget) {\n            if ((firstMoveable === null || firstMoveable === void 0 ? void 0 : firstMoveable.props.target) === firstTarget) {\n                borderRadius = (_b = (_a = moveable.moveables[0]) === null || _a === void 0 ? void 0 : _a.state.style.borderRadius) !== null && _b !== void 0 ? _b : \"\";\n                style.borderRadius = borderRadius;\n            } else {\n                borderRadius = getComputedStyle(firstTarget).borderRadius;\n                style.borderRadius = borderRadius;\n            }\n        }\n    }\n    return borderRadius;\n}\n/**\r\n * @namespace Moveable.Roundable\r\n * @description Whether to show and drag or double click border-radius\r\n */ var Roundable = {\n    name: \"roundable\",\n    props: [\n        \"roundable\",\n        \"roundRelative\",\n        \"minRoundControls\",\n        \"maxRoundControls\",\n        \"roundClickable\",\n        \"roundPadding\",\n        \"isDisplayShadowRoundControls\"\n    ],\n    events: [\n        \"roundStart\",\n        \"round\",\n        \"roundEnd\",\n        \"roundGroupStart\",\n        \"roundGroup\",\n        \"roundGroupEnd\"\n    ],\n    css: [\n        \".control.border-radius {\\nbackground: #d66;\\ncursor: pointer;\\nz-index: 3;\\n}\",\n        \".control.border-radius.vertical {\\nbackground: #d6d;\\nz-index: 2;\\n}\",\n        \".control.border-radius.virtual {\\nopacity: 0.5;\\nz-index: 1;\\n}\",\n        \":host.round-line-clickable .line.direction {\\ncursor: pointer;\\n}\"\n    ],\n    className: function(moveable) {\n        var roundClickable = moveable.props.roundClickable;\n        return roundClickable === true || roundClickable === \"line\" ? prefix(\"round-line-clickable\") : \"\";\n    },\n    requestStyle: function() {\n        return [\n            \"borderRadius\"\n        ];\n    },\n    requestChildStyle: function() {\n        return [\n            \"borderRadius\"\n        ];\n    },\n    render: function(moveable, React) {\n        var _a = moveable.getState(), target = _a.target, width = _a.width, height = _a.height, allMatrix = _a.allMatrix, is3d = _a.is3d, left = _a.left, top = _a.top, borderRadiusState = _a.borderRadiusState;\n        var _b = moveable.props, _c = _b.minRoundControls, minRoundControls = _c === void 0 ? [\n            0,\n            0\n        ] : _c, _d = _b.maxRoundControls, maxRoundControls = _d === void 0 ? [\n            4,\n            4\n        ] : _d, zoom = _b.zoom, _e = _b.roundPadding, roundPadding = _e === void 0 ? 0 : _e, isDisplayShadowRoundControls = _b.isDisplayShadowRoundControls, groupable = _b.groupable;\n        if (!target) {\n            return null;\n        }\n        var borderRadius = borderRadiusState || getStyleBorderRadius(moveable);\n        var n = is3d ? 4 : 3;\n        var radiusValues = getBorderRadius(borderRadius, width, height, minRoundControls, true);\n        if (!radiusValues) {\n            return null;\n        }\n        var verticalCount = 0;\n        var horizontalCount = 0;\n        var basePos = groupable ? [\n            0,\n            0\n        ] : [\n            left,\n            top\n        ];\n        return radiusValues.map(function(v, i) {\n            var horizontal = v.horizontal;\n            var vertical = v.vertical;\n            var direction = v.direction || \"\";\n            var originalPos = __spreadArray([], __read(v.pos), false);\n            horizontalCount += Math.abs(horizontal);\n            verticalCount += Math.abs(vertical);\n            if (horizontal && direction.indexOf(\"n\") > -1) {\n                originalPos[1] -= roundPadding;\n            }\n            if (vertical && direction.indexOf(\"w\") > -1) {\n                originalPos[0] -= roundPadding;\n            }\n            if (horizontal && direction.indexOf(\"s\") > -1) {\n                originalPos[1] += roundPadding;\n            }\n            if (vertical && direction.indexOf(\"e\") > -1) {\n                originalPos[0] += roundPadding;\n            }\n            var pos = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, originalPos, n), basePos);\n            var isDisplayVerticalShadow = isDisplayShadowRoundControls && isDisplayShadowRoundControls !== \"horizontal\";\n            var isDisplay = v.vertical ? verticalCount <= maxRoundControls[1] && (isDisplayVerticalShadow || !v.virtual) : horizontalCount <= maxRoundControls[0] && (isDisplayShadowRoundControls || !v.virtual);\n            return React.createElement(\"div\", {\n                key: \"borderRadiusControl\".concat(i),\n                className: prefix(\"control\", \"border-radius\", v.vertical ? \"vertical\" : \"\", v.virtual ? \"virtual\" : \"\"),\n                \"data-radius-index\": i,\n                style: {\n                    display: isDisplay ? \"block\" : \"none\",\n                    transform: \"translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) scale(\").concat(zoom, \")\")\n                }\n            });\n        });\n    },\n    dragControlCondition: function(moveable, e) {\n        if (!e.inputEvent || e.isRequest) {\n            return false;\n        }\n        var className = e.inputEvent.target.getAttribute(\"class\") || \"\";\n        return className.indexOf(\"border-radius\") > -1 || className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n    },\n    dragGroupControlCondition: function(moveable, e) {\n        return this.dragControlCondition(moveable, e);\n    },\n    dragControlStart: function(moveable, e) {\n        var inputEvent = e.inputEvent, datas = e.datas;\n        var inputTarget = inputEvent.target;\n        var className = inputTarget.getAttribute(\"class\") || \"\";\n        var isControl = className.indexOf(\"border-radius\") > -1;\n        var isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n        var controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n        var lineIndex = -1;\n        if (isLine) {\n            var indexAttr = inputTarget.getAttribute(\"data-line-key\") || \"\";\n            if (indexAttr) {\n                lineIndex = parseInt(indexAttr.replace(/render-line-/g, \"\"), 10);\n                if (isNaN(lineIndex)) {\n                    lineIndex = -1;\n                }\n            }\n        }\n        if (!isControl && !isLine) {\n            return false;\n        }\n        var params = fillParams(moveable, e, {});\n        var result = triggerEvent(moveable, \"onRoundStart\", params);\n        if (result === false) {\n            return false;\n        }\n        datas.lineIndex = lineIndex;\n        datas.controlIndex = controlIndex;\n        datas.isControl = isControl;\n        datas.isLine = isLine;\n        setDragStart(moveable, e);\n        var _a = moveable.props, roundRelative = _a.roundRelative, _b = _a.minRoundControls, minRoundControls = _b === void 0 ? [\n            0,\n            0\n        ] : _b;\n        var state = moveable.state;\n        var width = state.width, height = state.height;\n        datas.isRound = true;\n        datas.prevDist = [\n            0,\n            0\n        ];\n        var borderRadius = getStyleBorderRadius(moveable);\n        var controlPoses = getBorderRadius(borderRadius || \"\", width, height, minRoundControls, true) || [];\n        datas.controlPoses = controlPoses;\n        state.borderRadiusState = getRadiusStyles(controlPoses, roundRelative, width, height).styles.join(\" \");\n        return params;\n    },\n    dragControl: function(moveable, e) {\n        var datas = e.datas;\n        var controlPoses = datas.controlPoses;\n        if (!datas.isRound || !datas.isControl || !controlPoses.length) {\n            return false;\n        }\n        var index = datas.controlIndex;\n        var _a = __read(getDragDist(e), 2), distX = _a[0], distY = _a[1];\n        var dist = [\n            distX,\n            distY\n        ];\n        var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, datas.prevDist);\n        var _b = moveable.props.maxRoundControls, maxRoundControls = _b === void 0 ? [\n            4,\n            4\n        ] : _b;\n        var _c = moveable.state, width = _c.width, height = _c.height;\n        var selectedControlPose = controlPoses[index];\n        var selectedVertical = selectedControlPose.vertical;\n        var selectedHorizontal = selectedControlPose.horizontal;\n        // 0: [0, 1, 2, 3] maxCount === 1\n        // 0: [0, 2] maxCount === 2\n        // 1: [1, 3] maxCount === 2\n        // 0: [0] maxCount === 3\n        // 1: [1, 3] maxCount === 3\n        var dists = controlPoses.map(function(pose) {\n            var horizontal = pose.horizontal, vertical = pose.vertical;\n            var poseDist = [\n                horizontal * selectedHorizontal * dist[0],\n                vertical * selectedVertical * dist[1]\n            ];\n            if (horizontal) {\n                if (maxRoundControls[0] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {\n                    return poseDist;\n                }\n            } else if (maxRoundControls[1] === 0) {\n                poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;\n                return poseDist;\n            } else if (selectedVertical) {\n                if (maxRoundControls[1] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {\n                    return poseDist;\n                }\n            }\n            return [\n                0,\n                0\n            ];\n        });\n        dists[index] = dist;\n        var nextPoses = controlPoses.map(function(info, i) {\n            return __assign(__assign({}, info), {\n                pos: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(info.pos, dists[i])\n            });\n        });\n        if (index < 4) {\n            nextPoses.slice(0, index + 1).forEach(function(info) {\n                info.virtual = false;\n            });\n        } else {\n            nextPoses.slice(4, index + 1).forEach(function(info) {\n                info.virtual = false;\n            });\n        }\n        datas.prevDist = [\n            distX,\n            distY\n        ];\n        return triggerRoundEvent(moveable, e, dist, delta, nextPoses);\n    },\n    dragControlEnd: function(moveable, e) {\n        var state = moveable.state;\n        state.borderRadiusState = \"\";\n        var datas = e.datas, isDouble = e.isDouble;\n        if (!datas.isRound) {\n            return false;\n        }\n        var isControl = datas.isControl, controlIndex = datas.controlIndex, isLine = datas.isLine, lineIndex = datas.lineIndex;\n        var controlPoses = datas.controlPoses;\n        var length = controlPoses.filter(function(_a) {\n            var virtual = _a.virtual;\n            return virtual;\n        }).length;\n        var _a = moveable.props.roundClickable, roundClickable = _a === void 0 ? true : _a;\n        if (isDouble && roundClickable) {\n            if (isControl && (roundClickable === true || roundClickable === \"control\")) {\n                removeBorderRadius(controlPoses, controlIndex);\n            } else if (isLine && (roundClickable === true || roundClickable === \"line\")) {\n                var _b = __read(calculatePointerDist(moveable, e), 2), distX = _b[0], distY = _b[1];\n                addBorderRadiusByLine(controlPoses, lineIndex, distX, distY);\n            }\n            if (length !== controlPoses.filter(function(_a) {\n                var virtual = _a.virtual;\n                return virtual;\n            }).length) {\n                triggerRoundEvent(moveable, e, [\n                    0,\n                    0\n                ], [\n                    0,\n                    0\n                ], controlPoses);\n            }\n        }\n        var params = fillEndParams(moveable, e, {});\n        triggerEvent(moveable, \"onRoundEnd\", params);\n        state.borderRadiusState = \"\";\n        return params;\n    },\n    dragGroupControlStart: function(moveable, e) {\n        var result = this.dragControlStart(moveable, e);\n        if (!result) {\n            return false;\n        }\n        var moveables = moveable.moveables;\n        var targets = moveable.props.targets;\n        var events = fillChildEvents(moveable, \"roundable\", e);\n        var nextParams = __assign({\n            targets: moveable.props.targets,\n            events: events.map(function(ev, i) {\n                return __assign(__assign({}, ev), {\n                    target: targets[i],\n                    moveable: moveables[i],\n                    currentTarget: moveables[i]\n                });\n            })\n        }, result);\n        triggerEvent(moveable, \"onRoundGroupStart\", nextParams);\n        return result;\n    },\n    dragGroupControl: function(moveable, e) {\n        var result = this.dragControl(moveable, e);\n        if (!result) {\n            return false;\n        }\n        var moveables = moveable.moveables;\n        var targets = moveable.props.targets;\n        var events = fillChildEvents(moveable, \"roundable\", e);\n        var nextParams = __assign({\n            targets: moveable.props.targets,\n            events: events.map(function(ev, i) {\n                return __assign(__assign(__assign({}, ev), {\n                    target: targets[i],\n                    moveable: moveables[i],\n                    currentTarget: moveables[i]\n                }), fillCSSObject({\n                    borderRadius: result.borderRadius\n                }, ev));\n            })\n        }, result);\n        triggerEvent(moveable, \"onRoundGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd: function(moveable, e) {\n        var moveables = moveable.moveables;\n        var targets = moveable.props.targets;\n        var events = fillChildEvents(moveable, \"roundable\", e);\n        catchEvent(moveable, \"onRound\", function(parentEvent) {\n            var nextParams = __assign({\n                targets: moveable.props.targets,\n                events: events.map(function(ev, i) {\n                    return __assign(__assign(__assign({}, ev), {\n                        target: targets[i],\n                        moveable: moveables[i],\n                        currentTarget: moveables[i]\n                    }), fillCSSObject({\n                        borderRadius: parentEvent.borderRadius\n                    }, ev));\n                })\n            }, parentEvent);\n            triggerEvent(moveable, \"onRoundGroup\", nextParams);\n        });\n        var result = this.dragControlEnd(moveable, e);\n        if (!result) {\n            return false;\n        }\n        var nextParams = __assign({\n            targets: moveable.props.targets,\n            events: events.map(function(ev, i) {\n                var _a;\n                return __assign(__assign({}, ev), {\n                    target: targets[i],\n                    moveable: moveables[i],\n                    currentTarget: moveables[i],\n                    lastEvent: (_a = ev.datas) === null || _a === void 0 ? void 0 : _a.lastEvent\n                });\n            })\n        }, result);\n        triggerEvent(moveable, \"onRoundGroupEnd\", nextParams);\n        return nextParams;\n    },\n    unset: function(moveable) {\n        moveable.state.borderRadiusState = \"\";\n    }\n};\n/**\r\n * Whether to show and drag or double click border-radius, (default: false)\r\n * @name Moveable.Roundable#roundable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n * });\r\n * moveable.on(\"roundStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"round\", e => {\r\n *     e.target.style.borderRadius = e.borderRadius;\r\n * }).on(\"roundEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * % Can be used instead of the absolute px\r\n * @name Moveable.Roundable#roundRelative\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n * });\r\n * moveable.on(\"roundStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"round\", e => {\r\n *     e.target.style.borderRadius = e.borderRadius;\r\n * }).on(\"roundEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])\r\n * @name Moveable.Roundable#minRoundControls\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n *     minRoundControls: [0, 0],\r\n * });\r\n * moveable.minRoundControls = [1, 0];\r\n */ /**\r\n * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])\r\n * @name Moveable.Roundable#maxRoundControls\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n *     maxRoundControls: [4, 4],\r\n * });\r\n * moveable.maxRoundControls = [1, 0];\r\n */ /**\r\n * Whether you can add/delete round controls by double-clicking a line or control.\r\n * @name Moveable.Roundable#roundClickable\r\n * @default true\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n *     roundClickable: true,\r\n * });\r\n * moveable.roundClickable = false;\r\n */ /**\r\n * Whether to show a round control that does not actually exist as a shadow\r\n * @name Moveable.Roundable#isDisplayShadowRoundControls\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     isDisplayShadowRoundControls: false,\r\n * });\r\n * moveable.isDisplayShadowRoundControls = true;\r\n */ /**\r\n * The padding value of the position of the round control\r\n * @name Moveable.Roundable#roundPadding\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundPadding: 0,\r\n * });\r\n * moveable.roundPadding = 15;\r\n */ /**\r\n * When drag start the clip area or controls, the `roundStart` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event roundStart\r\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n * });\r\n * moveable.on(\"roundStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"round\", e => {\r\n *     e.target.style.borderRadius = e.borderRadius;\r\n * }).on(\"roundEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * When drag or double click the border area or controls, the `round` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event round\r\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\r\n * @example\r\n  * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n * });\r\n * moveable.on(\"roundStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"round\", e => {\r\n *     e.target.style.borderRadius = e.borderRadius;\r\n * }).on(\"roundEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * When drag end the border area or controls, the `roundEnd` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event roundEnd\r\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\r\n * @example\r\n  * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n * });\r\n * moveable.on(\"roundStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"round\", e => {\r\n *     e.target.style.borderRadius = e.borderRadius;\r\n * }).on(\"roundEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * When drag start the clip area or controls, the `roundGroupStart` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event roundGroupStart\r\n * @param {Moveable.Roundable.OnRoundGroupStart} - Parameters for the `roundGroupStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     targets: [target1, target2, target3],\r\n *     roundable: true,\r\n * });\r\n * moveable.on(\"roundGroupStart\", e => {\r\n *     console.log(e.targets);\r\n * }).on(\"roundGroup\", e => {\r\n *   e.events.forEach(ev => {\r\n *       ev.target.style.cssText += ev.cssText;\r\n *   });\r\n * }).on(\"roundGroupEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * When drag or double click the border area or controls, the `roundGroup` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event roundGroup\r\n * @param {Moveable.Roundable.OnRoundGroup} - Parameters for the `roundGroup` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     targets: [target1, target2, target3],\r\n *     roundable: true,\r\n * });\r\n * moveable.on(\"roundGroupStart\", e => {\r\n *     console.log(e.targets);\r\n * }).on(\"roundGroup\", e => {\r\n *   e.events.forEach(ev => {\r\n *       ev.target.style.cssText += ev.cssText;\r\n *   });\r\n * }).on(\"roundGroupEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ /**\r\n * When drag end the border area or controls, the `roundGroupEnd` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event roundGroupEnd\r\n * @param {Moveable.Roundable.onRoundGroupEnd} - Parameters for the `roundGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     targets: [target1, target2, target3],\r\n *     roundable: true,\r\n * });\r\n * moveable.on(\"roundGroupStart\", e => {\r\n *     console.log(e.targets);\r\n * }).on(\"roundGroup\", e => {\r\n *     e.events.forEach(ev => {\r\n *         ev.target.style.cssText += ev.cssText;\r\n *     });\r\n * }).on(\"roundGroupEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */ function isIdentityMatrix(matrix, is3d) {\n    var n = is3d ? 4 : 3;\n    var identityMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\n    var value = \"matrix\".concat(is3d ? \"3d\" : \"\", \"(\").concat(identityMatrix.join(\",\"), \")\");\n    return matrix === value || matrix === \"matrix(1,0,0,1,0,0)\";\n}\nvar BeforeRenderable = {\n    isPinch: true,\n    name: \"beforeRenderable\",\n    props: [],\n    events: [\n        \"beforeRenderStart\",\n        \"beforeRender\",\n        \"beforeRenderEnd\",\n        \"beforeRenderGroupStart\",\n        \"beforeRenderGroup\",\n        \"beforeRenderGroupEnd\"\n    ],\n    dragRelation: \"weak\",\n    setTransform: function(moveable, e) {\n        var _a = moveable.state, is3d = _a.is3d, targetMatrix = _a.targetMatrix, inlineTransform = _a.inlineTransform;\n        var cssMatrix = is3d ? \"matrix3d(\".concat(targetMatrix.join(\",\"), \")\") : \"matrix(\".concat((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertMatrixtoCSS)(targetMatrix, true), \")\");\n        var startTransform = !inlineTransform || inlineTransform === \"none\" ? cssMatrix : inlineTransform;\n        e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(startTransform);\n    },\n    resetStyle: function(e) {\n        var datas = e.datas;\n        datas.nextStyle = {};\n        datas.nextTransforms = e.datas.startTransforms;\n        datas.nextTransformAppendedIndexes = [];\n    },\n    fillDragStartParams: function(moveable, e) {\n        return fillParams(moveable, e, {\n            setTransform: function(transform) {\n                e.datas.startTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(transform);\n            },\n            isPinch: !!e.isPinch\n        });\n    },\n    fillDragParams: function(moveable, e) {\n        return fillParams(moveable, e, {\n            isPinch: !!e.isPinch\n        });\n    },\n    dragStart: function(moveable, e) {\n        this.setTransform(moveable, e);\n        this.resetStyle(e);\n        triggerEvent(moveable, \"onBeforeRenderStart\", this.fillDragStartParams(moveable, e));\n    },\n    drag: function(moveable, e) {\n        if (!e.datas.startTransforms) {\n            this.setTransform(moveable, e);\n        }\n        this.resetStyle(e);\n        triggerEvent(moveable, \"onBeforeRender\", fillParams(moveable, e, {\n            isPinch: !!e.isPinch\n        }));\n    },\n    dragEnd: function(moveable, e) {\n        if (!e.datas.startTransforms) {\n            this.setTransform(moveable, e);\n            this.resetStyle(e);\n        }\n        triggerEvent(moveable, \"onBeforeRenderEnd\", fillParams(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag\n        }));\n    },\n    dragGroupStart: function(moveable, e) {\n        var _this = this;\n        this.dragStart(moveable, e);\n        var events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        var moveables = moveable.moveables;\n        var params = events.map(function(childEvent, i) {\n            var childMoveable = moveables[i];\n            _this.setTransform(childMoveable, childEvent);\n            _this.resetStyle(childEvent);\n            return _this.fillDragStartParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, \"onBeforeRenderGroupStart\", fillParams(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            setTransform: function() {},\n            events: params\n        }));\n    },\n    dragGroup: function(moveable, e) {\n        var _this = this;\n        this.drag(moveable, e);\n        var events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        var moveables = moveable.moveables;\n        var params = events.map(function(childEvent, i) {\n            var childMoveable = moveables[i];\n            _this.resetStyle(childEvent);\n            return _this.fillDragParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, \"onBeforeRenderGroup\", fillParams(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            events: params\n        }));\n    },\n    dragGroupEnd: function(moveable, e) {\n        this.dragEnd(moveable, e);\n        triggerEvent(moveable, \"onBeforeRenderGroupEnd\", fillParams(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets\n        }));\n    },\n    dragControlStart: function(moveable, e) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl: function(moveable, e) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd: function(moveable, e) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart: function(moveable, e) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl: function(moveable, e) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd: function(moveable, e) {\n        return this.dragGroupEnd(moveable, e);\n    }\n};\nvar Renderable = {\n    name: \"renderable\",\n    props: [],\n    events: [\n        \"renderStart\",\n        \"render\",\n        \"renderEnd\",\n        \"renderGroupStart\",\n        \"renderGroup\",\n        \"renderGroupEnd\"\n    ],\n    dragRelation: \"weak\",\n    dragStart: function(moveable, e) {\n        triggerEvent(moveable, \"onRenderStart\", fillParams(moveable, e, {\n            isPinch: !!e.isPinch\n        }));\n    },\n    drag: function(moveable, e) {\n        triggerEvent(moveable, \"onRender\", this.fillDragParams(moveable, e));\n    },\n    dragAfter: function(moveable, e) {\n        return this.drag(moveable, e);\n    },\n    dragEnd: function(moveable, e) {\n        triggerEvent(moveable, \"onRenderEnd\", this.fillDragEndParams(moveable, e));\n    },\n    dragGroupStart: function(moveable, e) {\n        triggerEvent(moveable, \"onRenderGroupStart\", fillParams(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets\n        }));\n    },\n    dragGroup: function(moveable, e) {\n        var _this = this;\n        var events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        var moveables = moveable.moveables;\n        var params = events.map(function(childEvent, i) {\n            var childMoveable = moveables[i];\n            return _this.fillDragParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, \"onRenderGroup\", fillParams(moveable, e, __assign(__assign({\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            transform: getNextTransformText(e),\n            transformObject: {}\n        }, fillCSSObject(getNextStyle(e))), {\n            events: params\n        })));\n    },\n    dragGroupEnd: function(moveable, e) {\n        var _this = this;\n        var events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        var moveables = moveable.moveables;\n        var params = events.map(function(childEvent, i) {\n            var childMoveable = moveables[i];\n            return _this.fillDragEndParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, \"onRenderGroupEnd\", fillParams(moveable, e, __assign({\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n            events: params,\n            transformObject: {},\n            transform: getNextTransformText(e)\n        }, fillCSSObject(getNextStyle(e)))));\n    },\n    dragControlStart: function(moveable, e) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl: function(moveable, e) {\n        return this.drag(moveable, e);\n    },\n    dragControlAfter: function(moveable, e) {\n        return this.dragAfter(moveable, e);\n    },\n    dragControlEnd: function(moveable, e) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart: function(moveable, e) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl: function(moveable, e) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd: function(moveable, e) {\n        return this.dragGroupEnd(moveable, e);\n    },\n    fillDragParams: function(moveable, e) {\n        var transformObject = {};\n        (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(getNextTransforms(e) || []).forEach(function(matrixInfo) {\n            transformObject[matrixInfo.name] = matrixInfo.functionValue;\n        });\n        return fillParams(moveable, e, __assign({\n            isPinch: !!e.isPinch,\n            transformObject: transformObject,\n            transform: getNextTransformText(e)\n        }, fillCSSObject(getNextStyle(e))));\n    },\n    fillDragEndParams: function(moveable, e) {\n        var transformObject = {};\n        (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(getNextTransforms(e) || []).forEach(function(matrixInfo) {\n            transformObject[matrixInfo.name] = matrixInfo.functionValue;\n        });\n        return fillParams(moveable, e, __assign({\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            transformObject: transformObject,\n            transform: getNextTransformText(e)\n        }, fillCSSObject(getNextStyle(e))));\n    }\n};\nfunction triggerAble(moveable, moveableAbles, eventOperations, eventAffix, eventType, e, requestInstant) {\n    // pre setting\n    e.clientDistX = e.distX;\n    e.clientDistY = e.distY;\n    var isStart = eventType === \"Start\";\n    var isEnd = eventType === \"End\";\n    var isAfter = eventType === \"After\";\n    var target = moveable.state.target;\n    var isRequest = e.isRequest;\n    var isControl = eventAffix.indexOf(\"Control\") > -1;\n    if (!target || isStart && isControl && !isRequest && moveable.areaElement === e.inputEvent.target) {\n        return false;\n    }\n    var ables = __spreadArray([], __read(moveableAbles), false);\n    if (isRequest) {\n        var requestAble_1 = e.requestAble;\n        if (!ables.some(function(able) {\n            return able.name === requestAble_1;\n        })) {\n            ables.push.apply(ables, __spreadArray([], __read(moveable.props.ables.filter(function(able) {\n                return able.name === requestAble_1;\n            })), false));\n        }\n    }\n    if (!ables.length || ables.every(function(able) {\n        return able.dragRelation;\n    })) {\n        return false;\n    }\n    // \"drag\" \"Control\" \"After\"\n    var inputEvent = e.inputEvent;\n    var inputTarget;\n    if (isEnd && inputEvent) {\n        inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;\n    }\n    var isDragStop = false;\n    var stop = function() {\n        var _a;\n        isDragStop = true;\n        (_a = e.stop) === null || _a === void 0 ? void 0 : _a.call(e);\n    };\n    var isFirstStart = isStart && (!moveable.targetGesto || !moveable.controlGesto || !moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag());\n    if (isFirstStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    // trigger ables\n    var datas = e.datas;\n    var gestoType = isControl ? \"controlGesto\" : \"targetGesto\";\n    var prevGesto = moveable[gestoType];\n    var trigger = function(able, eventName, conditionName) {\n        if (!(eventName in able) || prevGesto !== moveable[gestoType]) {\n            return false;\n        }\n        var ableName = able.name;\n        var nextDatas = datas[ableName] || (datas[ableName] = {});\n        if (isStart) {\n            nextDatas.isEventStart = !conditionName || !able[conditionName] || able[conditionName](moveable, e);\n        }\n        if (!nextDatas.isEventStart) {\n            return false;\n        }\n        var result = able[eventName](moveable, __assign(__assign({}, e), {\n            stop: stop,\n            datas: nextDatas,\n            originalDatas: datas,\n            inputTarget: inputTarget\n        }));\n        moveable._emitter.off();\n        if (isStart && result === false) {\n            nextDatas.isEventStart = false;\n        }\n        return result;\n    };\n    // unset ables for first drag start\n    if (isFirstStart) {\n        ables.forEach(function(able) {\n            able.unset && able.unset(moveable);\n        });\n    }\n    // BeforeRenderable\n    trigger(BeforeRenderable, \"drag\".concat(eventAffix).concat(eventType));\n    var forceEndedCount = 0;\n    var updatedCount = 0;\n    eventOperations.forEach(function(eventOperation) {\n        if (isDragStop) {\n            return false;\n        }\n        var eventName = \"\".concat(eventOperation).concat(eventAffix).concat(eventType);\n        var conditionName = \"\".concat(eventOperation).concat(eventAffix, \"Condition\");\n        if (eventType === \"\" && !isRequest) {\n            // Convert distX, distY\n            convertDragDist(moveable.state, e);\n        }\n        // const isGroup = eventAffix.indexOf(\"Group\") > -1;\n        var eventAbles = ables.filter(function(able) {\n            return able[eventName];\n        });\n        eventAbles = eventAbles.filter(function(able, i) {\n            return able.name && eventAbles.indexOf(able) === i;\n        });\n        var results = eventAbles.filter(function(able) {\n            return trigger(able, eventName, conditionName);\n        });\n        var isUpdate = results.length;\n        // end ables\n        if (isDragStop) {\n            ++forceEndedCount;\n        }\n        if (isUpdate) {\n            ++updatedCount;\n        }\n        if (!isDragStop && isStart && eventAbles.length && !isUpdate) {\n            forceEndedCount += eventAbles.filter(function(able) {\n                var ableName = able.name;\n                var nextDatas = datas[ableName];\n                if (nextDatas.isEventStart) {\n                    if (able.dragRelation === \"strong\") {\n                        return false;\n                    }\n                    // stop drag\n                    return true;\n                }\n                // pre stop drag\n                return false;\n            }).length ? 1 : 0;\n        }\n    });\n    if (!isAfter || updatedCount) {\n        trigger(Renderable, \"drag\".concat(eventAffix).concat(eventType));\n    }\n    // stop gesto condition\n    var isForceEnd = prevGesto !== moveable[gestoType] || forceEndedCount === eventOperations.length;\n    if (isEnd || isDragStop || isForceEnd) {\n        moveable.state.gestos = {};\n        if (moveable.moveables) {\n            moveable.moveables.forEach(function(childMoveable) {\n                childMoveable.state.gestos = {};\n            });\n        }\n        ables.forEach(function(able) {\n            able.unset && able.unset(moveable);\n        });\n    }\n    if (isStart && !isForceEnd && !isRequest && updatedCount && moveable.props.preventDefault) {\n        e === null || e === void 0 ? void 0 : e.preventDefault();\n    }\n    if (moveable.isUnmounted || isForceEnd) {\n        return false;\n    }\n    if (!isStart && updatedCount && !requestInstant || isEnd) {\n        var flushSync = moveable.props.flushSync || defaultSync;\n        flushSync(function() {\n            moveable.updateRect(isEnd ? eventType : \"\", true, false);\n            moveable.forceUpdate();\n        });\n    }\n    if (!isStart && !isEnd && !isAfter && updatedCount && !requestInstant) {\n        triggerAble(moveable, moveableAbles, eventOperations, eventAffix, eventType + \"After\", e);\n    }\n    return true;\n}\nfunction checkMoveableTarget(moveable, isControl) {\n    return function(e, target) {\n        var _a;\n        if (target === void 0) {\n            target = e.inputEvent.target;\n        }\n        var eventTarget = target;\n        var areaElement = moveable.areaElement;\n        var dragTargetElement = moveable._dragTarget;\n        if (!dragTargetElement || !isControl && ((_a = moveable.controlGesto) === null || _a === void 0 ? void 0 : _a.isFlag())) {\n            return false;\n        }\n        return eventTarget === dragTargetElement || dragTargetElement.contains(eventTarget) || eventTarget === areaElement || !moveable.isMoveableElement(eventTarget) && !moveable.controlBox.contains(eventTarget) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(eventTarget, \"moveable-area\") || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(eventTarget, \"moveable-padding\") || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(eventTarget, \"moveable-edgeDraggable\");\n    };\n}\nfunction getTargetAbleGesto(moveable, moveableTarget, eventAffix) {\n    var controlBox = moveable.controlBox;\n    var targets = [];\n    var props = moveable.props;\n    var dragArea = props.dragArea;\n    var target = moveable.state.target;\n    var dragTarget = props.dragTarget;\n    targets.push(controlBox);\n    if (!dragArea || dragTarget) {\n        targets.push(moveableTarget);\n    }\n    if (!dragArea && dragTarget && target && moveableTarget !== target && props.dragTargetSelf) {\n        targets.push(target);\n    }\n    var checkTarget = checkMoveableTarget(moveable);\n    return getAbleGesto(moveable, targets, \"targetAbles\", eventAffix, {\n        dragStart: checkTarget,\n        pinchStart: checkTarget\n    });\n}\nfunction getControlAbleGesto(moveable, eventAffix) {\n    var controlBox = moveable.controlBox;\n    var targets = [];\n    targets.push(controlBox);\n    var checkTarget = checkMoveableTarget(moveable, true);\n    var checkControlTarget = function(e, target) {\n        if (target === void 0) {\n            target = e.inputEvent.target;\n        }\n        if (target === controlBox) {\n            return true;\n        }\n        var result = checkTarget(e, target);\n        return !result;\n    };\n    return getAbleGesto(moveable, targets, \"controlAbles\", eventAffix, {\n        dragStart: checkControlTarget,\n        pinchStart: checkControlTarget\n    });\n}\nfunction getAbleGesto(moveable, target, ableType, eventAffix, conditionFunctions) {\n    if (conditionFunctions === void 0) {\n        conditionFunctions = {};\n    }\n    var isTargetAbles = ableType === \"targetAbles\";\n    var _a = moveable.props, pinchOutside = _a.pinchOutside, pinchThreshold = _a.pinchThreshold, preventClickEventOnDrag = _a.preventClickEventOnDrag, preventClickDefault = _a.preventClickDefault, checkInput = _a.checkInput, dragFocusedInput = _a.dragFocusedInput, _b = _a.preventDefault, preventDefault = _b === void 0 ? true : _b, _c = _a.preventRightClick, preventRightClick = _c === void 0 ? true : _c, _d = _a.preventWheelClick, preventWheelClick = _d === void 0 ? true : _d, dragContaienrOption = _a.dragContainer;\n    var dragContainer = getRefTarget(dragContaienrOption, true);\n    var options = {\n        preventDefault: preventDefault,\n        preventRightClick: preventRightClick,\n        preventWheelClick: preventWheelClick,\n        container: dragContainer || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)(moveable.getControlBoxElement()),\n        pinchThreshold: pinchThreshold,\n        pinchOutside: pinchOutside,\n        preventClickEventOnDrag: isTargetAbles ? preventClickEventOnDrag : false,\n        preventClickEventOnDragStart: isTargetAbles ? preventClickDefault : false,\n        preventClickEventByCondition: isTargetAbles ? null : function(e) {\n            return moveable.controlBox.contains(e.target);\n        },\n        checkInput: isTargetAbles ? checkInput : false,\n        dragFocusedInput: dragFocusedInput\n    };\n    var gesto = new gesto__WEBPACK_IMPORTED_MODULE_9__[\"default\"](target, options);\n    var isControl = eventAffix === \"Control\";\n    [\n        \"drag\",\n        \"pinch\"\n    ].forEach(function(eventOperation) {\n        [\n            \"Start\",\n            \"\",\n            \"End\"\n        ].forEach(function(eventType) {\n            gesto.on(\"\".concat(eventOperation).concat(eventType), function(e) {\n                var _a;\n                var eventName = e.eventType;\n                var isPinchScheduled = eventOperation === \"drag\" && e.isPinch;\n                if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n                    e.stop();\n                    return;\n                }\n                if (isPinchScheduled) {\n                    return;\n                }\n                var eventOperations = eventOperation === \"drag\" ? [\n                    eventOperation\n                ] : [\n                    \"drag\",\n                    eventOperation\n                ];\n                var moveableAbles = __spreadArray([], __read(moveable[ableType]), false);\n                var result = triggerAble(moveable, moveableAbles, eventOperations, eventAffix, eventType, e);\n                if (!result) {\n                    e.stop();\n                } else if (moveable.props.stopPropagation || eventType === \"Start\" && isControl) {\n                    (_a = e === null || e === void 0 ? void 0 : e.inputEvent) === null || _a === void 0 ? void 0 : _a.stopPropagation();\n                }\n            });\n        });\n    });\n    return gesto;\n}\nvar EventManager = /*#__PURE__*/ function() {\n    function EventManager(target, moveable, eventName) {\n        var _this = this;\n        this.target = target;\n        this.moveable = moveable;\n        this.eventName = eventName;\n        this.ables = [];\n        this._onEvent = function(e) {\n            var eventName = _this.eventName;\n            var moveable = _this.moveable;\n            if (moveable.state.disableNativeEvent) {\n                return;\n            }\n            _this.ables.forEach(function(able) {\n                able[eventName](moveable, {\n                    inputEvent: e\n                });\n            });\n        };\n        target.addEventListener(eventName.toLowerCase(), this._onEvent);\n    }\n    EventManager.prototype.setAbles = function(ables) {\n        this.ables = ables;\n    };\n    EventManager.prototype.destroy = function() {\n        this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent);\n        this.target = null;\n        this.moveable = null;\n    };\n    return EventManager;\n}();\nfunction calculateMatrixStack(target, container, rootContainer, isAbsolute3d) {\n    var _a;\n    if (rootContainer === void 0) {\n        rootContainer = container;\n    }\n    var _b = getMatrixStackInfo(target, container), matrixes = _b.matrixes, is3d = _b.is3d, prevTargetMatrix = _b.targetMatrix, transformOrigin = _b.transformOrigin, targetOrigin = _b.targetOrigin, offsetContainer = _b.offsetContainer, hasFixed = _b.hasFixed, containerZoom = _b.zoom; // prevMatrix\n    var _c = getCachedMatrixContainerInfo(offsetContainer, rootContainer), rootMatrixes = _c.matrixes, isRoot3d = _c.is3d, offsetRootContainer = _c.offsetContainer, rootZoom = _c.zoom; // prevRootMatrix\n    // if (rootContainer === document.body) {\n    //     console.log(offsetContainer, rootContainer, rootMatrixes);\n    // }\n    var isNext3d = isAbsolute3d || isRoot3d || is3d;\n    var n = isNext3d ? 4 : 3;\n    var isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n    var targetMatrix = prevTargetMatrix;\n    // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n    // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    var allMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\n    var rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\n    var beforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\n    var offsetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\n    var length = matrixes.length;\n    var nextRootMatrixes = rootMatrixes.map(function(info) {\n        return __assign(__assign({}, info), {\n            matrix: info.matrix ? __spreadArray([], __read(info.matrix), false) : undefined\n        });\n    }).reverse();\n    matrixes.reverse();\n    if (!is3d && isNext3d) {\n        targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 3, 4);\n        convert3DMatrixes(matrixes);\n    }\n    if (!isRoot3d && isNext3d) {\n        convert3DMatrixes(nextRootMatrixes);\n    }\n    // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n    // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container\n    // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n    // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n    nextRootMatrixes.forEach(function(info) {\n        rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(rootMatrix, info.matrix, n);\n    });\n    var originalRootContainer = rootContainer || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(target);\n    var endContainer = ((_a = nextRootMatrixes[0]) === null || _a === void 0 ? void 0 : _a.target) || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;\n    var rootMatrixBeforeOffset = nextRootMatrixes.slice(1).reduce(function(matrix, info) {\n        return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(matrix, info.matrix, n);\n    }, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n));\n    matrixes.forEach(function(info, i) {\n        if (length - 2 === i) {\n            // length - 3\n            beforeMatrix = allMatrix.slice();\n        }\n        if (length - 1 === i) {\n            // length - 2\n            offsetMatrix = allMatrix.slice();\n        }\n        // calculate for SVGElement\n        if (!info.matrix) {\n            var nextInfo = matrixes[i + 1];\n            var offset = getSVGOffset(info, nextInfo, endContainer, n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(rootMatrixBeforeOffset, allMatrix, n));\n            info.matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(offset, n);\n        }\n        allMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(allMatrix, info.matrix, n);\n    });\n    var isMatrix3d = !isSVGGraphicElement && is3d;\n    if (!targetMatrix) {\n        targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(isMatrix3d ? 4 : 3);\n    }\n    var targetTransform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16 ? (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);\n    var originalRootMatrix = rootMatrix;\n    rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.ignoreDimension)(rootMatrix, n, n);\n    return {\n        hasZoom: containerZoom !== 1 || rootZoom !== 1,\n        hasFixed: hasFixed,\n        matrixes: matrixes,\n        rootMatrix: rootMatrix,\n        originalRootMatrix: originalRootMatrix,\n        beforeMatrix: beforeMatrix,\n        offsetMatrix: offsetMatrix,\n        allMatrix: allMatrix,\n        targetMatrix: targetMatrix,\n        targetTransform: targetTransform,\n        inlineTransform: target.style.transform,\n        transformOrigin: transformOrigin,\n        targetOrigin: targetOrigin,\n        is3d: isNext3d,\n        offsetContainer: offsetContainer,\n        offsetRootContainer: offsetRootContainer\n    };\n}\nfunction calculateElementInfo(target, container, rootContainer, isAbsolute3d) {\n    if (rootContainer === void 0) {\n        rootContainer = container;\n    }\n    var width = 0;\n    var height = 0;\n    var rotation = 0;\n    var allResult = {};\n    var sizes = getSize(target);\n    if (target) {\n        width = sizes.offsetWidth;\n        height = sizes.offsetHeight;\n    }\n    if (target) {\n        var result = calculateMatrixStack(target, container, rootContainer, isAbsolute3d);\n        var position = calculateElementPosition(result.allMatrix, result.transformOrigin, width, height);\n        allResult = __assign(__assign({}, result), position);\n        var rotationPosition = calculateElementPosition(result.allMatrix, [\n            50,\n            50\n        ], 100, 100);\n        rotation = getRotationRad([\n            rotationPosition.pos1,\n            rotationPosition.pos2\n        ], rotationPosition.direction);\n    }\n    var n = isAbsolute3d ? 4 : 3;\n    return __assign(__assign(__assign({\n        hasZoom: false,\n        width: width,\n        height: height,\n        rotation: rotation\n    }, sizes), {\n        originalRootMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),\n        rootMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),\n        beforeMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),\n        offsetMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),\n        allMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),\n        targetMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),\n        targetTransform: \"\",\n        inlineTransform: \"\",\n        transformOrigin: [\n            0,\n            0\n        ],\n        targetOrigin: [\n            0,\n            0\n        ],\n        is3d: !!isAbsolute3d,\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        origin: [\n            0,\n            0\n        ],\n        pos1: [\n            0,\n            0\n        ],\n        pos2: [\n            0,\n            0\n        ],\n        pos3: [\n            0,\n            0\n        ],\n        pos4: [\n            0,\n            0\n        ],\n        direction: 1,\n        hasFixed: false,\n        offsetContainer: null,\n        offsetRootContainer: null,\n        matrixes: []\n    }), allResult);\n}\nfunction getElementInfo(target, container, rootContainer) {\n    if (rootContainer === void 0) {\n        rootContainer = container;\n    }\n    return calculateElementInfo(target, container, rootContainer, true);\n}\nfunction getMoveableTargetInfo(moveableElement, target, container, parentContainer, rootContainer, requestStyles) {\n    if (requestStyles === void 0) {\n        requestStyles = [];\n    }\n    var beforeDirection = 1;\n    var beforeOrigin = [\n        0,\n        0\n    ];\n    var targetClientRect = resetClientRect();\n    var moveableClientRect = resetClientRect();\n    var containerClientRect = resetClientRect();\n    var rootContainerClientRect = resetClientRect();\n    var offsetDelta = [\n        0,\n        0\n    ];\n    var style = {};\n    var result = calculateElementInfo(target, container, rootContainer, true);\n    if (target) {\n        var getStyle_1 = getCachedStyle(target);\n        requestStyles.forEach(function(name) {\n            style[name] = getStyle_1(name);\n        });\n        var n = result.is3d ? 4 : 3;\n        var beforePosition = calculateElementPosition(result.offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(result.transformOrigin, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.getOrigin)(result.targetMatrix, n)), result.width, result.height);\n        beforeDirection = beforePosition.direction;\n        beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(beforePosition.origin, [\n            beforePosition.left - result.left,\n            beforePosition.top - result.top\n        ]);\n        rootContainerClientRect = getClientRect(result.offsetRootContainer);\n        var offsetContainer = getOffsetInfo(parentContainer, parentContainer, true).offsetParent || result.offsetRootContainer;\n        if (result.hasZoom) {\n            var absoluteTargetPosition = calculateElementPosition((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(result.originalRootMatrix, result.allMatrix), result.transformOrigin, result.width, result.height);\n            var absoluteContainerPosition = calculateElementPosition(result.originalRootMatrix, getTransformOriginArray(getCachedStyle(offsetContainer)(\"transformOrigin\")).map(function(pos) {\n                return parseFloat(pos);\n            }), offsetContainer.offsetWidth, offsetContainer.offsetHeight);\n            targetClientRect = getClientRectByPosition(absoluteTargetPosition, rootContainerClientRect);\n            containerClientRect = getClientRectByPosition(absoluteContainerPosition, rootContainerClientRect, offsetContainer, true);\n            if (moveableElement) {\n                var left = absoluteTargetPosition.left;\n                var top_1 = absoluteTargetPosition.top;\n                moveableClientRect = getClientRectByPosition({\n                    left: left,\n                    top: top_1,\n                    bottom: top_1,\n                    right: top_1\n                }, rootContainerClientRect);\n            }\n        } else {\n            targetClientRect = getClientRect(target);\n            containerClientRect = getCachedClientRect(offsetContainer);\n            if (moveableElement) {\n                moveableClientRect = getClientRect(moveableElement);\n            }\n            var containerClientRectLeft = containerClientRect.left, containerClientRectTop = containerClientRect.top, containterClientLeft = containerClientRect.clientLeft, containerClientTop = containerClientRect.clientTop;\n            var clientDelta = [\n                targetClientRect.left - containerClientRectLeft,\n                targetClientRect.top - containerClientRectTop\n            ];\n            offsetDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculateInversePosition(result.rootMatrix, clientDelta, 4), [\n                containterClientLeft + result.left,\n                containerClientTop + result.top\n            ]);\n        }\n    }\n    return __assign({\n        targetClientRect: targetClientRect,\n        containerClientRect: containerClientRect,\n        moveableClientRect: moveableClientRect,\n        rootContainerClientRect: rootContainerClientRect,\n        beforeDirection: beforeDirection,\n        beforeOrigin: beforeOrigin,\n        originalBeforeOrigin: beforeOrigin,\n        target: target,\n        style: style,\n        offsetDelta: offsetDelta\n    }, result);\n}\nfunction getPersistState(rect) {\n    var pos1 = rect.pos1, pos2 = rect.pos2, pos3 = rect.pos3, pos4 = rect.pos4;\n    if (!pos1 || !pos2 || !pos3 || !pos4) {\n        return null;\n    }\n    var minPos = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getMinMaxs)([\n        pos1,\n        pos2,\n        pos3,\n        pos4\n    ]);\n    var posDelta = [\n        minPos.minX,\n        minPos.minY\n    ];\n    var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(rect.origin, posDelta);\n    pos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos1, posDelta);\n    pos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos2, posDelta);\n    pos3 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos3, posDelta);\n    pos4 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos4, posDelta);\n    return __assign(__assign({}, rect), {\n        left: rect.left,\n        top: rect.top,\n        posDelta: posDelta,\n        pos1: pos1,\n        pos2: pos2,\n        pos3: pos3,\n        pos4: pos4,\n        origin: origin,\n        beforeOrigin: origin,\n        // originalBeforeOrigin: origin,\n        isPersisted: true\n    });\n}\nvar MoveableManager = /*#__PURE__*/ function(_super) {\n    __extends(MoveableManager, _super);\n    function MoveableManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = __assign({\n            container: null,\n            gestos: {},\n            renderLines: [\n                [\n                    [\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0\n                    ]\n                ],\n                [\n                    [\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0\n                    ]\n                ],\n                [\n                    [\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0\n                    ]\n                ],\n                [\n                    [\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0\n                    ]\n                ]\n            ],\n            renderPoses: [\n                [\n                    0,\n                    0\n                ],\n                [\n                    0,\n                    0\n                ],\n                [\n                    0,\n                    0\n                ],\n                [\n                    0,\n                    0\n                ]\n            ],\n            disableNativeEvent: false,\n            posDelta: [\n                0,\n                0\n            ]\n        }, getMoveableTargetInfo(null));\n        _this.renderState = {};\n        _this.enabledAbles = [];\n        _this.targetAbles = [];\n        _this.controlAbles = [];\n        _this.rotation = 0;\n        _this.scale = [\n            1,\n            1\n        ];\n        _this.isMoveableMounted = false;\n        _this.isUnmounted = false;\n        _this.events = {\n            \"mouseEnter\": null,\n            \"mouseLeave\": null\n        };\n        _this._emitter = new _scena_event_emitter__WEBPACK_IMPORTED_MODULE_10__[\"default\"]();\n        _this._prevOriginalDragTarget = null;\n        _this._originalDragTarget = null;\n        _this._prevDragTarget = null;\n        _this._dragTarget = null;\n        _this._prevPropTarget = null;\n        _this._propTarget = null;\n        _this._prevDragArea = false;\n        _this._isPropTargetChanged = false;\n        _this._hasFirstTarget = false;\n        _this._reiszeObserver = null;\n        _this._observerId = 0;\n        _this._mutationObserver = null;\n        _this._rootContainer = null;\n        _this._viewContainer = null;\n        _this._viewClassNames = [];\n        _this._store = {};\n        _this.checkUpdateRect = function() {\n            if (_this.isDragging()) {\n                return;\n            }\n            var parentMoveable = _this.props.parentMoveable;\n            if (parentMoveable) {\n                parentMoveable.checkUpdateRect();\n                return;\n            }\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.cancelAnimationFrame)(_this._observerId);\n            _this._observerId = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.requestAnimationFrame)(function() {\n                if (_this.isDragging()) {\n                    return;\n                }\n                _this.updateRect();\n            });\n        };\n        _this._onPreventClick = function(e) {\n            e.stopPropagation();\n            e.preventDefault();\n        // removeEvent(window, \"click\", this._onPreventClick, true);\n        };\n        return _this;\n    }\n    MoveableManager.prototype.render = function() {\n        var props = this.props;\n        var state = this.getState();\n        var parentPosition = props.parentPosition, className = props.className, propsTarget = props.target, zoom = props.zoom, cspNonce = props.cspNonce, translateZ = props.translateZ, ControlBoxElement = props.cssStyled, groupable = props.groupable, linePadding = props.linePadding, controlPadding = props.controlPadding;\n        this._checkUpdateRootContainer();\n        this.checkUpdate();\n        this.updateRenderPoses();\n        var _a = __read(parentPosition || [\n            0,\n            0\n        ], 2), parentLeft = _a[0], parentTop = _a[1];\n        var left = state.left, top = state.top, stateTarget = state.target, direction = state.direction, hasFixed = state.hasFixed, offsetDelta = state.offsetDelta;\n        var groupTargets = props.targets;\n        var isDragging = this.isDragging();\n        var ableAttributes = {};\n        this.getEnabledAbles().forEach(function(able) {\n            ableAttributes[\"data-able-\".concat(able.name.toLowerCase())] = true;\n        });\n        var ableClassName = this._getAbleClassName();\n        var isDisplay = groupTargets && groupTargets.length && (stateTarget || groupable) || propsTarget || !this._hasFirstTarget && this.state.isPersisted;\n        var isVisible = this.controlBox || this.props.firstRenderState || this.props.persistData;\n        var translate = [\n            left - parentLeft,\n            top - parentTop\n        ];\n        if (!groupable && props.useAccuratePosition) {\n            translate[0] += offsetDelta[0];\n            translate[1] += offsetDelta[1];\n        }\n        var style = {\n            \"position\": hasFixed ? \"fixed\" : \"absolute\",\n            \"display\": isDisplay ? \"block\" : \"none\",\n            \"visibility\": isVisible ? \"visible\" : \"hidden\",\n            \"transform\": \"translate3d(\".concat(translate[0], \"px, \").concat(translate[1], \"px, \").concat(translateZ, \")\"),\n            \"--zoom\": zoom,\n            \"--zoompx\": \"\".concat(zoom, \"px\")\n        };\n        if (linePadding) {\n            style[\"--moveable-line-padding\"] = linePadding;\n        }\n        if (controlPadding) {\n            style[\"--moveable-control-padding\"] = controlPadding;\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlBoxElement, __assign({\n            cspNonce: cspNonce,\n            ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, \"controlBox\"),\n            className: \"\".concat(prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\"), \" \").concat(ableClassName, \" \").concat(className)\n        }, ableAttributes, {\n            onClick: this._onPreventClick,\n            style: style\n        }), this.renderAbles(), this._renderLines());\n    };\n    MoveableManager.prototype.componentDidMount = function() {\n        this.isMoveableMounted = true;\n        this.isUnmounted = false;\n        var props = this.props;\n        var parentMoveable = props.parentMoveable, container = props.container;\n        this._checkUpdateRootContainer();\n        this._checkUpdateViewContainer();\n        this._updateTargets();\n        this._updateNativeEvents();\n        this._updateEvents();\n        this.updateCheckInput();\n        this._updateObserver(this.props);\n        if (!container && !parentMoveable && !this.state.isPersisted) {\n            this.updateRect(\"\", false, false);\n            this.forceUpdate();\n        }\n    };\n    MoveableManager.prototype.componentDidUpdate = function(prevProps) {\n        this._checkUpdateRootContainer();\n        this._checkUpdateViewContainer();\n        this._updateNativeEvents();\n        this._updateTargets();\n        this._updateEvents();\n        this.updateCheckInput();\n        this._updateObserver(prevProps);\n    };\n    MoveableManager.prototype.componentWillUnmount = function() {\n        var _a, _b;\n        this.isMoveableMounted = false;\n        this.isUnmounted = true;\n        this._emitter.off();\n        (_a = this._reiszeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this._mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n        var viewContainer = this._viewContainer;\n        if (viewContainer) {\n            this._changeAbleViewClassNames([]);\n        }\n        unsetGesto(this, false);\n        unsetGesto(this, true);\n        var events = this.events;\n        for(var name_1 in events){\n            var manager = events[name_1];\n            manager && manager.destroy();\n        }\n    };\n    MoveableManager.prototype.getTargets = function() {\n        var target = this.props.target;\n        return target ? [\n            target\n        ] : [];\n    };\n    /**\r\n     * Get the able used in MoveableManager.\r\n     * @method Moveable#getAble\r\n     * @param - able name\r\n     */ MoveableManager.prototype.getAble = function(ableName) {\n        var ables = this.props.ables || [];\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(ables, function(able) {\n            return able.name === ableName;\n        });\n    };\n    MoveableManager.prototype.getContainer = function() {\n        var _a = this.props, parentMoveable = _a.parentMoveable, wrapperMoveable = _a.wrapperMoveable, container = _a.container;\n        return container || wrapperMoveable && wrapperMoveable.getContainer() || parentMoveable && parentMoveable.getContainer() || this.controlBox.parentElement;\n    };\n    /**\r\n     * Returns the element of the control box.\r\n     * @method Moveable#getControlBoxElement\r\n     */ MoveableManager.prototype.getControlBoxElement = function() {\n        return this.controlBox;\n    };\n    /**\r\n     * Target element to be dragged in moveable\r\n     * @method Moveable#getDragElement\r\n     */ MoveableManager.prototype.getDragElement = function() {\n        return this._dragTarget;\n    };\n    /**\r\n     * Check if the target is an element included in the moveable.\r\n     * @method Moveable#isMoveableElement\r\n     * @param - the target\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * window.addEventListener(\"click\", e => {\r\n     *     if (!moveable.isMoveableElement(e.target)) {\r\n     *         moveable.target = e.target;\r\n     *     }\r\n     * });\r\n     */ MoveableManager.prototype.isMoveableElement = function(target) {\n        var _a;\n        return target && (((_a = target.getAttribute) === null || _a === void 0 ? void 0 : _a.call(target, \"class\")) || \"\").indexOf(PREFIX) > -1;\n    };\n    /**\r\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\r\n     * @method Moveable#dragStart\r\n     * @param - external `MouseEvent`or `TouchEvent`\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * document.body.addEventListener(\"mousedown\", e => {\r\n     *     if (!moveable.isMoveableElement(e.target)) {\r\n     *          moveable.dragStart(e);\r\n     *     }\r\n     * });\r\n     */ MoveableManager.prototype.dragStart = function(e, target) {\n        if (target === void 0) {\n            target = e.target;\n        }\n        var targetGesto = this.targetGesto;\n        var controlGesto = this.controlGesto;\n        if (targetGesto && checkMoveableTarget(this)({\n            inputEvent: e\n        }, target)) {\n            if (!targetGesto.isFlag()) {\n                targetGesto.triggerDragStart(e);\n            }\n        } else if (controlGesto && this.isMoveableElement(target)) {\n            if (!controlGesto.isFlag()) {\n                controlGesto.triggerDragStart(e);\n            }\n        }\n        return this;\n    };\n    /**\r\n     * Hit test an element or rect on a moveable target.\r\n     * (100% = 100)\r\n     * @method Moveable#hitTest\r\n     * @param - element or rect to test\r\n     * @return - Get hit test rate (rate > 0 is hitted)\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * document.body.addEventListener(\"mousedown\", e => {\r\n     *     if (moveable.hitTest(e.target) > 0) {\r\n     *          console.log(\"hiited\");\r\n     *     }\r\n     * });\r\n     */ MoveableManager.prototype.hitTest = function(el) {\n        var _a = this.state, target = _a.target, pos1 = _a.pos1, pos2 = _a.pos2, pos3 = _a.pos3, pos4 = _a.pos4, targetClientRect = _a.targetClientRect;\n        if (!target) {\n            return 0;\n        }\n        var rect;\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNode)(el)) {\n            var clientRect = el.getBoundingClientRect();\n            rect = {\n                left: clientRect.left,\n                top: clientRect.top,\n                width: clientRect.width,\n                height: clientRect.height\n            };\n        } else {\n            rect = __assign({\n                width: 0,\n                height: 0\n            }, el);\n        }\n        var rectLeft = rect.left, rectTop = rect.top, rectWidth = rect.width, rectHeight = rect.height;\n        var points = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.fitPoints)([\n            pos1,\n            pos2,\n            pos4,\n            pos3\n        ], targetClientRect);\n        var size = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getOverlapSize)(points, [\n            [\n                rectLeft,\n                rectTop\n            ],\n            [\n                rectLeft + rectWidth,\n                rectTop\n            ],\n            [\n                rectLeft + rectWidth,\n                rectTop + rectHeight\n            ],\n            [\n                rectLeft,\n                rectTop + rectHeight\n            ]\n        ]);\n        var totalSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getAreaSize)(points);\n        if (!size || !totalSize) {\n            return 0;\n        }\n        return Math.min(100, size / totalSize * 100);\n    };\n    /**\r\n     * Whether the coordinates are inside Moveable\r\n     * @method Moveable#isInside\r\n     * @param - x coordinate\r\n     * @param - y coordinate\r\n     * @return - True if the coordinate is in moveable or false\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * document.body.addEventListener(\"mousedown\", e => {\r\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\r\n     *          console.log(\"inside\");\r\n     *     }\r\n     * });\r\n     */ MoveableManager.prototype.isInside = function(clientX, clientY) {\n        var _a = this.state, target = _a.target, pos1 = _a.pos1, pos2 = _a.pos2, pos3 = _a.pos3, pos4 = _a.pos4, targetClientRect = _a.targetClientRect;\n        if (!target) {\n            return false;\n        }\n        return (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.isInside)([\n            clientX,\n            clientY\n        ], (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.fitPoints)([\n            pos1,\n            pos2,\n            pos4,\n            pos3\n        ], targetClientRect));\n    };\n    /**\r\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\r\n     * @method Moveable#updateRect\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * window.addEventListener(\"resize\", e => {\r\n     *     moveable.updateRect();\r\n     * });\r\n     */ MoveableManager.prototype.updateRect = function(type, isTarget, isSetState) {\n        if (isSetState === void 0) {\n            isSetState = true;\n        }\n        var props = this.props;\n        var isSingle = !props.parentPosition && !props.wrapperMoveable;\n        if (isSingle) {\n            setStoreCache(true);\n        }\n        var parentMoveable = props.parentMoveable;\n        var state = this.state;\n        var target = state.target || props.target;\n        var container = this.getContainer();\n        var rootContainer = parentMoveable ? parentMoveable._rootContainer : this._rootContainer;\n        var nextState = getMoveableTargetInfo(this.controlBox, target, container, container, rootContainer || container, this._getRequestStyles());\n        if (!target && this._hasFirstTarget && props.persistData) {\n            var persistState = getPersistState(props.persistData);\n            for(var name_2 in persistState){\n                nextState[name_2] = persistState[name_2];\n            }\n        }\n        if (isSingle) {\n            setStoreCache();\n        }\n        this.updateState(nextState, parentMoveable ? false : isSetState);\n    };\n    /**\r\n     * Check if the moveable state is being dragged.\r\n     * @method Moveable#isDragging\r\n     * @param - If you want to check if able is dragging, specify ableName.\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * // false\r\n     * console.log(moveable.isDragging());\r\n     *\r\n     * moveable.on(\"drag\", () => {\r\n     *   // true\r\n     *   console.log(moveable.isDragging());\r\n     * });\r\n     */ MoveableManager.prototype.isDragging = function(ableName) {\n        var _a, _b;\n        var targetGesto = this.targetGesto;\n        var controlGesto = this.controlGesto;\n        if (targetGesto === null || targetGesto === void 0 ? void 0 : targetGesto.isFlag()) {\n            if (!ableName) {\n                return true;\n            }\n            var data = targetGesto.getEventData();\n            return !!((_a = data[ableName]) === null || _a === void 0 ? void 0 : _a.isEventStart);\n        }\n        if (controlGesto === null || controlGesto === void 0 ? void 0 : controlGesto.isFlag()) {\n            if (!ableName) {\n                return true;\n            }\n            var data = controlGesto.getEventData();\n            return !!((_b = data[ableName]) === null || _b === void 0 ? void 0 : _b.isEventStart);\n        }\n        return false;\n    };\n    /**\r\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\r\n     * Use `.updateRect()` method\r\n     * @method Moveable#updateTarget\r\n     * @deprecated\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * moveable.updateTarget();\r\n     */ MoveableManager.prototype.updateTarget = function(type) {\n        this.updateRect(type, true);\n    };\n    /**\r\n     * You can get the vertex information, position and offset size information of the target based on the container.\r\n     * @method Moveable#getRect\r\n     * @return - The Rect Info\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * const rectInfo = moveable.getRect();\r\n     */ MoveableManager.prototype.getRect = function() {\n        var state = this.state;\n        var poses = getAbsolutePosesByState(this.state);\n        var _a = __read(poses, 4), pos1 = _a[0], pos2 = _a[1], pos3 = _a[2], pos4 = _a[3];\n        var rect = getRect(poses);\n        var offsetWidth = state.width, offsetHeight = state.height;\n        var width = rect.width, height = rect.height, left = rect.left, top = rect.top;\n        var statePos = [\n            state.left,\n            state.top\n        ];\n        var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(statePos, state.origin);\n        var beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(statePos, state.beforeOrigin);\n        var transformOrigin = state.transformOrigin;\n        return {\n            width: width,\n            height: height,\n            left: left,\n            top: top,\n            pos1: pos1,\n            pos2: pos2,\n            pos3: pos3,\n            pos4: pos4,\n            offsetWidth: offsetWidth,\n            offsetHeight: offsetHeight,\n            beforeOrigin: beforeOrigin,\n            origin: origin,\n            transformOrigin: transformOrigin,\n            rotation: this.getRotation()\n        };\n    };\n    /**\r\n     * Get a manager that manages the moveable's state and props.\r\n     * @method Moveable#getManager\r\n     * @return - The Rect Info\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * const manager = moveable.getManager(); // real moveable class instance\r\n     */ MoveableManager.prototype.getManager = function() {\n        return this;\n    };\n    /**\r\n     * You can stop the dragging currently in progress through a method from outside.\r\n     * @method Moveable#stopDrag\r\n     * @return - The Rect Info\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * moveable.stopDrag();\r\n     */ MoveableManager.prototype.stopDrag = function(type) {\n        if (!type || type === \"target\") {\n            var gesto = this.targetGesto;\n            if ((gesto === null || gesto === void 0 ? void 0 : gesto.isIdle()) === false) {\n                unsetAbles(this, false);\n            }\n            gesto === null || gesto === void 0 ? void 0 : gesto.stop();\n        }\n        if (!type || type === \"control\") {\n            var gesto = this.controlGesto;\n            if ((gesto === null || gesto === void 0 ? void 0 : gesto.isIdle()) === false) {\n                unsetAbles(this, true);\n            }\n            gesto === null || gesto === void 0 ? void 0 : gesto.stop();\n        }\n    };\n    MoveableManager.prototype.getRotation = function() {\n        var _a = this.state, pos1 = _a.pos1, pos2 = _a.pos2, direction = _a.direction;\n        return getAbsoluteRotation(pos1, pos2, direction);\n    };\n    /**\r\n     * Request able through a method rather than an event.\r\n     * At the moment of execution, requestStart is executed,\r\n     * and then request and requestEnd can be executed through Requester.\r\n     * @method Moveable#request\r\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\r\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\r\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\r\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\r\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\r\n     * @param - ableName\r\n     * @param - request to be able params.\r\n     * @param - If isInstant is true, request and requestEnd are executed immediately.\r\n     * @return - Able Requester. If there is no request in able, nothing will work.\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * // Instantly Request (requestStart - request - requestEnd)\r\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\r\n     *\r\n     * // Start move\r\n     * const requester = moveable.request(\"draggable\");\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * requester.requestEnd();\r\n     */ MoveableManager.prototype.request = function(ableName, param, isInstant) {\n        if (param === void 0) {\n            param = {};\n        }\n        var self = this;\n        var props = self.props;\n        var manager = props.parentMoveable || props.wrapperMoveable || self;\n        var allAbles = manager.props.ables;\n        var groupable = props.groupable;\n        var requsetAble = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(allAbles, function(able) {\n            return able.name === ableName;\n        });\n        if (this.isDragging() || !requsetAble || !requsetAble.request) {\n            return {\n                request: function() {\n                    return this;\n                },\n                requestEnd: function() {\n                    return this;\n                }\n            };\n        }\n        var ableRequester = requsetAble.request(self);\n        var requestInstant = isInstant || param.isInstant;\n        var ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n        var eventAffix = \"\".concat(groupable ? \"Group\" : \"\").concat(ableRequester.isControl ? \"Control\" : \"\");\n        var moveableAbles = __spreadArray([], __read(manager[ableType]), false);\n        var requester = {\n            request: function(ableParam) {\n                triggerAble(self, moveableAbles, [\n                    \"drag\"\n                ], eventAffix, \"\", __assign(__assign({}, ableRequester.request(ableParam)), {\n                    requestAble: ableName,\n                    isRequest: true\n                }), requestInstant);\n                return requester;\n            },\n            requestEnd: function() {\n                triggerAble(self, moveableAbles, [\n                    \"drag\"\n                ], eventAffix, \"End\", __assign(__assign({}, ableRequester.requestEnd()), {\n                    requestAble: ableName,\n                    isRequest: true\n                }), requestInstant);\n                return requester;\n            }\n        };\n        triggerAble(self, moveableAbles, [\n            \"drag\"\n        ], eventAffix, \"Start\", __assign(__assign({}, ableRequester.requestStart(param)), {\n            requestAble: ableName,\n            isRequest: true\n        }), requestInstant);\n        return requestInstant ? requester.request(param).requestEnd() : requester;\n    };\n    /**\r\n     * moveable is the top level that manages targets\r\n     * `Single`: MoveableManager instance\r\n     * `Group`: MoveableGroup instance\r\n     * `IndividualGroup`: MoveableIndividaulGroup instance\r\n     * Returns leaf target MoveableManagers.\r\n     */ MoveableManager.prototype.getMoveables = function() {\n        return [\n            this\n        ];\n    };\n    /**\r\n     * Remove the Moveable object and the events.\r\n     * @method Moveable#destroy\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * moveable.destroy();\r\n     */ MoveableManager.prototype.destroy = function() {\n        this.componentWillUnmount();\n    };\n    MoveableManager.prototype.updateRenderPoses = function() {\n        var state = this.getState();\n        var props = this.props;\n        var padding = props.padding;\n        var originalBeforeOrigin = state.originalBeforeOrigin, transformOrigin = state.transformOrigin, allMatrix = state.allMatrix, is3d = state.is3d, pos1 = state.pos1, pos2 = state.pos2, pos3 = state.pos3, pos4 = state.pos4, stateLeft = state.left, stateTop = state.top, isPersisted = state.isPersisted;\n        var zoom = props.zoom || 1;\n        if (!padding && zoom <= 1) {\n            state.renderPoses = [\n                pos1,\n                pos2,\n                pos3,\n                pos4\n            ];\n            state.renderLines = [\n                [\n                    pos1,\n                    pos2\n                ],\n                [\n                    pos2,\n                    pos4\n                ],\n                [\n                    pos4,\n                    pos3\n                ],\n                [\n                    pos3,\n                    pos1\n                ]\n            ];\n            return;\n        }\n        var _a = getPaddingBox(padding || {}), left = _a.left, top = _a.top, bottom = _a.bottom, right = _a.right;\n        var n = is3d ? 4 : 3;\n        // const clipPathInfo = getClipPath(\n        //     props.target,\n        //     offsetWidth,\n        //     offsetHeight,\n        // );\n        // if (clipPathInfo) {\n        //     left -= Math.max(0, clipPathInfo.left);\n        //     top -= Math.max(0, clipPathInfo.top);\n        //     bottom -= Math.max(0, offsetHeight - clipPathInfo.bottom);\n        //     right -= Math.max(0, offsetWidth - clipPathInfo.right);\n        // }\n        var absoluteOrigin = [];\n        if (isPersisted) {\n            absoluteOrigin = transformOrigin;\n        } else if (this.controlBox && props.groupable) {\n            absoluteOrigin = originalBeforeOrigin;\n        } else {\n            absoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(originalBeforeOrigin, [\n                stateLeft,\n                stateTop\n            ]);\n        }\n        var nextMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(absoluteOrigin.map(function(v) {\n            return -v;\n        }), n), allMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(transformOrigin, n));\n        var renderPos1 = calculatePadding(nextMatrix, pos1, [\n            -left,\n            -top\n        ], n);\n        var renderPos2 = calculatePadding(nextMatrix, pos2, [\n            right,\n            -top\n        ], n);\n        var renderPos3 = calculatePadding(nextMatrix, pos3, [\n            -left,\n            bottom\n        ], n);\n        var renderPos4 = calculatePadding(nextMatrix, pos4, [\n            right,\n            bottom\n        ], n);\n        state.renderPoses = [\n            renderPos1,\n            renderPos2,\n            renderPos3,\n            renderPos4\n        ];\n        state.renderLines = [\n            [\n                renderPos1,\n                renderPos2\n            ],\n            [\n                renderPos2,\n                renderPos4\n            ],\n            [\n                renderPos4,\n                renderPos3\n            ],\n            [\n                renderPos3,\n                renderPos1\n            ]\n        ];\n        if (zoom) {\n            var zoomOffset = zoom / 2;\n            state.renderLines = [\n                [\n                    calculatePadding(nextMatrix, pos1, [\n                        -left - zoomOffset,\n                        -top\n                    ], n),\n                    calculatePadding(nextMatrix, pos2, [\n                        right + zoomOffset,\n                        -top\n                    ], n)\n                ],\n                [\n                    calculatePadding(nextMatrix, pos2, [\n                        right,\n                        -top - zoomOffset\n                    ], n),\n                    calculatePadding(nextMatrix, pos4, [\n                        right,\n                        bottom + zoomOffset\n                    ], n)\n                ],\n                [\n                    calculatePadding(nextMatrix, pos4, [\n                        right + zoomOffset,\n                        bottom\n                    ], n),\n                    calculatePadding(nextMatrix, pos3, [\n                        -left - zoomOffset,\n                        bottom\n                    ], n)\n                ],\n                [\n                    calculatePadding(nextMatrix, pos3, [\n                        -left,\n                        bottom + zoomOffset\n                    ], n),\n                    calculatePadding(nextMatrix, pos1, [\n                        -left,\n                        -top - zoomOffset\n                    ], n)\n                ]\n            ];\n        }\n    };\n    MoveableManager.prototype.checkUpdate = function() {\n        this._isPropTargetChanged = false;\n        var _a = this.props, target = _a.target, container = _a.container, parentMoveable = _a.parentMoveable;\n        var _b = this.state, stateTarget = _b.target, stateContainer = _b.container;\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n        var isTargetChanged = !equals(stateTarget, target);\n        var isChanged = isTargetChanged || !equals(stateContainer, container);\n        if (!isChanged) {\n            return;\n        }\n        var moveableContainer = container || this.controlBox;\n        if (moveableContainer) {\n            this.unsetAbles();\n        }\n        this.updateState({\n            target: target,\n            container: container\n        });\n        if (!parentMoveable && moveableContainer) {\n            this.updateRect(\"End\", false, false);\n        }\n        this._isPropTargetChanged = isTargetChanged;\n    };\n    MoveableManager.prototype.waitToChangeTarget = function() {\n        return new Promise(function() {});\n    };\n    MoveableManager.prototype.triggerEvent = function(name, e) {\n        var props = this.props;\n        this._emitter.trigger(name, e);\n        if (props.parentMoveable && e.isRequest && !e.isRequestChild) {\n            return props.parentMoveable.triggerEvent(name, e, true);\n        }\n        var callback = props[name];\n        return callback && callback(e);\n    };\n    MoveableManager.prototype.useCSS = function(tag, css) {\n        var customStyleMap = this.props.customStyledMap;\n        var key = tag + css;\n        if (!customStyleMap[key]) {\n            customStyleMap[key] = (0,react_css_styled__WEBPACK_IMPORTED_MODULE_11__.styled)(tag, css);\n        }\n        return customStyleMap[key];\n    };\n    MoveableManager.prototype.getState = function() {\n        var _a;\n        var props = this.props;\n        if (props.target || ((_a = props.targets) === null || _a === void 0 ? void 0 : _a.length)) {\n            this._hasFirstTarget = true;\n        }\n        var hasControlBox = this.controlBox;\n        var persistData = props.persistData;\n        var firstRenderState = props.firstRenderState;\n        if (firstRenderState && !hasControlBox) {\n            return firstRenderState;\n        }\n        if (!this._hasFirstTarget && persistData) {\n            var persistState = getPersistState(persistData);\n            if (persistState) {\n                this.updateState(persistState, false);\n                return this.state;\n            }\n        }\n        this.state.isPersisted = false;\n        return this.state;\n    };\n    MoveableManager.prototype.updateSelectors = function() {};\n    MoveableManager.prototype.unsetAbles = function() {\n        var _this = this;\n        this.targetAbles.forEach(function(able) {\n            if (able.unset) {\n                able.unset(_this);\n            }\n        });\n    };\n    MoveableManager.prototype.updateAbles = function(ables, eventAffix) {\n        if (ables === void 0) {\n            ables = this.props.ables;\n        }\n        if (eventAffix === void 0) {\n            eventAffix = \"\";\n        }\n        var props = this.props;\n        var triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        var enabledAbles = this.getEnabledAbles(ables);\n        var dragStart = \"drag\".concat(eventAffix, \"Start\");\n        var pinchStart = \"pinch\".concat(eventAffix, \"Start\");\n        var dragControlStart = \"drag\".concat(eventAffix, \"ControlStart\");\n        var targetAbles = filterAbles(enabledAbles, [\n            dragStart,\n            pinchStart\n        ], triggerAblesSimultaneously);\n        var controlAbles = filterAbles(enabledAbles, [\n            dragControlStart\n        ], triggerAblesSimultaneously);\n        this.enabledAbles = enabledAbles;\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    };\n    MoveableManager.prototype.updateState = function(nextState, isSetState) {\n        if (isSetState) {\n            if (this.isUnmounted) {\n                return;\n            }\n            this.setState(nextState);\n        } else {\n            var state = this.state;\n            for(var name_3 in nextState){\n                state[name_3] = nextState[name_3];\n            }\n        }\n    };\n    MoveableManager.prototype.getEnabledAbles = function(ables) {\n        if (ables === void 0) {\n            ables = this.props.ables;\n        }\n        var props = this.props;\n        return ables.filter(function(able) {\n            return able && (able.always && props[able.name] !== false || props[able.name]);\n        });\n    };\n    MoveableManager.prototype.renderAbles = function() {\n        var _this = this;\n        var props = this.props;\n        var triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        var Renderer = {\n            createElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement\n        };\n        this.renderState = {};\n        return groupByMap(flat(filterAbles(this.getEnabledAbles(), [\n            \"render\"\n        ], triggerAblesSimultaneously).map(function(_a) {\n            var render = _a.render;\n            return render(_this, Renderer) || [];\n        })).filter(function(el) {\n            return el;\n        }), function(_a) {\n            var key = _a.key;\n            return key;\n        }).map(function(group) {\n            return group[0];\n        });\n    };\n    MoveableManager.prototype.updateCheckInput = function() {\n        this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n    };\n    MoveableManager.prototype._getRequestStyles = function() {\n        var styleNames = this.getEnabledAbles().reduce(function(names, able) {\n            var _a, _b;\n            var ableStyleNames = (_b = (_a = able.requestStyle) === null || _a === void 0 ? void 0 : _a.call(able)) !== null && _b !== void 0 ? _b : [];\n            return __spreadArray(__spreadArray([], __read(names), false), __read(ableStyleNames), false);\n        }, __spreadArray([], __read(this.props.requestStyles || []), false));\n        return styleNames;\n    };\n    MoveableManager.prototype._updateObserver = function(prevProps) {\n        this._updateResizeObserver(prevProps);\n        this._updateMutationObserver(prevProps);\n    };\n    MoveableManager.prototype._updateEvents = function() {\n        var hasTargetAble = this.targetAbles.length;\n        var hasControlAble = this.controlAbles.length;\n        var target = this._dragTarget;\n        var isUnset = !hasTargetAble && this.targetGesto || this._isTargetChanged(true);\n        if (isUnset) {\n            unsetGesto(this, false);\n            this.updateState({\n                gestos: {}\n            });\n        }\n        if (!hasControlAble) {\n            unsetGesto(this, true);\n        }\n        if (target && hasTargetAble && !this.targetGesto) {\n            this.targetGesto = getTargetAbleGesto(this, target, \"\");\n        }\n        if (!this.controlGesto && hasControlAble) {\n            this.controlGesto = getControlAbleGesto(this, \"Control\");\n        }\n    };\n    MoveableManager.prototype._updateTargets = function() {\n        var props = this.props;\n        this._prevPropTarget = this._propTarget;\n        this._prevDragTarget = this._dragTarget;\n        this._prevOriginalDragTarget = this._originalDragTarget;\n        this._prevDragArea = props.dragArea;\n        this._propTarget = props.target;\n        this._originalDragTarget = props.dragTarget || props.target;\n        this._dragTarget = getRefTarget(this._originalDragTarget, true);\n    };\n    MoveableManager.prototype._renderLines = function() {\n        var props = this.props;\n        var _a = props, zoom = _a.zoom, hideDefaultLines = _a.hideDefaultLines, hideChildMoveableDefaultLines = _a.hideChildMoveableDefaultLines, parentMoveable = _a.parentMoveable;\n        if (hideDefaultLines || parentMoveable && hideChildMoveableDefaultLines) {\n            return [];\n        }\n        var state = this.getState();\n        var Renderer = {\n            createElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement\n        };\n        return state.renderLines.map(function(line, i) {\n            return renderLine(Renderer, \"\", line[0], line[1], zoom, \"render-line-\".concat(i));\n        });\n    };\n    MoveableManager.prototype._isTargetChanged = function(useDragArea) {\n        var props = this.props;\n        var nextTarget = props.dragTarget || props.target;\n        var prevTarget = this._prevOriginalDragTarget;\n        var prevDragArea = this._prevDragArea;\n        var dragArea = props.dragArea;\n        // check target without dragArea\n        var isDragTargetChanged = !dragArea && prevTarget !== nextTarget;\n        var isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;\n        return isDragTargetChanged || isDragAreaChanged || this._prevPropTarget != this._propTarget;\n    };\n    MoveableManager.prototype._updateNativeEvents = function() {\n        var _this = this;\n        var props = this.props;\n        var target = props.dragArea ? this.areaElement : this.state.target;\n        var events = this.events;\n        var eventKeys = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(events);\n        if (this._isTargetChanged()) {\n            for(var eventName in events){\n                var manager = events[eventName];\n                manager && manager.destroy();\n                events[eventName] = null;\n            }\n        }\n        if (!target) {\n            return;\n        }\n        var enabledAbles = this.enabledAbles;\n        eventKeys.forEach(function(eventName) {\n            var ables = filterAbles(enabledAbles, [\n                eventName\n            ]);\n            var hasAbles = ables.length > 0;\n            var manager = events[eventName];\n            if (!hasAbles) {\n                if (manager) {\n                    manager.destroy();\n                    events[eventName] = null;\n                }\n                return;\n            }\n            if (!manager) {\n                manager = new EventManager(target, _this, eventName);\n                events[eventName] = manager;\n            }\n            manager.setAbles(ables);\n        });\n    };\n    MoveableManager.prototype._checkUpdateRootContainer = function() {\n        var rootContainer = this.props.rootContainer;\n        if (!this._rootContainer && rootContainer) {\n            this._rootContainer = getRefTarget(rootContainer, true);\n        }\n    };\n    MoveableManager.prototype._checkUpdateViewContainer = function() {\n        var viewContainerOption = this.props.viewContainer;\n        if (!this._viewContainer && viewContainerOption) {\n            this._viewContainer = getRefTarget(viewContainerOption, true);\n        }\n        var viewContainer = this._viewContainer;\n        if (viewContainer) {\n            this._changeAbleViewClassNames(__spreadArray(__spreadArray([], __read(this._getAbleViewClassNames()), false), [\n                this.isDragging() ? VIEW_DRAGGING : \"\"\n            ], false));\n        }\n    };\n    MoveableManager.prototype._changeAbleViewClassNames = function(classNames) {\n        var viewContainer = this._viewContainer;\n        var nextClassNames = groupBy(classNames.filter(Boolean), function(el) {\n            return el;\n        }).map(function(_a) {\n            var _b = __read(_a, 1), className = _b[0];\n            return className;\n        });\n        var prevClassNames = this._viewClassNames;\n        var _a = (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_12__.diff)(prevClassNames, nextClassNames), removed = _a.removed, added = _a.added;\n        removed.forEach(function(index) {\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.removeClass)(viewContainer, prevClassNames[index]);\n        });\n        added.forEach(function(index) {\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.addClass)(viewContainer, nextClassNames[index]);\n        });\n        this._viewClassNames = nextClassNames;\n    };\n    MoveableManager.prototype._getAbleViewClassNames = function() {\n        var _this = this;\n        return (this.getEnabledAbles().map(function(able) {\n            var _a;\n            return ((_a = able.viewClassName) === null || _a === void 0 ? void 0 : _a.call(able, _this)) || \"\";\n        }).join(\" \") + \" \".concat(this._getAbleClassName(\"-view\"))).split(/\\s+/g);\n    };\n    MoveableManager.prototype._getAbleClassName = function(classPrefix) {\n        var _this = this;\n        if (classPrefix === void 0) {\n            classPrefix = \"\";\n        }\n        var ables = this.getEnabledAbles();\n        var targetGesto = this.targetGesto;\n        var controlGesto = this.controlGesto;\n        var targetGestoData = (targetGesto === null || targetGesto === void 0 ? void 0 : targetGesto.isFlag()) ? targetGesto.getEventData() : {};\n        var controlGestoData = (controlGesto === null || controlGesto === void 0 ? void 0 : controlGesto.isFlag()) ? controlGesto.getEventData() : {};\n        return ables.map(function(able) {\n            var _a, _b, _c;\n            var name = able.name;\n            var className = ((_a = able.className) === null || _a === void 0 ? void 0 : _a.call(able, _this)) || \"\";\n            if (((_b = targetGestoData[name]) === null || _b === void 0 ? void 0 : _b.isEventStart) || ((_c = controlGestoData[name]) === null || _c === void 0 ? void 0 : _c.isEventStart)) {\n                className += \" \".concat(prefix(\"\".concat(name).concat(classPrefix, \"-dragging\")));\n            }\n            return className.trim();\n        }).filter(Boolean).join(\" \");\n    };\n    MoveableManager.prototype._updateResizeObserver = function(prevProps) {\n        var _a;\n        var props = this.props;\n        var target = props.target;\n        var win = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)(this.getControlBoxElement());\n        if (!win.ResizeObserver || !target || !props.useResizeObserver) {\n            (_a = this._reiszeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n            return;\n        }\n        if (prevProps.target === target && this._reiszeObserver) {\n            return;\n        }\n        var observer = new win.ResizeObserver(this.checkUpdateRect);\n        observer.observe(target, {\n            box: \"border-box\"\n        });\n        this._reiszeObserver = observer;\n    };\n    MoveableManager.prototype._updateMutationObserver = function(prevProps) {\n        var _this = this;\n        var _a;\n        var props = this.props;\n        var target = props.target;\n        var win = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)(this.getControlBoxElement());\n        if (!win.MutationObserver || !target || !props.useMutationObserver) {\n            (_a = this._mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n            return;\n        }\n        if (prevProps.target === target && this._mutationObserver) {\n            return;\n        }\n        var observer = new win.MutationObserver(function(records) {\n            var e_1, _a;\n            try {\n                for(var records_1 = __values(records), records_1_1 = records_1.next(); !records_1_1.done; records_1_1 = records_1.next()){\n                    var mutation = records_1_1.value;\n                    if (mutation.type === \"attributes\" && mutation.attributeName === \"style\") {\n                        _this.checkUpdateRect();\n                    }\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (records_1_1 && !records_1_1.done && (_a = records_1.return)) _a.call(records_1);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        });\n        observer.observe(target, {\n            attributes: true\n        });\n        this._mutationObserver = observer;\n    };\n    MoveableManager.defaultProps = {\n        dragTargetSelf: false,\n        target: null,\n        dragTarget: null,\n        container: null,\n        rootContainer: null,\n        origin: true,\n        parentMoveable: null,\n        wrapperMoveable: null,\n        isWrapperMounted: false,\n        parentPosition: null,\n        warpSelf: false,\n        svgOrigin: \"\",\n        dragContainer: null,\n        useResizeObserver: false,\n        useMutationObserver: false,\n        preventDefault: true,\n        preventRightClick: true,\n        preventWheelClick: true,\n        linePadding: 0,\n        controlPadding: 0,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        passDragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n        zoom: 1,\n        triggerAblesSimultaneously: false,\n        padding: {},\n        pinchOutside: true,\n        checkInput: false,\n        dragFocusedInput: false,\n        groupable: false,\n        hideDefaultLines: false,\n        cspNonce: \"\",\n        translateZ: 0,\n        cssStyled: null,\n        customStyledMap: {},\n        props: {},\n        stopPropagation: false,\n        preventClickDefault: false,\n        preventClickEventOnDrag: true,\n        flushSync: defaultSync,\n        firstRenderState: null,\n        persistData: null,\n        viewContainer: null,\n        requestStyles: [],\n        useAccuratePosition: false\n    };\n    return MoveableManager;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\n/**\r\n * The target to indicate Moveable Control Box.\r\n * @name Moveable#target\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n * moveable.target = document.querySelector(\".target\");\r\n */ /**\r\n * Zooms in the elements of a moveable.\r\n * @name Moveable#zoom\r\n * @default 1\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n * moveable.zoom = 2;\r\n */ /**\r\n * Whether the target size is detected and updated whenever it changes.\r\n * @name Moveable#useResizeObserver\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n * moveable.useResizeObserver = true;\r\n */ /**\r\n * Resize, Scale Events at edges\r\n * @name Moveable#edge\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n * moveable.edge = true;\r\n */ /**\r\n * You can specify the className of the moveable controlbox.\r\n * @name Moveable#className\r\n * @default \"\"\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   className: \"\",\r\n * });\r\n *\r\n * moveable.className = \"moveable1\";\r\n */ /**\r\n * The target(s) to drag Moveable target(s)\r\n * @name Moveable#dragTarget\r\n * @default target\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n * moveable.target = document.querySelector(\".target\");\r\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\r\n */ /**\r\n * `renderStart` event occurs at the first start of all events.\r\n * @memberof Moveable\r\n * @event renderStart\r\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: document.querySelector(\".target\"),\r\n * });\r\n * moveable.on(\"renderStart\", ({ target }) => {\r\n *     console.log(\"onRenderStart\", target);\r\n * });\r\n */ /**\r\n * `render` event occurs before the target is drawn on the screen.\r\n * @memberof Moveable\r\n * @event render\r\n * @param {Moveable.OnRender} - Parameters for the `render` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: document.querySelector(\".target\"),\r\n * });\r\n * moveable.on(\"render\", ({ target }) => {\r\n *     console.log(\"onRender\", target);\r\n * });\r\n */ /**\r\n * `renderEnd` event occurs at the end of all events.\r\n * @memberof Moveable\r\n * @event renderEnd\r\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: document.querySelector(\".target\"),\r\n * });\r\n * moveable.on(\"renderEnd\", ({ target }) => {\r\n *     console.log(\"onRenderEnd\", target);\r\n * });\r\n */ /**\r\n * `renderGroupStart` event occurs at the first start of all events in group.\r\n * @memberof Moveable\r\n * @event renderGroupStart\r\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n * });\r\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\r\n *     console.log(\"onRenderGroupStart\", targets);\r\n * });\r\n */ /**\r\n * `renderGroup` event occurs before the target is drawn on the screen in group.\r\n * @memberof Moveable\r\n * @event renderGroup\r\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n * });\r\n * moveable.on(\"renderGroup\", ({ targets }) => {\r\n *     console.log(\"onRenderGroup\", targets);\r\n * });\r\n */ /**\r\n * `renderGroupEnd` event occurs at the end of all events in group.\r\n * @memberof Moveable\r\n * @event renderGroupEnd\r\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n * });\r\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\r\n *     console.log(\"onRenderGroupEnd\", targets);\r\n * });\r\n */ var Groupable = {\n    name: \"groupable\",\n    props: [\n        \"defaultGroupRotate\",\n        \"useDefaultGroupRotate\",\n        \"defaultGroupOrigin\",\n        \"groupable\",\n        \"groupableProps\",\n        \"targetGroups\",\n        \"hideChildMoveableDefaultLines\"\n    ],\n    events: [],\n    render: function(moveable, React) {\n        var _a;\n        var props = moveable.props;\n        var targets = props.targets || [];\n        var _b = moveable.getState(), left = _b.left, top = _b.top, isPersisted = _b.isPersisted;\n        var zoom = props.zoom || 1;\n        var renderGroupRects = moveable.renderGroupRects;\n        var persistDatChildren = ((_a = props.persistData) === null || _a === void 0 ? void 0 : _a.children) || [];\n        if (isPersisted) {\n            targets = persistDatChildren.map(function() {\n                return null;\n            });\n        } else {\n            persistDatChildren = [];\n        }\n        var parentPosition = watchValue(moveable, \"parentPosition\", [\n            left,\n            top\n        ], function(styles) {\n            return styles.join(\",\");\n        });\n        var requestStyles = watchValue(moveable, \"requestStyles\", moveable.getRequestChildStyles(), function(styles) {\n            return styles.join(\",\");\n        });\n        moveable.moveables = moveable.moveables.slice(0, targets.length);\n        return __spreadArray(__spreadArray([], __read(targets.map(function(target, i) {\n            return React.createElement(MoveableManager, {\n                key: \"moveable\" + i,\n                ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.refs)(moveable, \"moveables\", i),\n                target: target,\n                origin: false,\n                requestStyles: requestStyles,\n                cssStyled: props.cssStyled,\n                customStyledMap: props.customStyledMap,\n                useResizeObserver: props.useResizeObserver,\n                useMutationObserver: props.useMutationObserver,\n                hideChildMoveableDefaultLines: props.hideChildMoveableDefaultLines,\n                parentMoveable: moveable,\n                parentPosition: [\n                    left,\n                    top\n                ],\n                persistData: persistDatChildren[i],\n                zoom: zoom\n            });\n        })), false), __read(flat(renderGroupRects.map(function(_a, i) {\n            var pos1 = _a.pos1, pos2 = _a.pos2, pos3 = _a.pos3, pos4 = _a.pos4;\n            var poses = [\n                pos1,\n                pos2,\n                pos3,\n                pos4\n            ];\n            return [\n                [\n                    0,\n                    1\n                ],\n                [\n                    1,\n                    3\n                ],\n                [\n                    3,\n                    2\n                ],\n                [\n                    2,\n                    0\n                ]\n            ].map(function(_a, j) {\n                var _b = __read(_a, 2), from = _b[0], to = _b[1];\n                return renderLine(React, \"\", (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(poses[from], parentPosition), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(poses[to], parentPosition), zoom, \"group-rect-\".concat(i, \"-\").concat(j));\n            });\n        }))), false);\n    }\n};\nvar Clickable = makeAble(\"clickable\", {\n    props: [\n        \"clickable\"\n    ],\n    events: [\n        \"click\",\n        \"clickGroup\"\n    ],\n    always: true,\n    dragRelation: \"weak\",\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    dragStart: function() {\n        return;\n    },\n    dragControlStart: function() {\n        return;\n    },\n    dragGroupStart: function(moveable, e) {\n        e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\n    },\n    dragEnd: function(moveable, e) {\n        var target = moveable.props.target;\n        var inputEvent = e.inputEvent;\n        var inputTarget = e.inputTarget;\n        var isMoveableElement = moveable.isMoveableElement(inputTarget);\n        var containsElement = !isMoveableElement && moveable.controlBox.contains(inputTarget);\n        if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) || containsElement) {\n            return;\n        }\n        var containsTarget = target.contains(inputTarget);\n        triggerEvent(moveable, \"onClick\", fillParams(moveable, e, {\n            isDouble: e.isDouble,\n            inputTarget: inputTarget,\n            isTarget: target === inputTarget,\n            moveableTarget: moveable.props.target,\n            containsTarget: containsTarget\n        }));\n    },\n    dragGroupEnd: function(moveable, e) {\n        var inputEvent = e.inputEvent;\n        var inputTarget = e.inputTarget;\n        if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) || e.datas.inputTarget === inputTarget) {\n            return;\n        }\n        var targets = moveable.props.targets;\n        var targetIndex = targets.indexOf(inputTarget);\n        var isTarget = targetIndex > -1;\n        var containsTarget = false;\n        if (targetIndex === -1) {\n            targetIndex = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(targets, function(parentTarget) {\n                return parentTarget.contains(inputTarget);\n            });\n            containsTarget = targetIndex > -1;\n        }\n        triggerEvent(moveable, \"onClickGroup\", fillParams(moveable, e, {\n            isDouble: e.isDouble,\n            targets: targets,\n            inputTarget: inputTarget,\n            targetIndex: targetIndex,\n            isTarget: isTarget,\n            containsTarget: containsTarget,\n            moveableTarget: targets[targetIndex]\n        }));\n    },\n    dragControlEnd: function(moveable, e) {\n        this.dragEnd(moveable, e);\n    },\n    dragGroupControlEnd: function(moveable, e) {\n        this.dragEnd(moveable, e);\n    }\n});\n/**\r\n * When you click on the element, the `click` event is called.\r\n * @memberof Moveable\r\n * @event click\r\n * @param {Moveable.OnClick} - Parameters for the `click` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: document.querySelector(\".target\"),\r\n * });\r\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\r\n *     // If you click on an element other than the target and not included in the target, index is -1.\r\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\r\n * });\r\n */ /**\r\n * When you click on the element inside the group, the `clickGroup` event is called.\r\n * @memberof Moveable\r\n * @event clickGroup\r\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n * });\r\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\r\n *     // If you click on an element other than the target and not included in the target, index is -1.\r\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\r\n * });\r\n */ function getDraggableEvent(e) {\n    var datas = e.originalDatas.draggable;\n    if (!datas) {\n        e.originalDatas.draggable = {};\n        datas = e.originalDatas.draggable;\n    }\n    return __assign(__assign({}, e), {\n        datas: datas\n    });\n}\nvar edgeDraggable = makeAble(\"edgeDraggable\", {\n    css: [\n        \".edge.edgeDraggable.line {\\ncursor: move;\\n}\"\n    ],\n    render: function(moveable, React) {\n        var props = moveable.props;\n        var edge = props.edgeDraggable;\n        if (!edge) {\n            return [];\n        }\n        return renderEdgeLines(React, \"edgeDraggable\", edge, moveable.getState().renderPoses, props.zoom);\n    },\n    dragCondition: function(moveable, e) {\n        var _a;\n        var props = moveable.props;\n        var target = (_a = e.inputEvent) === null || _a === void 0 ? void 0 : _a.target;\n        if (!props.edgeDraggable || !target) {\n            return false;\n        }\n        return !props.draggable && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"direction\")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"edge\")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"edgeDraggable\"));\n    },\n    dragStart: function(moveable, e) {\n        return Draggable.dragStart(moveable, getDraggableEvent(e));\n    },\n    drag: function(moveable, e) {\n        return Draggable.drag(moveable, getDraggableEvent(e));\n    },\n    dragEnd: function(moveable, e) {\n        return Draggable.dragEnd(moveable, getDraggableEvent(e));\n    },\n    dragGroupCondition: function(moveable, e) {\n        var _a;\n        var props = moveable.props;\n        var target = (_a = e.inputEvent) === null || _a === void 0 ? void 0 : _a.target;\n        if (!props.edgeDraggable || !target) {\n            return false;\n        }\n        return !props.draggable && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"direction\")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"line\"));\n    },\n    dragGroupStart: function(moveable, e) {\n        return Draggable.dragGroupStart(moveable, getDraggableEvent(e));\n    },\n    dragGroup: function(moveable, e) {\n        return Draggable.dragGroup(moveable, getDraggableEvent(e));\n    },\n    dragGroupEnd: function(moveable, e) {\n        return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));\n    },\n    unset: function(moveable) {\n        return Draggable.unset(moveable);\n    }\n});\n/**\r\n * Whether to move by dragging the edge line (default: false)\r\n * @name Moveable.Draggable#edgeDraggable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *  draggable: true,\r\n *  edgeDraggable: false,\r\n * });\r\n *\r\n * moveable.edgeDraggable = true;\r\n */ var IndividualGroupable = {\n    name: \"individualGroupable\",\n    props: [\n        \"individualGroupable\",\n        \"individualGroupableProps\"\n    ],\n    events: []\n};\nvar MOVEABLE_ABLES = [\n    BeforeRenderable,\n    Default,\n    Snappable,\n    Pinchable,\n    Draggable,\n    edgeDraggable,\n    Resizable,\n    Scalable,\n    Warpable,\n    Rotatable,\n    Scrollable,\n    Padding,\n    Origin,\n    OriginDraggable,\n    Clippable,\n    Roundable,\n    Groupable,\n    IndividualGroupable,\n    Clickable,\n    DragArea,\n    Renderable\n];\nvar MOVEABLE_EVENTS = /*#__PURE__*/ MOVEABLE_ABLES.reduce(function(current, able) {\n    (able.events || []).forEach(function(name) {\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.pushSet)(current, name);\n    });\n    return current;\n}, []);\nvar MOVEABLE_PROPS = /*#__PURE__*/ MOVEABLE_ABLES.reduce(function(current, able) {\n    (able.props || []).forEach(function(name) {\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.pushSet)(current, name);\n    });\n    return current;\n}, []);\nfunction solveConstantsDistance(_a, pos) {\n    var _b = __read(_a, 3), a = _b[0], b = _b[1], c = _b[2];\n    return (a * pos[0] + b * pos[1] + c) / Math.sqrt(a * a + b * b);\n}\nfunction solveC(_a, pos) {\n    var _b = __read(_a, 2), a = _b[0], b = _b[1];\n    // ax + by + c = 0\n    // -ax -by;\n    return -a * pos[0] - b * pos[1];\n}\nfunction getMaxPos(poses, index) {\n    return Math.max.apply(Math, __spreadArray([], __read(poses.map(function(_a) {\n        var _b = __read(_a, 4), pos1 = _b[0], pos2 = _b[1], pos3 = _b[2], pos4 = _b[3];\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    })), false));\n}\nfunction getMinPos(poses, index) {\n    return Math.min.apply(Math, __spreadArray([], __read(poses.map(function(_a) {\n        var _b = __read(_a, 4), pos1 = _b[0], pos2 = _b[1], pos3 = _b[2], pos4 = _b[3];\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    })), false));\n}\nfunction getGroupRect(parentPoses, rotation) {\n    var _a, _b, _c;\n    var pos1 = [\n        0,\n        0\n    ];\n    var pos2 = [\n        0,\n        0\n    ];\n    var pos3 = [\n        0,\n        0\n    ];\n    var pos4 = [\n        0,\n        0\n    ];\n    var width = 0;\n    var height = 0;\n    if (!parentPoses.length) {\n        return {\n            pos1: pos1,\n            pos2: pos2,\n            pos3: pos3,\n            pos4: pos4,\n            minX: 0,\n            minY: 0,\n            maxX: 0,\n            maxY: 0,\n            width: width,\n            height: height,\n            rotation: rotation\n        };\n    }\n    var fixedRotation = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(rotation, TINY_NUM);\n    if (fixedRotation % 90) {\n        var rad = fixedRotation / 180 * Math.PI;\n        var a1_1 = Math.tan(rad);\n        var a2_1 = -1 / a1_1;\n        // ax = y  // -ax + y = 0 // 0 => 1\n        // -ax = y // ax + y = 0  // 0 => 3\n        var a1MinMax_1 = [\n            MAX_NUM,\n            MIN_NUM\n        ];\n        var a1MinMaxPos_1 = [\n            [\n                0,\n                0\n            ],\n            [\n                0,\n                0\n            ]\n        ];\n        var a2MinMax_1 = [\n            MAX_NUM,\n            MIN_NUM\n        ];\n        var a2MinMaxPos_1 = [\n            [\n                0,\n                0\n            ],\n            [\n                0,\n                0\n            ]\n        ];\n        parentPoses.forEach(function(poses) {\n            poses.forEach(function(pos) {\n                // const b1 = pos[1] - a1 * pos[0];\n                // const b2 = pos[1] - a2 * pos[0];\n                var a1Dist = solveConstantsDistance([\n                    -a1_1,\n                    1,\n                    0\n                ], pos);\n                var a2Dist = solveConstantsDistance([\n                    -a2_1,\n                    1,\n                    0\n                ], pos);\n                if (a1MinMax_1[0] > a1Dist) {\n                    a1MinMaxPos_1[0] = pos;\n                    a1MinMax_1[0] = a1Dist;\n                }\n                if (a1MinMax_1[1] < a1Dist) {\n                    a1MinMaxPos_1[1] = pos;\n                    a1MinMax_1[1] = a1Dist;\n                }\n                if (a2MinMax_1[0] > a2Dist) {\n                    a2MinMaxPos_1[0] = pos;\n                    a2MinMax_1[0] = a2Dist;\n                }\n                if (a2MinMax_1[1] < a2Dist) {\n                    a2MinMaxPos_1[1] = pos;\n                    a2MinMax_1[1] = a2Dist;\n                }\n            });\n        });\n        var _d = __read(a1MinMaxPos_1, 2), a1MinPos = _d[0], a1MaxPos = _d[1];\n        var _e = __read(a2MinMaxPos_1, 2), a2MinPos = _e[0], a2MaxPos = _e[1];\n        var minHorizontalLine = [\n            -a1_1,\n            1,\n            solveC([\n                -a1_1,\n                1\n            ], a1MinPos)\n        ];\n        var maxHorizontalLine = [\n            -a1_1,\n            1,\n            solveC([\n                -a1_1,\n                1\n            ], a1MaxPos)\n        ];\n        var minVerticalLine = [\n            -a2_1,\n            1,\n            solveC([\n                -a2_1,\n                1\n            ], a2MinPos)\n        ];\n        var maxVerticalLine = [\n            -a2_1,\n            1,\n            solveC([\n                -a2_1,\n                1\n            ], a2MaxPos)\n        ];\n        _a = __read([\n            [\n                minHorizontalLine,\n                minVerticalLine\n            ],\n            [\n                minHorizontalLine,\n                maxVerticalLine\n            ],\n            [\n                maxHorizontalLine,\n                minVerticalLine\n            ],\n            [\n                maxHorizontalLine,\n                maxVerticalLine\n            ]\n        ].map(function(_a) {\n            var _b = __read(_a, 2), line1 = _b[0], line2 = _b[1];\n            return (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getIntersectionPointsByConstants)(line1, line2)[0];\n        }), 4), pos1 = _a[0], pos2 = _a[1], pos3 = _a[2], pos4 = _a[3];\n        width = a2MinMax_1[1] - a2MinMax_1[0];\n        height = a1MinMax_1[1] - a1MinMax_1[0];\n    } else {\n        var minX_1 = getMinPos(parentPoses, 0);\n        var minY_1 = getMinPos(parentPoses, 1);\n        var maxX_1 = getMaxPos(parentPoses, 0);\n        var maxY_1 = getMaxPos(parentPoses, 1);\n        pos1 = [\n            minX_1,\n            minY_1\n        ];\n        pos2 = [\n            maxX_1,\n            minY_1\n        ];\n        pos3 = [\n            minX_1,\n            maxY_1\n        ];\n        pos4 = [\n            maxX_1,\n            maxY_1\n        ];\n        width = maxX_1 - minX_1;\n        height = maxY_1 - minY_1;\n        if (fixedRotation % 180) {\n            // 0\n            // 1 2\n            // 3 4\n            // 90\n            // 3 1\n            // 4 2\n            // 180\n            // 4 3\n            // 2 1\n            // 270\n            // 2 4\n            // 1 3\n            // 1, 2, 3,4 = 3 1 4 2\n            var changedX = [\n                pos3,\n                pos1,\n                pos4,\n                pos2\n            ];\n            _b = __read(changedX, 4), pos1 = _b[0], pos2 = _b[1], pos3 = _b[2], pos4 = _b[3];\n            width = maxY_1 - minY_1;\n            height = maxX_1 - minX_1;\n        }\n    }\n    if (fixedRotation % 360 > 180) {\n        // 1 2   4 3\n        // 3 4   2 1\n        var changedX = [\n            pos4,\n            pos3,\n            pos2,\n            pos1\n        ];\n        _c = __read(changedX, 4), pos1 = _c[0], pos2 = _c[1], pos3 = _c[2], pos4 = _c[3];\n    }\n    var _f = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getMinMaxs)([\n        pos1,\n        pos2,\n        pos3,\n        pos4\n    ]), minX = _f.minX, minY = _f.minY, maxX = _f.maxX, maxY = _f.maxY;\n    return {\n        pos1: pos1,\n        pos2: pos2,\n        pos3: pos3,\n        pos4: pos4,\n        width: width,\n        height: height,\n        minX: minX,\n        minY: minY,\n        maxX: maxX,\n        maxY: maxY,\n        rotation: rotation\n    };\n}\nfunction findMoveableGroups(moveables, childTargetGroups) {\n    var groups = childTargetGroups.map(function(targetGroup) {\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(targetGroup)) {\n            var childMoveableGroups = findMoveableGroups(moveables, targetGroup);\n            var length_1 = childMoveableGroups.length;\n            if (length_1 > 1) {\n                return childMoveableGroups;\n            } else if (length_1 === 1) {\n                return childMoveableGroups[0];\n            } else {\n                return null;\n            }\n        } else {\n            var checked = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(moveables, function(_a) {\n                var manager = _a.manager;\n                return manager.props.target === targetGroup;\n            });\n            if (checked) {\n                checked.finded = true;\n                return checked.manager;\n            }\n            return null;\n        }\n    }).filter(Boolean);\n    if (groups.length === 1 && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(groups[0])) {\n        return groups[0];\n    }\n    return groups;\n}\n/**\r\n * @namespace Moveable.Group\r\n * @description You can make targets moveable.\r\n */ var MoveableGroup = /*#__PURE__*/ function(_super) {\n    __extends(MoveableGroup, _super);\n    function MoveableGroup() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.differ = new _egjs_children_differ__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n        _this.moveables = [];\n        _this.transformOrigin = \"50% 50%\";\n        _this.renderGroupRects = [];\n        _this._targetGroups = [];\n        _this._hasFirstTargets = false;\n        return _this;\n    }\n    MoveableGroup.prototype.componentDidMount = function() {\n        _super.prototype.componentDidMount.call(this);\n    };\n    MoveableGroup.prototype.checkUpdate = function() {\n        this._isPropTargetChanged = false;\n        this.updateAbles();\n    };\n    MoveableGroup.prototype.getTargets = function() {\n        return this.props.targets;\n    };\n    MoveableGroup.prototype.updateRect = function(type, isTarget, isSetState) {\n        var _a;\n        if (isSetState === void 0) {\n            isSetState = true;\n        }\n        var state = this.state;\n        if (!this.controlBox || state.isPersisted) {\n            return;\n        }\n        setStoreCache(true);\n        this.moveables.forEach(function(moveable) {\n            moveable.updateRect(type, false, false);\n        });\n        var props = this.props;\n        var moveables = this.moveables;\n        var target = state.target || props.target;\n        var checkeds = moveables.map(function(moveable) {\n            return {\n                finded: false,\n                manager: moveable\n            };\n        });\n        var targetGroups = this.props.targetGroups || [];\n        var moveableGroups = findMoveableGroups(checkeds, targetGroups);\n        var useDefaultGroupRotate = props.useDefaultGroupRotate;\n        moveableGroups.push.apply(moveableGroups, __spreadArray([], __read(checkeds.filter(function(_a) {\n            var finded = _a.finded;\n            return !finded;\n        }).map(function(_a) {\n            var manager = _a.manager;\n            return manager;\n        })), false));\n        var renderGroupRects = [];\n        var isReset = !isTarget || type !== \"\" && props.updateGroup;\n        var defaultGroupRotate = props.defaultGroupRotate || 0;\n        if (!this._hasFirstTargets) {\n            var persistedRoatation = (_a = props.persistData) === null || _a === void 0 ? void 0 : _a.rotation;\n            if (persistedRoatation != null) {\n                defaultGroupRotate = persistedRoatation;\n            }\n        }\n        function getMoveableGroupRect(group, parentRotation, isRoot) {\n            var posesRotations = group.map(function(moveable) {\n                if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(moveable)) {\n                    var rect = getMoveableGroupRect(moveable, parentRotation);\n                    var poses = [\n                        rect.pos1,\n                        rect.pos2,\n                        rect.pos3,\n                        rect.pos4\n                    ];\n                    renderGroupRects.push(rect);\n                    return {\n                        poses: poses,\n                        rotation: rect.rotation\n                    };\n                } else {\n                    return {\n                        poses: getAbsolutePosesByState(moveable.state),\n                        rotation: moveable.getRotation()\n                    };\n                }\n            });\n            var rotations = posesRotations.map(function(_a) {\n                var rotation = _a.rotation;\n                return rotation;\n            });\n            var groupRotation = 0;\n            var firstRotation = rotations[0];\n            var isSameRotation = rotations.every(function(nextRotation) {\n                return Math.abs(firstRotation - nextRotation) < 0.1;\n            });\n            if (isReset) {\n                groupRotation = !useDefaultGroupRotate && isSameRotation ? firstRotation : defaultGroupRotate;\n            } else {\n                groupRotation = !useDefaultGroupRotate && !isRoot && isSameRotation ? firstRotation : parentRotation;\n            }\n            var groupPoses = posesRotations.map(function(_a) {\n                var poses = _a.poses;\n                return poses;\n            });\n            var groupRect = getGroupRect(groupPoses, groupRotation);\n            return groupRect;\n        }\n        var rootGroupRect = getMoveableGroupRect(moveableGroups, this.rotation, true);\n        if (isReset) {\n            // reset rotataion\n            this.rotation = rootGroupRect.rotation;\n            this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n            this.scale = [\n                1,\n                1\n            ];\n        }\n        this._targetGroups = targetGroups;\n        this.renderGroupRects = renderGroupRects;\n        var transformOrigin = this.transformOrigin;\n        var rotation = this.rotation;\n        var scale = this.scale;\n        var width = rootGroupRect.width, height = rootGroupRect.height, minX = rootGroupRect.minX, minY = rootGroupRect.minY;\n        var posesInfo = rotatePosesInfo([\n            [\n                0,\n                0\n            ],\n            [\n                width,\n                0\n            ],\n            [\n                0,\n                height\n            ],\n            [\n                width,\n                height\n            ]\n        ], convertTransformOriginArray(transformOrigin, width, height), this.rotation / 180 * Math.PI);\n        var _b = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getMinMaxs)(posesInfo.result), deltaX = _b.minX, deltaY = _b.minY;\n        var rotateScale = \" rotate(\".concat(rotation, \"deg)\") + \" scale(\".concat(sign(scale[0]), \", \").concat(sign(scale[1]), \")\");\n        var transform = \"translate(\".concat(-deltaX, \"px, \").concat(-deltaY, \"px)\").concat(rotateScale);\n        this.controlBox.style.transform = \"translate3d(\".concat(minX, \"px, \").concat(minY, \"px, \").concat(this.props.translateZ || 0, \")\");\n        target.style.cssText += \"left:0px;top:0px;\" + \"transform-origin:\".concat(transformOrigin, \";\") + \"width:\".concat(width, \"px;height:\").concat(height, \"px;\") + \"transform: \".concat(transform);\n        state.width = width;\n        state.height = height;\n        var container = this.getContainer();\n        var info = getMoveableTargetInfo(this.controlBox, target, this.controlBox, this.getContainer(), this._rootContainer || container, []);\n        var pos = [\n            info.left,\n            info.top\n        ];\n        var _c = __read(getAbsolutePosesByState(info), 4), pos1 = _c[0], pos2 = _c[1], pos3 = _c[2], pos4 = _c[3]; // info.left + info.pos(1 ~ 4)\n        var minPos = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getMinMaxs)([\n            pos1,\n            pos2,\n            pos3,\n            pos4\n        ]);\n        var delta = [\n            minPos.minX,\n            minPos.minY\n        ];\n        var direction = sign(scale[0] * scale[1]);\n        info.pos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos1, delta);\n        info.pos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos2, delta);\n        info.pos3 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos3, delta);\n        info.pos4 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos4, delta);\n        // info.left = info.left + delta[0];\n        // info.top = info.top + delta[1];\n        info.left = minX - info.left + delta[0];\n        info.top = minY - info.top + delta[1];\n        info.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.origin), delta);\n        info.beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.beforeOrigin), delta);\n        info.originalBeforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.originalBeforeOrigin);\n        info.transformOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.transformOrigin), delta);\n        target.style.transform = \"translate(\".concat(-deltaX - delta[0], \"px, \").concat(-deltaY - delta[1], \"px)\") + rotateScale;\n        setStoreCache();\n        this.updateState(__assign(__assign({}, info), {\n            posDelta: delta,\n            direction: direction,\n            beforeDirection: direction\n        }), isSetState);\n    };\n    MoveableGroup.prototype.getRect = function() {\n        return __assign(__assign({}, _super.prototype.getRect.call(this)), {\n            children: this.moveables.map(function(child) {\n                return child.getRect();\n            })\n        });\n    };\n    MoveableGroup.prototype.triggerEvent = function(name, e, isManager) {\n        if (isManager || name.indexOf(\"Group\") > -1) {\n            return _super.prototype.triggerEvent.call(this, name, e);\n        } else {\n            this._emitter.trigger(name, e);\n        }\n    };\n    MoveableGroup.prototype.getRequestChildStyles = function() {\n        var styleNames = this.getEnabledAbles().reduce(function(names, able) {\n            var _a, _b;\n            var ableStyleNames = (_b = (_a = able.requestChildStyle) === null || _a === void 0 ? void 0 : _a.call(able)) !== null && _b !== void 0 ? _b : [];\n            return __spreadArray(__spreadArray([], __read(names), false), __read(ableStyleNames), false);\n        }, []);\n        return styleNames;\n    };\n    MoveableGroup.prototype.getMoveables = function() {\n        return __spreadArray([], __read(this.moveables), false);\n    };\n    MoveableGroup.prototype.updateAbles = function() {\n        _super.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], __read(this.props.ables), false), [\n            Groupable\n        ], false), \"Group\");\n    };\n    MoveableGroup.prototype._updateTargets = function() {\n        _super.prototype._updateTargets.call(this);\n        this._originalDragTarget = this.props.dragTarget || this.areaElement;\n        this._dragTarget = getRefTarget(this._originalDragTarget, true);\n    };\n    MoveableGroup.prototype._updateEvents = function() {\n        var state = this.state;\n        var props = this.props;\n        var prevTarget = this._prevDragTarget;\n        var nextTarget = props.dragTarget || this.areaElement;\n        var targets = props.targets;\n        var _a = this.differ.update(targets), added = _a.added, changed = _a.changed, removed = _a.removed;\n        var isTargetChanged = added.length || removed.length;\n        if (isTargetChanged || this._prevOriginalDragTarget !== this._originalDragTarget) {\n            unsetGesto(this, false);\n            unsetGesto(this, true);\n            this.updateState({\n                gestos: {}\n            });\n        }\n        if (prevTarget !== nextTarget) {\n            state.target = null;\n        }\n        if (!state.target) {\n            state.target = this.areaElement;\n            this.controlBox.style.display = \"block\";\n        }\n        if (state.target) {\n            if (!this.targetGesto) {\n                this.targetGesto = getTargetAbleGesto(this, this._dragTarget, \"Group\");\n            }\n            if (!this.controlGesto) {\n                this.controlGesto = getControlAbleGesto(this, \"GroupControl\");\n            }\n        }\n        var isContainerChanged = !equals(state.container, props.container);\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        if (isContainerChanged || isTargetChanged || this.transformOrigin !== (props.defaultGroupOrigin || \"50% 50%\") || changed.length || targets.length && !isDeepArrayEquals(this._targetGroups, props.targetGroups || [])) {\n            this.updateRect();\n            this._hasFirstTargets = true;\n        }\n        this._isPropTargetChanged = !!isTargetChanged;\n    };\n    MoveableGroup.prototype._updateObserver = function() {};\n    MoveableGroup.defaultProps = __assign(__assign({}, MoveableManager.defaultProps), {\n        transformOrigin: [\n            \"50%\",\n            \"50%\"\n        ],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n        defaultGroupOrigin: \"50% 50%\"\n    });\n    return MoveableGroup;\n}(MoveableManager);\n/**\r\n * @namespace Moveable.IndividualGroup\r\n * @description Create targets individually, not as a group.Create targets individually, not as a group.\r\n */ var MoveableIndividualGroup = /*#__PURE__*/ function(_super) {\n    __extends(MoveableIndividualGroup, _super);\n    function MoveableIndividualGroup() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.moveables = [];\n        return _this;\n    }\n    MoveableIndividualGroup.prototype.render = function() {\n        var _this = this;\n        var _a;\n        var props = this.props;\n        var cspNonce = props.cspNonce, ControlBoxElement = props.cssStyled, persistData = props.persistData;\n        var targets = props.targets || [];\n        var length = targets.length;\n        var canPersist = this.isUnmounted || !length;\n        var persistDatChildren = (_a = persistData === null || persistData === void 0 ? void 0 : persistData.children) !== null && _a !== void 0 ? _a : [];\n        if (canPersist && !length && persistDatChildren.length) {\n            targets = persistDatChildren.map(function() {\n                return null;\n            });\n        } else if (!canPersist) {\n            persistDatChildren = [];\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlBoxElement, {\n            cspNonce: cspNonce,\n            ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, \"controlBox\"),\n            className: prefix(\"control-box\")\n        }, targets.map(function(target, i) {\n            var _a, _b;\n            var individualProps = (_b = (_a = props.individualGroupableProps) === null || _a === void 0 ? void 0 : _a.call(props, target, i)) !== null && _b !== void 0 ? _b : {};\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MoveableManager, __assign({\n                key: \"moveable\" + i,\n                ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.refs)(_this, \"moveables\", i)\n            }, props, individualProps, {\n                target: target,\n                wrapperMoveable: _this,\n                isWrapperMounted: _this.isMoveableMounted,\n                persistData: persistDatChildren[i]\n            }));\n        }));\n    };\n    MoveableIndividualGroup.prototype.componentDidMount = function() {};\n    MoveableIndividualGroup.prototype.componentDidUpdate = function() {};\n    MoveableIndividualGroup.prototype.getTargets = function() {\n        return this.props.targets;\n    };\n    MoveableIndividualGroup.prototype.updateRect = function(type, isTarget, isSetState) {\n        if (isSetState === void 0) {\n            isSetState = true;\n        }\n        setStoreCache(true);\n        this.moveables.forEach(function(moveable) {\n            moveable.updateRect(type, isTarget, isSetState);\n        });\n        setStoreCache();\n    };\n    MoveableIndividualGroup.prototype.getRect = function() {\n        return __assign(__assign({}, _super.prototype.getRect.call(this)), {\n            children: this.moveables.map(function(child) {\n                return child.getRect();\n            })\n        });\n    };\n    MoveableIndividualGroup.prototype.request = function(ableName, param, isInstant) {\n        if (param === void 0) {\n            param = {};\n        }\n        var results = this.moveables.map(function(m) {\n            return m.request(ableName, __assign(__assign({}, param), {\n                isInstant: false\n            }), false);\n        });\n        var requestInstant = isInstant || param.isInstant;\n        var requester = {\n            request: function(ableParam) {\n                results.forEach(function(r) {\n                    return r.request(ableParam);\n                });\n                return this;\n            },\n            requestEnd: function() {\n                results.forEach(function(r) {\n                    return r.requestEnd();\n                });\n                return this;\n            }\n        };\n        return requestInstant ? requester.request(param).requestEnd() : requester;\n    };\n    MoveableIndividualGroup.prototype.dragStart = function(e, target) {\n        if (target === void 0) {\n            target = e.target;\n        }\n        var inputTarget = target;\n        var childMoveable = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(this.moveables, function(child) {\n            var target = child.getTargets()[0];\n            var controlBoxElement = child.getControlBoxElement();\n            var dragElement = child.getDragElement();\n            if (!target || !dragElement) {\n                return false;\n            }\n            return dragElement === inputTarget || dragElement.contains(inputTarget) || dragElement !== target && target === inputTarget || target.contains(inputTarget) || controlBoxElement === inputTarget || controlBoxElement.contains(inputTarget);\n        });\n        if (childMoveable) {\n            childMoveable.dragStart(e, target);\n        }\n        return this;\n    };\n    MoveableIndividualGroup.prototype.hitTest = function() {\n        return 0;\n    };\n    MoveableIndividualGroup.prototype.isInside = function() {\n        return false;\n    };\n    MoveableIndividualGroup.prototype.isDragging = function() {\n        return false;\n    };\n    MoveableIndividualGroup.prototype.getDragElement = function() {\n        return null;\n    };\n    MoveableIndividualGroup.prototype.getMoveables = function() {\n        return __spreadArray([], __read(this.moveables), false);\n    };\n    MoveableIndividualGroup.prototype.updateRenderPoses = function() {};\n    MoveableIndividualGroup.prototype.checkUpdate = function() {};\n    MoveableIndividualGroup.prototype.triggerEvent = function() {};\n    MoveableIndividualGroup.prototype.updateAbles = function() {};\n    MoveableIndividualGroup.prototype._updateEvents = function() {};\n    MoveableIndividualGroup.prototype._updateObserver = function() {};\n    return MoveableIndividualGroup;\n}(MoveableManager);\nfunction getElementTargets(refTargets, selectorMap) {\n    var elementTargets = [];\n    refTargets.forEach(function(target) {\n        if (!target) {\n            return;\n        }\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(target)) {\n            if (selectorMap[target]) {\n                elementTargets.push.apply(elementTargets, __spreadArray([], __read(selectorMap[target]), false));\n            }\n            return;\n        }\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target)) {\n            elementTargets.push.apply(elementTargets, __spreadArray([], __read(getElementTargets(target, selectorMap)), false));\n        } else {\n            elementTargets.push(target);\n        }\n    });\n    return elementTargets;\n}\nfunction getTargetGroups(refTargets, selectorMap) {\n    var targetGroups = [];\n    refTargets.forEach(function(target) {\n        if (!target) {\n            return;\n        }\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(target)) {\n            if (selectorMap[target]) {\n                targetGroups.push.apply(targetGroups, __spreadArray([], __read(selectorMap[target]), false));\n            }\n            return;\n        }\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target)) {\n            targetGroups.push(getTargetGroups(target, selectorMap));\n        } else {\n            targetGroups.push(target);\n        }\n    });\n    return targetGroups;\n}\nfunction compareRefTargets(prevRefTargets, nextRefTargets) {\n    return prevRefTargets.length !== nextRefTargets.length || prevRefTargets.some(function(target, i) {\n        var nextTarget = nextRefTargets[i];\n        if (!target && !nextTarget) {\n            return false;\n        } else if (target != nextTarget) {\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(nextTarget)) {\n                return compareRefTargets(target, nextTarget);\n            }\n            return true;\n        }\n        return false;\n    });\n}\nvar InitialMoveable = /*#__PURE__*/ function(_super) {\n    __extends(InitialMoveable, _super);\n    function InitialMoveable() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.refTargets = [];\n        _this.selectorMap = {};\n        _this._differ = new _egjs_children_differ__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n        _this._elementTargets = [];\n        _this._tmpRefTargets = [];\n        _this._tmpSelectorMap = {};\n        _this._onChangeTargets = null;\n        return _this;\n    }\n    InitialMoveable.makeStyled = function() {\n        var cssMap = {};\n        var ables = this.getTotalAbles();\n        ables.forEach(function(_a) {\n            var css = _a.css;\n            if (!css) {\n                return;\n            }\n            css.forEach(function(text) {\n                cssMap[text] = true;\n            });\n        });\n        var style = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(cssMap).join(\"\\n\");\n        this.defaultStyled = (0,react_css_styled__WEBPACK_IMPORTED_MODULE_11__.styled)(\"div\", (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.prefixCSS)(PREFIX, MOVEABLE_CSS + style));\n    };\n    InitialMoveable.getTotalAbles = function() {\n        return __spreadArray([\n            Default,\n            Groupable,\n            IndividualGroupable,\n            DragArea\n        ], __read(this.defaultAbles), false);\n    };\n    InitialMoveable.prototype.render = function() {\n        var _a;\n        var moveableContructor = this.constructor;\n        if (!moveableContructor.defaultStyled) {\n            moveableContructor.makeStyled();\n        }\n        var _b = this.props, userAbles = _b.ables, userProps = _b.props, props = __rest(_b, [\n            \"ables\",\n            \"props\"\n        ]);\n        var _c = __read(this._updateRefs(true), 2), refTargets = _c[0], nextSelectorMap = _c[1];\n        var elementTargets = getElementTargets(refTargets, nextSelectorMap);\n        var isGroup = elementTargets.length > 1;\n        var totalAbles = moveableContructor.getTotalAbles();\n        var ables = __spreadArray(__spreadArray([], __read(totalAbles), false), __read(userAbles || []), false);\n        var nextProps = __assign(__assign(__assign({}, props), userProps || {}), {\n            ables: ables,\n            cssStyled: moveableContructor.defaultStyled,\n            customStyledMap: moveableContructor.customStyledMap\n        });\n        this._elementTargets = elementTargets;\n        var firstRenderState = null;\n        var prevMoveable = this.moveable;\n        var persistData = props.persistData;\n        if (persistData === null || persistData === void 0 ? void 0 : persistData.children) {\n            isGroup = true;\n        }\n        // Even one child is treated as a group if individualGroupable is enabled. #867\n        if (props.individualGroupable) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MoveableIndividualGroup, __assign({\n                key: \"individual-group\",\n                ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, \"moveable\")\n            }, nextProps, {\n                target: null,\n                targets: elementTargets\n            }));\n        }\n        if (isGroup) {\n            var targetGroups = getTargetGroups(refTargets, nextSelectorMap);\n            // manager\n            if (prevMoveable && !prevMoveable.props.groupable && !prevMoveable.props.individualGroupable) {\n                var target = prevMoveable.props.target;\n                if (target && elementTargets.indexOf(target) > -1) {\n                    firstRenderState = __assign({}, prevMoveable.state);\n                }\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MoveableGroup, __assign({\n                key: \"group\",\n                ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, \"moveable\")\n            }, nextProps, (_a = props.groupableProps) !== null && _a !== void 0 ? _a : {}, {\n                target: null,\n                targets: elementTargets,\n                targetGroups: targetGroups,\n                firstRenderState: firstRenderState\n            }));\n        } else {\n            var target_1 = elementTargets[0];\n            // manager\n            if (prevMoveable && (prevMoveable.props.groupable || prevMoveable.props.individualGroupable)) {\n                var moveables = prevMoveable.moveables || [];\n                var prevTargetMoveable = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(moveables, function(mv) {\n                    return mv.props.target === target_1;\n                });\n                if (prevTargetMoveable) {\n                    firstRenderState = __assign({}, prevTargetMoveable.state);\n                }\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MoveableManager, __assign({\n                key: \"single\",\n                ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, \"moveable\")\n            }, nextProps, {\n                target: target_1,\n                firstRenderState: firstRenderState\n            }));\n        }\n    };\n    InitialMoveable.prototype.componentDidMount = function() {\n        this._checkChangeTargets();\n    };\n    InitialMoveable.prototype.componentDidUpdate = function() {\n        this._checkChangeTargets();\n    };\n    InitialMoveable.prototype.componentWillUnmount = function() {\n        this.selectorMap = {};\n        this.refTargets = [];\n    };\n    /**\r\n     * Get targets set in moveable through target or targets of props.\r\n     * @method Moveable#getTargets\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body, {\r\n     *    target: [targetRef, \".target\", document.querySelectorAll(\".target\")],\r\n     * });\r\n     *\r\n     * console.log(moveable.getTargets());\r\n     */ InitialMoveable.prototype.getTargets = function() {\n        var _a, _b;\n        return (_b = (_a = this.moveable) === null || _a === void 0 ? void 0 : _a.getTargets()) !== null && _b !== void 0 ? _b : [];\n    };\n    /**\r\n     * If the element list corresponding to the selector among the targets is changed, it is updated.\r\n     * @method Moveable#updateSelectors\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body, {\r\n     *    target: \".target\",\r\n     * });\r\n     *\r\n     * moveable.updateSelectors();\r\n     */ InitialMoveable.prototype.updateSelectors = function() {\n        this.selectorMap = {};\n        this._updateRefs();\n        this.forceUpdate();\n    };\n    /**\r\n     * User changes target and waits for target to change.\r\n     * @method Moveable#waitToChangeTarget\r\n     * @story combination-with-other-components--components-selecto\r\n     * @example\r\n     * document.querySelector(\".target\").addEventListener(\"mousedown\", e => {\r\n     *   moveable.waitToChangeTarget().then(() => {\r\n     *      moveable.dragStart(e, e.currentTarget);\r\n     *   });\r\n     *   moveable.target = e.currentTarget;\r\n     * });\r\n     */ InitialMoveable.prototype.waitToChangeTarget = function() {\n        // let resolvePromise: (e: OnChangeTarget) => void;\n        var _this = this;\n        // this._onChangeTargets = () => {\n        //     this._onChangeTargets = null;\n        //     resolvePromise({\n        //         moveable: this.getManager(),\n        //         targets: this._elementTargets,\n        //     });\n        // };\n        // return new Promise<OnChangeTarget>(resolve => {\n        //     resolvePromise = resolve;\n        // });\n        var resolvePromise;\n        this._onChangeTargets = function() {\n            _this._onChangeTargets = null;\n            resolvePromise();\n        };\n        return new Promise(function(resolve) {\n            resolvePromise = resolve;\n        });\n    };\n    InitialMoveable.prototype.waitToChangeTargets = function() {\n        return this.waitToChangeTarget();\n    };\n    InitialMoveable.prototype.getManager = function() {\n        return this.moveable;\n    };\n    InitialMoveable.prototype.getMoveables = function() {\n        return this.moveable.getMoveables();\n    };\n    InitialMoveable.prototype.getDragElement = function() {\n        return this.moveable.getDragElement();\n    };\n    InitialMoveable.prototype._updateRefs = function(isRender) {\n        var prevRefTargets = this.refTargets;\n        var nextRefTargets = getRefTargets(this.props.target || this.props.targets);\n        var isBrowser = typeof document !== \"undefined\";\n        var isUpdate = compareRefTargets(prevRefTargets, nextRefTargets);\n        var selectorMap = this.selectorMap;\n        var nextSelectorMap = {};\n        this.refTargets.forEach(function updateSelectorMap(target) {\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(target)) {\n                var selectorTarget = selectorMap[target];\n                if (selectorTarget) {\n                    nextSelectorMap[target] = selectorMap[target];\n                } else if (isBrowser) {\n                    isUpdate = true;\n                    nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));\n                }\n            } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target)) {\n                target.forEach(updateSelectorMap);\n            }\n        });\n        this._tmpRefTargets = nextRefTargets;\n        this._tmpSelectorMap = nextSelectorMap;\n        return [\n            nextRefTargets,\n            nextSelectorMap,\n            !isRender && isUpdate\n        ];\n    };\n    InitialMoveable.prototype._checkChangeTargets = function() {\n        var _a, _b, _c;\n        this.refTargets = this._tmpRefTargets;\n        this.selectorMap = this._tmpSelectorMap;\n        var _d = this._differ.update(this._elementTargets), added = _d.added, removed = _d.removed;\n        var isTargetChanged = added.length || removed.length;\n        if (isTargetChanged) {\n            (_b = (_a = this.props).onChangeTargets) === null || _b === void 0 ? void 0 : _b.call(_a, {\n                moveable: this.moveable,\n                targets: this._elementTargets\n            });\n            (_c = this._onChangeTargets) === null || _c === void 0 ? void 0 : _c.call(this);\n        }\n        var _e = __read(this._updateRefs(), 3), refTargets = _e[0], selectorMap = _e[1], isUpdate = _e[2];\n        this.refTargets = refTargets;\n        this.selectorMap = selectorMap;\n        if (isUpdate) {\n            this.forceUpdate();\n        }\n    };\n    InitialMoveable.defaultAbles = [];\n    InitialMoveable.customStyledMap = {};\n    InitialMoveable.defaultStyled = null;\n    __decorate([\n        (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.withMethods)(MOVEABLE_METHODS)\n    ], InitialMoveable.prototype, \"moveable\", void 0);\n    return InitialMoveable;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\nvar Moveable = /*#__PURE__*/ function(_super) {\n    __extends(Moveable, _super);\n    function Moveable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Moveable.defaultAbles = MOVEABLE_ABLES;\n    return Moveable;\n}(InitialMoveable);\nfunction makeMoveable(ables) {\n    var _a;\n    return _a = /*#__PURE__*/ function(_super) {\n        __extends(Moveable, _super);\n        function Moveable() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return Moveable;\n    }(InitialMoveable), _a.defaultAbles = ables, _a;\n}\n //# sourceMappingURL=moveable.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbW92ZWFibGUvZGlzdC9tb3ZlYWJsZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7OztBQU9BLEdBQ21DO0FBQzhDO0FBQ29hO0FBQ3ZMO0FBQ3JQO0FBQ1o7QUFDbEI7QUFDbUY7QUFDL0Y7QUFDTztBQUNaO0FBQ2dCO0FBQ007QUFDRztBQUVuRDs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsMkJBQTJCLEdBRTNCLElBQUlvRixnQkFBZ0IsU0FBU0MsQ0FBQyxFQUFFQyxDQUFDO0lBQzdCRixnQkFBZ0JHLE9BQU9DLGNBQWMsSUFDaEM7UUFBRUMsV0FBVyxFQUFFO0lBQUMsY0FBYUMsU0FBUyxTQUFVTCxDQUFDLEVBQUVDLENBQUM7UUFBSUQsRUFBRUksU0FBUyxHQUFHSDtJQUFHLEtBQzFFLFNBQVVELENBQUMsRUFBRUMsQ0FBQztRQUFJLElBQUssSUFBSUssS0FBS0wsRUFBRyxJQUFJQyxPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO0lBQUU7SUFDcEcsT0FBT1AsY0FBY0MsR0FBR0M7QUFDNUI7QUFFQSxTQUFTUyxVQUFVVixDQUFDLEVBQUVDLENBQUM7SUFDbkIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFDakMsTUFBTSxJQUFJVSxVQUFVLHlCQUF5QkMsT0FBT1gsS0FBSztJQUM3REYsY0FBY0MsR0FBR0M7SUFDakIsU0FBU1k7UUFBTyxJQUFJLENBQUNDLFdBQVcsR0FBR2Q7SUFBRztJQUN0Q0EsRUFBRU8sU0FBUyxHQUFHTixNQUFNLE9BQU9DLE9BQU9hLE1BQU0sQ0FBQ2QsS0FBTVksQ0FBQUEsR0FBR04sU0FBUyxHQUFHTixFQUFFTSxTQUFTLEVBQUUsSUFBSU0sSUFBRztBQUN0RjtBQUVBLElBQUlHLFdB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QUFDLElBQUksRUFBRUYsY0FBYyxJQUFJO0lBQ25FO0lBQ0FxcEUsU0FBU3JCLFlBQVksR0FBRzVGO0lBQ3hCLE9BQU9pSDtBQUNYLEVBQUUvQjtBQUVGLFNBQVNnQyxhQUFhcHNDLEtBQUs7SUFDdkIsSUFBSW4yQjtJQUNKLE9BQU9BLEtBQUssV0FBVyxHQUFJLFNBQVUrd0QsTUFBTTtRQUNuQzE0RCxVQUFVaXFFLFVBQVV2UjtRQUNwQixTQUFTdVI7WUFDTCxPQUFPdlIsV0FBVyxRQUFRQSxPQUFPNTNELEtBQUssQ0FBQyxJQUFJLEVBQUVGLGNBQWMsSUFBSTtRQUNuRTtRQUNBLE9BQU9xcEU7SUFDWCxFQUFFL0Isa0JBQ0Z2Z0UsR0FBR2loRSxZQUFZLEdBQUc5cUMsT0FDbEJuMkI7QUFDUjtBQUVrVSxDQUNsVSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGlwanMvLi9ub2RlX21vZHVsZXMvcmVhY3QtbW92ZWFibGUvZGlzdC9tb3ZlYWJsZS5lc20uanM/YmZmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiByZWFjdC1tb3ZlYWJsZVxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvbW92ZWFibGUvYmxvYi9tYXN0ZXIvcGFja2FnZXMvcmVhY3QtbW92ZWFibGVcbnZlcnNpb246IDAuNTYuMFxuKi9cbmltcG9ydCBnZXRBZ2VudCBmcm9tICdAZWdqcy9hZ2VudCc7XG5pbXBvcnQgeyBwcmVmaXhOYW1lcywgcmVmLCByZWZzLCBwcmVmaXhDU1MsIHdpdGhNZXRob2RzIH0gZnJvbSAnZnJhbWV3b3JrLXV0aWxzJztcbmltcG9ydCB7IGZpbmRJbmRleCwgZmluZCwgaXNBcnJheSwgc3BsaXRTcGFjZSwgc3BsaXRVbml0LCBkb3QsIGlzU3RyaW5nLCBnZXREb2N1bWVudEVsZW1lbnQsIGdldERvY3VtZW50Qm9keSwgZ2V0V2luZG93LCB0aHJvdHRsZSwgZ2V0S2V5cywgZ2V0UmFkLCBUSU5ZX05VTSBhcyBUSU5ZX05VTSQxLCBhdmVyYWdlLCBnZXREaXN0IGFzIGdldERpc3QkMSwgdGhyb3R0bGVBcnJheSwgY2FsY3VsYXRlQm91bmRTaXplLCBjb252ZXJ0VW5pdFNpemUsIGlzTnVtYmVyLCBoYXNDbGFzcywgaXNPYmplY3QsIGZsYXQgYXMgZmxhdCQxLCBkZWNhbWVsaXplLCBpc05vZGUsIGlzRnVuY3Rpb24sIGlzV2luZG93LCBjb3VudGVyLCBpc1VuZGVmaW5lZCwgYmV0d2VlbiwgYWRkQ2xhc3MsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgcmVtb3ZlQ2xhc3MsIHNwbGl0QnJhY2tldCwgc3BsaXRDb21tYSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUsIHB1c2hTZXQgfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuaW1wb3J0IHsgbWludXMsIGludmVydCwgY29udmVydFBvc2l0aW9uTWF0cml4LCBwbHVzLCBjYWxjdWxhdGUsIGZyb21UcmFuc2xhdGlvbiwgbXVsdGlwbHksIGNvbnZlcnREaW1lbnNpb24sIGNyZWF0ZVNjYWxlTWF0cml4LCBjb252ZXJ0Q1NTdG9NYXRyaXgsIGNyZWF0ZUlkZW50aXR5TWF0cml4LCBjcmVhdGVPcmlnaW5NYXRyaXgsIGNyZWF0ZVJvdGF0ZU1hdHJpeCwgcm90YXRlLCBnZXRPcmlnaW4sIG11bHRpcGxpZXMsIGNvbnZlcnRNYXRyaXh0b0NTUywgaWdub3JlRGltZW5zaW9uLCBjcmVhdGVXYXJwTWF0cml4IH0gZnJvbSAnQHNjZW5hL21hdHJpeCc7XG5pbXBvcnQgeyBwYXJzZSwgcGFyc2VNYXQsIHRvTWF0LCBjYWxjdWxhdGVNYXRyaXhEaXN0IH0gZnJvbSAnY3NzLXRvLW1hdCc7XG5pbXBvcnQgQ2hpbGRyZW5EaWZmZXIsIHsgZGlmZiB9IGZyb20gJ0BlZ2pzL2NoaWxkcmVuLWRpZmZlcic7XG5pbXBvcnQgRHJhZ1Njcm9sbCBmcm9tICdAc2NlbmEvZHJhZ3Njcm9sbCc7XG5pbXBvcnQgeyBnZXRNaW5NYXhzLCBmaXRQb2ludHMsIGdldE92ZXJsYXBTaXplLCBnZXRBcmVhU2l6ZSwgaXNJbnNpZGUsIGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzIH0gZnJvbSAnb3ZlcmxhcC1hcmVhJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgR2VzdG8gZnJvbSAnZ2VzdG8nO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSAncmVhY3QtY3NzLXN0eWxlZCc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ0BzY2VuYS9ldmVudC1lbWl0dGVyJztcbmltcG9ydCB7IGRpZmYgYXMgZGlmZiQxIH0gZnJvbSAnQGVnanMvbGlzdC1kaWZmZXInO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XG5cbmZ1bmN0aW9uIG1ha2VBYmxlKG5hbWUsIGFibGUpIHtcclxuICAgIHJldHVybiBfX2Fzc2lnbih7IGV2ZW50czogW10sIHByb3BzOiBbXSwgbmFtZTogbmFtZSB9LCBhYmxlKTtcclxufVxuXG52YXIgRElSRUNUSU9OUzQgPSBbXCJuXCIsIFwid1wiLCBcInNcIiwgXCJlXCJdO1xyXG52YXIgRElSRUNUSU9OUyA9IFtcIm5cIiwgXCJ3XCIsIFwic1wiLCBcImVcIiwgXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXTtcclxuZnVuY3Rpb24gZ2V0U1ZHQ3Vyc29yKHNjYWxlLCBkZWdyZWUpIHtcclxuICAgIHJldHVybiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiXCIuY29uY2F0KDMyICogc2NhbGUsIFwicHhcXFwiIGhlaWdodD1cXFwiXCIpLmNvbmNhdCgzMiAqIHNjYWxlLCBcInB4XFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiID48cGF0aCBkPVxcXCJNIDE2LDUgTCAxMiwxMCBMIDE0LjUsMTAgTCAxNC41LDIyIEwgMTIsMjIgTCAxNiwyNyBMIDIwLDIyIEwgMTcuNSwyMiBMIDE3LjUsMTAgTCAyMCwgMTAgTCAxNiw1IFpcXFwiIHN0cm9rZS1saW5lam9pbj1cXFwicm91bmRcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBmaWxsPVxcXCJibGFja1xcXCIgc3Ryb2tlPVxcXCJ3aGl0ZVxcXCIgc3R5bGU9XFxcInRyYW5zZm9ybTpyb3RhdGUoXCIpLmNvbmNhdChkZWdyZWUsIFwiZGVnKTt0cmFuc2Zvcm0tb3JpZ2luOiAxNnB4IDE2cHhcXFwiPjwvcGF0aD48L3N2Zz5cIik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3Vyc29yQ1NTKGRlZ3JlZSkge1xyXG4gICAgdmFyIHgxID0gZ2V0U1ZHQ3Vyc29yKDEsIGRlZ3JlZSk7XHJcbiAgICAvLyBjb25zdCB4MiA9IGdldFNWR0N1cnNvcigyLCBkZWdyZWUpO1xyXG4gICAgdmFyIGRlZ3JlZTQ1ID0gKE1hdGgucm91bmQoZGVncmVlIC8gNDUpICogNDUpICUgMTgwO1xyXG4gICAgdmFyIGRlZmF1bHRDdXJzb3IgPSBcIm5zLXJlc2l6ZVwiO1xyXG4gICAgaWYgKGRlZ3JlZTQ1ID09PSAxMzUpIHtcclxuICAgICAgICBkZWZhdWx0Q3Vyc29yID0gXCJud3NlLXJlc2l6ZVwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGVncmVlNDUgPT09IDQ1KSB7XHJcbiAgICAgICAgZGVmYXVsdEN1cnNvciA9IFwibmVzdy1yZXNpemVcIjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRlZ3JlZTQ1ID09PSA5MCkge1xyXG4gICAgICAgIGRlZmF1bHRDdXJzb3IgPSBcImV3LXJlc2l6ZVwiO1xyXG4gICAgfVxyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcclxuICAgIHJldHVybiBcImN1cnNvcjpcIi5jb25jYXQoZGVmYXVsdEN1cnNvciwgXCI7Y3Vyc29yOiB1cmwoJ1wiKS5jb25jYXQoeDEsIFwiJykgMTYgMTYsIFwiKS5jb25jYXQoZGVmYXVsdEN1cnNvciwgXCI7XCIpO1xyXG59XHJcbnZhciBhZ2VudCA9IGdldEFnZW50KCk7XHJcbnZhciBJU19XRUJLSVQgPSBhZ2VudC5icm93c2VyLndlYmtpdDtcclxudmFyIElTX1dFQktJVDYwNSA9IElTX1dFQktJVCAmJiAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG5hdmkgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8geyB1c2VyQWdlbnQ6IFwiXCIgfSA6IHdpbmRvdy5uYXZpZ2F0b3I7XHJcbiAgICB2YXIgcmVzID0gL2FwcGxld2Via2l0XFwvKFteXFxzXSspL2cuZXhlYyhuYXZpLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuICAgIHJldHVybiByZXMgPyBwYXJzZUZsb2F0KHJlc1sxXSkgPCA2MDUgOiBmYWxzZTtcclxufSkoKTtcclxudmFyIGJyb3dzZXJOYW1lID0gYWdlbnQuYnJvd3Nlci5uYW1lO1xyXG52YXIgYnJvd3NlclZlcnNpb24gPSBwYXJzZUludChhZ2VudC5icm93c2VyLnZlcnNpb24sIDEwKTtcclxudmFyIElTX0NIUk9NRSA9IGJyb3dzZXJOYW1lID09PSBcImNocm9tZVwiO1xyXG52YXIgSVNfQ0hST01JVU0gPSBhZ2VudC5icm93c2VyLmNocm9taXVtO1xyXG52YXIgY2hyb21pdW1WZXJzaW9uID0gcGFyc2VJbnQoYWdlbnQuYnJvd3Nlci5jaHJvbWl1bVZlcnNpb24sIDEwKSB8fCAwO1xyXG52YXIgSVNfQ0hST01JVU0xMDkgPSAoSVNfQ0hST01FICYmIGJyb3dzZXJWZXJzaW9uID49IDEwOSlcclxuICAgIHx8IChJU19DSFJPTUlVTSAmJiBjaHJvbWl1bVZlcnNpb24gPj0gMTA5KTtcclxudmFyIElTX0ZJUkVGT1ggPSBicm93c2VyTmFtZSA9PT0gXCJmaXJlZm94XCI7XHJcbnZhciBJU19TQUZBUklfQUJPVkUxNSA9IHBhcnNlSW50KGFnZW50LmJyb3dzZXIud2Via2l0VmVyc2lvbiwgMTApID49IDYxMlxyXG4gICAgfHwgYnJvd3NlclZlcnNpb24gPj0gMTU7XHJcbnZhciBQUkVGSVggPSBcIm1vdmVhYmxlLVwiO1xyXG52YXIgZGlyZWN0aW9uQ1NTID0gRElSRUNUSU9OUy5tYXAoZnVuY3Rpb24gKGRpcikge1xyXG4gICAgdmFyIHRvcCA9IFwiXCI7XHJcbiAgICB2YXIgbGVmdCA9IFwiXCI7XHJcbiAgICB2YXIgb3JpZ2luWCA9IFwiY2VudGVyXCI7XHJcbiAgICB2YXIgb3JpZ2luWSA9IFwiY2VudGVyXCI7XHJcbiAgICB2YXIgb2Zmc2V0ID0gXCJjYWxjKHZhcigtLW1vdmVhYmxlLWNvbnRyb2wtcGFkZGluZywgMjApICogLTFweClcIjtcclxuICAgIGlmIChkaXIuaW5kZXhPZihcIm5cIikgPiAtMSkge1xyXG4gICAgICAgIHRvcCA9IFwidG9wOiBcIi5jb25jYXQob2Zmc2V0LCBcIjtcIik7XHJcbiAgICAgICAgb3JpZ2luWSA9IFwiYm90dG9tXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlyLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcclxuICAgICAgICB0b3AgPSBcInRvcDogMHB4O1wiO1xyXG4gICAgICAgIG9yaWdpblkgPSBcInRvcFwiO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpci5pbmRleE9mKFwid1wiKSA+IC0xKSB7XHJcbiAgICAgICAgbGVmdCA9IFwibGVmdDogXCIuY29uY2F0KG9mZnNldCwgXCI7XCIpO1xyXG4gICAgICAgIG9yaWdpblggPSBcInJpZ2h0XCI7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlyLmluZGV4T2YoXCJlXCIpID4gLTEpIHtcclxuICAgICAgICBsZWZ0ID0gXCJsZWZ0OiAwcHg7XCI7XHJcbiAgICAgICAgb3JpZ2luWCA9IFwibGVmdFwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiLmFyb3VuZC1jb250cm9sW2RhdGEtZGlyZWN0aW9uKj1cXFwiXCIuY29uY2F0KGRpciwgXCJcXFwiXSB7XFxuICAgICAgICBcIikuY29uY2F0KGxlZnQpLmNvbmNhdCh0b3AsIFwiXFxuICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBcIikuY29uY2F0KG9yaWdpblgsIFwiIFwiKS5jb25jYXQob3JpZ2luWSwgXCI7XFxuICAgIH1cIik7XHJcbn0pLmpvaW4oXCJcXG5cIik7XHJcbnZhciBNT1ZFQUJMRV9DU1MgPSBcIlxcbntcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxud2lkdGg6IDFweDtcXG5oZWlnaHQ6IDFweDtcXG5sZWZ0OiAwO1xcbnRvcDogMDtcXG56LWluZGV4OiAzMDAwO1xcbi0tbW92ZWFibGUtY29sb3I6ICM0YWY7XFxuLS16b29tOiAxO1xcbi0tem9vbXB4OiAxcHg7XFxuLS1tb3ZlYWJsZS1saW5lLXBhZGRpbmc6IDA7XFxuLS1tb3ZlYWJsZS1jb250cm9sLXBhZGRpbmc6IDA7XFxud2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG5vdXRsaW5lOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XFxufVxcbi5jb250cm9sLWJveCB7XFxuei1pbmRleDogMDtcXG59XFxuLmxpbmUsIC5jb250cm9sIHtcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxubGVmdDogMDtcXG50b3A6IDA7XFxud2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG59XFxuLmNvbnRyb2wge1xcbndpZHRoOiAxNHB4O1xcbmhlaWdodDogMTRweDtcXG5ib3JkZXItcmFkaXVzOiA1MCU7XFxuYm9yZGVyOiAycHggc29saWQgI2ZmZjtcXG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbmJhY2tncm91bmQ6ICM0YWY7XFxuYmFja2dyb3VuZDogdmFyKC0tbW92ZWFibGUtY29sb3IpO1xcbm1hcmdpbi10b3A6IC03cHg7XFxubWFyZ2luLWxlZnQ6IC03cHg7XFxuYm9yZGVyOiAycHggc29saWQgI2ZmZjtcXG56LWluZGV4OiAxMDtcXG59XFxuLmFyb3VuZC1jb250cm9sIHtcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxud2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG53aWR0aDogY2FsYyh2YXIoLS1tb3ZlYWJsZS1jb250cm9sLXBhZGRpbmcsIDIwKSAqIDFweCk7XFxuaGVpZ2h0OiBjYWxjKHZhcigtLW1vdmVhYmxlLWNvbnRyb2wtcGFkZGluZywgMjApICogMXB4KTtcXG5sZWZ0OiBjYWxjKHZhcigtLW1vdmVhYmxlLWNvbnRyb2wtcGFkZGluZywgMjApICogLTAuNXB4KTtcXG50b3A6IGNhbGModmFyKC0tbW92ZWFibGUtY29udHJvbC1wYWRkaW5nLCAyMCkgKiAtMC41cHgpO1xcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuei1pbmRleDogODtcXG5jdXJzb3I6IGFsaWFzO1xcbnRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XFxufVxcblwiLmNvbmNhdChkaXJlY3Rpb25DU1MsIFwiXFxuLnBhZGRpbmcge1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG50b3A6IDBweDtcXG5sZWZ0OiAwcHg7XFxud2lkdGg6IDEwMHB4O1xcbmhlaWdodDogMTAwcHg7XFxudHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcbn1cXG4ubGluZSB7XFxud2lkdGg6IDFweDtcXG5oZWlnaHQ6IDFweDtcXG5iYWNrZ3JvdW5kOiAjNGFmO1xcbmJhY2tncm91bmQ6IHZhcigtLW1vdmVhYmxlLWNvbG9yKTtcXG50cmFuc2Zvcm0tb3JpZ2luOiAwcHggNTAlO1xcbn1cXG4ubGluZS5lZGdlIHtcXG56LWluZGV4OiAxO1xcbmJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbn1cXG4ubGluZS5kYXNoZWQge1xcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxufVxcbi5saW5lLmRhc2hlZC5ob3Jpem9udGFsIHtcXG5ib3JkZXItdG9wOiAxcHggZGFzaGVkICM0YWY7XFxuYm9yZGVyLXRvcC1jb2xvcjogIzRhZjtcXG5ib3JkZXItdG9wLWNvbG9yOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XFxufVxcbi5saW5lLmRhc2hlZC52ZXJ0aWNhbCB7XFxuYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzRhZjtcXG5ib3JkZXItbGVmdC1jb2xvcjogIzRhZjtcXG5ib3JkZXItbGVmdC1jb2xvcjogdmFyKC0tbW92ZWFibGUtY29sb3IpO1xcbn1cXG4ubGluZS52ZXJ0aWNhbCB7XFxudHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xcbn1cXG4ubGluZS5ob3Jpem9udGFsIHtcXG50cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxufVxcbi5saW5lLnZlcnRpY2FsLmJvbGQge1xcbndpZHRoOiAycHg7XFxufVxcbi5saW5lLmhvcml6b250YWwuYm9sZCB7XFxuaGVpZ2h0OiAycHg7XFxufVxcblxcbi5jb250cm9sLm9yaWdpbiB7XFxuYm9yZGVyLWNvbG9yOiAjZjU1O1xcbmJhY2tncm91bmQ6ICNmZmY7XFxud2lkdGg6IDEycHg7XFxuaGVpZ2h0OiAxMnB4O1xcbm1hcmdpbi10b3A6IC02cHg7XFxubWFyZ2luLWxlZnQ6IC02cHg7XFxucG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblwiKS5jb25jYXQoWzAsIDE1LCAzMCwgNDUsIDYwLCA3NSwgOTAsIDEwNSwgMTIwLCAxMzUsIDE1MCwgMTY1XS5tYXAoZnVuY3Rpb24gKGRlZ3JlZSkgeyByZXR1cm4gXCJcXG4uZGlyZWN0aW9uW2RhdGEtcm90YXRpb249XFxcIlwiLmNvbmNhdChkZWdyZWUsIFwiXFxcIl0sIDpnbG9iYWwgLnZpZXctY29udHJvbC1yb3RhdGlvblwiKS5jb25jYXQoZGVncmVlLCBcIiB7XFxuXCIpLmNvbmNhdChnZXRDdXJzb3JDU1MoZGVncmVlKSwgXCJcXG59XFxuXCIpOyB9KS5qb2luKFwiXFxuXCIpLCBcIlxcblxcbi5saW5lLmRpcmVjdGlvbjpiZWZvcmUge1xcbmNvbnRlbnQ6IFxcXCJcXFwiO1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG53aWR0aDogMTAwJTtcXG5oZWlnaHQ6IGNhbGModmFyKC0tbW92ZWFibGUtbGluZS1wYWRkaW5nLCAwKSAqIDFweCk7XFxuYm90dG9tOiAwO1xcbmxlZnQ6IDA7XFxufVxcbi5ncm91cCB7XFxuei1pbmRleDogLTE7XFxufVxcbi5hcmVhIHtcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi5hcmVhLXBpZWNlcyB7XFxucG9zaXRpb246IGFic29sdXRlO1xcbnRvcDogMDtcXG5sZWZ0OiAwO1xcbmRpc3BsYXk6IG5vbmU7XFxufVxcbi5hcmVhLmF2b2lkLCAuYXJlYS5wYXNzIHtcXG5wb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuLmFyZWEuYXZvaWQrLmFyZWEtcGllY2VzIHtcXG5kaXNwbGF5OiBibG9jaztcXG59XFxuLmFyZWEtcGllY2Uge1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuXCIpLmNvbmNhdChJU19XRUJLSVQ2MDUgPyBcIjpnbG9iYWwgc3ZnICo6YmVmb3JlIHtcXG5jb250ZW50OlxcXCJcXFwiO1xcbnRyYW5zZm9ybS1vcmlnaW46IGluaGVyaXQ7XFxufVwiIDogXCJcIiwgXCJcXG5cIik7XHJcbnZhciBORUFSQllfUE9TID0gW1xyXG4gICAgWzAsIDEsIDJdLFxyXG4gICAgWzEsIDAsIDNdLFxyXG4gICAgWzIsIDAsIDNdLFxyXG4gICAgWzMsIDEsIDJdLFxyXG5dO1xyXG52YXIgRkxPQVRfUE9JTlRfTlVNID0gMC4wMDAxO1xyXG52YXIgVElOWV9OVU0gPSAwLjAwMDAwMDE7XHJcbnZhciBNSU5fU0NBTEUgPSAwLjAwMDAwMDAwMTtcclxudmFyIE1BWF9OVU0gPSBNYXRoLnBvdygxMCwgMTApO1xyXG52YXIgTUlOX05VTSA9IC1NQVhfTlVNO1xyXG52YXIgRElSRUNUSU9OX1JFR0lPTl9UT19ESVJFQ1RJT04gPSB7XHJcbiAgICBuOiBbMCwgLTFdLFxyXG4gICAgZTogWzEsIDBdLFxyXG4gICAgczogWzAsIDFdLFxyXG4gICAgdzogWy0xLCAwXSxcclxuICAgIG53OiBbLTEsIC0xXSxcclxuICAgIG5lOiBbMSwgLTFdLFxyXG4gICAgc3c6IFstMSwgMV0sXHJcbiAgICBzZTogWzEsIDFdLFxyXG59O1xyXG52YXIgRElSRUNUSU9OX0lOREVYRVMgPSB7XHJcbiAgICBuOiBbMCwgMV0sXHJcbiAgICBlOiBbMSwgM10sXHJcbiAgICBzOiBbMywgMl0sXHJcbiAgICB3OiBbMiwgMF0sXHJcbiAgICBudzogWzBdLFxyXG4gICAgbmU6IFsxXSxcclxuICAgIHN3OiBbMl0sXHJcbiAgICBzZTogWzNdLFxyXG59O1xyXG52YXIgRElSRUNUSU9OX1JPVEFUSU9OUyA9IHtcclxuICAgIG46IDAsXHJcbiAgICBzOiAxODAsXHJcbiAgICB3OiAyNzAsXHJcbiAgICBlOiA5MCxcclxuICAgIG53OiAzMTUsXHJcbiAgICBuZTogNDUsXHJcbiAgICBzdzogMjI1LFxyXG4gICAgc2U6IDEzNSxcclxufTtcclxudmFyIE1PVkVBQkxFX01FVEhPRFMgPSBbXHJcbiAgICBcImlzTW92ZWFibGVFbGVtZW50XCIsXHJcbiAgICBcInVwZGF0ZVJlY3RcIixcclxuICAgIFwidXBkYXRlVGFyZ2V0XCIsXHJcbiAgICBcImRlc3Ryb3lcIixcclxuICAgIFwiZHJhZ1N0YXJ0XCIsXHJcbiAgICBcImlzSW5zaWRlXCIsXHJcbiAgICBcImhpdFRlc3RcIixcclxuICAgIFwic2V0U3RhdGVcIixcclxuICAgIFwiZ2V0UmVjdFwiLFxyXG4gICAgXCJyZXF1ZXN0XCIsXHJcbiAgICBcImlzRHJhZ2dpbmdcIixcclxuICAgIFwiZ2V0TWFuYWdlclwiLFxyXG4gICAgXCJmb3JjZVVwZGF0ZVwiLFxyXG4gICAgXCJ3YWl0VG9DaGFuZ2VUYXJnZXRcIixcclxuICAgIFwidXBkYXRlU2VsZWN0b3JzXCIsXHJcbiAgICBcImdldFRhcmdldHNcIixcclxuICAgIFwic3RvcERyYWdcIixcclxuICAgIFwiZ2V0Q29udHJvbEJveEVsZW1lbnRcIixcclxuICAgIFwiZ2V0TW92ZWFibGVzXCIsXHJcbiAgICBcImdldERyYWdFbGVtZW50XCIsXHJcbl07XG5cbmZ1bmN0aW9uIHNldEN1c3RvbURyYWcoZSwgc3RhdGUsIGRlbHRhLCBpc1BpbmNoLCBpc0NvbnZlcnQsIGFibGVOYW1lKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgaWYgKGFibGVOYW1lID09PSB2b2lkIDApIHsgYWJsZU5hbWUgPSBcImRyYWdnYWJsZVwiOyB9XHJcbiAgICB2YXIgcmVzdWx0ID0gKF9iID0gKF9hID0gc3RhdGUuZ2VzdG9zW2FibGVOYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vdmUoZGVsdGEsIGUuaW5wdXRFdmVudCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xyXG4gICAgdmFyIGRhdGFzID0gcmVzdWx0Lm9yaWdpbmFsRGF0YXMgfHwgcmVzdWx0LmRhdGFzO1xyXG4gICAgdmFyIGFibGVEYXRhcyA9IGRhdGFzW2FibGVOYW1lXSB8fCAoZGF0YXNbYWJsZU5hbWVdID0ge30pO1xyXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCAoaXNDb252ZXJ0ID8gY29udmVydERyYWdEaXN0KHN0YXRlLCByZXN1bHQpIDogcmVzdWx0KSksIHsgaXNQaW5jaDogISFpc1BpbmNoLCBwYXJlbnRFdmVudDogdHJ1ZSwgZGF0YXM6IGFibGVEYXRhcywgb3JpZ2luYWxEYXRhczogZS5vcmlnaW5hbERhdGFzIH0pO1xyXG59XHJcbnZhciBDdXN0b21HZXN0byA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEN1c3RvbUdlc3RvKGFibGVOYW1lKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmIChhYmxlTmFtZSA9PT0gdm9pZCAwKSB7IGFibGVOYW1lID0gXCJkcmFnZ2FibGVcIjsgfVxyXG4gICAgICAgIHRoaXMuYWJsZU5hbWUgPSBhYmxlTmFtZTtcclxuICAgICAgICB0aGlzLnByZXZYID0gMDtcclxuICAgICAgICB0aGlzLnByZXZZID0gMDtcclxuICAgICAgICB0aGlzLnN0YXJ0WCA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGFydFkgPSAwO1xyXG4gICAgICAgIHRoaXMuaXNEcmFnID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0ZsYWcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRhdGFzID0ge1xyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5kYXRhcyA9IChfYSA9IHt9LFxyXG4gICAgICAgICAgICBfYVthYmxlTmFtZV0gPSB7fSxcclxuICAgICAgICAgICAgX2EpO1xyXG4gICAgfVxyXG4gICAgQ3VzdG9tR2VzdG8ucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uIChjbGllbnQsIGUpIHtcclxuICAgICAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXM7XHJcbiAgICAgICAgdGhpcy5kYXRhcyA9IG9yaWdpbmFsRGF0YXM7XHJcbiAgICAgICAgaWYgKCFvcmlnaW5hbERhdGFzW3RoaXMuYWJsZU5hbWVdKSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRGF0YXNbdGhpcy5hYmxlTmFtZV0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm1vdmUoY2xpZW50LCBlLmlucHV0RXZlbnQpKSwgeyB0eXBlOiBcImRyYWdzdGFydFwiIH0pO1xyXG4gICAgfTtcclxuICAgIEN1c3RvbUdlc3RvLnByb3RvdHlwZS5kcmFnID0gZnVuY3Rpb24gKGNsaWVudCwgaW5wdXRFdmVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdmUoW1xyXG4gICAgICAgICAgICBjbGllbnRbMF0gLSB0aGlzLnByZXZYLFxyXG4gICAgICAgICAgICBjbGllbnRbMV0gLSB0aGlzLnByZXZZLFxyXG4gICAgICAgIF0sIGlucHV0RXZlbnQpO1xyXG4gICAgfTtcclxuICAgIEN1c3RvbUdlc3RvLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGRlbHRhLCBpbnB1dEV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGNsaWVudFg7XHJcbiAgICAgICAgdmFyIGNsaWVudFk7XHJcbiAgICAgICAgdmFyIGlzRmlyc3REcmFnID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRmxhZykge1xyXG4gICAgICAgICAgICB0aGlzLnByZXZYID0gZGVsdGFbMF07XHJcbiAgICAgICAgICAgIHRoaXMucHJldlkgPSBkZWx0YVsxXTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFggPSBkZWx0YVswXTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFkgPSBkZWx0YVsxXTtcclxuICAgICAgICAgICAgY2xpZW50WCA9IGRlbHRhWzBdO1xyXG4gICAgICAgICAgICBjbGllbnRZID0gZGVsdGFbMV07XHJcbiAgICAgICAgICAgIHRoaXMuaXNGbGFnID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpc1ByZXZEcmFnID0gdGhpcy5pc0RyYWc7XHJcbiAgICAgICAgICAgIGNsaWVudFggPSB0aGlzLnByZXZYICsgZGVsdGFbMF07XHJcbiAgICAgICAgICAgIGNsaWVudFkgPSB0aGlzLnByZXZZICsgZGVsdGFbMV07XHJcbiAgICAgICAgICAgIGlmIChkZWx0YVswXSB8fCBkZWx0YVsxXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNQcmV2RHJhZyAmJiB0aGlzLmlzRHJhZykge1xyXG4gICAgICAgICAgICAgICAgaXNGaXJzdERyYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJldlggPSBjbGllbnRYO1xyXG4gICAgICAgIHRoaXMucHJldlkgPSBjbGllbnRZO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiZHJhZ1wiLFxyXG4gICAgICAgICAgICBjbGllbnRYOiBjbGllbnRYLFxyXG4gICAgICAgICAgICBjbGllbnRZOiBjbGllbnRZLFxyXG4gICAgICAgICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50LFxyXG4gICAgICAgICAgICBpc0ZpcnN0RHJhZzogaXNGaXJzdERyYWcsXHJcbiAgICAgICAgICAgIGlzRHJhZzogdGhpcy5pc0RyYWcsXHJcbiAgICAgICAgICAgIGRpc3RYOiBjbGllbnRYIC0gdGhpcy5zdGFydFgsXHJcbiAgICAgICAgICAgIGRpc3RZOiBjbGllbnRZIC0gdGhpcy5zdGFydFksXHJcbiAgICAgICAgICAgIGRlbHRhWDogZGVsdGFbMF0sXHJcbiAgICAgICAgICAgIGRlbHRhWTogZGVsdGFbMV0sXHJcbiAgICAgICAgICAgIGRhdGFzOiB0aGlzLmRhdGFzW3RoaXMuYWJsZU5hbWVdLFxyXG4gICAgICAgICAgICBvcmlnaW5hbERhdGFzOiB0aGlzLmRhdGFzLFxyXG4gICAgICAgICAgICBwYXJlbnRFdmVudDogdHJ1ZSxcclxuICAgICAgICAgICAgcGFyZW50R2VzdG86IHRoaXMsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ3VzdG9tR2VzdG87XHJcbn0oKSk7XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVsZW1lbnRQb3NpdGlvbihtYXRyaXgsIG9yaWdpbiwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIGlzM2QgPSBtYXRyaXgubGVuZ3RoID09PSAxNjtcclxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgdmFyIHBvc2VzID0gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuKTtcclxuICAgIHZhciBfYSA9IF9fcmVhZChwb3NlcywgNCksIF9iID0gX19yZWFkKF9hWzBdLCAyKSwgeDEgPSBfYlswXSwgeTEgPSBfYlsxXSwgX2MgPSBfX3JlYWQoX2FbMV0sIDIpLCB4MiA9IF9jWzBdLCB5MiA9IF9jWzFdLCBfZCA9IF9fcmVhZChfYVsyXSwgMiksIHgzID0gX2RbMF0sIHkzID0gX2RbMV0sIF9lID0gX19yZWFkKF9hWzNdLCAyKSwgeDQgPSBfZVswXSwgeTQgPSBfZVsxXTtcclxuICAgIHZhciBfZiA9IF9fcmVhZChjYWxjdWxhdGVQb3NpdGlvbihtYXRyaXgsIG9yaWdpbiwgbiksIDIpLCBvcmlnaW5YID0gX2ZbMF0sIG9yaWdpblkgPSBfZlsxXTtcclxuICAgIHZhciBsZWZ0ID0gTWF0aC5taW4oeDEsIHgyLCB4MywgeDQpO1xyXG4gICAgdmFyIHRvcCA9IE1hdGgubWluKHkxLCB5MiwgeTMsIHk0KTtcclxuICAgIHZhciByaWdodCA9IE1hdGgubWF4KHgxLCB4MiwgeDMsIHg0KTtcclxuICAgIHZhciBib3R0b20gPSBNYXRoLm1heCh5MSwgeTIsIHkzLCB5NCk7XHJcbiAgICB4MSA9ICh4MSAtIGxlZnQpIHx8IDA7XHJcbiAgICB4MiA9ICh4MiAtIGxlZnQpIHx8IDA7XHJcbiAgICB4MyA9ICh4MyAtIGxlZnQpIHx8IDA7XHJcbiAgICB4NCA9ICh4NCAtIGxlZnQpIHx8IDA7XHJcbiAgICB5MSA9ICh5MSAtIHRvcCkgfHwgMDtcclxuICAgIHkyID0gKHkyIC0gdG9wKSB8fCAwO1xyXG4gICAgeTMgPSAoeTMgLSB0b3ApIHx8IDA7XHJcbiAgICB5NCA9ICh5NCAtIHRvcCkgfHwgMDtcclxuICAgIG9yaWdpblggPSAob3JpZ2luWCAtIGxlZnQpIHx8IDA7XHJcbiAgICBvcmlnaW5ZID0gKG9yaWdpblkgLSB0b3ApIHx8IDA7XHJcbiAgICB2YXIgc3ggPSBtYXRyaXhbMF07XHJcbiAgICB2YXIgc3kgPSBtYXRyaXhbbiArIDFdO1xyXG4gICAgdmFyIGRpcmVjdGlvbiA9IHNpZ24oc3ggKiBzeSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxyXG4gICAgICAgIGJvdHRvbTogYm90dG9tLFxyXG4gICAgICAgIG9yaWdpbjogW29yaWdpblgsIG9yaWdpblldLFxyXG4gICAgICAgIHBvczE6IFt4MSwgeTFdLFxyXG4gICAgICAgIHBvczI6IFt4MiwgeTJdLFxyXG4gICAgICAgIHBvczM6IFt4MywgeTNdLFxyXG4gICAgICAgIHBvczQ6IFt4NCwgeTRdLFxyXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQb2ludGVyRGlzdChtb3ZlYWJsZSwgZSkge1xyXG4gICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFgsIGNsaWVudFkgPSBlLmNsaWVudFksIGRhdGFzID0gZS5kYXRhcztcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCBtb3ZlYWJsZUNsaWVudFJlY3QgPSBfYS5tb3ZlYWJsZUNsaWVudFJlY3QsIHJvb3RNYXRyaXggPSBfYS5yb290TWF0cml4LCBpczNkID0gX2EuaXMzZCwgcG9zMSA9IF9hLnBvczE7XHJcbiAgICB2YXIgbGVmdCA9IG1vdmVhYmxlQ2xpZW50UmVjdC5sZWZ0LCB0b3AgPSBtb3ZlYWJsZUNsaWVudFJlY3QudG9wO1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQobWludXMoY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKHJvb3RNYXRyaXgsIFtjbGllbnRYIC0gbGVmdCwgY2xpZW50WSAtIHRvcF0sIG4pLCBwb3MxKSwgMiksIHBvc1ggPSBfYlswXSwgcG9zWSA9IF9iWzFdO1xyXG4gICAgdmFyIF9jID0gX19yZWFkKGdldERyYWdEaXN0KHsgZGF0YXM6IGRhdGFzLCBkaXN0WDogcG9zWCwgZGlzdFk6IHBvc1kgfSksIDIpLCBkaXN0WCA9IF9jWzBdLCBkaXN0WSA9IF9jWzFdO1xyXG4gICAgcmV0dXJuIFtkaXN0WCwgZGlzdFldO1xyXG59XHJcbmZ1bmN0aW9uIHNldERyYWdTdGFydChtb3ZlYWJsZSwgX2EpIHtcclxuICAgIHZhciBkYXRhcyA9IF9hLmRhdGFzO1xyXG4gICAgdmFyIF9iID0gbW92ZWFibGUuc3RhdGUsIGFsbE1hdHJpeCA9IF9iLmFsbE1hdHJpeCwgYmVmb3JlTWF0cml4ID0gX2IuYmVmb3JlTWF0cml4LCBpczNkID0gX2IuaXMzZCwgbGVmdCA9IF9iLmxlZnQsIHRvcCA9IF9iLnRvcCwgb3JpZ2luID0gX2Iub3JpZ2luLCBvZmZzZXRNYXRyaXggPSBfYi5vZmZzZXRNYXRyaXgsIHRhcmdldE1hdHJpeCA9IF9iLnRhcmdldE1hdHJpeCwgdHJhbnNmb3JtT3JpZ2luID0gX2IudHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICBkYXRhcy5pczNkID0gaXMzZDtcclxuICAgIGRhdGFzLm1hdHJpeCA9IGFsbE1hdHJpeDtcclxuICAgIGRhdGFzLnRhcmdldE1hdHJpeCA9IHRhcmdldE1hdHJpeDtcclxuICAgIGRhdGFzLmJlZm9yZU1hdHJpeCA9IGJlZm9yZU1hdHJpeDtcclxuICAgIGRhdGFzLm9mZnNldE1hdHJpeCA9IG9mZnNldE1hdHJpeDtcclxuICAgIGRhdGFzLnRyYW5zZm9ybU9yaWdpbiA9IHRyYW5zZm9ybU9yaWdpbjtcclxuICAgIGRhdGFzLmludmVyc2VNYXRyaXggPSBpbnZlcnQoYWxsTWF0cml4LCBuKTtcclxuICAgIGRhdGFzLmludmVyc2VCZWZvcmVNYXRyaXggPSBpbnZlcnQoYmVmb3JlTWF0cml4LCBuKTtcclxuICAgIGRhdGFzLmFic29sdXRlT3JpZ2luID0gY29udmVydFBvc2l0aW9uTWF0cml4KHBsdXMoW2xlZnQsIHRvcF0sIG9yaWdpbiksIG4pO1xyXG4gICAgZGF0YXMuc3RhcnREcmFnQmVmb3JlRGlzdCA9IGNhbGN1bGF0ZShkYXRhcy5pbnZlcnNlQmVmb3JlTWF0cml4LCBkYXRhcy5hYnNvbHV0ZU9yaWdpbiwgbik7XHJcbiAgICBkYXRhcy5zdGFydERyYWdEaXN0ID0gY2FsY3VsYXRlKGRhdGFzLmludmVyc2VNYXRyaXgsIGRhdGFzLmFic29sdXRlT3JpZ2luLCBuKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1EaXJlY3Rpb24oZSkge1xyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZUVsZW1lbnRQb3NpdGlvbihlLmRhdGFzLmJlZm9yZVRyYW5zZm9ybSwgWzUwLCA1MF0sIDEwMCwgMTAwKS5kaXJlY3Rpb247XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KG1vdmVhYmxlLCBldmVudCwgZnVuY3Rpb25OYW1lKSB7XHJcbiAgICB2YXIgZGF0YXMgPSBldmVudC5kYXRhcywgb3JpZ2luYWxEYXRhcyA9IGV2ZW50Lm9yaWdpbmFsRGF0YXMuYmVmb3JlUmVuZGVyYWJsZTtcclxuICAgIHZhciBpbmRleCA9IGRhdGFzLnRyYW5zZm9ybUluZGV4O1xyXG4gICAgdmFyIG5leHRUcmFuc2Zvcm1zID0gb3JpZ2luYWxEYXRhcy5uZXh0VHJhbnNmb3JtcztcclxuICAgIHZhciBsZW5ndGggPSBuZXh0VHJhbnNmb3Jtcy5sZW5ndGg7XHJcbiAgICB2YXIgbmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcyA9IG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcztcclxuICAgIHZhciBuZXh0SW5kZXggPSAtMTtcclxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAvLyB0cmFuc2xhdGUgPT4gcm90YXRlID0+IHNjYWxlXHJcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gXCJ0cmFuc2xhdGVcIikge1xyXG4gICAgICAgICAgICBuZXh0SW5kZXggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmdW5jdGlvbk5hbWUgPT09IFwicm90YXRlXCIpIHtcclxuICAgICAgICAgICAgbmV4dEluZGV4ID0gZmluZEluZGV4KG5leHRUcmFuc2Zvcm1zLCBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gdGV4dC5tYXRjaCgvc2NhbGVcXCgvZyk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV4dEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICBuZXh0SW5kZXggPSBuZXh0VHJhbnNmb3Jtcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFzLnRyYW5zZm9ybUluZGV4ID0gbmV4dEluZGV4O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmluZChuZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzLCBmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5pbmRleCA9PT0gaW5kZXggJiYgaW5mby5mdW5jdGlvbk5hbWUgPT09IGZ1bmN0aW9uTmFtZTsgfSkpIHtcclxuICAgICAgICBuZXh0SW5kZXggPSBpbmRleDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5leHRJbmRleCA9IGluZGV4ICsgbmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcy5maWx0ZXIoZnVuY3Rpb24gKGluZm8pIHsgcmV0dXJuIGluZm8uaW5kZXggPCBpbmRleDsgfSkubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdCA9IGNvbnZlcnRUcmFuc2Zvcm1JbmZvKG5leHRUcmFuc2Zvcm1zLCBtb3ZlYWJsZS5zdGF0ZSwgbmV4dEluZGV4KTtcclxuICAgIHZhciB0YXJnZXRGdW5jdGlvbiA9IHJlc3VsdC50YXJnZXRGdW5jdGlvbjtcclxuICAgIHZhciBtYXRGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWUgPT09IFwicm90YXRlXCIgPyBcInJvdGF0ZVpcIiA6IGZ1bmN0aW9uTmFtZTtcclxuICAgIGRhdGFzLmJlZm9yZUZ1bmN0aW9uVGV4dHMgPSByZXN1bHQuYmVmb3JlRnVuY3Rpb25UZXh0cztcclxuICAgIGRhdGFzLmFmdGVyRnVuY3Rpb25UZXh0cyA9IHJlc3VsdC5hZnRlckZ1bmN0aW9uVGV4dHM7XHJcbiAgICBkYXRhcy5iZWZvcmVUcmFuc2Zvcm0gPSByZXN1bHQuYmVmb3JlRnVuY3Rpb25NYXRyaXg7XHJcbiAgICBkYXRhcy5iZWZvcmVUcmFuc2Zvcm0yID0gcmVzdWx0LmJlZm9yZUZ1bmN0aW9uTWF0cml4MjtcclxuICAgIGRhdGFzLnRhcmdldFRhbnNmb3JtID0gcmVzdWx0LnRhcmdldEZ1bmN0aW9uTWF0cml4O1xyXG4gICAgZGF0YXMuYWZ0ZXJUcmFuc2Zvcm0gPSByZXN1bHQuYWZ0ZXJGdW5jdGlvbk1hdHJpeDtcclxuICAgIGRhdGFzLmFmdGVyVHJhbnNmb3JtMiA9IHJlc3VsdC5hZnRlckZ1bmN0aW9uTWF0cml4MjtcclxuICAgIGRhdGFzLnRhcmdldEFsbFRyYW5zZm9ybSA9IHJlc3VsdC5hbGxGdW5jdGlvbk1hdHJpeDtcclxuICAgIGlmICh0YXJnZXRGdW5jdGlvbi5mdW5jdGlvbk5hbWUgPT09IG1hdEZ1bmN0aW9uTmFtZSkge1xyXG4gICAgICAgIGRhdGFzLmFmdGVyRnVuY3Rpb25UZXh0cy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgZGF0YXMuaXNBcHBlbmRUcmFuc2Zvcm0gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlbmd0aCA+IG5leHRJbmRleCkge1xyXG4gICAgICAgIGRhdGFzLmlzQXBwZW5kVHJhbnNmb3JtID0gdHJ1ZTtcclxuICAgICAgICBvcmlnaW5hbERhdGFzLm5leHRUcmFuc2Zvcm1BcHBlbmRlZEluZGV4ZXMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChuZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzKSwgZmFsc2UpLCBbe1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxyXG4gICAgICAgICAgICAgICAgaXNBcHBlbmQ6IHRydWUsXHJcbiAgICAgICAgICAgIH1dLCBmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybUZvcm1hdChkYXRhcywgdmFsdWUsIGRpc3QpIHtcclxuICAgIHJldHVybiBcIlwiLmNvbmNhdChkYXRhcy5iZWZvcmVGdW5jdGlvblRleHRzLmpvaW4oXCIgXCIpLCBcIiBcIikuY29uY2F0KGRhdGFzLmlzQXBwZW5kVHJhbnNmb3JtID8gZGlzdCA6IHZhbHVlLCBcIiBcIikuY29uY2F0KGRhdGFzLmFmdGVyRnVuY3Rpb25UZXh0cy5qb2luKFwiIFwiKSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRGlzdChfYSkge1xyXG4gICAgdmFyIGRhdGFzID0gX2EuZGF0YXMsIGRpc3RYID0gX2EuZGlzdFgsIGRpc3RZID0gX2EuZGlzdFk7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoZ2V0QmVmb3JlRHJhZ0Rpc3QoeyBkYXRhczogZGF0YXMsIGRpc3RYOiBkaXN0WCwgZGlzdFk6IGRpc3RZIH0pLCAyKSwgYnggPSBfYlswXSwgYnkgPSBfYlsxXTtcclxuICAgIC8vIEIgKiBbdHgsIHR5XSAqIEEgPSBbYngsIGJ5XSAqIHRhcmdldE1hdHJpeDtcclxuICAgIC8vIFt0eCwgdHldID0gQi0xICogW2J4LCBieV0gKiB0YXJnZXRNYXRyaXggKiBBLTEgKiBbMCwgMF07XHJcbiAgICB2YXIgcmVzID0gZ2V0VHJhbnNmcm9tTWF0cml4KGRhdGFzLCBmcm9tVHJhbnNsYXRpb24oW2J4LCBieV0sIDQpKTtcclxuICAgIHJldHVybiBjYWxjdWxhdGUocmVzLCBjb252ZXJ0UG9zaXRpb25NYXRyaXgoWzAsIDAsIDBdLCA0KSwgNCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNmcm9tTWF0cml4KGRhdGFzLCB0YXJnZXRNYXRyaXgsIGlzQWZ0ZXIpIHtcclxuICAgIHZhciBiZWZvcmVUcmFuc2Zvcm0gPSBkYXRhcy5iZWZvcmVUcmFuc2Zvcm0sIGFmdGVyVHJhbnNmb3JtID0gZGF0YXMuYWZ0ZXJUcmFuc2Zvcm0sIGJlZm9yZVRyYW5zZm9ybTIgPSBkYXRhcy5iZWZvcmVUcmFuc2Zvcm0yLCBhZnRlclRyYW5zZm9ybTIgPSBkYXRhcy5hZnRlclRyYW5zZm9ybTIsIHRhcmdldEFsbFRyYW5zZm9ybSA9IGRhdGFzLnRhcmdldEFsbFRyYW5zZm9ybTtcclxuICAgIC8vIEIgKiBhZnRlclRhcmdldE1hdHJpeCAqIEEgPSAodGFyZ2V0TWF0cml4ICogdGFyZ2V0QWxsVHJhbnNmb3JtKVxyXG4gICAgLy8gYWZ0ZXJUYXJnZXRNYXRyaXggPSBCLTEgKiB0YXJnZXRNYXRyaXggKiB0YXJnZXRBbGxUcmFuc2Zvcm0gKiBBLTFcclxuICAgIC8vIG5leHRUYXJnZXRNYXRyaXggPSAodGFyZ2V0TWF0cml4ICogdGFyZ2V0QWxsVHJhbnNmb3JtKVxyXG4gICAgdmFyIG5leHRUYXJnZXRNYXRyaXggPSBpc0FmdGVyXHJcbiAgICAgICAgPyBtdWx0aXBseSh0YXJnZXRBbGxUcmFuc2Zvcm0sIHRhcmdldE1hdHJpeCwgNClcclxuICAgICAgICA6IG11bHRpcGx5KHRhcmdldE1hdHJpeCwgdGFyZ2V0QWxsVHJhbnNmb3JtLCA0KTtcclxuICAgIC8vIHJlczEgPSBCLTEgKiBuZXh0VGFyZ2V0TWF0cml4XHJcbiAgICB2YXIgcmVzMSA9IG11bHRpcGx5KGludmVydChpc0FmdGVyID8gYmVmb3JlVHJhbnNmb3JtMiA6IGJlZm9yZVRyYW5zZm9ybSwgNCksIG5leHRUYXJnZXRNYXRyaXgsIDQpO1xyXG4gICAgLy8gcmVzMyA9IHJlczIgKiBBLTFcclxuICAgIHZhciBhZnRlclRhcmdldE1hdHJpeCA9IG11bHRpcGx5KHJlczEsIGludmVydChpc0FmdGVyID8gYWZ0ZXJUcmFuc2Zvcm0yIDogYWZ0ZXJUcmFuc2Zvcm0sIDQpLCA0KTtcclxuICAgIHJldHVybiBhZnRlclRhcmdldE1hdHJpeDtcclxufVxyXG5mdW5jdGlvbiBnZXRCZWZvcmVEcmFnRGlzdChfYSkge1xyXG4gICAgdmFyIGRhdGFzID0gX2EuZGF0YXMsIGRpc3RYID0gX2EuZGlzdFgsIGRpc3RZID0gX2EuZGlzdFk7XHJcbiAgICAvLyBUVCA9IEJUXHJcbiAgICB2YXIgaW52ZXJzZUJlZm9yZU1hdHJpeCA9IGRhdGFzLmludmVyc2VCZWZvcmVNYXRyaXgsIGlzM2QgPSBkYXRhcy5pczNkLCBzdGFydERyYWdCZWZvcmVEaXN0ID0gZGF0YXMuc3RhcnREcmFnQmVmb3JlRGlzdCwgYWJzb2x1dGVPcmlnaW4gPSBkYXRhcy5hYnNvbHV0ZU9yaWdpbjtcclxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgLy8gQUJTX09SSUdJTiAqIFtkaXN0WCwgZGlzdFldID0gQk0gKiAoT1JJR0lOICsgW3R4LCB0eV0pXHJcbiAgICAvLyBCTSAtMSAqIEFCU19PUklHSU4gKiBbZGlzdFgsIGRpc3RZXSAtIE9SSUdJTiA9IFt0eCwgdHldXHJcbiAgICByZXR1cm4gbWludXMoY2FsY3VsYXRlKGludmVyc2VCZWZvcmVNYXRyaXgsIHBsdXMoYWJzb2x1dGVPcmlnaW4sIFtkaXN0WCwgZGlzdFldKSwgbiksIHN0YXJ0RHJhZ0JlZm9yZURpc3QpO1xyXG59XHJcbmZ1bmN0aW9uIGdldERyYWdEaXN0KF9hLCBpc0JlZm9yZSkge1xyXG4gICAgdmFyIGRhdGFzID0gX2EuZGF0YXMsIGRpc3RYID0gX2EuZGlzdFgsIGRpc3RZID0gX2EuZGlzdFk7XHJcbiAgICB2YXIgaW52ZXJzZUJlZm9yZU1hdHJpeCA9IGRhdGFzLmludmVyc2VCZWZvcmVNYXRyaXgsIGludmVyc2VNYXRyaXggPSBkYXRhcy5pbnZlcnNlTWF0cml4LCBpczNkID0gZGF0YXMuaXMzZCwgc3RhcnREcmFnQmVmb3JlRGlzdCA9IGRhdGFzLnN0YXJ0RHJhZ0JlZm9yZURpc3QsIHN0YXJ0RHJhZ0Rpc3QgPSBkYXRhcy5zdGFydERyYWdEaXN0LCBhYnNvbHV0ZU9yaWdpbiA9IGRhdGFzLmFic29sdXRlT3JpZ2luO1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICByZXR1cm4gbWludXMoY2FsY3VsYXRlKGlzQmVmb3JlID8gaW52ZXJzZUJlZm9yZU1hdHJpeCA6IGludmVyc2VNYXRyaXgsIHBsdXMoYWJzb2x1dGVPcmlnaW4sIFtkaXN0WCwgZGlzdFldKSwgbiksIGlzQmVmb3JlID8gc3RhcnREcmFnQmVmb3JlRGlzdCA6IHN0YXJ0RHJhZ0Rpc3QpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEludmVyc2VEcmFnRGlzdChfYSwgaXNCZWZvcmUpIHtcclxuICAgIHZhciBkYXRhcyA9IF9hLmRhdGFzLCBkaXN0WCA9IF9hLmRpc3RYLCBkaXN0WSA9IF9hLmRpc3RZO1xyXG4gICAgdmFyIGJlZm9yZU1hdHJpeCA9IGRhdGFzLmJlZm9yZU1hdHJpeCwgbWF0cml4ID0gZGF0YXMubWF0cml4LCBpczNkID0gZGF0YXMuaXMzZCwgc3RhcnREcmFnQmVmb3JlRGlzdCA9IGRhdGFzLnN0YXJ0RHJhZ0JlZm9yZURpc3QsIHN0YXJ0RHJhZ0Rpc3QgPSBkYXRhcy5zdGFydERyYWdEaXN0LCBhYnNvbHV0ZU9yaWdpbiA9IGRhdGFzLmFic29sdXRlT3JpZ2luO1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICByZXR1cm4gbWludXMoY2FsY3VsYXRlKGlzQmVmb3JlID8gYmVmb3JlTWF0cml4IDogbWF0cml4LCBwbHVzKGlzQmVmb3JlID8gc3RhcnREcmFnQmVmb3JlRGlzdCA6IHN0YXJ0RHJhZ0Rpc3QsIFtkaXN0WCwgZGlzdFldKSwgbiksIGFic29sdXRlT3JpZ2luKTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVUcmFuc2Zvcm1PcmlnaW4odHJhbnNmb3JtT3JpZ2luLCB3aWR0aCwgaGVpZ2h0LCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIHByZXZPcmlnaW4pIHtcclxuICAgIGlmIChwcmV2V2lkdGggPT09IHZvaWQgMCkgeyBwcmV2V2lkdGggPSB3aWR0aDsgfVxyXG4gICAgaWYgKHByZXZIZWlnaHQgPT09IHZvaWQgMCkgeyBwcmV2SGVpZ2h0ID0gaGVpZ2h0OyB9XHJcbiAgICBpZiAocHJldk9yaWdpbiA9PT0gdm9pZCAwKSB7IHByZXZPcmlnaW4gPSBbMCwgMF07IH1cclxuICAgIGlmICghdHJhbnNmb3JtT3JpZ2luKSB7XHJcbiAgICAgICAgcmV0dXJuIHByZXZPcmlnaW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNmb3JtT3JpZ2luLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XHJcbiAgICAgICAgdmFyIF9hID0gc3BsaXRVbml0KHBvcyksIHZhbHVlID0gX2EudmFsdWUsIHVuaXQgPSBfYS51bml0O1xyXG4gICAgICAgIHZhciBwcmV2U2l6ZSA9IChpID8gcHJldkhlaWdodCA6IHByZXZXaWR0aCk7XHJcbiAgICAgICAgdmFyIHNpemUgPSAoaSA/IGhlaWdodCA6IHdpZHRoKTtcclxuICAgICAgICBpZiAocG9zID09PSBcIiVcIiB8fCBpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgLy8gbm8gdmFsdWUgYnV0ICVcclxuICAgICAgICAgICAgdmFyIG1lYXN1cmVSYXRpbyA9IHByZXZTaXplID8gcHJldk9yaWdpbltpXSAvIHByZXZTaXplIDogMDtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUgKiBtZWFzdXJlUmF0aW87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHVuaXQgIT09IFwiJVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpemUgKiB2YWx1ZSAvIDEwMDtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBvc0luZGV4ZXNCeURpcmVjdGlvbihkaXJlY3Rpb24pIHtcclxuICAgIHZhciBpbmRleGVzID0gW107XHJcbiAgICBpZiAoZGlyZWN0aW9uWzFdID49IDApIHtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uWzBdID49IDApIHtcclxuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKDMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyZWN0aW9uWzBdIDw9IDApIHtcclxuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKDIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChkaXJlY3Rpb25bMV0gPD0gMCkge1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPj0gMCkge1xyXG4gICAgICAgICAgICBpbmRleGVzLnB1c2goMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPD0gMCkge1xyXG4gICAgICAgICAgICBpbmRleGVzLnB1c2goMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZGV4ZXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UG9zZXNCeURpcmVjdGlvbihwb3NlcywgZGlyZWN0aW9uKSB7XHJcbiAgICAvKlxyXG4gICAgWy0xLCAtMV0ocG9zMSkgICAgICAgWzAsIC0xXShwb3MxLHBvczIpICAgICAgIFsxLCAtMV0ocG9zMilcclxuICAgIFstMSwgMF0ocG9zMSwgcG9zMykgICAgICAgICAgICAgICAgICAgICAgICAgICBbMSwgMF0ocG9zMiwgcG9zNClcclxuICAgIFstMSwgMV0ocG9zMykgICAgICAgIFswLCAxXShwb3MzLCBwb3M0KSAgICAgICBbMSwgMV0ocG9zNClcclxuICAgICovXHJcbiAgICByZXR1cm4gZ2V0UG9zSW5kZXhlc0J5RGlyZWN0aW9uKGRpcmVjdGlvbikubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gcG9zZXNbaW5kZXhdOyB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRQb3NCeVNpbmdsZURpcmVjdGlvbihwb3NlcywgZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgcmF0aW8gPSAoZGlyZWN0aW9uICsgMSkgLyAyO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBkb3QocG9zZXNbMF1bMF0sIHBvc2VzWzFdWzBdLCByYXRpbywgMSAtIHJhdGlvKSxcclxuICAgICAgICBkb3QocG9zZXNbMF1bMV0sIHBvc2VzWzFdWzFdLCByYXRpbywgMSAtIHJhdGlvKSxcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcmVjdGlvbikge1xyXG4gICAgdmFyIHRvcCA9IGdldFBvc0J5U2luZ2xlRGlyZWN0aW9uKFtwb3Nlc1swXSwgcG9zZXNbMV1dLCBkaXJlY3Rpb25bMF0pO1xyXG4gICAgdmFyIGJvdHRvbSA9IGdldFBvc0J5U2luZ2xlRGlyZWN0aW9uKFtwb3Nlc1syXSwgcG9zZXNbM11dLCBkaXJlY3Rpb25bMF0pO1xyXG4gICAgcmV0dXJuIGdldFBvc0J5U2luZ2xlRGlyZWN0aW9uKFt0b3AsIGJvdHRvbV0sIGRpcmVjdGlvblsxXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGlzdChzdGFydFBvcywgbWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuLCBmaXhlZERpcmVjdGlvbikge1xyXG4gICAgdmFyIHBvc2VzID0gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuKTtcclxuICAgIHZhciBmaXhlZFBvcyA9IGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBmaXhlZERpcmVjdGlvbik7XHJcbiAgICB2YXIgZGlzdFggPSBzdGFydFBvc1swXSAtIGZpeGVkUG9zWzBdO1xyXG4gICAgdmFyIGRpc3RZID0gc3RhcnRQb3NbMV0gLSBmaXhlZFBvc1sxXTtcclxuICAgIHJldHVybiBbZGlzdFgsIGRpc3RZXTtcclxufVxyXG5mdW5jdGlvbiBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgdGFyZ2V0TWF0cml4LCBvcmlnaW4sIG4pIHtcclxuICAgIHJldHVybiBtdWx0aXBseShvZmZzZXRNYXRyaXgsIGdldEFic29sdXRlTWF0cml4KHRhcmdldE1hdHJpeCwgbiwgb3JpZ2luKSwgbik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmV4dFRyYW5zZm9ybU1hdHJpeChzdGF0ZSwgZGF0YXMsIHRyYW5zZm9ybSwgaXNBbGxUcmFuc2Zvcm0pIHtcclxuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW4sIG9mZnNldE1hdHJpeCA9IHN0YXRlLm9mZnNldE1hdHJpeCwgaXMzZCA9IHN0YXRlLmlzM2Q7XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIHZhciB0YXJnZXRUcmFuc2Zvcm07XHJcbiAgICBpZiAoaXNTdHJpbmcodHJhbnNmb3JtKSkge1xyXG4gICAgICAgIHZhciBiZWZvcmVUcmFuc2Zvcm0gPSBkYXRhcy5iZWZvcmVUcmFuc2Zvcm0sIGFmdGVyVHJhbnNmb3JtID0gZGF0YXMuYWZ0ZXJUcmFuc2Zvcm07XHJcbiAgICAgICAgaWYgKGlzQWxsVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFRyYW5zZm9ybSA9IGNvbnZlcnREaW1lbnNpb24ocGFyc2VNYXQodHJhbnNmb3JtKSwgNCwgbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXRUcmFuc2Zvcm0gPSBjb252ZXJ0RGltZW5zaW9uKG11bHRpcGx5KG11bHRpcGx5KGJlZm9yZVRyYW5zZm9ybSwgcGFyc2VNYXQoW3RyYW5zZm9ybV0pLCA0KSwgYWZ0ZXJUcmFuc2Zvcm0sIDQpLCA0LCBuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0TmV4dE1hdHJpeChvZmZzZXRNYXRyaXgsIHRhcmdldFRyYW5zZm9ybSwgdHJhbnNmb3JtT3JpZ2luLCBuKTtcclxufVxyXG5mdW5jdGlvbiBzY2FsZU1hdHJpeChzdGF0ZSwgc2NhbGUpIHtcclxuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW4sIG9mZnNldE1hdHJpeCA9IHN0YXRlLm9mZnNldE1hdHJpeCwgaXMzZCA9IHN0YXRlLmlzM2QsIHRhcmdldE1hdHJpeCA9IHN0YXRlLnRhcmdldE1hdHJpeCwgdGFyZ2V0QWxsVHJhbnNmb3JtID0gc3RhdGUudGFyZ2V0QWxsVHJhbnNmb3JtO1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICByZXR1cm4gZ2V0TmV4dE1hdHJpeChvZmZzZXRNYXRyaXgsIG11bHRpcGx5KHRhcmdldEFsbFRyYW5zZm9ybSB8fCB0YXJnZXRNYXRyaXgsIGNyZWF0ZVNjYWxlTWF0cml4KHNjYWxlLCBuKSwgbiksIHRyYW5zZm9ybU9yaWdpbiwgbik7XHJcbn1cclxuZnVuY3Rpb24gZmlsbFRyYW5zZm9ybVN0YXJ0RXZlbnQobW92ZWFibGUsIGUpIHtcclxuICAgIHZhciBvcmlnaW5hbERhdGFzID0gZ2V0QmVmb3JlUmVuZGVyYWJsZURhdGFzKGUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cclxuICAgICAgICAgICAgb3JpZ2luYWxEYXRhcy5zdGFydFRyYW5zZm9ybXMgPSBpc0FycmF5KHRyYW5zZm9ybSkgPyB0cmFuc2Zvcm0gOiBzcGxpdFNwYWNlKHRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgIHNldFRyYW5zZm9ybUluZGV4KG1vdmVhYmxlLCBlLCBpbmRleCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRUcmFuc2Zvcm1JbmRleDogZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHNldFRyYW5zZm9ybUluZGV4KG1vdmVhYmxlLCBlLCBpbmRleCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gc2V0RGVmYXVsdFRyYW5zZm9ybUluZGV4KG1vdmVhYmxlLCBlLCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIG9yaWdpbmFsRGF0YXMgPSBnZXRCZWZvcmVSZW5kZXJhYmxlRGF0YXMoZSk7XHJcbiAgICB2YXIgc3RhcnRUcmFuc2Zvcm1zID0gb3JpZ2luYWxEYXRhcy5zdGFydFRyYW5zZm9ybXM7XHJcbiAgICBzZXRUcmFuc2Zvcm1JbmRleChtb3ZlYWJsZSwgZSwgZmluZEluZGV4KHN0YXJ0VHJhbnNmb3JtcywgZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIGZ1bmMuaW5kZXhPZihcIlwiLmNvbmNhdChwcm9wZXJ0eSwgXCIoXCIpKSA9PT0gMDsgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHNldFRyYW5zZm9ybUluZGV4KG1vdmVhYmxlLCBlLCBpbmRleCkge1xyXG4gICAgdmFyIG9yaWdpbmFsRGF0YXMgPSBnZXRCZWZvcmVSZW5kZXJhYmxlRGF0YXMoZSk7XHJcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgZGF0YXMudHJhbnNmb3JtSW5kZXggPSBpbmRleDtcclxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgdHJhbnNmb3JtID0gb3JpZ2luYWxEYXRhcy5zdGFydFRyYW5zZm9ybXNbaW5kZXhdO1xyXG4gICAgaWYgKCF0cmFuc2Zvcm0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgIHZhciBpbmZvID0gcGFyc2UoW3RyYW5zZm9ybV0sIHtcclxuICAgICAgICBcInglXCI6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2IC8gMTAwICogc3RhdGUub2Zmc2V0V2lkdGg7IH0sXHJcbiAgICAgICAgXCJ5JVwiOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAvIDEwMCAqIHN0YXRlLm9mZnNldEhlaWdodDsgfSxcclxuICAgIH0pO1xyXG4gICAgZGF0YXMuc3RhcnRWYWx1ZSA9IGluZm9bMF0uZnVuY3Rpb25WYWx1ZTtcclxufVxyXG5mdW5jdGlvbiBmaWxsT3JpZ2luYWxUcmFuc2Zvcm0oZSwgdHJhbnNmb3JtKSB7XHJcbiAgICB2YXIgb3JpZ2luYWxEYXRhcyA9IGdldEJlZm9yZVJlbmRlcmFibGVEYXRhcyhlKTtcclxuICAgIG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybXMgPSBzcGxpdFNwYWNlKHRyYW5zZm9ybSk7XHJcbiAgICAvLyBvcmlnaW5hbERhdGFzLm5leHRUYXJnZXRNYXRyaXggPSBwYXJzZU1hdCh0cmFuc2Zvcm0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEJlZm9yZVJlbmRlcmFibGVEYXRhcyhlKSB7XHJcbiAgICByZXR1cm4gZS5vcmlnaW5hbERhdGFzLmJlZm9yZVJlbmRlcmFibGU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmV4dFRyYW5zZm9ybXMoZSkge1xyXG4gICAgdmFyIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXMuYmVmb3JlUmVuZGVyYWJsZTtcclxuICAgIHJldHVybiBvcmlnaW5hbERhdGFzLm5leHRUcmFuc2Zvcm1zO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5leHRUcmFuc2Zvcm1UZXh0KGUpIHtcclxuICAgIHJldHVybiAoZ2V0TmV4dFRyYW5zZm9ybXMoZSkgfHwgW10pLmpvaW4oXCIgXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5leHRTdHlsZShlKSB7XHJcbiAgICByZXR1cm4gZ2V0QmVmb3JlUmVuZGVyYWJsZURhdGFzKGUpLm5leHRTdHlsZTtcclxufVxyXG5mdW5jdGlvbiBmaWxsVHJhbnNmb3JtRXZlbnQobW92ZWFibGUsIG5leHRUcmFuc2Zvcm0sIGRlbHRhLCBpc1BpbmNoLCBlKSB7XHJcbiAgICBmaWxsT3JpZ2luYWxUcmFuc2Zvcm0oZSwgbmV4dFRyYW5zZm9ybSk7XHJcbiAgICB2YXIgZHJhZyA9IERyYWdnYWJsZS5kcmFnKG1vdmVhYmxlLCBzZXRDdXN0b21EcmFnKGUsIG1vdmVhYmxlLnN0YXRlLCBkZWx0YSwgaXNQaW5jaCwgZmFsc2UpKTtcclxuICAgIHZhciBhZnRlclRyYW5zZm9ybSA9IGRyYWcgPyBkcmFnLnRyYW5zZm9ybSA6IG5leHRUcmFuc2Zvcm07XHJcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oeyB0cmFuc2Zvcm06IG5leHRUcmFuc2Zvcm0sIGRyYWc6IGRyYWcgfSwgZmlsbENTU09iamVjdCh7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybSxcclxuICAgIH0sIGUpKSwgeyBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0gfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlRml4ZWRQb3NpdGlvbihtb3ZlYWJsZSwgdHJhbnNmb3JtLCBmaXhlZERpcmVjdGlvbiwgZml4ZWRPZmZzZXQsIGRhdGFzLCBpc0FsbFRyYW5zZm9ybSkge1xyXG4gICAgdmFyIG5leHRNYXRyaXggPSBnZXROZXh0VHJhbnNmb3JtTWF0cml4KG1vdmVhYmxlLnN0YXRlLCBkYXRhcywgdHJhbnNmb3JtLCBpc0FsbFRyYW5zZm9ybSk7XHJcbiAgICB2YXIgbmV4dEZpeGVkUG9zaXRpb24gPSBnZXREaXJlY3Rpb25PZmZzZXQobW92ZWFibGUsIGZpeGVkRGlyZWN0aW9uLCBmaXhlZE9mZnNldCwgbmV4dE1hdHJpeCk7XHJcbiAgICByZXR1cm4gbmV4dEZpeGVkUG9zaXRpb247XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlRGlzdChtb3ZlYWJsZSwgdHJhbnNmb3JtLCBmaXhlZERpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZml4ZWRPZmZzZXQsIGRhdGFzLCBpc0FsbFRyYW5zZm9ybSkge1xyXG4gICAgdmFyIG5leHRGaXhlZFBvc2l0aW9uID0gZ2V0VHJhbnNsYXRlRml4ZWRQb3NpdGlvbihtb3ZlYWJsZSwgdHJhbnNmb3JtLCBmaXhlZERpcmVjdGlvbiwgZml4ZWRPZmZzZXQsIGRhdGFzLCBpc0FsbFRyYW5zZm9ybSk7XHJcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgIHZhciBsZWZ0ID0gc3RhdGUubGVmdCwgdG9wID0gc3RhdGUudG9wO1xyXG4gICAgdmFyIGdyb3VwYWJsZSA9IG1vdmVhYmxlLnByb3BzLmdyb3VwYWJsZTtcclxuICAgIHZhciBncm91cExlZnQgPSBncm91cGFibGUgPyBsZWZ0IDogMDtcclxuICAgIHZhciBncm91cFRvcCA9IGdyb3VwYWJsZSA/IHRvcCA6IDA7XHJcbiAgICB2YXIgZGlzdCA9IG1pbnVzKGZpeGVkUG9zaXRpb24sIG5leHRGaXhlZFBvc2l0aW9uKTtcclxuICAgIHJldHVybiBtaW51cyhkaXN0LCBbZ3JvdXBMZWZ0LCBncm91cFRvcF0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNjYWxlRGlzdChtb3ZlYWJsZSwgdHJhbnNmb3JtLCBmaXhlZERpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZml4ZWRPZmZzZXQsIGRhdGFzLCBpc0FsbFRyYW5zZm9ybSkge1xyXG4gICAgdmFyIGRpc3QgPSBnZXRUcmFuc2xhdGVEaXN0KG1vdmVhYmxlLCB0cmFuc2Zvcm0sIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBmaXhlZE9mZnNldCwgZGF0YXMsIGlzQWxsVHJhbnNmb3JtKTtcclxuICAgIHJldHVybiBkaXN0O1xyXG59XHJcbmZ1bmN0aW9uIGdldERpcmVjdGlvbkJ5UG9zKHBvcywgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICB3aWR0aCA/IC0xICsgcG9zWzBdIC8gKHdpZHRoIC8gMikgOiAwLFxyXG4gICAgICAgIGhlaWdodCA/IC0xICsgcG9zWzFdIC8gKGhlaWdodCAvIDIpIDogMCxcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uT2Zmc2V0KG1vdmVhYmxlLCBmaXhlZERpcmVjdGlvbiwgZml4ZWRPZmZzZXQsIG5leHRNYXRyaXgpIHtcclxuICAgIGlmIChuZXh0TWF0cml4ID09PSB2b2lkIDApIHsgbmV4dE1hdHJpeCA9IG1vdmVhYmxlLnN0YXRlLmFsbE1hdHJpeDsgfVxyXG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodCwgaXMzZCA9IF9hLmlzM2Q7XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIHZhciBmaXhlZE9mZnNldFBvc2l0aW9uID0gW1xyXG4gICAgICAgIHdpZHRoIC8gMiAqICgxICsgZml4ZWREaXJlY3Rpb25bMF0pICsgZml4ZWRPZmZzZXRbMF0sXHJcbiAgICAgICAgaGVpZ2h0IC8gMiAqICgxICsgZml4ZWREaXJlY3Rpb25bMV0pICsgZml4ZWRPZmZzZXRbMV0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZVBvc2l0aW9uKG5leHRNYXRyaXgsIGZpeGVkT2Zmc2V0UG9zaXRpb24sIG4pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFJvdGF0ZURpc3QobW92ZWFibGUsIHJvdGF0ZURpc3QsIGRhdGFzKSB7XHJcbiAgICB2YXIgZml4ZWREaXJlY3Rpb24gPSBkYXRhcy5maXhlZERpcmVjdGlvbjtcclxuICAgIHZhciBmaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcclxuICAgIHZhciBmaXhlZE9mZnNldCA9IGRhdGFzLmZpeGVkT2Zmc2V0O1xyXG4gICAgcmV0dXJuIGdldFRyYW5zbGF0ZURpc3QobW92ZWFibGUsIFwicm90YXRlKFwiLmNvbmNhdChyb3RhdGVEaXN0LCBcImRlZylcIiksIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBmaXhlZE9mZnNldCwgZGF0YXMpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFJlc2l6ZURpc3QobW92ZWFibGUsIHdpZHRoLCBoZWlnaHQsIGZpeGVkUG9zaXRpb24sIHRyYW5zZm9ybU9yaWdpbiwgZGF0YXMpIHtcclxuICAgIHZhciBncm91cGFibGUgPSBtb3ZlYWJsZS5wcm9wcy5ncm91cGFibGU7XHJcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgIHZhciBwcmV2T3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luLCBvZmZzZXRNYXRyaXggPSBzdGF0ZS5vZmZzZXRNYXRyaXgsIGlzM2QgPSBzdGF0ZS5pczNkLCBwcmV2V2lkdGggPSBzdGF0ZS53aWR0aCwgcHJldkhlaWdodCA9IHN0YXRlLmhlaWdodCwgbGVmdCA9IHN0YXRlLmxlZnQsIHRvcCA9IHN0YXRlLnRvcDtcclxuICAgIHZhciBmaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgdmFyIHRhcmdldE1hdHJpeCA9IGRhdGFzLm5leHRUYXJnZXRNYXRyaXggfHwgc3RhdGUudGFyZ2V0TWF0cml4O1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICB2YXIgbmV4dE9yaWdpbiA9IGNhbGN1bGF0ZVRyYW5zZm9ybU9yaWdpbih0cmFuc2Zvcm1PcmlnaW4sIHdpZHRoLCBoZWlnaHQsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgcHJldk9yaWdpbik7XHJcbiAgICB2YXIgZ3JvdXBMZWZ0ID0gZ3JvdXBhYmxlID8gbGVmdCA6IDA7XHJcbiAgICB2YXIgZ3JvdXBUb3AgPSBncm91cGFibGUgPyB0b3AgOiAwO1xyXG4gICAgdmFyIG5leHRNYXRyaXggPSBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgdGFyZ2V0TWF0cml4LCBuZXh0T3JpZ2luLCBuKTtcclxuICAgIHZhciBkaXN0ID0gZ2V0RGlzdChmaXhlZFBvc2l0aW9uLCBuZXh0TWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuLCBmaXhlZERpcmVjdGlvbik7XHJcbiAgICByZXR1cm4gbWludXMoZGlzdCwgW2dyb3VwTGVmdCwgZ3JvdXBUb3BdKTtcclxufVxyXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVBvc2l0aW9uKG1vdmVhYmxlLCBkaXJlY3Rpb24pIHtcclxuICAgIHJldHVybiBnZXRQb3NCeURpcmVjdGlvbihnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSksIGRpcmVjdGlvbik7XHJcbn1cblxuZnVuY3Rpb24gZ2V0R2VzdG9EYXRhKG1vdmVhYmxlLCBhYmxlTmFtZSkge1xyXG4gICAgdmFyIHRhcmdldEdlc3RvID0gbW92ZWFibGUudGFyZ2V0R2VzdG87XHJcbiAgICB2YXIgY29udHJvbEdlc3RvID0gbW92ZWFibGUuY29udHJvbEdlc3RvO1xyXG4gICAgdmFyIGRhdGE7XHJcbiAgICBpZiAodGFyZ2V0R2VzdG8gPT09IG51bGwgfHwgdGFyZ2V0R2VzdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldEdlc3RvLmlzRmxhZygpKSB7XHJcbiAgICAgICAgZGF0YSA9IHRhcmdldEdlc3RvLmdldEV2ZW50RGF0YSgpW2FibGVOYW1lXTtcclxuICAgIH1cclxuICAgIGlmICghZGF0YSAmJiAoY29udHJvbEdlc3RvID09PSBudWxsIHx8IGNvbnRyb2xHZXN0byA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udHJvbEdlc3RvLmlzRmxhZygpKSkge1xyXG4gICAgICAgIGRhdGEgPSBjb250cm9sR2VzdG8uZ2V0RXZlbnREYXRhKClbYWJsZU5hbWVdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGEgfHwge307XHJcbn1cblxuZnVuY3Rpb24gZ2V0U2hhZG93Um9vdChwYXJlbnRFbGVtZW50KSB7XHJcbiAgICBpZiAocGFyZW50RWxlbWVudCAmJiBwYXJlbnRFbGVtZW50LmdldFJvb3ROb2RlKSB7XHJcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gcGFyZW50RWxlbWVudC5nZXRSb290Tm9kZSgpO1xyXG4gICAgICAgIGlmIChyb290Tm9kZS5ub2RlVHlwZSA9PT0gMTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvb3ROb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybjtcclxufVxyXG5mdW5jdGlvbiBnZXRJbmRpdmlkdWFsVHJhbnNmb3JtcyhnZXRTdHlsZSkge1xyXG4gICAgdmFyIHNjYWxlID0gZ2V0U3R5bGUoXCJzY2FsZVwiKTtcclxuICAgIHZhciByb3RhdGUgPSBnZXRTdHlsZShcInJvdGF0ZVwiKTtcclxuICAgIHZhciB0cmFuc2xhdGUgPSBnZXRTdHlsZShcInRyYW5zbGF0ZVwiKTtcclxuICAgIHZhciBpbmRpdmlkdWFsVHJhbnNmb3JtcyA9IFtdO1xyXG4gICAgaWYgKHRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgIT09IFwiMHB4XCIgJiYgdHJhbnNsYXRlICE9PSBcIm5vbmVcIikge1xyXG4gICAgICAgIGluZGl2aWR1YWxUcmFuc2Zvcm1zLnB1c2goXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRyYW5zbGF0ZS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIsXCIpLCBcIilcIikpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJvdGF0ZSAmJiByb3RhdGUgIT09IFwiMVwiICYmIHJvdGF0ZSAhPT0gXCJub25lXCIpIHtcclxuICAgICAgICBpbmRpdmlkdWFsVHJhbnNmb3Jtcy5wdXNoKFwicm90YXRlKFwiLmNvbmNhdChyb3RhdGUsIFwiKVwiKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2NhbGUgJiYgc2NhbGUgIT09IFwiMVwiICYmIHNjYWxlICE9PSBcIm5vbmVcIikge1xyXG4gICAgICAgIGluZGl2aWR1YWxUcmFuc2Zvcm1zLnB1c2goXCJzY2FsZShcIi5jb25jYXQoc2NhbGUuc3BsaXQoL1xccysvKS5qb2luKFwiLFwiKSwgXCIpXCIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbmRpdmlkdWFsVHJhbnNmb3JtcztcclxufVxyXG5mdW5jdGlvbiBnZXRNYXRyaXhTdGFja0luZm8odGFyZ2V0LCBjb250YWluZXIsIGNoZWNrQ29udGFpbmVyKSB7XHJcbiAgICB2YXIgZWwgPSB0YXJnZXQ7XHJcbiAgICB2YXIgbWF0cml4ZXMgPSBbXTtcclxuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQodGFyZ2V0KSB8fCBnZXREb2N1bWVudEJvZHkodGFyZ2V0KTtcclxuICAgIHZhciByZXF1ZXN0RW5kID0gIWNoZWNrQ29udGFpbmVyICYmIHRhcmdldCA9PT0gY29udGFpbmVyIHx8IHRhcmdldCA9PT0gZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgdmFyIGlzRW5kID0gcmVxdWVzdEVuZDtcclxuICAgIHZhciBpczNkID0gZmFsc2U7XHJcbiAgICB2YXIgbiA9IDM7XHJcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgdmFyIHRhcmdldFRyYW5zZm9ybU9yaWdpbjtcclxuICAgIHZhciB0YXJnZXRNYXRyaXg7XHJcbiAgICB2YXIgaGFzRml4ZWQgPSBmYWxzZTtcclxuICAgIHZhciBvZmZzZXRDb250YWluZXIgPSBnZXRPZmZzZXRJbmZvKGNvbnRhaW5lciwgY29udGFpbmVyLCB0cnVlKS5vZmZzZXRQYXJlbnQ7XHJcbiAgICB2YXIgem9vbSA9IDE7XHJcbiAgICB3aGlsZSAoZWwgJiYgIWlzRW5kKSB7XHJcbiAgICAgICAgaXNFbmQgPSByZXF1ZXN0RW5kO1xyXG4gICAgICAgIHZhciBnZXRTdHlsZSA9IGdldENhY2hlZFN0eWxlKGVsKTtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBnZXRTdHlsZShcInBvc2l0aW9uXCIpO1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBnZXRFbGVtZW50VHJhbnNmb3JtKGVsKTtcclxuICAgICAgICB2YXIgaXNGaXhlZCA9IHBvc2l0aW9uID09PSBcImZpeGVkXCI7XHJcbiAgICAgICAgdmFyIGluZGl2aWR1YWxUcmFuc2Zvcm1zID0gZ2V0SW5kaXZpZHVhbFRyYW5zZm9ybXMoZ2V0U3R5bGUpO1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBjb252ZXJ0Q1NTdG9NYXRyaXgoZ2V0VHJhbnNmb3JtTWF0cml4KHRyYW5zZm9ybSkpO1xyXG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSB2b2lkIDA7XHJcbiAgICAgICAgdmFyIGlzT2Zmc2V0RW5kID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGlzU3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHBhcmVudENsaWVudExlZnQgPSAwO1xyXG4gICAgICAgIHZhciBwYXJlbnRDbGllbnRUb3AgPSAwO1xyXG4gICAgICAgIHZhciBmaXhlZENsaWVudExlZnQgPSAwO1xyXG4gICAgICAgIHZhciBmaXhlZENsaWVudFRvcCA9IDA7XHJcbiAgICAgICAgdmFyIGZpeGVkSW5mbyA9IHtcclxuICAgICAgICAgICAgaGFzVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgZml4ZWRDb250YWluZXI6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaXNGaXhlZCkge1xyXG4gICAgICAgICAgICBoYXNGaXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZpeGVkSW5mbyA9IGdldFBvc2l0aW9uRml4ZWRJbmZvKGVsKTtcclxuICAgICAgICAgICAgb2Zmc2V0Q29udGFpbmVyID0gZml4ZWRJbmZvLmZpeGVkQ29udGFpbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb252ZXJ0IDMgdG8gNFxyXG4gICAgICAgIHZhciBsZW5ndGhfMSA9IG1hdHJpeC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKCFpczNkICYmIChsZW5ndGhfMSA9PT0gMTYgfHwgaW5kaXZpZHVhbFRyYW5zZm9ybXMubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICBpczNkID0gdHJ1ZTtcclxuICAgICAgICAgICAgbiA9IDQ7XHJcbiAgICAgICAgICAgIGNvbnZlcnQzRE1hdHJpeGVzKG1hdHJpeGVzKTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldE1hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0TWF0cml4ID0gY29udmVydERpbWVuc2lvbih0YXJnZXRNYXRyaXgsIDMsIDQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpczNkICYmIGxlbmd0aF8xID09PSA5KSB7XHJcbiAgICAgICAgICAgIG1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24obWF0cml4LCAzLCA0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9hID0gZ2V0T2Zmc2V0UG9zSW5mbyhlbCwgdGFyZ2V0KSwgdGFnTmFtZSA9IF9hLnRhZ05hbWUsIGhhc09mZnNldCA9IF9hLmhhc09mZnNldCwgaXNTVkcgPSBfYS5pc1NWRywgb3JpZ2luXzEgPSBfYS5vcmlnaW4sIHRhcmdldE9yaWdpbiA9IF9hLnRhcmdldE9yaWdpbiwgb2Zmc2V0UG9zID0gX2Eub2Zmc2V0O1xyXG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChvZmZzZXRQb3MsIDIpLCBvZmZzZXRMZWZ0ID0gX2JbMF0sIG9mZnNldFRvcCA9IF9iWzFdO1xyXG4gICAgICAgIC8vIG5vIHRhcmdldCB3aXRoIHN2Z1xyXG4gICAgICAgIGlmICh0YWdOYW1lID09PSBcInN2Z1wiICYmICFlbC5vd25lclNWR0VsZW1lbnQgJiYgdGFyZ2V0TWF0cml4KSB7XHJcbiAgICAgICAgICAgIC8vIHNjYWxlIG1hdHJpeCBmb3Igc3ZnJ3MgU1ZHRWxlbWVudHMuXHJcbiAgICAgICAgICAgIG1hdHJpeGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0YXJnZXRcIixcclxuICAgICAgICAgICAgICAgIHRhcmdldDogZWwsXHJcbiAgICAgICAgICAgICAgICBtYXRyaXg6IGdldFNWR01hdHJpeChlbCwgbiksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtYXRyaXhlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwib2Zmc2V0XCIsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGVsLFxyXG4gICAgICAgICAgICAgICAgbWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0YXJnZXRab29tID0gcGFyc2VGbG9hdChnZXRTdHlsZShcInpvb21cIikpIHx8IDE7XHJcbiAgICAgICAgaWYgKGlzRml4ZWQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gZml4ZWRJbmZvLmZpeGVkQ29udGFpbmVyO1xyXG4gICAgICAgICAgICBpc09mZnNldEVuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0SW5mbyA9IGdldE9mZnNldEluZm8oZWwsIGNvbnRhaW5lciwgZmFsc2UsIHRydWUsIGdldFN0eWxlKTtcclxuICAgICAgICAgICAgdmFyIG9mZnNldFpvb20gPSBvZmZzZXRJbmZvLm9mZnNldFpvb207XHJcbiAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldEluZm8ub2Zmc2V0UGFyZW50O1xyXG4gICAgICAgICAgICBpc09mZnNldEVuZCA9IG9mZnNldEluZm8uaXNFbmQ7XHJcbiAgICAgICAgICAgIGlzU3RhdGljID0gb2Zmc2V0SW5mby5pc1N0YXRpYztcclxuICAgICAgICAgICAgem9vbSAqPSBvZmZzZXRab29tO1xyXG4gICAgICAgICAgICBpZiAoKG9mZnNldEluZm8uaXNDdXN0b21FbGVtZW50IHx8IG9mZnNldFpvb20gIT09IDEpICYmIGlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0IC09IG9mZnNldFBhcmVudC5vZmZzZXRMZWZ0O1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0VG9wIC09IG9mZnNldFBhcmVudC5vZmZzZXRUb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoSVNfRklSRUZPWCB8fCBJU19DSFJPTUlVTTEwOSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFNsb3RFbGVtZW50ID0gb2Zmc2V0SW5mby5wYXJlbnRTbG90RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRTbG90RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXN0b21PZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbU9mZnNldExlZnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXN0b21PZmZzZXRUb3AgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXN0b21PZmZzZXRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnZXRTaGFkb3dSb290KGN1c3RvbU9mZnNldFBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbU9mZnNldExlZnQgKz0gY3VzdG9tT2Zmc2V0UGFyZW50Lm9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbU9mZnNldFRvcCArPSBjdXN0b21PZmZzZXRQYXJlbnQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21PZmZzZXRQYXJlbnQgPSBjdXN0b21PZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0IC09IGN1c3RvbU9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wIC09IGN1c3RvbU9mZnNldFRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoSVNfV0VCS0lUICYmICFJU19TQUZBUklfQUJPVkUxNVxyXG4gICAgICAgICAgICAmJiBoYXNPZmZzZXQgJiYgIWlzU1ZHICYmIGlzU3RhdGljXHJcbiAgICAgICAgICAgICYmIChwb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHBvc2l0aW9uID09PSBcInN0YXRpY1wiKSkge1xyXG4gICAgICAgICAgICBvZmZzZXRMZWZ0IC09IG9mZnNldFBhcmVudC5vZmZzZXRMZWZ0O1xyXG4gICAgICAgICAgICBvZmZzZXRUb3AgLT0gb2Zmc2V0UGFyZW50Lm9mZnNldFRvcDtcclxuICAgICAgICAgICAgcmVxdWVzdEVuZCA9IHJlcXVlc3RFbmQgfHwgaXNPZmZzZXRFbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0ZpeGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNPZmZzZXQgJiYgZml4ZWRJbmZvLmhhc1RyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYm9yZGVyXHJcbiAgICAgICAgICAgICAgICBmaXhlZENsaWVudExlZnQgPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcclxuICAgICAgICAgICAgICAgIGZpeGVkQ2xpZW50VG9wID0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGhhc09mZnNldCAmJiBvZmZzZXRDb250YWluZXIgIT09IG9mZnNldFBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gYm9yZGVyXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDbGllbnRMZWZ0ID0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDbGllbnRUb3AgPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYXNPZmZzZXQgJiYgb2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXJnaW4gPSBnZXRCb2R5T2Zmc2V0KGVsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ICs9IG1hcmdpblswXTtcclxuICAgICAgICAgICAgICAgIG9mZnNldFRvcCArPSBtYXJnaW5bMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWF0cml4ZXMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwidGFyZ2V0XCIsXHJcbiAgICAgICAgICAgIHRhcmdldDogZWwsXHJcbiAgICAgICAgICAgIG1hdHJpeDogZ2V0QWJzb2x1dGVNYXRyaXgobWF0cml4LCBuLCBvcmlnaW5fMSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGluZGl2aWR1YWxUcmFuc2Zvcm1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtYXRyaXhlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwib2Zmc2V0XCIsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGVsLFxyXG4gICAgICAgICAgICAgICAgbWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1hdHJpeGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0YXJnZXRcIixcclxuICAgICAgICAgICAgICAgIHRhcmdldDogZWwsXHJcbiAgICAgICAgICAgICAgICBtYXRyaXg6IGdldEFic29sdXRlTWF0cml4KHBhcnNlTWF0KGluZGl2aWR1YWxUcmFuc2Zvcm1zKSwgbiwgb3JpZ2luXzEpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc09mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgaXNFbGVtZW50VGFyZ2V0ID0gZWwgPT09IHRhcmdldDtcclxuICAgICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBpc0VsZW1lbnRUYXJnZXQgPyAwIDogZWwuc2Nyb2xsTGVmdDtcclxuICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IGlzRWxlbWVudFRhcmdldCA/IDAgOiBlbC5zY3JvbGxUb3A7XHJcbiAgICAgICAgICAgIG1hdHJpeGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJvZmZzZXRcIixcclxuICAgICAgICAgICAgICAgIHRhcmdldDogZWwsXHJcbiAgICAgICAgICAgICAgICBtYXRyaXg6IGNyZWF0ZU9yaWdpbk1hdHJpeChbXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCAtIHNjcm9sbExlZnQgKyBwYXJlbnRDbGllbnRMZWZ0IC0gZml4ZWRDbGllbnRMZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCAtIHNjcm9sbFRvcCArIHBhcmVudENsaWVudFRvcCAtIGZpeGVkQ2xpZW50VG9wLFxyXG4gICAgICAgICAgICAgICAgXSwgbiksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc3ZnXHJcbiAgICAgICAgICAgIG1hdHJpeGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJvZmZzZXRcIixcclxuICAgICAgICAgICAgICAgIHRhcmdldDogZWwsXHJcbiAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbl8xLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHJhbnNmb3Jt7Jy866GcIOqzhOyCsOuQmOyngCDslYrripQgem9vbeydhCDsnITtlZwgKDAsIDApIOydhCDquLDspIAgbWF0cml4IOy2lOqwgC5cclxuICAgICAgICBpZiAodGFyZ2V0Wm9vbSAhPT0gMSkge1xyXG4gICAgICAgICAgICBtYXRyaXhlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiem9vbVwiLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBlbCxcclxuICAgICAgICAgICAgICAgIG1hdHJpeDogZ2V0QWJzb2x1dGVNYXRyaXgoY3JlYXRlU2NhbGVNYXRyaXgoW3RhcmdldFpvb20sIHRhcmdldFpvb21dLCBuKSwgbiwgWzAsIDBdKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGFyZ2V0TWF0cml4KSB7XHJcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeCA9IG1hdHJpeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1PcmlnaW4pIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luXzE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtT3JpZ2luKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFRyYW5zZm9ybU9yaWdpbiA9IHRhcmdldE9yaWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRW5kIHx8IGlzRml4ZWQpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbCA9IG9mZnNldFBhcmVudDtcclxuICAgICAgICAgICAgcmVxdWVzdEVuZCA9IGlzT2Zmc2V0RW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNoZWNrQ29udGFpbmVyIHx8IGVsID09PSBkb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaXNFbmQgPSByZXF1ZXN0RW5kO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghdGFyZ2V0TWF0cml4KSB7XHJcbiAgICAgICAgdGFyZ2V0TWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XHJcbiAgICB9XHJcbiAgICBpZiAoIXRyYW5zZm9ybU9yaWdpbikge1xyXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IFswLCAwXTtcclxuICAgIH1cclxuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtT3JpZ2luKSB7XHJcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtT3JpZ2luID0gWzAsIDBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB6b29tOiB6b29tLFxyXG4gICAgICAgIG9mZnNldENvbnRhaW5lcjogb2Zmc2V0Q29udGFpbmVyLFxyXG4gICAgICAgIG1hdHJpeGVzOiBtYXRyaXhlcyxcclxuICAgICAgICB0YXJnZXRNYXRyaXg6IHRhcmdldE1hdHJpeCxcclxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpbixcclxuICAgICAgICB0YXJnZXRPcmlnaW46IHRhcmdldFRyYW5zZm9ybU9yaWdpbixcclxuICAgICAgICBpczNkOiBpczNkLFxyXG4gICAgICAgIGhhc0ZpeGVkOiBoYXNGaXhlZCxcclxuICAgIH07XHJcbn1cblxudmFyIGNhY2hlU3R5bGVNYXAgPSBudWxsO1xyXG52YXIgY2xpZW50UmVjdFN0eWxlTWFwID0gbnVsbDtcclxudmFyIG1hdHJpeENvbnRhaW5lckluZm9zID0gbnVsbDtcclxuZnVuY3Rpb24gc2V0U3RvcmVDYWNoZSh1c2VDYWNoZSkge1xyXG4gICAgaWYgKHVzZUNhY2hlKSB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5NYXApIHtcclxuICAgICAgICAgICAgY2FjaGVTdHlsZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgY2xpZW50UmVjdFN0eWxlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXRyaXhDb250YWluZXJJbmZvcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2FjaGVTdHlsZU1hcCA9IG51bGw7XHJcbiAgICAgICAgbWF0cml4Q29udGFpbmVySW5mb3MgPSBudWxsO1xyXG4gICAgICAgIGNsaWVudFJlY3RTdHlsZU1hcCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ2xpZW50UmVjdChlbCkge1xyXG4gICAgdmFyIGNsaWVudFJlY3QgPSBjbGllbnRSZWN0U3R5bGVNYXAgPT09IG51bGwgfHwgY2xpZW50UmVjdFN0eWxlTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGllbnRSZWN0U3R5bGVNYXAuZ2V0KGVsKTtcclxuICAgIGlmIChjbGllbnRSZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgbmV4dENsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0KGVsLCB0cnVlKTtcclxuICAgIGlmIChjbGllbnRSZWN0U3R5bGVNYXApIHtcclxuICAgICAgICBjbGllbnRSZWN0U3R5bGVNYXAuc2V0KGVsLCBuZXh0Q2xpZW50UmVjdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV4dENsaWVudFJlY3Q7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2FjaGVkTWF0cml4Q29udGFpbmVySW5mbyh0YXJnZXQsIGNvbnRhaW5lcikge1xyXG4gICAgaWYgKG1hdHJpeENvbnRhaW5lckluZm9zKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdF8xID0gZmluZChtYXRyaXhDb250YWluZXJJbmZvcywgZnVuY3Rpb24gKGluZm8pIHsgcmV0dXJuIGluZm9bMF1bMF0gPT0gdGFyZ2V0ICYmIGluZm9bMF1bMV0gPT0gY29udGFpbmVyOyB9KTtcclxuICAgICAgICBpZiAocmVzdWx0XzEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF8xWzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciByZXN1bHQgPSBnZXRNYXRyaXhTdGFja0luZm8odGFyZ2V0LCBjb250YWluZXIsIHRydWUpO1xyXG4gICAgaWYgKG1hdHJpeENvbnRhaW5lckluZm9zKSB7XHJcbiAgICAgICAgbWF0cml4Q29udGFpbmVySW5mb3MucHVzaChbW3RhcmdldCwgY29udGFpbmVyXSwgcmVzdWx0XSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGdldENhY2hlZFN0eWxlKGVsZW1lbnQpIHtcclxuICAgIHZhciBjYWNoZSA9IGNhY2hlU3R5bGVNYXAgPT09IG51bGwgfHwgY2FjaGVTdHlsZU1hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FjaGVTdHlsZU1hcC5nZXQoZWxlbWVudCk7XHJcbiAgICBpZiAoIWNhY2hlKSB7XHJcbiAgICAgICAgdmFyIG5leHRTdHlsZV8xID0gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKCFjYWNoZVN0eWxlTWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U3R5bGVfMVtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhY2hlID0ge1xyXG4gICAgICAgICAgICBzdHlsZTogbmV4dFN0eWxlXzEsXHJcbiAgICAgICAgICAgIGNhY2hlZDoge30sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjYWNoZVN0eWxlTWFwLnNldChlbGVtZW50LCBjYWNoZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuY2FjaGVkO1xyXG4gICAgdmFyIHN0eWxlID0gY2FjaGUuc3R5bGU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgaWYgKCEocHJvcGVydHkgaW4gY2FjaGVkKSkge1xyXG4gICAgICAgICAgICBjYWNoZWRbcHJvcGVydHldID0gc3R5bGVbcHJvcGVydHldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2FjaGVkW3Byb3BlcnR5XTtcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBuYW1lLCBlKSB7XHJcbiAgICB2YXIgZGF0YXMgPSBlLm9yaWdpbmFsRGF0YXM7XHJcbiAgICBkYXRhcy5ncm91cGFibGUgPSBkYXRhcy5ncm91cGFibGUgfHwge307XHJcbiAgICB2YXIgZ3JvdXBhYmxlRGF0YXMgPSBkYXRhcy5ncm91cGFibGU7XHJcbiAgICBncm91cGFibGVEYXRhcy5jaGlsZERhdGFzID0gZ3JvdXBhYmxlRGF0YXMuY2hpbGREYXRhcyB8fCBbXTtcclxuICAgIHZhciBjaGlsZERhdGFzID0gZ3JvdXBhYmxlRGF0YXMuY2hpbGREYXRhcztcclxuICAgIHJldHVybiBtb3ZlYWJsZS5tb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChfLCBpKSB7XHJcbiAgICAgICAgY2hpbGREYXRhc1tpXSA9IGNoaWxkRGF0YXNbaV0gfHwge307XHJcbiAgICAgICAgY2hpbGREYXRhc1tpXVtuYW1lXSA9IGNoaWxkRGF0YXNbaV1bbmFtZV0gfHwge307XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBpc1JlcXVlc3RDaGlsZDogdHJ1ZSwgZGF0YXM6IGNoaWxkRGF0YXNbaV1bbmFtZV0sIG9yaWdpbmFsRGF0YXM6IGNoaWxkRGF0YXNbaV0gfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyQ2hpbGRHZXN0byhtb3ZlYWJsZSwgYWJsZSwgdHlwZSwgZGVsdGEsIGUsIGlzQ29udmVydCwgYWJsZU5hbWUpIHtcclxuICAgIHZhciBpc1N0YXJ0ID0gISF0eXBlLm1hdGNoKC9TdGFydCQvZyk7XHJcbiAgICB2YXIgaXNFbmQgPSAhIXR5cGUubWF0Y2goL0VuZCQvZyk7XHJcbiAgICB2YXIgaXNQaW5jaCA9IGUuaXNQaW5jaDtcclxuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBhYmxlLm5hbWUsIGUpO1xyXG4gICAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcclxuICAgIHZhciBjaGlsZEV2ZW50cyA9IFtdO1xyXG4gICAgdmFyIGV2ZW50UGFyYW1zID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoZXYsIGkpIHtcclxuICAgICAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBjaGlsZE1vdmVhYmxlLnN0YXRlO1xyXG4gICAgICAgIHZhciBnZXN0b3MgPSBzdGF0ZS5nZXN0b3M7XHJcbiAgICAgICAgdmFyIGNoaWxkRXZlbnQgPSBldjtcclxuICAgICAgICBpZiAoaXNTdGFydCkge1xyXG4gICAgICAgICAgICBjaGlsZEV2ZW50ID0gbmV3IEN1c3RvbUdlc3RvKGFibGVOYW1lKS5kcmFnU3RhcnQoZGVsdGEsIGV2KTtcclxuICAgICAgICAgICAgY2hpbGRFdmVudHMucHVzaChjaGlsZEV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghZ2VzdG9zW2FibGVOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgZ2VzdG9zW2FibGVOYW1lXSA9IGRhdGFzLmNoaWxkR2VzdG9zW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZ2VzdG9zW2FibGVOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkRXZlbnQgPSBzZXRDdXN0b21EcmFnKGV2LCBzdGF0ZSwgZGVsdGEsIGlzUGluY2gsIGlzQ29udmVydCwgYWJsZU5hbWUpO1xyXG4gICAgICAgICAgICBjaGlsZEV2ZW50cy5wdXNoKGNoaWxkRXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gYWJsZVt0eXBlXShjaGlsZE1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2hpbGRFdmVudCksIHsgcGFyZW50RmxhZzogdHJ1ZSB9KSk7XHJcbiAgICAgICAgaWYgKGlzRW5kKSB7XHJcbiAgICAgICAgICAgIGdlc3Rvc1thYmxlTmFtZV0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSk7XHJcbiAgICBpZiAoaXNTdGFydCkge1xyXG4gICAgICAgIGRhdGFzLmNoaWxkR2VzdG9zID0gbW92ZWFibGVzLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnN0YXRlLmdlc3Rvc1thYmxlTmFtZV07IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBldmVudFBhcmFtczogZXZlbnRQYXJhbXMsXHJcbiAgICAgICAgY2hpbGRFdmVudHM6IGNoaWxkRXZlbnRzLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgYWJsZSwgdHlwZSwgZSwgZWFjaEV2ZW50LCBjYWxsYmFjaykge1xyXG4gICAgaWYgKGVhY2hFdmVudCA9PT0gdm9pZCAwKSB7IGVhY2hFdmVudCA9IGZ1bmN0aW9uIChfLCBldikgeyByZXR1cm4gZXY7IH07IH1cclxuICAgIHZhciBpc0VuZCA9ICEhdHlwZS5tYXRjaCgvRW5kJC9nKTtcclxuICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIGFibGUubmFtZSwgZSk7XHJcbiAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xyXG4gICAgdmFyIGNoaWxkcyA9IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGV2LCBpKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XHJcbiAgICAgICAgdmFyIGNoaWxkRXZlbnQgPSBldjtcclxuICAgICAgICBjaGlsZEV2ZW50ID0gZWFjaEV2ZW50KGNoaWxkTW92ZWFibGUsIGV2KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gYWJsZVt0eXBlXShjaGlsZE1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2hpbGRFdmVudCksIHsgcGFyZW50RmxhZzogdHJ1ZSB9KSk7XHJcbiAgICAgICAgcmVzdWx0ICYmIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNoaWxkTW92ZWFibGUsIGV2LCByZXN1bHQsIGkpO1xyXG4gICAgICAgIGlmIChpc0VuZCkge1xyXG4gICAgICAgICAgICBjaGlsZE1vdmVhYmxlLnN0YXRlLmdlc3RvcyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY2hpbGRzO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0Q2hpbGREaXN0KG1vdmVhYmxlLCBjaGlsZCwgcGFyZW50RGF0YXMsIGNoaWxkRXZlbnQpIHtcclxuICAgIHZhciBmaXhlZERpcmVjdGlvbiA9IHBhcmVudERhdGFzLmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBwYXJlbnREYXRhcy5maXhlZFBvc2l0aW9uO1xyXG4gICAgdmFyIHN0YXJ0UG9zaXRpb25zID0gY2hpbGRFdmVudC5kYXRhcy5zdGFydFBvc2l0aW9ucyB8fCBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShjaGlsZC5zdGF0ZSk7XHJcbiAgICB2YXIgcG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24oc3RhcnRQb3NpdGlvbnMsIGZpeGVkRGlyZWN0aW9uKTtcclxuICAgIHZhciBfYSA9IF9fcmVhZChjYWxjdWxhdGUoY3JlYXRlUm90YXRlTWF0cml4KC1tb3ZlYWJsZS5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUEksIDMpLCBbcG9zWzBdIC0gZml4ZWRQb3NpdGlvblswXSwgcG9zWzFdIC0gZml4ZWRQb3NpdGlvblsxXSwgMV0sIDMpLCAyKSwgb3JpZ2luYWxYID0gX2FbMF0sIG9yaWdpbmFsWSA9IF9hWzFdO1xyXG4gICAgY2hpbGRFdmVudC5kYXRhcy5vcmlnaW5hbFggPSBvcmlnaW5hbFg7XHJcbiAgICBjaGlsZEV2ZW50LmRhdGFzLm9yaWdpbmFsWSA9IG9yaWdpbmFsWTtcclxuICAgIHJldHVybiBjaGlsZEV2ZW50O1xyXG59XG5cbmZ1bmN0aW9uIHJlbmRlckRpcmVjdGlvbkNvbnRyb2xzQnlJbmZvcyhtb3ZlYWJsZSwgYWJsZU5hbWUsIHJlbmRlckRpcmVjdGlvbnMsIFJlYWN0KSB7XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5nZXRTdGF0ZSgpLCByZW5kZXJQb3NlcyA9IF9hLnJlbmRlclBvc2VzLCByb3RhdGlvblJhZCA9IF9hLnJvdGF0aW9uLCBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb247XHJcbiAgICB2YXIgem9vbSA9IGdldFByb3BzKG1vdmVhYmxlLnByb3BzLCBhYmxlTmFtZSkuem9vbTtcclxuICAgIHZhciBkZWdSb3RhdGlvbiA9IGFic0RlZ3JlZShyb3RhdGlvblJhZCAvIE1hdGguUEkgKiAxODApO1xyXG4gICAgdmFyIGRpcmVjdGlvbk1hcCA9IHt9O1xyXG4gICAgdmFyIHJlbmRlclN0YXRlID0gbW92ZWFibGUucmVuZGVyU3RhdGU7XHJcbiAgICBpZiAoIXJlbmRlclN0YXRlLnJlbmRlckRpcmVjdGlvbk1hcCkge1xyXG4gICAgICAgIHJlbmRlclN0YXRlLnJlbmRlckRpcmVjdGlvbk1hcCA9IHt9O1xyXG4gICAgfVxyXG4gICAgdmFyIHJlbmRlckRpcmVjdGlvbk1hcCA9IHJlbmRlclN0YXRlLnJlbmRlckRpcmVjdGlvbk1hcDtcclxuICAgIHJlbmRlckRpcmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgZGlyID0gX2EuZGlyO1xyXG4gICAgICAgIGRpcmVjdGlvbk1hcFtkaXJdID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGRpcmVjdGlvblNpZ24gPSBzaWduKGRpcmVjdGlvbik7XHJcbiAgICByZXR1cm4gcmVuZGVyRGlyZWN0aW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhLCBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcywgZGlyID0gX2EuZGlyO1xyXG4gICAgICAgIHZhciBpbmRleGVzID0gRElSRUNUSU9OX0lOREVYRVNbZGlyXTtcclxuICAgICAgICBpZiAoIWluZGV4ZXMgfHwgIWRpcmVjdGlvbk1hcFtkaXJdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJEaXJlY3Rpb25NYXBbZGlyXSA9IHRydWU7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvblJvdGF0aW9uID0gKHRocm90dGxlKGRlZ1JvdGF0aW9uLCAxNSkgKyBkaXJlY3Rpb25TaWduICogRElSRUNUSU9OX1JPVEFUSU9OU1tkaXJdICsgNzIwKSAlIDE4MDtcclxuICAgICAgICB2YXIgZGF0YUF0dHJzID0ge307XHJcbiAgICAgICAgZ2V0S2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGRhdGFBdHRyc1tcImRhdGEtXCIuY29uY2F0KG5hbWUpXSA9IGRhdGFbbmFtZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBwcmVmaXguYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtcImNvbnRyb2xcIiwgXCJkaXJlY3Rpb25cIiwgZGlyLCBhYmxlTmFtZV0sIF9fcmVhZChjbGFzc05hbWVzKSwgZmFsc2UpKSwgXCJkYXRhLXJvdGF0aW9uXCI6IGRpcmVjdGlvblJvdGF0aW9uLCBcImRhdGEtZGlyZWN0aW9uXCI6IGRpciB9LCBkYXRhQXR0cnMsIHsga2V5OiBcImRpcmVjdGlvbi1cIi5jb25jYXQoZGlyKSwgc3R5bGU6IGdldENvbnRyb2xUcmFuc2Zvcm0uYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtyb3RhdGlvblJhZCwgem9vbV0sIF9fcmVhZChpbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHJlbmRlclBvc2VzW2luZGV4XTsgfSkpLCBmYWxzZSkpIH0pKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJEaXJlY3Rpb25Db250cm9scyhtb3ZlYWJsZSwgZGVmYXVsdERpcmVjdGlvbnMsIGFibGVOYW1lLCBSZWFjdCkge1xyXG4gICAgdmFyIF9hID0gZ2V0UHJvcHMobW92ZWFibGUucHJvcHMsIGFibGVOYW1lKSwgX2IgPSBfYS5yZW5kZXJEaXJlY3Rpb25zLCBkaXJlY3Rpb25zID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHREaXJlY3Rpb25zIDogX2IsIGRpc3BsYXlBcm91bmRDb250cm9scyA9IF9hLmRpc3BsYXlBcm91bmRDb250cm9scztcclxuICAgIGlmICghZGlyZWN0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHZhciByZW5kZXJEaXJlY3Rpb25zID0gZGlyZWN0aW9ucyA9PT0gdHJ1ZSA/IERJUkVDVElPTlMgOiBkaXJlY3Rpb25zO1xyXG4gICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKChkaXNwbGF5QXJvdW5kQ29udHJvbHMgPyByZW5kZXJBcm91bmRDb250cm9scyhtb3ZlYWJsZSwgUmVhY3QsIGFibGVOYW1lLCByZW5kZXJEaXJlY3Rpb25zKSA6IFtdKSksIGZhbHNlKSwgX19yZWFkKHJlbmRlckRpcmVjdGlvbkNvbnRyb2xzQnlJbmZvcyhtb3ZlYWJsZSwgYWJsZU5hbWUsIHJlbmRlckRpcmVjdGlvbnMubWFwKGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7fSxcclxuICAgICAgICAgICAgY2xhc3NOYW1lczogW10sXHJcbiAgICAgICAgICAgIGRpcjogZGlyLFxyXG4gICAgICAgIH07XHJcbiAgICB9KSwgUmVhY3QpKSwgZmFsc2UpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckxpbmUoUmVhY3QsIGRpcmVjdGlvbiwgcG9zMSwgcG9zMiwgem9vbSwga2V5KSB7XHJcbiAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSA2OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBjbGFzc05hbWVzW19pIC0gNl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIHJhZCA9IGdldFJhZChwb3MxLCBwb3MyKTtcclxuICAgIHZhciByb3RhdGlvbiA9IGRpcmVjdGlvbiA/ICh0aHJvdHRsZShyYWQgLyBNYXRoLlBJICogMTgwLCAxNSkpICUgMTgwIDogLTE7XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogXCJsaW5lLVwiLmNvbmNhdChrZXkpLCBjbGFzc05hbWU6IHByZWZpeC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW1wibGluZVwiLCBcImRpcmVjdGlvblwiLCBkaXJlY3Rpb24gPyBcImVkZ2VcIiA6IFwiXCIsIGRpcmVjdGlvbl0sIF9fcmVhZChjbGFzc05hbWVzKSwgZmFsc2UpKSwgXCJkYXRhLXJvdGF0aW9uXCI6IHJvdGF0aW9uLCBcImRhdGEtbGluZS1rZXlcIjoga2V5LCBcImRhdGEtZGlyZWN0aW9uXCI6IGRpcmVjdGlvbiwgc3R5bGU6IGdldExpbmVTdHlsZShwb3MxLCBwb3MyLCB6b29tLCByYWQpIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckVkZ2VMaW5lcyhSZWFjdCwgYWJsZU5hbWUsIGVkZ2UsIHBvc2VzLCB6b29tKSB7XHJcbiAgICB2YXIgZGlyZWN0aW9ucyA9IGVkZ2UgPT09IHRydWUgPyBESVJFQ1RJT05TNCA6IGVkZ2U7XHJcbiAgICByZXR1cm4gZGlyZWN0aW9ucy5tYXAoZnVuY3Rpb24gKGRpcmVjdGlvbiwgaSkge1xyXG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChESVJFQ1RJT05fSU5ERVhFU1tkaXJlY3Rpb25dLCAyKSwgaW5kZXgxID0gX2FbMF0sIGluZGV4MiA9IF9hWzFdO1xyXG4gICAgICAgIGlmIChpbmRleDIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJMaW5lKFJlYWN0LCBkaXJlY3Rpb24sIHBvc2VzW2luZGV4MV0sIHBvc2VzW2luZGV4Ml0sIHpvb20sIFwiXCIuY29uY2F0KGFibGVOYW1lLCBcIkVkZ2VcIikuY29uY2F0KGkpLCBhYmxlTmFtZSk7XHJcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVuZGVyRGlyZWN0aW9ucyhhYmxlTmFtZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcclxuICAgICAgICB2YXIgZWRnZSA9IGdldFByb3BzKG1vdmVhYmxlLnByb3BzLCBhYmxlTmFtZSkuZWRnZTtcclxuICAgICAgICBpZiAoZWRnZSAmJiAoZWRnZSA9PT0gdHJ1ZSB8fCBlZGdlLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHJlbmRlckVkZ2VMaW5lcyhSZWFjdCwgYWJsZU5hbWUsIGVkZ2UsIG1vdmVhYmxlLmdldFN0YXRlKCkucmVuZGVyUG9zZXMsIG1vdmVhYmxlLnByb3BzLnpvb20pKSwgZmFsc2UpLCBfX3JlYWQocmVuZGVyRGlhZ29uYWxEaXJlY3Rpb25zKG1vdmVhYmxlLCBhYmxlTmFtZSwgUmVhY3QpKSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyQWxsRGlyZWN0aW9ucyhtb3ZlYWJsZSwgYWJsZU5hbWUsIFJlYWN0KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyQWxsRGlyZWN0aW9ucyhtb3ZlYWJsZSwgYWJsZU5hbWUsIFJlYWN0KSB7XHJcbiAgICByZXR1cm4gcmVuZGVyRGlyZWN0aW9uQ29udHJvbHMobW92ZWFibGUsIERJUkVDVElPTlMsIGFibGVOYW1lLCBSZWFjdCk7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyRGlhZ29uYWxEaXJlY3Rpb25zKG1vdmVhYmxlLCBhYmxlTmFtZSwgUmVhY3QpIHtcclxuICAgIHJldHVybiByZW5kZXJEaXJlY3Rpb25Db250cm9scyhtb3ZlYWJsZSwgW1wibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl0sIGFibGVOYW1lLCBSZWFjdCk7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyQXJvdW5kQ29udHJvbHMobW92ZWFibGUsIFJlYWN0LCBhYmxlTmFtZSwgcmVuZGVyRGlyZWN0aW9ucykge1xyXG4gICAgdmFyIHJlbmRlclN0YXRlID0gbW92ZWFibGUucmVuZGVyU3RhdGU7XHJcbiAgICBpZiAoIXJlbmRlclN0YXRlLnJlbmRlckRpcmVjdGlvbk1hcCkge1xyXG4gICAgICAgIHJlbmRlclN0YXRlLnJlbmRlckRpcmVjdGlvbk1hcCA9IHt9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9hID0gbW92ZWFibGUuZ2V0U3RhdGUoKSwgcmVuZGVyUG9zZXMgPSBfYS5yZW5kZXJQb3Nlcywgcm90YXRpb25SYWQgPSBfYS5yb3RhdGlvbiwgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xyXG4gICAgdmFyIHJlbmRlckRpcmVjdGlvbk1hcCA9IHJlbmRlclN0YXRlLnJlbmRlckRpcmVjdGlvbk1hcDtcclxuICAgIHZhciB6b29tID0gbW92ZWFibGUucHJvcHMuem9vbTtcclxuICAgIHZhciBkaXJlY3Rpb25TaWduID0gc2lnbihkaXJlY3Rpb24pO1xyXG4gICAgdmFyIGRlZ1JvdGF0aW9uID0gcm90YXRpb25SYWQgLyBNYXRoLlBJICogMTgwO1xyXG4gICAgcmV0dXJuIChyZW5kZXJEaXJlY3Rpb25zIHx8IGdldEtleXMocmVuZGVyRGlyZWN0aW9uTWFwKSkubWFwKGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICB2YXIgaW5kZXhlcyA9IERJUkVDVElPTl9JTkRFWEVTW2Rpcl07XHJcbiAgICAgICAgaWYgKCFpbmRleGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGlyZWN0aW9uUm90YXRpb24gPSAodGhyb3R0bGUoZGVnUm90YXRpb24sIDE1KSArIGRpcmVjdGlvblNpZ24gKiBESVJFQ1RJT05fUk9UQVRJT05TW2Rpcl0gKyA3MjApICUgMTgwO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1wiYXJvdW5kLWNvbnRyb2xcIl07XHJcbiAgICAgICAgaWYgKGFibGVOYW1lKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaChcImRpcmVjdGlvblwiLCBhYmxlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogcHJlZml4LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGNsYXNzTmFtZXMpLCBmYWxzZSkpLCBcImRhdGEtcm90YXRpb25cIjogZGlyZWN0aW9uUm90YXRpb24sIFwiZGF0YS1kaXJlY3Rpb25cIjogZGlyLCBrZXk6IFwiZGlyZWN0aW9uLWFyb3VuZC1cIi5jb25jYXQoZGlyKSwgc3R5bGU6IGdldENvbnRyb2xUcmFuc2Zvcm0uYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtyb3RhdGlvblJhZCwgem9vbV0sIF9fcmVhZChpbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHJlbmRlclBvc2VzW2luZGV4XTsgfSkpLCBmYWxzZSkpIH0pKTtcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRQb3Nlcyhib3VuZHMsIHZlcnRpY2FsUG9zZXMsIGhvcml6b250YWxQb3Nlcykge1xyXG4gICAgdmFyIF9hID0gYm91bmRzIHx8IHt9LCBfYiA9IF9hLnBvc2l0aW9uLCBwb3NpdGlvbiA9IF9iID09PSB2b2lkIDAgPyBcImNsaWVudFwiIDogX2IsIF9jID0gX2EubGVmdCwgbGVmdCA9IF9jID09PSB2b2lkIDAgPyAtSW5maW5pdHkgOiBfYywgX2QgPSBfYS50b3AsIHRvcCA9IF9kID09PSB2b2lkIDAgPyAtSW5maW5pdHkgOiBfZCwgX2UgPSBfYS5yaWdodCwgcmlnaHQgPSBfZSA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfZSwgX2YgPSBfYS5ib3R0b20sIGJvdHRvbSA9IF9mID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9mO1xyXG4gICAgdmFyIG5leHRCb3VuZHMgPSB7XHJcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxyXG4gICAgICAgIGJvdHRvbTogYm90dG9tLFxyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmVydGljYWw6IGNoZWNrQm91bmRzKG5leHRCb3VuZHMsIHZlcnRpY2FsUG9zZXMsIHRydWUpLFxyXG4gICAgICAgIGhvcml6b250YWw6IGNoZWNrQm91bmRzKG5leHRCb3VuZHMsIGhvcml6b250YWxQb3NlcywgZmFsc2UpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRCb3VuZHMobW92ZWFibGUsIGV4dGVybmFsQm91bmRzKSB7XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSwgX2IgPSBfYS5jb250YWluZXJDbGllbnRSZWN0LCBjb250YWluZXJIZWlnaHQgPSBfYi5jbGllbnRIZWlnaHQsIGNvbnRhaW5lcldpZHRoID0gX2IuY2xpZW50V2lkdGgsIGNsaWVudExlZnQgPSBfYi5jbGllbnRMZWZ0LCBjbGllbnRUb3AgPSBfYi5jbGllbnRUb3AsIF9jID0gX2Euc25hcE9mZnNldCwgc25hcE9mZnNldExlZnQgPSBfYy5sZWZ0LCBzbmFwT2Zmc2V0VG9wID0gX2MudG9wLCBzbmFwT2Zmc2V0UmlnaHQgPSBfYy5yaWdodCwgc25hcE9mZnNldEJvdHRvbSA9IF9jLmJvdHRvbTtcclxuICAgIHZhciBib3VuZHMgPSBleHRlcm5hbEJvdW5kcyB8fCBtb3ZlYWJsZS5wcm9wcy5ib3VuZHMgfHwge307XHJcbiAgICB2YXIgcG9zaXRpb24gPSBib3VuZHMucG9zaXRpb24gfHwgXCJjbGllbnRcIjtcclxuICAgIHZhciBpc0NTUyA9IHBvc2l0aW9uID09PSBcImNzc1wiO1xyXG4gICAgdmFyIF9kID0gYm91bmRzLmxlZnQsIGxlZnQgPSBfZCA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2QsIF9lID0gYm91bmRzLnRvcCwgdG9wID0gX2UgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9lO1xyXG4gICAgdmFyIF9mID0gYm91bmRzLnJpZ2h0LCByaWdodCA9IF9mID09PSB2b2lkIDAgPyBpc0NTUyA/IC1JbmZpbml0eSA6IEluZmluaXR5IDogX2YsIF9nID0gYm91bmRzLmJvdHRvbSwgYm90dG9tID0gX2cgPT09IHZvaWQgMCA/IGlzQ1NTID8gLUluZmluaXR5IDogSW5maW5pdHkgOiBfZztcclxuICAgIGlmIChpc0NTUykge1xyXG4gICAgICAgIHJpZ2h0ID0gY29udGFpbmVyV2lkdGggKyBzbmFwT2Zmc2V0UmlnaHQgLSBzbmFwT2Zmc2V0TGVmdCAtIHJpZ2h0O1xyXG4gICAgICAgIGJvdHRvbSA9IGNvbnRhaW5lckhlaWdodCArIHNuYXBPZmZzZXRCb3R0b20gLSBzbmFwT2Zmc2V0VG9wIC0gYm90dG9tO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBsZWZ0ICsgc25hcE9mZnNldExlZnQgLSBjbGllbnRMZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiByaWdodCArIHNuYXBPZmZzZXRMZWZ0IC0gY2xpZW50TGVmdCxcclxuICAgICAgICB0b3A6IHRvcCArIHNuYXBPZmZzZXRUb3AgLSBjbGllbnRUb3AsXHJcbiAgICAgICAgYm90dG9tOiBib3R0b20gKyBzbmFwT2Zmc2V0VG9wIC0gY2xpZW50VG9wLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0JvdW5kS2VlcFJhdGlvKG1vdmVhYmxlLCBzdGFydFBvcywgZW5kUG9zKSB7XHJcbiAgICB2YXIgX2EgPSBnZXRCb3VuZHMobW92ZWFibGUpLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b207XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoZW5kUG9zLCAyKSwgZW5kWCA9IF9iWzBdLCBlbmRZID0gX2JbMV07XHJcbiAgICB2YXIgX2MgPSBfX3JlYWQobWludXMoZW5kUG9zLCBzdGFydFBvcyksIDIpLCBkeCA9IF9jWzBdLCBkeSA9IF9jWzFdO1xyXG4gICAgaWYgKGFicyhkeCkgPCBUSU5ZX05VTSkge1xyXG4gICAgICAgIGR4ID0gMDtcclxuICAgIH1cclxuICAgIGlmIChhYnMoZHkpIDwgVElOWV9OVU0pIHtcclxuICAgICAgICBkeSA9IDA7XHJcbiAgICB9XHJcbiAgICB2YXIgaXNCb3R0b20gPSBkeSA+IDA7XHJcbiAgICB2YXIgaXNSaWdodCA9IGR4ID4gMDtcclxuICAgIHZhciB2ZXJ0aWNhbEluZm8gPSB7XHJcbiAgICAgICAgaXNCb3VuZDogZmFsc2UsXHJcbiAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgIHBvczogMCxcclxuICAgIH07XHJcbiAgICB2YXIgaG9yaXpvbnRhbEluZm8gPSB7XHJcbiAgICAgICAgaXNCb3VuZDogZmFsc2UsXHJcbiAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgIHBvczogMCxcclxuICAgIH07XHJcbiAgICBpZiAoZHggPT09IDAgJiYgZHkgPT09IDApIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbDogdmVydGljYWxJbmZvLFxyXG4gICAgICAgICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsSW5mbyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZHggPT09IDApIHtcclxuICAgICAgICBpZiAoaXNCb3R0b20pIHtcclxuICAgICAgICAgICAgaWYgKGJvdHRvbSA8IGVuZFkpIHtcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWxJbmZvLnBvcyA9IGJvdHRvbTtcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWxJbmZvLm9mZnNldCA9IGVuZFkgLSBib3R0b207XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0b3AgPiBlbmRZKSB7XHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsSW5mby5wb3MgPSB0b3A7XHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0gdG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZHkgPT09IDApIHtcclxuICAgICAgICBpZiAoaXNSaWdodCkge1xyXG4gICAgICAgICAgICBpZiAocmlnaHQgPCBlbmRYKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEluZm8ucG9zID0gcmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEluZm8ub2Zmc2V0ID0gZW5kWCAtIHJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobGVmdCA+IGVuZFgpIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSW5mby5wb3MgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgdmVydGljYWxJbmZvLm9mZnNldCA9IGVuZFggLSBsZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8geSAtIHkxID0gYSAqICh4IC0geDEpXHJcbiAgICAgICAgdmFyIGEgPSBkeSAvIGR4O1xyXG4gICAgICAgIHZhciBiID0gZW5kUG9zWzFdIC0gYSAqIGVuZFg7XHJcbiAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICB2YXIgaXNCb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChpc1JpZ2h0ICYmIHJpZ2h0IDw9IGVuZFgpIHtcclxuICAgICAgICAgICAgeSA9IGEgKiByaWdodCArIGI7XHJcbiAgICAgICAgICAgIHggPSByaWdodDtcclxuICAgICAgICAgICAgaXNCb3VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFpc1JpZ2h0ICYmIGVuZFggPD0gbGVmdCkge1xyXG4gICAgICAgICAgICB5ID0gYSAqIGxlZnQgKyBiO1xyXG4gICAgICAgICAgICB4ID0gbGVmdDtcclxuICAgICAgICAgICAgaXNCb3VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0JvdW5kKSB7XHJcbiAgICAgICAgICAgIGlmICh5IDwgdG9wIHx8IHkgPiBib3R0b20pIHtcclxuICAgICAgICAgICAgICAgIGlzQm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzQm91bmQpIHtcclxuICAgICAgICAgICAgaWYgKGlzQm90dG9tICYmIGJvdHRvbSA8PSBlbmRZKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgeCA9ICh5IC0gYikgLyBhO1xyXG4gICAgICAgICAgICAgICAgaXNCb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQm90dG9tICYmIGVuZFkgPD0gdG9wKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gdG9wO1xyXG4gICAgICAgICAgICAgICAgeCA9ICh5IC0gYikgLyBhO1xyXG4gICAgICAgICAgICAgICAgaXNCb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQm91bmQpIHtcclxuICAgICAgICAgICAgdmVydGljYWxJbmZvLmlzQm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbEluZm8ucG9zID0geDtcclxuICAgICAgICAgICAgdmVydGljYWxJbmZvLm9mZnNldCA9IGVuZFggLSB4O1xyXG4gICAgICAgICAgICBob3Jpem9udGFsSW5mby5pc0JvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgaG9yaXpvbnRhbEluZm8ucG9zID0geTtcclxuICAgICAgICAgICAgaG9yaXpvbnRhbEluZm8ub2Zmc2V0ID0gZW5kWSAtIHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2ZXJ0aWNhbDogdmVydGljYWxJbmZvLFxyXG4gICAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxJbmZvLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0JvdW5kcyhib3VuZHMsIHBvc2VzLCBpc1ZlcnRpY2FsKSB7XHJcbiAgICAvLyAwICAgWzEwMCAtIDIwMF0gIDMwMFxyXG4gICAgdmFyIHN0YXJ0Qm91bmRQb3MgPSBib3VuZHNbaXNWZXJ0aWNhbCA/IFwibGVmdFwiIDogXCJ0b3BcIl07XHJcbiAgICB2YXIgZW5kQm91bmRQb3MgPSBib3VuZHNbaXNWZXJ0aWNhbCA/IFwicmlnaHRcIiA6IFwiYm90dG9tXCJdO1xyXG4gICAgLy8gNDUwXHJcbiAgICB2YXIgbWluUG9zID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBvc2VzKSwgZmFsc2UpKTtcclxuICAgIHZhciBtYXhQb3MgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocG9zZXMpLCBmYWxzZSkpO1xyXG4gICAgdmFyIGJvdW5kSW5mb3MgPSBbXTtcclxuICAgIGlmIChzdGFydEJvdW5kUG9zICsgMSA+IG1pblBvcykge1xyXG4gICAgICAgIGJvdW5kSW5mb3MucHVzaCh7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJzdGFydFwiLFxyXG4gICAgICAgICAgICBpc0JvdW5kOiB0cnVlLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IG1pblBvcyAtIHN0YXJ0Qm91bmRQb3MsXHJcbiAgICAgICAgICAgIHBvczogc3RhcnRCb3VuZFBvcyxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChlbmRCb3VuZFBvcyAtIDEgPCBtYXhQb3MpIHtcclxuICAgICAgICBib3VuZEluZm9zLnB1c2goe1xyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiZW5kXCIsXHJcbiAgICAgICAgICAgIGlzQm91bmQ6IHRydWUsXHJcbiAgICAgICAgICAgIG9mZnNldDogbWF4UG9zIC0gZW5kQm91bmRQb3MsXHJcbiAgICAgICAgICAgIHBvczogZW5kQm91bmRQb3MsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWJvdW5kSW5mb3MubGVuZ3RoKSB7XHJcbiAgICAgICAgYm91bmRJbmZvcy5wdXNoKHtcclxuICAgICAgICAgICAgaXNCb3VuZDogZmFsc2UsXHJcbiAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgcG9zOiAwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJvdW5kSW5mb3Muc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYWJzKGIub2Zmc2V0KSAtIGFicyhhLm9mZnNldCk7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIGlzQm91bmRSb3RhdGUkMShyZWxhdGl2ZVBvc2VzLCBib3VuZFJlY3QsIHJhZCkge1xyXG4gICAgdmFyIG5leHRQb3NlcyA9IHJhZCA/IHJlbGF0aXZlUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHJvdGF0ZShwb3MsIHJhZCk7IH0pIDogcmVsYXRpdmVQb3NlcztcclxuICAgIHJldHVybiBuZXh0UG9zZXMuc29tZShmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIChwb3NbMF0gPCBib3VuZFJlY3QubGVmdCAmJiBhYnMocG9zWzBdIC0gYm91bmRSZWN0LmxlZnQpID4gMC4xKVxyXG4gICAgICAgICAgICB8fCAocG9zWzBdID4gYm91bmRSZWN0LnJpZ2h0ICYmIGFicyhwb3NbMF0gLSBib3VuZFJlY3QucmlnaHQpID4gMC4xKVxyXG4gICAgICAgICAgICB8fCAocG9zWzFdIDwgYm91bmRSZWN0LnRvcCAmJiBhYnMocG9zWzFdIC0gYm91bmRSZWN0LnRvcCkgPiAwLjEpXHJcbiAgICAgICAgICAgIHx8IChwb3NbMV0gPiBib3VuZFJlY3QuYm90dG9tICYmIGFicyhwb3NbMV0gLSBib3VuZFJlY3QuYm90dG9tKSA+IDAuMSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBib3VuZFJvdGF0ZSh2ZWMsIGJvdW5kUG9zLCBpbmRleCkge1xyXG4gICAgdmFyIHIgPSBnZXREaXN0U2l6ZSh2ZWMpO1xyXG4gICAgdmFyIG5leHRQb3MgPSBNYXRoLnNxcnQociAqIHIgLSBib3VuZFBvcyAqIGJvdW5kUG9zKSB8fCAwO1xyXG4gICAgcmV0dXJuIFtuZXh0UG9zLCAtbmV4dFBvc10uc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhYnMoYSAtIHZlY1tpbmRleCA/IDAgOiAxXSkgLSBhYnMoYiAtIHZlY1tpbmRleCA/IDAgOiAxXSk7XHJcbiAgICB9KS5tYXAoZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgIHJldHVybiBnZXRSYWQoWzAsIDBdLCBpbmRleCA/IFtwb3MsIGJvdW5kUG9zXSA6IFtib3VuZFBvcywgcG9zXSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjaGVja1JvdGF0ZUJvdW5kcyhtb3ZlYWJsZSwgcHJldlBvc2VzLCBuZXh0UG9zZXMsIG9yaWdpbiwgcm90YXRpb24pIHtcclxuICAgIGlmICghbW92ZWFibGUucHJvcHMuYm91bmRzKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdmFyIHJhZCA9IHJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcclxuICAgIHZhciBfYSA9IGdldEJvdW5kcyhtb3ZlYWJsZSksIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQsIGJvdHRvbSA9IF9hLmJvdHRvbTtcclxuICAgIHZhciByZWxhdGl2ZUxlZnQgPSBsZWZ0IC0gb3JpZ2luWzBdO1xyXG4gICAgdmFyIHJlbGF0aXZlUmlnaHQgPSByaWdodCAtIG9yaWdpblswXTtcclxuICAgIHZhciByZWxhdGl2ZVRvcCA9IHRvcCAtIG9yaWdpblsxXTtcclxuICAgIHZhciByZWxhdGl2ZUJvdHRvbSA9IGJvdHRvbSAtIG9yaWdpblsxXTtcclxuICAgIHZhciBib3VuZFJlY3QgPSB7XHJcbiAgICAgICAgbGVmdDogcmVsYXRpdmVMZWZ0LFxyXG4gICAgICAgIHRvcDogcmVsYXRpdmVUb3AsXHJcbiAgICAgICAgcmlnaHQ6IHJlbGF0aXZlUmlnaHQsXHJcbiAgICAgICAgYm90dG9tOiByZWxhdGl2ZUJvdHRvbSxcclxuICAgIH07XHJcbiAgICBpZiAoIWlzQm91bmRSb3RhdGUkMShuZXh0UG9zZXMsIGJvdW5kUmVjdCwgMCkpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICBbXHJcbiAgICAgICAgW3JlbGF0aXZlTGVmdCwgMF0sXHJcbiAgICAgICAgW3JlbGF0aXZlUmlnaHQsIDBdLFxyXG4gICAgICAgIFtyZWxhdGl2ZVRvcCwgMV0sXHJcbiAgICAgICAgW3JlbGF0aXZlQm90dG9tLCAxXSxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBib3VuZFBvcyA9IF9iWzBdLCBpbmRleCA9IF9iWzFdO1xyXG4gICAgICAgIG5leHRQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXh0UG9zKSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVJhZDEgPSBnZXRSYWQoWzAsIDBdLCBuZXh0UG9zKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYm91bmRSb3RhdGUobmV4dFBvcywgYm91bmRQb3MsIGluZGV4KVxyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocmVsYXRpdmVSYWQyKSB7IHJldHVybiByYWQgKyByZWxhdGl2ZVJhZDIgLSByZWxhdGl2ZVJhZDE7IH0pXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuZXh0UmFkKSB7IHJldHVybiAhaXNCb3VuZFJvdGF0ZSQxKHByZXZQb3NlcywgYm91bmRSZWN0LCBuZXh0UmFkKTsgfSlcclxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG5leHRSYWQpIHsgcmV0dXJuIHRocm90dGxlKG5leHRSYWQgKiAxODAgLyBNYXRoLlBJLCBUSU5ZX05VTSk7IH0pKSwgZmFsc2UpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxuXG52YXIgVkVSVElDQUxfTkFNRVMgPSBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJjZW50ZXJcIl07XHJcbnZhciBIT1JJWk9OVEFMX05BTUVTID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibWlkZGxlXCJdO1xyXG52YXIgU05BUF9TS0lQX05BTUVTX01BUCA9IHtcclxuICAgIFwibGVmdFwiOiBcInN0YXJ0XCIsXHJcbiAgICBcInJpZ2h0XCI6IFwiZW5kXCIsXHJcbiAgICBcImNlbnRlclwiOiBcImNlbnRlclwiLFxyXG4gICAgXCJ0b3BcIjogXCJzdGFydFwiLFxyXG4gICAgXCJib3R0b21cIjogXCJlbmRcIixcclxuICAgIFwibWlkZGxlXCI6IFwiY2VudGVyXCIsXHJcbn07XHJcbnZhciBWRVJUSUNBTF9OQU1FU19NQVAgPSB7XHJcbiAgICBzdGFydDogXCJsZWZ0XCIsXHJcbiAgICBlbmQ6IFwicmlnaHRcIixcclxuICAgIGNlbnRlcjogXCJjZW50ZXJcIixcclxufTtcclxudmFyIEhPUklaT05UQUxfTkFNRVNfTUFQID0ge1xyXG4gICAgc3RhcnQ6IFwidG9wXCIsXHJcbiAgICBlbmQ6IFwiYm90dG9tXCIsXHJcbiAgICBjZW50ZXI6IFwibWlkZGxlXCIsXHJcbn07XHJcbmZ1bmN0aW9uIGdldEluaXRpYWxCb3VuZHMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IGZhbHNlLFxyXG4gICAgICAgIHRvcDogZmFsc2UsXHJcbiAgICAgICAgcmlnaHQ6IGZhbHNlLFxyXG4gICAgICAgIGJvdHRvbTogZmFsc2UsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGhhc0d1aWRlbGluZXMobW92ZWFibGUsIGFibGVOYW1lKSB7XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgc25hcHBhYmxlID0gX2Euc25hcHBhYmxlLCBib3VuZHMgPSBfYS5ib3VuZHMsIGlubmVyQm91bmRzID0gX2EuaW5uZXJCb3VuZHMsIHZlcnRpY2FsR3VpZGVsaW5lcyA9IF9hLnZlcnRpY2FsR3VpZGVsaW5lcywgaG9yaXpvbnRhbEd1aWRlbGluZXMgPSBfYS5ob3Jpem9udGFsR3VpZGVsaW5lcywgc25hcEdyaWRXaWR0aCA9IF9hLnNuYXBHcmlkV2lkdGgsIHNuYXBHcmlkSGVpZ2h0ID0gX2Euc25hcEdyaWRIZWlnaHQsIF9iID0gbW92ZWFibGUuc3RhdGUsIGd1aWRlbGluZXMgPSBfYi5ndWlkZWxpbmVzLCBlbmFibGVTbmFwID0gX2IuZW5hYmxlU25hcDtcclxuICAgIGlmICghc25hcHBhYmxlIHx8XHJcbiAgICAgICAgIWVuYWJsZVNuYXAgfHxcclxuICAgICAgICAoYWJsZU5hbWUgJiYgc25hcHBhYmxlICE9PSB0cnVlICYmIHNuYXBwYWJsZS5pbmRleE9mKGFibGVOYW1lKSA8IDApKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNuYXBHcmlkV2lkdGggfHxcclxuICAgICAgICBzbmFwR3JpZEhlaWdodCB8fFxyXG4gICAgICAgIGJvdW5kcyB8fFxyXG4gICAgICAgIGlubmVyQm91bmRzIHx8XHJcbiAgICAgICAgKGd1aWRlbGluZXMgJiYgZ3VpZGVsaW5lcy5sZW5ndGgpIHx8XHJcbiAgICAgICAgKHZlcnRpY2FsR3VpZGVsaW5lcyAmJiB2ZXJ0aWNhbEd1aWRlbGluZXMubGVuZ3RoKSB8fFxyXG4gICAgICAgIChob3Jpem9udGFsR3VpZGVsaW5lcyAmJiBob3Jpem9udGFsR3VpZGVsaW5lcy5sZW5ndGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U25hcERpcmVjdGlvbnMoc25hcERpcmVjdGlvbnMpIHtcclxuICAgIGlmIChzbmFwRGlyZWN0aW9ucyA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzbmFwRGlyZWN0aW9ucyA9PT0gdHJ1ZSB8fCAhc25hcERpcmVjdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4geyBsZWZ0OiB0cnVlLCByaWdodDogdHJ1ZSwgdG9wOiB0cnVlLCBib3R0b206IHRydWUgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBzbmFwRGlyZWN0aW9ucztcclxufVxyXG5mdW5jdGlvbiBtYXBTbmFwRGlyZWN0aW9uUG9zZXMoc25hcERpcmVjdGlvbnMsIHNuYXBQb3Nlcykge1xyXG4gICAgdmFyIG5leHRTbmFwRGlyZWN0aW9ucyA9IGdldFNuYXBEaXJlY3Rpb25zKHNuYXBEaXJlY3Rpb25zKTtcclxuICAgIHZhciBuZXh0U25hcFBvc2VzID0ge307XHJcbiAgICBmb3IgKHZhciBuYW1lXzEgaW4gbmV4dFNuYXBEaXJlY3Rpb25zKSB7XHJcbiAgICAgICAgaWYgKG5hbWVfMSBpbiBzbmFwUG9zZXMgJiYgbmV4dFNuYXBEaXJlY3Rpb25zW25hbWVfMV0pIHtcclxuICAgICAgICAgICAgbmV4dFNuYXBQb3Nlc1tuYW1lXzFdID0gc25hcFBvc2VzW25hbWVfMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5leHRTbmFwUG9zZXM7XHJcbn1cclxuZnVuY3Rpb24gc3BsaXRTbmFwRGlyZWN0aW9uUG9zZXMoc25hcERpcmVjdGlvbnMsIHNuYXBQb3Nlcykge1xyXG4gICAgdmFyIG5leHRTbmFwUG9zZXMgPSBtYXBTbmFwRGlyZWN0aW9uUG9zZXMoc25hcERpcmVjdGlvbnMsIHNuYXBQb3Nlcyk7XHJcbiAgICB2YXIgaG9yaXpvbnRhbE5hbWVzID0gSE9SSVpPTlRBTF9OQU1FUy5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgaW4gbmV4dFNuYXBQb3NlczsgfSk7XHJcbiAgICB2YXIgdmVydGljYWxOYW1lcyA9IFZFUlRJQ0FMX05BTUVTLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSBpbiBuZXh0U25hcFBvc2VzOyB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaG9yaXpvbnRhbE5hbWVzOiBob3Jpem9udGFsTmFtZXMsXHJcbiAgICAgICAgdmVydGljYWxOYW1lczogdmVydGljYWxOYW1lcyxcclxuICAgICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuZXh0U25hcFBvc2VzW25hbWVdOyB9KSxcclxuICAgICAgICB2ZXJ0aWNhbDogdmVydGljYWxOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5leHRTbmFwUG9zZXNbbmFtZV07IH0pLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVDb250YWluZXJQb3Mocm9vdE1hdHJpeCwgY29udGFpbmVyUmVjdCwgbikge1xyXG4gICAgdmFyIGNsaWVudFBvcyA9IGNhbGN1bGF0ZVBvc2l0aW9uKHJvb3RNYXRyaXgsIFtjb250YWluZXJSZWN0LmNsaWVudExlZnQsIGNvbnRhaW5lclJlY3QuY2xpZW50VG9wXSwgbik7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGNvbnRhaW5lclJlY3QubGVmdCArIGNsaWVudFBvc1swXSxcclxuICAgICAgICBjb250YWluZXJSZWN0LnRvcCArIGNsaWVudFBvc1sxXSxcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gc29sdmVMaW5lQ29uc3RhbnRzKF9hKSB7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBwb2ludDEgPSBfYlswXSwgcG9pbnQyID0gX2JbMV07XHJcbiAgICB2YXIgZHggPSBwb2ludDJbMF0gLSBwb2ludDFbMF07XHJcbiAgICB2YXIgZHkgPSBwb2ludDJbMV0gLSBwb2ludDFbMV07XHJcbiAgICBpZiAoTWF0aC5hYnMoZHgpIDwgVElOWV9OVU0kMSkge1xyXG4gICAgICAgIGR4ID0gMDtcclxuICAgIH1cclxuICAgIGlmIChNYXRoLmFicyhkeSkgPCBUSU5ZX05VTSQxKSB7XHJcbiAgICAgICAgZHkgPSAwO1xyXG4gICAgfVxyXG4gICAgLy8gYiA+IDBcclxuICAgIC8vIGF4ICsgYnkgKyBjID0gMFxyXG4gICAgdmFyIGEgPSAwO1xyXG4gICAgdmFyIGIgPSAwO1xyXG4gICAgdmFyIGMgPSAwO1xyXG4gICAgaWYgKCFkeCkge1xyXG4gICAgICAgIC8vIC14ICsgMSA9IDBcclxuICAgICAgICBhID0gLTE7XHJcbiAgICAgICAgYyA9IHBvaW50MVswXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFkeSkge1xyXG4gICAgICAgIC8vIHkgLSAxID0gMFxyXG4gICAgICAgIGIgPSAxO1xyXG4gICAgICAgIGMgPSAtcG9pbnQxWzFdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8geSA9IC1hKHggLSB4MSkgKyB5MVxyXG4gICAgICAgIC8vIGF4ICsgeSArIGEgKiB4MSAtIHkxID0gMFxyXG4gICAgICAgIGEgPSAtZHkgLyBkeDtcclxuICAgICAgICBiID0gMTtcclxuICAgICAgICBjID0gYSAqIHBvaW50MVswXSAtIHBvaW50MVsxXTtcclxuICAgIH1cclxuICAgIHJldHVybiBbYSwgYiwgY10ubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aHJvdHRsZSh2LCBUSU5ZX05VTSQxKTsgfSk7XHJcbn1cblxudmFyIE5BTUVfc25hcFJvdGF0aW9uVGhyZXNob2xkID0gXCJzbmFwUm90YXRpb25UaHJlc2hvbGRcIjtcclxudmFyIE5BTUVfc25hcFJvdGF0aW9uRGVncmVlcyA9IFwic25hcFJvdGF0aW9uRGVncmVlc1wiO1xyXG52YXIgTkFNRV9zbmFwSG9yaXpvbnRhbFRocmVzaG9sZCA9IFwic25hcEhvcml6b250YWxUaHJlc2hvbGRcIjtcclxudmFyIE5BTUVfc25hcFZlcnRpY2FsVGhyZXNob2xkID0gXCJzbmFwVmVydGljYWxUaHJlc2hvbGRcIjtcblxuZnVuY3Rpb24gY2hlY2tNb3ZlYWJsZVNuYXBQb3Nlcyhtb3ZlYWJsZSwgcG9zZXNYLCBwb3Nlc1ksIGRpclhzLCBkaXJZcywgY3VzdG9tU25hcFZlcnRpY2FsVGhyZXNob2xkLCBjdXN0b21TbmFwSG9yaXpvbnRhbFRocmVzaG9sZCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgaWYgKGRpclhzID09PSB2b2lkIDApIHsgZGlyWHMgPSBbXTsgfVxyXG4gICAgaWYgKGRpcllzID09PSB2b2lkIDApIHsgZGlyWXMgPSBbXTsgfVxyXG4gICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICB2YXIgc25hcFRocmVzaG9sZE11bHRpcGxlcyA9ICgoX2EgPSBtb3ZlYWJsZS5zdGF0ZS5zbmFwVGhyZXNob2xkSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm11bHRpcGxlcykgfHwgWzEsIDFdO1xyXG4gICAgdmFyIHNuYXBIb3Jpem9udGFsVGhyZXNob2xkID0gc2VsZWN0VmFsdWUoY3VzdG9tU25hcEhvcml6b250YWxUaHJlc2hvbGQsIHByb3BzW05BTUVfc25hcEhvcml6b250YWxUaHJlc2hvbGRdLCA1KTtcclxuICAgIHZhciBzbmFwVmVydGljYWxUaHJlc2hvbGQgPSBzZWxlY3RWYWx1ZShjdXN0b21TbmFwVmVydGljYWxUaHJlc2hvbGQsIHByb3BzW05BTUVfc25hcFZlcnRpY2FsVGhyZXNob2xkXSwgNSk7XHJcbiAgICByZXR1cm4gY2hlY2tTbmFwUG9zZXMobW92ZWFibGUuc3RhdGUuZ3VpZGVsaW5lcywgcG9zZXNYLCBwb3Nlc1ksIGRpclhzLCBkaXJZcywgc25hcEhvcml6b250YWxUaHJlc2hvbGQsIHNuYXBWZXJ0aWNhbFRocmVzaG9sZCwgc25hcFRocmVzaG9sZE11bHRpcGxlcyk7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTbmFwUG9zZXMoZ3VpZGVsaW5lcywgcG9zZXNYLCBwb3Nlc1ksIGRpclhzLCBkaXJZcywgc25hcEhvcml6b250YWxUaHJlc2hvbGQsIHNuYXBWZXJ0aWNhbFRocmVzaG9sZCwgbXVsdGlwbGVzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZlcnRpY2FsOiBjaGVja1NuYXAoZ3VpZGVsaW5lcywgXCJ2ZXJ0aWNhbFwiLCBwb3Nlc1gsIHNuYXBWZXJ0aWNhbFRocmVzaG9sZCAqIG11bHRpcGxlc1swXSwgZGlyWHMpLFxyXG4gICAgICAgIGhvcml6b250YWw6IGNoZWNrU25hcChndWlkZWxpbmVzLCBcImhvcml6b250YWxcIiwgcG9zZXNZLCBzbmFwSG9yaXpvbnRhbFRocmVzaG9sZCAqIG11bHRpcGxlc1sxXSwgZGlyWXMpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGVja1NuYXBLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcclxuICAgIHZhciBfYSA9IF9fcmVhZChlbmRQb3MsIDIpLCBlbmRYID0gX2FbMF0sIGVuZFkgPSBfYVsxXTtcclxuICAgIHZhciBfYiA9IF9fcmVhZChzdGFydFBvcywgMiksIHN0YXJ0WCA9IF9iWzBdLCBzdGFydFkgPSBfYlsxXTtcclxuICAgIHZhciBfYyA9IF9fcmVhZChtaW51cyhlbmRQb3MsIHN0YXJ0UG9zKSwgMiksIGR4ID0gX2NbMF0sIGR5ID0gX2NbMV07XHJcbiAgICB2YXIgaXNCb3R0b20gPSBkeSA+IDA7XHJcbiAgICB2YXIgaXNSaWdodCA9IGR4ID4gMDtcclxuICAgIGR4ID0gZ2V0VGlueURpc3QoZHgpO1xyXG4gICAgZHkgPSBnZXRUaW55RGlzdChkeSk7XHJcbiAgICB2YXIgdmVydGljYWxJbmZvID0ge1xyXG4gICAgICAgIGlzU25hcDogZmFsc2UsXHJcbiAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgIHBvczogMCxcclxuICAgIH07XHJcbiAgICB2YXIgaG9yaXpvbnRhbEluZm8gPSB7XHJcbiAgICAgICAgaXNTbmFwOiBmYWxzZSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgcG9zOiAwLFxyXG4gICAgfTtcclxuICAgIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbEluZm8sXHJcbiAgICAgICAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxJbmZvLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgX2QgPSBjaGVja01vdmVhYmxlU25hcFBvc2VzKG1vdmVhYmxlLCBkeCA/IFtlbmRYXSA6IFtdLCBkeSA/IFtlbmRZXSA6IFtdLCBbXSwgW10sIHVuZGVmaW5lZCwgdW5kZWZpbmVkKSwgdmVydGljYWxTbmFwSW5mbyA9IF9kLnZlcnRpY2FsLCBob3Jpem9udGFsU25hcEluZm8gPSBfZC5ob3Jpem9udGFsO1xyXG4gICAgdmVydGljYWxTbmFwSW5mby5wb3NJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IF9hLnBvcztcclxuICAgICAgICByZXR1cm4gaXNSaWdodCA/IHBvcyA+PSBzdGFydFggOiBwb3MgPD0gc3RhcnRYO1xyXG4gICAgfSk7XHJcbiAgICBob3Jpem9udGFsU25hcEluZm8ucG9zSW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBwb3MgPSBfYS5wb3M7XHJcbiAgICAgICAgcmV0dXJuIGlzQm90dG9tID8gcG9zID49IHN0YXJ0WSA6IHBvcyA8PSBzdGFydFk7XHJcbiAgICB9KTtcclxuICAgIHZlcnRpY2FsU25hcEluZm8uaXNTbmFwID0gdmVydGljYWxTbmFwSW5mby5wb3NJbmZvcy5sZW5ndGggPiAwO1xyXG4gICAgaG9yaXpvbnRhbFNuYXBJbmZvLmlzU25hcCA9IGhvcml6b250YWxTbmFwSW5mby5wb3NJbmZvcy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9lID0gZ2V0TmVhcmVzdFNuYXBHdWlkZWxpbmVJbmZvKHZlcnRpY2FsU25hcEluZm8pLCBpc1ZlcnRpY2FsU25hcCA9IF9lLmlzU25hcCwgdmVydGljYWxHdWlkZWxpbmUgPSBfZS5ndWlkZWxpbmU7XHJcbiAgICB2YXIgX2YgPSBnZXROZWFyZXN0U25hcEd1aWRlbGluZUluZm8oaG9yaXpvbnRhbFNuYXBJbmZvKSwgaXNIb3Jpem9udGFsU25hcCA9IF9mLmlzU25hcCwgaG9yaXpvbnRhbEd1aWRlbGluZSA9IF9mLmd1aWRlbGluZTtcclxuICAgIHZhciBob3Jpem9udGFsUG9zID0gaXNIb3Jpem9udGFsU25hcCA/IGhvcml6b250YWxHdWlkZWxpbmUucG9zWzFdIDogMDtcclxuICAgIHZhciB2ZXJ0aWNhbFBvcyA9IGlzVmVydGljYWxTbmFwID8gdmVydGljYWxHdWlkZWxpbmUucG9zWzBdIDogMDtcclxuICAgIGlmIChkeCA9PT0gMCkge1xyXG4gICAgICAgIGlmIChpc0hvcml6b250YWxTbmFwKSB7XHJcbiAgICAgICAgICAgIGhvcml6b250YWxJbmZvLmlzU25hcCA9IHRydWU7XHJcbiAgICAgICAgICAgIGhvcml6b250YWxJbmZvLnBvcyA9IGhvcml6b250YWxHdWlkZWxpbmUucG9zWzFdO1xyXG4gICAgICAgICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0gaG9yaXpvbnRhbEluZm8ucG9zO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGR5ID09PSAwKSB7XHJcbiAgICAgICAgaWYgKGlzVmVydGljYWxTbmFwKSB7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsSW5mby5pc1NuYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbEluZm8ucG9zID0gdmVydGljYWxQb3M7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsSW5mby5vZmZzZXQgPSBlbmRYIC0gdmVydGljYWxQb3M7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8geSAtIHkxID0gYSAqICh4IC0geDEpXHJcbiAgICAgICAgdmFyIGEgPSBkeSAvIGR4O1xyXG4gICAgICAgIHZhciBiID0gZW5kUG9zWzFdIC0gYSAqIGVuZFg7XHJcbiAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICB2YXIgaXNTbmFwID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGlzVmVydGljYWxTbmFwKSB7XHJcbiAgICAgICAgICAgIHggPSB2ZXJ0aWNhbFBvcztcclxuICAgICAgICAgICAgeSA9IGEgKiB4ICsgYjtcclxuICAgICAgICAgICAgaXNTbmFwID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNIb3Jpem9udGFsU25hcCkge1xyXG4gICAgICAgICAgICB5ID0gaG9yaXpvbnRhbFBvcztcclxuICAgICAgICAgICAgeCA9ICh5IC0gYikgLyBhO1xyXG4gICAgICAgICAgICBpc1NuYXAgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTbmFwKSB7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsSW5mby5pc1NuYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbEluZm8ucG9zID0geDtcclxuICAgICAgICAgICAgdmVydGljYWxJbmZvLm9mZnNldCA9IGVuZFggLSB4O1xyXG4gICAgICAgICAgICBob3Jpem9udGFsSW5mby5pc1NuYXAgPSB0cnVlO1xyXG4gICAgICAgICAgICBob3Jpem9udGFsSW5mby5wb3MgPSB5O1xyXG4gICAgICAgICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0geTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbEluZm8sXHJcbiAgICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEluZm8sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFN0cmluZ0RpcmVjdGlvbihkaXIpIHtcclxuICAgIHZhciBzdHJpbmdEaXJlY3Rpb24gPSBcIlwiO1xyXG4gICAgaWYgKGRpciA9PT0gLTEgfHwgZGlyID09PSBcInRvcFwiIHx8IGRpciA9PT0gXCJsZWZ0XCIpIHtcclxuICAgICAgICBzdHJpbmdEaXJlY3Rpb24gPSBcInN0YXJ0XCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkaXIgPT09IDAgfHwgZGlyID09PSBcImNlbnRlclwiIHx8IGRpciA9PT0gXCJtaWRkbGVcIikge1xyXG4gICAgICAgIHN0cmluZ0RpcmVjdGlvbiA9IFwiY2VudGVyXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkaXIgPT09IDEgfHwgZGlyID09PSBcInJpZ2h0XCIgfHwgZGlyID09PSBcImJvdHRvbVwiKSB7XHJcbiAgICAgICAgc3RyaW5nRGlyZWN0aW9uID0gXCJlbmRcIjtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHJpbmdEaXJlY3Rpb247XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTbmFwcyhtb3ZlYWJsZSwgcmVjdCwgY3VzdG9tU25hcFZlcnRpY2FsVGhyZXNob2xkLCBjdXN0b21TbmFwSG9yaXpvbnRhbFRocmVzaG9sZCkge1xyXG4gICAgdmFyIHBvc2VzID0gc3BsaXRTbmFwRGlyZWN0aW9uUG9zZXMobW92ZWFibGUucHJvcHMuc25hcERpcmVjdGlvbnMsIHJlY3QpO1xyXG4gICAgdmFyIHJlc3VsdCA9IGNoZWNrTW92ZWFibGVTbmFwUG9zZXMobW92ZWFibGUsIHBvc2VzLnZlcnRpY2FsLCBwb3Nlcy5ob3Jpem9udGFsLCBwb3Nlcy52ZXJ0aWNhbE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2V0U3RyaW5nRGlyZWN0aW9uKG5hbWUpOyB9KSwgcG9zZXMuaG9yaXpvbnRhbE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2V0U3RyaW5nRGlyZWN0aW9uKG5hbWUpOyB9KSwgY3VzdG9tU25hcFZlcnRpY2FsVGhyZXNob2xkLCBjdXN0b21TbmFwSG9yaXpvbnRhbFRocmVzaG9sZCk7XHJcbiAgICB2YXIgaG9yaXpvbnRhbERpcmVjdGlvbiA9IGdldFN0cmluZ0RpcmVjdGlvbihwb3Nlcy5ob3Jpem9udGFsTmFtZXNbcmVzdWx0Lmhvcml6b250YWwuaW5kZXhdKTtcclxuICAgIHZhciB2ZXJ0aWNhbERpcmVjdGlvbiA9IGdldFN0cmluZ0RpcmVjdGlvbihwb3Nlcy52ZXJ0aWNhbE5hbWVzW3Jlc3VsdC52ZXJ0aWNhbC5pbmRleF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2ZXJ0aWNhbDogX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdC52ZXJ0aWNhbCksIHsgZGlyZWN0aW9uOiB2ZXJ0aWNhbERpcmVjdGlvbiB9KSxcclxuICAgICAgICBob3Jpem9udGFsOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0Lmhvcml6b250YWwpLCB7IGRpcmVjdGlvbjogaG9yaXpvbnRhbERpcmVjdGlvbiB9KSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmVhcmVzdFNuYXBHdWlkZWxpbmVJbmZvKHNuYXBJbmZvKSB7XHJcbiAgICB2YXIgaXNTbmFwID0gc25hcEluZm8uaXNTbmFwO1xyXG4gICAgaWYgKCFpc1NuYXApIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc1NuYXA6IGZhbHNlLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgIGRpc3Q6IC0xLFxyXG4gICAgICAgICAgICBwb3M6IDAsXHJcbiAgICAgICAgICAgIGd1aWRlbGluZTogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHBvc0luZm8gPSBzbmFwSW5mby5wb3NJbmZvc1swXTtcclxuICAgIHZhciBndWlkZWxpbmVJbmZvID0gcG9zSW5mby5ndWlkZWxpbmVJbmZvc1swXTtcclxuICAgIHZhciBvZmZzZXQgPSBndWlkZWxpbmVJbmZvLm9mZnNldDtcclxuICAgIHZhciBkaXN0ID0gZ3VpZGVsaW5lSW5mby5kaXN0O1xyXG4gICAgdmFyIGd1aWRlbGluZSA9IGd1aWRlbGluZUluZm8uZ3VpZGVsaW5lO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc1NuYXA6IGlzU25hcCxcclxuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcclxuICAgICAgICBkaXN0OiBkaXN0LFxyXG4gICAgICAgIHBvczogcG9zSW5mby5wb3MsXHJcbiAgICAgICAgZ3VpZGVsaW5lOiBndWlkZWxpbmUsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrU25hcChndWlkZWxpbmVzLCB0YXJnZXRUeXBlLCB0YXJnZXRQb3Nlcywgc25hcFRocmVzaG9sZCwgZGlycykge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGlmIChkaXJzID09PSB2b2lkIDApIHsgZGlycyA9IFtdOyB9XHJcbiAgICBpZiAoIWd1aWRlbGluZXMgfHwgIWd1aWRlbGluZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXNTbmFwOiBmYWxzZSxcclxuICAgICAgICAgICAgaW5kZXg6IC0xLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiXCIsXHJcbiAgICAgICAgICAgIHBvc0luZm9zOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGlzVmVydGljYWwgPSB0YXJnZXRUeXBlID09PSBcInZlcnRpY2FsXCI7XHJcbiAgICB2YXIgcG9zVHlwZSA9IGlzVmVydGljYWwgPyAwIDogMTtcclxuICAgIHZhciBzbmFwUG9zSW5mb3MgPSB0YXJnZXRQb3Nlcy5tYXAoZnVuY3Rpb24gKHRhcmdldFBvcywgaW5kZXgpIHtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyc1tpbmRleF0gfHwgXCJcIjtcclxuICAgICAgICB2YXIgZ3VpZGVsaW5lSW5mb3MgPSBndWlkZWxpbmVzLm1hcChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBndWlkZWxpbmUucG9zO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGFyZ2V0UG9zIC0gcG9zW3Bvc1R5cGVdO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBkaXN0OiBhYnMob2Zmc2V0KSxcclxuICAgICAgICAgICAgICAgIGd1aWRlbGluZTogZ3VpZGVsaW5lLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgZ3VpZGVsaW5lID0gX2EuZ3VpZGVsaW5lLCBkaXN0ID0gX2EuZGlzdDtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBndWlkZWxpbmUudHlwZTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgIT09IHRhcmdldFR5cGVcclxuICAgICAgICAgICAgICAgIHx8IGRpc3QgPiBzbmFwVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5kaXN0IC0gYi5kaXN0OyB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwb3M6IHRhcmdldFBvcyxcclxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICBndWlkZWxpbmVJbmZvczogZ3VpZGVsaW5lSW5mb3MsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxyXG4gICAgICAgIH07XHJcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHNuYXBQb3NJbmZvKSB7XHJcbiAgICAgICAgcmV0dXJuIHNuYXBQb3NJbmZvLmd1aWRlbGluZUluZm9zLmxlbmd0aCA+IDA7XHJcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuZ3VpZGVsaW5lSW5mb3NbMF0uZGlzdCAtIGIuZ3VpZGVsaW5lSW5mb3NbMF0uZGlzdDtcclxuICAgIH0pO1xyXG4gICAgdmFyIGlzU25hcCA9IHNuYXBQb3NJbmZvcy5sZW5ndGggPiAwO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc1NuYXA6IGlzU25hcCxcclxuICAgICAgICBpbmRleDogaXNTbmFwID8gc25hcFBvc0luZm9zWzBdLmluZGV4IDogLTEsXHJcbiAgICAgICAgZGlyZWN0aW9uOiAoX2IgPSAoX2EgPSBzbmFwUG9zSW5mb3NbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXJlY3Rpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCIsXHJcbiAgICAgICAgcG9zSW5mb3M6IHNuYXBQb3NJbmZvcyxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0U25hcEluZm9zQnlEaXJlY3Rpb24obW92ZWFibGUsIFxyXG4vLyBwb3MxIHBvczIgcG9zMyBwb3M0XHJcbnBvc2VzLCBzbmFwRGlyZWN0aW9uLCBjdXN0b21TbmFwVmVydGljYWxUaHJlc2hvbGQsIGN1c3RvbVNuYXBIb3Jpem9udGFsVGhyZXNob2xkKSB7XHJcbiAgICB2YXIgZGlycyA9IFtdO1xyXG4gICAgaWYgKHNuYXBEaXJlY3Rpb25bMF0gJiYgc25hcERpcmVjdGlvblsxXSkge1xyXG4gICAgICAgIGRpcnMgPSBbXHJcbiAgICAgICAgICAgIHNuYXBEaXJlY3Rpb24sXHJcbiAgICAgICAgICAgIFstc25hcERpcmVjdGlvblswXSwgc25hcERpcmVjdGlvblsxXV0sXHJcbiAgICAgICAgICAgIFtzbmFwRGlyZWN0aW9uWzBdLCAtc25hcERpcmVjdGlvblsxXV0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFzbmFwRGlyZWN0aW9uWzBdICYmICFzbmFwRGlyZWN0aW9uWzFdKSB7XHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICBbLTEsIC0xXSxcclxuICAgICAgICAgICAgWzEsIC0xXSxcclxuICAgICAgICAgICAgWzEsIDFdLFxyXG4gICAgICAgICAgICBbLTEsIDFdLFxyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoZGlyLCBpLCBhcnIpIHtcclxuICAgICAgICAgICAgdmFyIG5leHREaXIgPSAoYXJyW2kgKyAxXSB8fCBhcnJbMF0pO1xyXG4gICAgICAgICAgICBkaXJzLnB1c2goZGlyKTtcclxuICAgICAgICAgICAgZGlycy5wdXNoKFtcclxuICAgICAgICAgICAgICAgIChkaXJbMF0gKyBuZXh0RGlyWzBdKSAvIDIsXHJcbiAgICAgICAgICAgICAgICAoZGlyWzFdICsgbmV4dERpclsxXSkgLyAyLFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChtb3ZlYWJsZS5wcm9wcy5rZWVwUmF0aW8pIHtcclxuICAgICAgICAgICAgZGlycy5wdXNoKFstMSwgLTFdLCBbLTEsIDFdLCBbMSwgLTFdLCBbMSwgMV0sIHNuYXBEaXJlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGlycy5wdXNoLmFwcGx5KGRpcnMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChnZXRQb3Nlc0J5RGlyZWN0aW9uKFtcclxuICAgICAgICAgICAgICAgIFstMSwgLTFdLFxyXG4gICAgICAgICAgICAgICAgWzEsIC0xXSxcclxuICAgICAgICAgICAgICAgIFstMSwgLTFdLFxyXG4gICAgICAgICAgICAgICAgWzEsIDFdLFxyXG4gICAgICAgICAgICBdLCBzbmFwRGlyZWN0aW9uKSksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIGlmIChkaXJzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGRpcnMucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgKGRpcnNbMF1bMF0gKyBkaXJzWzFdWzBdKSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgKGRpcnNbMF1bMV0gKyBkaXJzWzFdWzFdKSAvIDIsXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBuZXh0UG9zZXMgPSBkaXJzLm1hcChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZGlyKTsgfSk7XHJcbiAgICB2YXIgeHMgPSBuZXh0UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1swXTsgfSk7XHJcbiAgICB2YXIgeXMgPSBuZXh0UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1sxXTsgfSk7XHJcbiAgICB2YXIgcmVzdWx0ID0gY2hlY2tNb3ZlYWJsZVNuYXBQb3Nlcyhtb3ZlYWJsZSwgeHMsIHlzLCBkaXJzLm1hcChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBnZXRTdHJpbmdEaXJlY3Rpb24oZGlyWzBdKTsgfSksIGRpcnMubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGdldFN0cmluZ0RpcmVjdGlvbihkaXJbMV0pOyB9KSwgY3VzdG9tU25hcFZlcnRpY2FsVGhyZXNob2xkLCBjdXN0b21TbmFwSG9yaXpvbnRhbFRocmVzaG9sZCk7XHJcbiAgICB2YXIgdmVydGljYWxEaXJlY3Rpb24gPSBnZXRTdHJpbmdEaXJlY3Rpb24oZGlycy5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZGlyWzBdOyB9KVtyZXN1bHQudmVydGljYWwuaW5kZXhdKTtcclxuICAgIHZhciBob3Jpem9udGFsRGlyZWN0aW9uID0gZ2V0U3RyaW5nRGlyZWN0aW9uKGRpcnMubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpclsxXTsgfSlbcmVzdWx0Lmhvcml6b250YWwuaW5kZXhdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmVydGljYWw6IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQudmVydGljYWwpLCB7IGRpcmVjdGlvbjogdmVydGljYWxEaXJlY3Rpb24gfSksXHJcbiAgICAgICAgaG9yaXpvbnRhbDogX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdC5ob3Jpem9udGFsKSwgeyBkaXJlY3Rpb246IGhvcml6b250YWxEaXJlY3Rpb24gfSksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrU25hcEJvdW5kUHJpb3JpdHkoYSwgYikge1xyXG4gICAgdmFyIGFEaXN0ID0gYWJzKGEub2Zmc2V0KTtcclxuICAgIHZhciBiRGlzdCA9IGFicyhiLm9mZnNldCk7XHJcbiAgICBpZiAoYS5pc0JvdW5kICYmIGIuaXNCb3VuZCkge1xyXG4gICAgICAgIHJldHVybiBiRGlzdCAtIGFEaXN0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYS5pc0JvdW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYi5pc0JvdW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhLmlzU25hcCAmJiBiLmlzU25hcCkge1xyXG4gICAgICAgIHJldHVybiBiRGlzdCAtIGFEaXN0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYS5pc1NuYXApIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiLmlzU25hcCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYURpc3QgPCBUSU5ZX05VTSkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYkRpc3QgPCBUSU5ZX05VTSkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiBhRGlzdCAtIGJEaXN0O1xyXG59XHJcbmZ1bmN0aW9uIGdldE5lYXJPZmZzZXRJbmZvKG9mZnNldHMsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gb2Zmc2V0cy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgYVNpZ24gPSBhLnNpZ25baW5kZXhdO1xyXG4gICAgICAgIHZhciBiU2lnbiA9IGIuc2lnbltpbmRleF07XHJcbiAgICAgICAgdmFyIGFPZmZzZXQgPSBhLm9mZnNldFtpbmRleF07XHJcbiAgICAgICAgdmFyIGJPZmZzZXQgPSBiLm9mZnNldFtpbmRleF07XHJcbiAgICAgICAgLy8gLTEgVGhlIHBvc2l0aW9ucyBvZiBhIGFuZCBiIGRvIG5vdCBjaGFuZ2UuXHJcbiAgICAgICAgLy8gMSBUaGUgcG9zaXRpb25zIG9mIGEgYW5kIGIgYXJlIHJldmVyc2VkLlxyXG4gICAgICAgIGlmICghYVNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFiU2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGVja1NuYXBCb3VuZFByaW9yaXR5KHsgaXNCb3VuZDogYS5pc0JvdW5kLCBpc1NuYXA6IGEuaXNTbmFwLCBvZmZzZXQ6IGFPZmZzZXQgfSwgeyBpc0JvdW5kOiBiLmlzQm91bmQsIGlzU25hcDogYi5pc1NuYXAsIG9mZnNldDogYk9mZnNldCB9KTtcclxuICAgIH0pWzBdO1xyXG59XHJcbmZ1bmN0aW9uIGdldENoZWNrU25hcERpcmVjdGlvbnMoZGlyZWN0aW9uLCBmaXhlZERpcmVjdGlvbiwga2VlcFJhdGlvKSB7XHJcbiAgICB2YXIgZGlyZWN0aW9ucyA9IFtdO1xyXG4gICAgLy8gY29uc3QgZml4ZWREaXJlY3Rpb24gPSBbLWRpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV07XHJcbiAgICBpZiAoa2VlcFJhdGlvKSB7XHJcbiAgICAgICAgaWYgKGFicyhmaXhlZERpcmVjdGlvblswXSkgIT09IDEgfHwgYWJzKGZpeGVkRGlyZWN0aW9uWzFdKSAhPT0gMSkge1xyXG4gICAgICAgICAgICBkaXJlY3Rpb25zLnB1c2goW2ZpeGVkRGlyZWN0aW9uLCBbLTEsIC0xXV0sIFtmaXhlZERpcmVjdGlvbiwgWy0xLCAxXV0sIFtmaXhlZERpcmVjdGlvbiwgWzEsIC0xXV0sIFtmaXhlZERpcmVjdGlvbiwgWzEsIDFdXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkaXJlY3Rpb25zLnB1c2goW2ZpeGVkRGlyZWN0aW9uLCBbZGlyZWN0aW9uWzBdLCAtZGlyZWN0aW9uWzFdXV0sIFtmaXhlZERpcmVjdGlvbiwgWy1kaXJlY3Rpb25bMF0sIGRpcmVjdGlvblsxXV1dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlyZWN0aW9ucy5wdXNoKFtmaXhlZERpcmVjdGlvbiwgZGlyZWN0aW9uXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoKGRpcmVjdGlvblswXSAmJiBkaXJlY3Rpb25bMV0pIHx8ICghZGlyZWN0aW9uWzBdICYmICFkaXJlY3Rpb25bMV0pKSB7XHJcbiAgICAgICAgICAgIHZhciBlbmREaXJlY3Rpb25fMSA9IGRpcmVjdGlvblswXSA/IGRpcmVjdGlvbiA6IFsxLCAxXTtcclxuICAgICAgICAgICAgWzEsIC0xXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWduWCkge1xyXG4gICAgICAgICAgICAgICAgWzEsIC0xXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWduWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0RGlyZWN0aW9uID0gW3NpZ25YICogZW5kRGlyZWN0aW9uXzFbMF0sIHNpZ25ZICogZW5kRGlyZWN0aW9uXzFbMV1dO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXhlZERpcmVjdGlvblswXSA9PT0gbmV4dERpcmVjdGlvblswXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBmaXhlZERpcmVjdGlvblsxXSA9PT0gbmV4dERpcmVjdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMucHVzaChbZml4ZWREaXJlY3Rpb24sIG5leHREaXJlY3Rpb25dKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWducyA9IGFicyhmaXhlZERpcmVjdGlvblswXSkgPT09IDEgPyBbMV0gOiBbMSwgLTFdO1xyXG4gICAgICAgICAgICBzaWducy5mb3JFYWNoKGZ1bmN0aW9uIChzaWduKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25zLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgIFtmaXhlZERpcmVjdGlvblswXSwgLTFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtzaWduICogZGlyZWN0aW9uWzBdLCAtMV0sXHJcbiAgICAgICAgICAgICAgICBdLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgW2ZpeGVkRGlyZWN0aW9uWzBdLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbc2lnbiAqIGRpcmVjdGlvblswXSwgMF0sXHJcbiAgICAgICAgICAgICAgICBdLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgW2ZpeGVkRGlyZWN0aW9uWzBdLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBbc2lnbiAqIGRpcmVjdGlvblswXSwgMV0sXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvblsxXSkge1xyXG4gICAgICAgICAgICB2YXIgc2lnbnMgPSBhYnMoZml4ZWREaXJlY3Rpb25bMV0pID09PSAxID8gWzFdIDogWzEsIC0xXTtcclxuICAgICAgICAgICAgc2lnbnMuZm9yRWFjaChmdW5jdGlvbiAoc2lnbikge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9ucy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICBbLTEsIGZpeGVkRGlyZWN0aW9uWzFdXSxcclxuICAgICAgICAgICAgICAgICAgICBbLTEsIHNpZ24gKiBkaXJlY3Rpb25bMV1dLFxyXG4gICAgICAgICAgICAgICAgXSwgW1xyXG4gICAgICAgICAgICAgICAgICAgIFswLCBmaXhlZERpcmVjdGlvblsxXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzAsIHNpZ24gKiBkaXJlY3Rpb25bMV1dLFxyXG4gICAgICAgICAgICAgICAgXSwgW1xyXG4gICAgICAgICAgICAgICAgICAgIFsxLCBmaXhlZERpcmVjdGlvblsxXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgWzEsIHNpZ24gKiBkaXJlY3Rpb25bMV1dLFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkaXJlY3Rpb25zO1xyXG59XG5cbmZ1bmN0aW9uIGlzU3RhcnRMaW5lKGRvdCwgbGluZSkge1xyXG4gICAgLy8gbCAgICBvICAgICA9PiB0cnVlXHJcbiAgICAvLyBvICAgIGwgICAgPT4gZmFsc2VcclxuICAgIHZhciBjeCA9IGF2ZXJhZ2UoW2xpbmVbMF1bMF0sIGxpbmVbMV1bMF1dKTtcclxuICAgIHZhciBjeSA9IGF2ZXJhZ2UoW2xpbmVbMF1bMV0sIGxpbmVbMV1bMV1dKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmVydGljYWw6IGN4IDw9IGRvdFswXSxcclxuICAgICAgICBob3Jpem9udGFsOiBjeSA8PSBkb3RbMV0sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGhpdFRlc3RMaW5lKGRvdCwgX2EpIHtcclxuICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHBvczEgPSBfYlswXSwgcG9zMiA9IF9iWzFdO1xyXG4gICAgdmFyIGR4ID0gcG9zMlswXSAtIHBvczFbMF07XHJcbiAgICB2YXIgZHkgPSBwb3MyWzFdIC0gcG9zMVsxXTtcclxuICAgIGlmIChhYnMoZHgpIDwgVElOWV9OVU0pIHtcclxuICAgICAgICBkeCA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoYWJzKGR5KSA8IFRJTllfTlVNKSB7XHJcbiAgICAgICAgZHkgPSAwO1xyXG4gICAgfVxyXG4gICAgdmFyIHRlc3QxO1xyXG4gICAgdmFyIHRlc3QyO1xyXG4gICAgaWYgKCFkeCkge1xyXG4gICAgICAgIHRlc3QxID0gcG9zMVswXTtcclxuICAgICAgICB0ZXN0MiA9IGRvdFswXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFkeSkge1xyXG4gICAgICAgIHRlc3QxID0gcG9zMVsxXTtcclxuICAgICAgICB0ZXN0MiA9IGRvdFsxXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBhID0gZHkgLyBkeDtcclxuICAgICAgICAvLyB5ID0gYSAqICh4IC0gcG9zMSkgKyBwb3MxXHJcbiAgICAgICAgdGVzdDEgPSBhICogKGRvdFswXSAtIHBvczFbMF0pICsgcG9zMVsxXTtcclxuICAgICAgICB0ZXN0MiA9IGRvdFsxXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0ZXN0MSAtIHRlc3QyO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVN0YXJ0TGluZShkb3RzLCBsaW5lLCBjZW50ZXJTaWduLCBlcnJvcikge1xyXG4gICAgaWYgKGVycm9yID09PSB2b2lkIDApIHsgZXJyb3IgPSBUSU5ZX05VTTsgfVxyXG4gICAgcmV0dXJuIGRvdHMuZXZlcnkoZnVuY3Rpb24gKGRvdCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGhpdFRlc3RMaW5lKGRvdCwgbGluZSk7XHJcbiAgICAgICAgdmFyIHNpZ24gPSB2YWx1ZSA8PSAwO1xyXG4gICAgICAgIHJldHVybiBzaWduID09PSBjZW50ZXJTaWduIHx8IGFicyh2YWx1ZSkgPD0gZXJyb3I7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0lubmVyQm91bmREb3QocG9zLCBzdGFydCwgZW5kLCBpc1N0YXJ0LCB0aHJlc2hvbGQpIHtcclxuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkgeyB0aHJlc2hvbGQgPSAwOyB9XHJcbiAgICBpZiAoKGlzU3RhcnQgJiYgc3RhcnQgLSB0aHJlc2hvbGQgPD0gcG9zKVxyXG4gICAgICAgIHx8ICghaXNTdGFydCAmJiBwb3MgPD0gZW5kICsgdGhyZXNob2xkKSkge1xyXG4gICAgICAgIC8vIGZhbHNlIDQwMiA1NjUgNjAyID0+IDM3IChbMCwgMzddKVxyXG4gICAgICAgIC8vIHRydWUgNDAwIDUyNC45NzEyNjAzNTQwMDM2IDYwMCA9PiAxMjQgKFsxMjQsIDBdKVxyXG4gICAgICAgIC8vIHRydWUgNDAwIDQxMCA2MDAgPT4gMTAgKFsxMCwgMF0pXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXNCb3VuZDogdHJ1ZSxcclxuICAgICAgICAgICAgb2Zmc2V0OiBpc1N0YXJ0ID8gc3RhcnQgLSBwb3MgOiBlbmQgLSBwb3MsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaXNCb3VuZDogZmFsc2UsXHJcbiAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0lubmVyQm91bmQobW92ZWFibGUsIF9hKSB7XHJcbiAgICB2YXIgbGluZSA9IF9hLmxpbmUsIGNlbnRlclNpZ24gPSBfYS5jZW50ZXJTaWduLCB2ZXJ0aWNhbFNpZ24gPSBfYS52ZXJ0aWNhbFNpZ24sIGhvcml6b250YWxTaWduID0gX2EuaG9yaXpvbnRhbFNpZ24sIGxpbmVDb25zdGFudHMgPSBfYS5saW5lQ29uc3RhbnRzO1xyXG4gICAgdmFyIGJvdW5kcyA9IG1vdmVhYmxlLnByb3BzLmlubmVyQm91bmRzO1xyXG4gICAgaWYgKCFib3VuZHMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc0FsbEJvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNCb3VuZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzVmVydGljYWxCb3VuZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbEJvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHZhciBsZWZ0ID0gYm91bmRzLmxlZnQsIHRvcCA9IGJvdW5kcy50b3AsIHdpZHRoID0gYm91bmRzLndpZHRoLCBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0O1xyXG4gICAgdmFyIGxlZnRMaW5lID0gW1tsZWZ0LCB0b3BdLCBbbGVmdCwgdG9wICsgaGVpZ2h0XV07XHJcbiAgICB2YXIgdG9wTGluZSA9IFtbbGVmdCwgdG9wXSwgW2xlZnQgKyB3aWR0aCwgdG9wXV07XHJcbiAgICB2YXIgcmlnaHRMaW5lID0gW1tsZWZ0ICsgd2lkdGgsIHRvcF0sIFtsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodF1dO1xyXG4gICAgdmFyIGJvdHRvbUxpbmUgPSBbW2xlZnQsIHRvcCArIGhlaWdodF0sIFtsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodF1dO1xyXG4gICAgaWYgKGlzU2FtZVN0YXJ0TGluZShbXHJcbiAgICAgICAgW2xlZnQsIHRvcF0sXHJcbiAgICAgICAgW2xlZnQgKyB3aWR0aCwgdG9wXSxcclxuICAgICAgICBbbGVmdCwgdG9wICsgaGVpZ2h0XSxcclxuICAgICAgICBbbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHRdLFxyXG4gICAgXSwgbGluZSwgY2VudGVyU2lnbikpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc0FsbEJvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNCb3VuZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzVmVydGljYWxCb3VuZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbEJvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIHRlc3QgdmVydGljYWxcclxuICAgIHZhciB0b3BCb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBsaW5lQ29uc3RhbnRzLCB0b3BMaW5lLCB2ZXJ0aWNhbFNpZ24pO1xyXG4gICAgdmFyIGJvdHRvbUJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIGxpbmVDb25zdGFudHMsIGJvdHRvbUxpbmUsIHZlcnRpY2FsU2lnbik7XHJcbiAgICAvLyB0ZXN0IGhvcml6b250YWxcclxuICAgIHZhciBsZWZ0Qm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgbGVmdExpbmUsIGhvcml6b250YWxTaWduKTtcclxuICAgIHZhciByaWdodEJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIGxpbmVDb25zdGFudHMsIHJpZ2h0TGluZSwgaG9yaXpvbnRhbFNpZ24pO1xyXG4gICAgdmFyIGlzQWxsVmVydGljYWxCb3VuZCA9IHRvcEJvdW5kSW5mby5pc0JvdW5kICYmIGJvdHRvbUJvdW5kSW5mby5pc0JvdW5kO1xyXG4gICAgdmFyIGlzVmVydGljYWxCb3VuZCA9IHRvcEJvdW5kSW5mby5pc0JvdW5kIHx8IGJvdHRvbUJvdW5kSW5mby5pc0JvdW5kO1xyXG4gICAgdmFyIGlzQWxsSG9yaXpvbnRhbEJvdW5kID0gbGVmdEJvdW5kSW5mby5pc0JvdW5kICYmIHJpZ2h0Qm91bmRJbmZvLmlzQm91bmQ7XHJcbiAgICB2YXIgaXNIb3Jpem9udGFsQm91bmQgPSBsZWZ0Qm91bmRJbmZvLmlzQm91bmQgfHwgcmlnaHRCb3VuZEluZm8uaXNCb3VuZDtcclxuICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IG1heE9mZnNldCh0b3BCb3VuZEluZm8ub2Zmc2V0LCBib3R0b21Cb3VuZEluZm8ub2Zmc2V0KTtcclxuICAgIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gbWF4T2Zmc2V0KGxlZnRCb3VuZEluZm8ub2Zmc2V0LCByaWdodEJvdW5kSW5mby5vZmZzZXQpO1xyXG4gICAgdmFyIG9mZnNldCA9IFswLCAwXTtcclxuICAgIHZhciBpc0JvdW5kID0gZmFsc2U7XHJcbiAgICB2YXIgaXNBbGxCb3VuZCA9IGZhbHNlO1xyXG4gICAgaWYgKGFicyhob3Jpem9udGFsT2Zmc2V0KSA8IGFicyh2ZXJ0aWNhbE9mZnNldCkpIHtcclxuICAgICAgICBvZmZzZXQgPSBbdmVydGljYWxPZmZzZXQsIDBdO1xyXG4gICAgICAgIGlzQm91bmQgPSBpc1ZlcnRpY2FsQm91bmQ7XHJcbiAgICAgICAgaXNBbGxCb3VuZCA9IGlzQWxsVmVydGljYWxCb3VuZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG9mZnNldCA9IFswLCBob3Jpem9udGFsT2Zmc2V0XTtcclxuICAgICAgICBpc0JvdW5kID0gaXNIb3Jpem9udGFsQm91bmQ7XHJcbiAgICAgICAgaXNBbGxCb3VuZCA9IGlzQWxsSG9yaXpvbnRhbEJvdW5kO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc0FsbEJvdW5kOiBpc0FsbEJvdW5kLFxyXG4gICAgICAgIGlzVmVydGljYWxCb3VuZDogaXNWZXJ0aWNhbEJvdW5kLFxyXG4gICAgICAgIGlzSG9yaXpvbnRhbEJvdW5kOiBpc0hvcml6b250YWxCb3VuZCxcclxuICAgICAgICBpc0JvdW5kOiBpc0JvdW5kLFxyXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBfYSwgYm91bmRMaW5lLCBpc1N0YXJ0LCB0aHJlc2hvbGQsIGlzUmVuZGVyKSB7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBhID0gX2JbMF0sIGIgPSBfYlsxXTtcclxuICAgIHZhciBkb3QxID0gbGluZVswXTtcclxuICAgIC8vIGNvbnN0IGRvdDIgPSBsaW5lWzFdO1xyXG4gICAgdmFyIGJvdW5kRG90MSA9IGJvdW5kTGluZVswXTtcclxuICAgIHZhciBib3VuZERvdDIgPSBib3VuZExpbmVbMV07XHJcbiAgICAvLyBjb25zdCBkeTEgPSBnZXRUaW55RGlzdChkb3QyWzFdIC0gZG90MVsxXSk7XHJcbiAgICAvLyBjb25zdCBkeDEgPSBnZXRUaW55RGlzdChkb3QyWzBdIC0gZG90MVswXSk7XHJcbiAgICB2YXIgZHkyID0gZ2V0VGlueURpc3QoYm91bmREb3QyWzFdIC0gYm91bmREb3QxWzFdKTtcclxuICAgIHZhciBkeDIgPSBnZXRUaW55RGlzdChib3VuZERvdDJbMF0gLSBib3VuZERvdDFbMF0pO1xyXG4gICAgdmFyIGhhc0R4ID0gYjtcclxuICAgIHZhciBoYXNEeSA9IGE7XHJcbiAgICB2YXIgc2xvcGUgPSAtYSAvIGI7XHJcbiAgICAvLyBsaW5lQ29uc3RhbnRzXHJcbiAgICAvLyBheCArIGJ5ICsgYyA9IDBcclxuICAgIC8vIGR4MiBvciBkeTIgaXMgemVyb1xyXG4gICAgaWYgKCFkeDIpIHtcclxuICAgICAgICAvLyB2ZXJ0aWNhbFxyXG4gICAgICAgIC8vIGJ5ICsgYyA9IDBcclxuICAgICAgICBpZiAoaXNSZW5kZXIgJiYgIWhhc0R5KSB7XHJcbiAgICAgICAgICAgIC8vIDkwZGVnXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGFzRHgpIHtcclxuICAgICAgICAgICAgLy8gYXggKyBieSArIGMgPSAwXHJcbiAgICAgICAgICAgIC8vIGNvbnN0IHkgPSBkeTEgPyBkeTEgLyBkeDEgKiAoYm91bmREb3QxWzBdIC0gZG90MVswXSkgKyBkb3QxWzFdIDogZG90MVsxXTtcclxuICAgICAgICAgICAgdmFyIHkgPSBzbG9wZSAqIChib3VuZERvdDFbMF0gLSBkb3QxWzBdKSArIGRvdDFbMV07XHJcbiAgICAgICAgICAgIC8vIGJvdW5kRG90MVsxXSA8PSB5ICA8PSBib3VuZERvdDJbMV1cclxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrSW5uZXJCb3VuZERvdCh5LCBib3VuZERvdDFbMV0sIGJvdW5kRG90MlsxXSwgaXNTdGFydCwgdGhyZXNob2xkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGF4ICsgYyA9IDBcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGJvdW5kRG90MVswXSAtIGRvdDFbMF07XHJcbiAgICAgICAgICAgIHZhciBpc0JvdW5kID0gYWJzKG9mZnNldCkgPD0gKHRocmVzaG9sZCB8fCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlzQm91bmQ6IGlzQm91bmQsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGlzQm91bmQgPyBvZmZzZXQgOiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFkeTIpIHtcclxuICAgICAgICAvLyBob3Jpem9udGFsXHJcbiAgICAgICAgaWYgKGlzUmVuZGVyICYmICFoYXNEeCkge1xyXG4gICAgICAgICAgICAvLyA5MGRlZ1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaXNCb3VuZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc0R5KSB7XHJcbiAgICAgICAgICAgIC8vIHkgPSBhICogKHggLSB4MSkgKyB5MVxyXG4gICAgICAgICAgICAvLyB4ID0gKHkgLSB5MSkgLyBhICsgeDFcclxuICAgICAgICAgICAgLy8gY29uc3QgYSA9IGR5MSAvIGR4MTtcclxuICAgICAgICAgICAgLy8gY29uc3QgeCA9IGR4MSA/IChib3VuZERvdDFbMV0gLSBkb3QxWzFdKSAvIGEgKyBkb3QxWzBdIDogZG90MVswXTtcclxuICAgICAgICAgICAgdmFyIHggPSAoYm91bmREb3QxWzFdIC0gZG90MVsxXSkgLyBzbG9wZSArIGRvdDFbMF07XHJcbiAgICAgICAgICAgIC8vIGJvdW5kRG90MVswXSA8PSB4ICYmIHggPD0gYm91bmREb3QyWzBdXHJcbiAgICAgICAgICAgIHJldHVybiBjaGVja0lubmVyQm91bmREb3QoeCwgYm91bmREb3QxWzBdLCBib3VuZERvdDJbMF0sIGlzU3RhcnQsIHRocmVzaG9sZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYm91bmREb3QxWzFdIC0gZG90MVsxXTtcclxuICAgICAgICAgICAgdmFyIGlzQm91bmQgPSBhYnMob2Zmc2V0KSA8PSAodGhyZXNob2xkIHx8IDApO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaXNCb3VuZDogaXNCb3VuZCxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogaXNCb3VuZCA/IG9mZnNldCA6IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldElubmVyQm91bmRJbmZvKG1vdmVhYmxlLCBsaW5lSW5mb3MsIGRhdGFzKSB7XHJcbiAgICByZXR1cm4gbGluZUluZm9zLm1hcChmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgIHZhciBfYSA9IGNoZWNrSW5uZXJCb3VuZChtb3ZlYWJsZSwgaW5mbyksIGlzQm91bmQgPSBfYS5pc0JvdW5kLCBvZmZzZXQgPSBfYS5vZmZzZXQsIGlzVmVydGljYWxCb3VuZCA9IF9hLmlzVmVydGljYWxCb3VuZCwgaXNIb3Jpem9udGFsQm91bmQgPSBfYS5pc0hvcml6b250YWxCb3VuZDtcclxuICAgICAgICB2YXIgbXVsdGlwbGUgPSBpbmZvLm11bHRpcGxlO1xyXG4gICAgICAgIHZhciBzaXplT2Zmc2V0ID0gZ2V0RHJhZ0Rpc3Qoe1xyXG4gICAgICAgICAgICBkYXRhczogZGF0YXMsXHJcbiAgICAgICAgICAgIGRpc3RYOiBvZmZzZXRbMF0sXHJcbiAgICAgICAgICAgIGRpc3RZOiBvZmZzZXRbMV0sXHJcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChzaXplLCBpKSB7IHJldHVybiBzaXplICogKG11bHRpcGxlW2ldID8gMiAvIG11bHRpcGxlW2ldIDogMCk7IH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNpZ246IG11bHRpcGxlLFxyXG4gICAgICAgICAgICBpc0JvdW5kOiBpc0JvdW5kLFxyXG4gICAgICAgICAgICBpc1ZlcnRpY2FsQm91bmQ6IGlzVmVydGljYWxCb3VuZCxcclxuICAgICAgICAgICAgaXNIb3Jpem9udGFsQm91bmQ6IGlzSG9yaXpvbnRhbEJvdW5kLFxyXG4gICAgICAgICAgICBpc1NuYXA6IGZhbHNlLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IHNpemVPZmZzZXQsXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldElubmVyQm91bmREcmFnSW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRhdGFzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgbGluZXMgPSBnZXRDaGVja0lubmVyQm91bmRMaW5lSW5mb3MobW92ZWFibGUsIHBvc2VzLCBbMCwgMF0sIGZhbHNlKS5tYXAoZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGluZm8pLCB7IG11bHRpcGxlOiBpbmZvLm11bHRpcGxlLm1hcChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBhYnMoZGlyKSAqIDI7IH0pIH0pO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgaW5uZXJCb3VuZEluZm8gPSBnZXRJbm5lckJvdW5kSW5mbyhtb3ZlYWJsZSwgbGluZXMsIGRhdGFzKTtcclxuICAgIHZhciB3aWR0aE9mZnNldEluZm8gPSBnZXROZWFyT2Zmc2V0SW5mbyhpbm5lckJvdW5kSW5mbywgMCk7XHJcbiAgICB2YXIgaGVpZ2h0T2Zmc2V0SW5mbyA9IGdldE5lYXJPZmZzZXRJbmZvKGlubmVyQm91bmRJbmZvLCAxKTtcclxuICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IDA7XHJcbiAgICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IDA7XHJcbiAgICB2YXIgaXNWZXJ0aWNhbEJvdW5kID0gd2lkdGhPZmZzZXRJbmZvLmlzVmVydGljYWxCb3VuZCB8fCBoZWlnaHRPZmZzZXRJbmZvLmlzVmVydGljYWxCb3VuZDtcclxuICAgIHZhciBpc0hvcml6b250YWxCb3VuZCA9IHdpZHRoT2Zmc2V0SW5mby5pc0hvcml6b250YWxCb3VuZCB8fCBoZWlnaHRPZmZzZXRJbmZvLmlzSG9yaXpvbnRhbEJvdW5kO1xyXG4gICAgaWYgKGlzVmVydGljYWxCb3VuZCB8fCBpc0hvcml6b250YWxCb3VuZCkge1xyXG4gICAgICAgIF9hID0gX19yZWFkKGdldEludmVyc2VEcmFnRGlzdCh7XHJcbiAgICAgICAgICAgIGRhdGFzOiBkYXRhcyxcclxuICAgICAgICAgICAgZGlzdFg6IC13aWR0aE9mZnNldEluZm8ub2Zmc2V0WzBdLFxyXG4gICAgICAgICAgICBkaXN0WTogLWhlaWdodE9mZnNldEluZm8ub2Zmc2V0WzFdLFxyXG4gICAgICAgIH0pLCAyKSwgdmVydGljYWxPZmZzZXQgPSBfYVswXSwgaG9yaXpvbnRhbE9mZnNldCA9IF9hWzFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2ZXJ0aWNhbDoge1xyXG4gICAgICAgICAgICBpc0JvdW5kOiBpc1ZlcnRpY2FsQm91bmQsXHJcbiAgICAgICAgICAgIG9mZnNldDogdmVydGljYWxPZmZzZXQsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBob3Jpem9udGFsOiB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IGlzSG9yaXpvbnRhbEJvdW5kLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IGhvcml6b250YWxPZmZzZXQsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2hlY2tTbmFwTGluZURpcmVjdGlvbnMoZGlyZWN0aW9uLCBrZWVwUmF0aW8pIHtcclxuICAgIHZhciBsaW5lRGlyZWN0aW9ucyA9IFtdO1xyXG4gICAgdmFyIHggPSBkaXJlY3Rpb25bMF07XHJcbiAgICB2YXIgeSA9IGRpcmVjdGlvblsxXTtcclxuICAgIGlmICh4ICYmIHkpIHtcclxuICAgICAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbMCwgeSAqIDJdLCBkaXJlY3Rpb24sIFsteCwgeV1dLCBbW3ggKiAyLCAwXSwgZGlyZWN0aW9uLCBbeCwgLXldXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh4KSB7XHJcbiAgICAgICAgLy8gdmVydGNhbFxyXG4gICAgICAgIGxpbmVEaXJlY3Rpb25zLnB1c2goW1t4ICogMiwgMF0sIFt4LCAxXSwgW3gsIC0xXV0pO1xyXG4gICAgICAgIGlmIChrZWVwUmF0aW8pIHtcclxuICAgICAgICAgICAgbGluZURpcmVjdGlvbnMucHVzaChbWzAsIC0xXSwgW3gsIC0xXSwgWy14LCAtMV1dLCBbWzAsIDFdLCBbeCwgMV0sIFsteCwgMV1dKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh5KSB7XHJcbiAgICAgICAgLy8gaG9yaXpvbnRhbFxyXG4gICAgICAgIGxpbmVEaXJlY3Rpb25zLnB1c2goW1swLCB5ICogMl0sIFsxLCB5XSwgWy0xLCB5XV0pO1xyXG4gICAgICAgIGlmIChrZWVwUmF0aW8pIHtcclxuICAgICAgICAgICAgbGluZURpcmVjdGlvbnMucHVzaChbWy0xLCAwXSwgWy0xLCB5XSwgWy0xLCAteV1dLCBbWzEsIDBdLCBbMSwgeV0sIFsxLCAteV1dKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBbMCwgMF0gdG8gYWxsIGRpcmVjdGlvblxyXG4gICAgICAgIGxpbmVEaXJlY3Rpb25zLnB1c2goW1stMSwgMF0sIFstMSwgLTFdLCBbLTEsIDFdXSwgW1sxLCAwXSwgWzEsIC0xXSwgWzEsIDFdXSwgW1swLCAtMV0sIFstMSwgLTFdLCBbMSwgLTFdXSwgW1swLCAxXSwgWy0xLCAxXSwgWzEsIDFdXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGluZURpcmVjdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2hlY2tJbm5lckJvdW5kTGluZUluZm9zKG1vdmVhYmxlLCBwb3NlcywgZGlyZWN0aW9uLCBrZWVwUmF0aW8pIHtcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCBhbGxNYXRyaXggPSBfYS5hbGxNYXRyaXgsIGlzM2QgPSBfYS5pczNkO1xyXG4gICAgdmFyIHZpcnR1YWxQb3NlcyA9IGNhbGN1bGF0ZVBvc2VzKGFsbE1hdHJpeCwgMTAwLCAxMDAsIGlzM2QgPyA0IDogMyk7XHJcbiAgICB2YXIgY2VudGVyID0gZ2V0UG9zQnlEaXJlY3Rpb24odmlydHVhbFBvc2VzLCBbMCwgMF0pO1xyXG4gICAgcmV0dXJuIGdldENoZWNrU25hcExpbmVEaXJlY3Rpb25zKGRpcmVjdGlvbiwga2VlcFJhdGlvKS5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAzKSwgbXVsdGlwbGUgPSBfYlswXSwgZGlyMSA9IF9iWzFdLCBkaXIyID0gX2JbMl07XHJcbiAgICAgICAgdmFyIHZpcnR1YWxMaW5lID0gW1xyXG4gICAgICAgICAgICBnZXRQb3NCeURpcmVjdGlvbih2aXJ0dWFsUG9zZXMsIGRpcjEpLFxyXG4gICAgICAgICAgICBnZXRQb3NCeURpcmVjdGlvbih2aXJ0dWFsUG9zZXMsIGRpcjIpLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIGxpbmVDb25zdGFudHMgPSBzb2x2ZUxpbmVDb25zdGFudHModmlydHVhbExpbmUpO1xyXG4gICAgICAgIHZhciBfYyA9IGlzU3RhcnRMaW5lKGNlbnRlciwgdmlydHVhbExpbmUpLCB2ZXJ0aWNhbFNpZ24gPSBfYy52ZXJ0aWNhbCwgaG9yaXpvbnRhbFNpZ24gPSBfYy5ob3Jpem9udGFsO1xyXG4gICAgICAgIHZhciBjZW50ZXJTaWduID0gaGl0VGVzdExpbmUoY2VudGVyLCB2aXJ0dWFsTGluZSkgPD0gMDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtdWx0aXBsZTogbXVsdGlwbGUsXHJcbiAgICAgICAgICAgIGNlbnRlclNpZ246IGNlbnRlclNpZ24sXHJcbiAgICAgICAgICAgIHZlcnRpY2FsU2lnbjogdmVydGljYWxTaWduLFxyXG4gICAgICAgICAgICBob3Jpem9udGFsU2lnbjogaG9yaXpvbnRhbFNpZ24sXHJcbiAgICAgICAgICAgIGxpbmVDb25zdGFudHM6IGxpbmVDb25zdGFudHMsXHJcbiAgICAgICAgICAgIGxpbmU6IFtcclxuICAgICAgICAgICAgICAgIGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXIxKSxcclxuICAgICAgICAgICAgICAgIGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXIyKSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaXNCb3VuZFJvdGF0ZShyZWxhdGl2ZVBvc2VzLCBib3VuZERvdHMsIGNlbnRlciwgcmFkKSB7XHJcbiAgICB2YXIgbmV4dFBvc2VzID0gcmFkID8gcmVsYXRpdmVQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcm90YXRlKHBvcywgcmFkKTsgfSkgOiByZWxhdGl2ZVBvc2VzO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBbbmV4dFBvc2VzWzBdLCBuZXh0UG9zZXNbMV1dLFxyXG4gICAgICAgIFtuZXh0UG9zZXNbMV0sIG5leHRQb3Nlc1szXV0sXHJcbiAgICAgICAgW25leHRQb3Nlc1szXSwgbmV4dFBvc2VzWzJdXSxcclxuICAgICAgICBbbmV4dFBvc2VzWzJdLCBuZXh0UG9zZXNbMF1dLFxyXG4gICAgXS5zb21lKGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgdmFyIGNlbnRlclNpZ24gPSBoaXRUZXN0TGluZShjZW50ZXIsIGxpbmUpIDw9IDA7XHJcbiAgICAgICAgcmV0dXJuICFpc1NhbWVTdGFydExpbmUoYm91bmREb3RzLCBsaW5lLCBjZW50ZXJTaWduKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldERpc3RQb2ludExpbmUoX2EpIHtcclxuICAgIC8vIHggPSAwLCB5ID0gMFxyXG4gICAgLy8gZCA9IChheCArIGJ5ICsgYykgLyByb290KGEyICsgYjIpXHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBwb3MxID0gX2JbMF0sIHBvczIgPSBfYlsxXTtcclxuICAgIHZhciBkeCA9IHBvczJbMF0gLSBwb3MxWzBdO1xyXG4gICAgdmFyIGR5ID0gcG9zMlsxXSAtIHBvczFbMV07XHJcbiAgICBpZiAoIWR4KSB7XHJcbiAgICAgICAgcmV0dXJuIGFicyhwb3MxWzBdKTtcclxuICAgIH1cclxuICAgIGlmICghZHkpIHtcclxuICAgICAgICByZXR1cm4gYWJzKHBvczFbMV0pO1xyXG4gICAgfVxyXG4gICAgLy8geSAtIHkxID0gYSh4IC0geDEpXHJcbiAgICAvLyAwID0gYXggLXkgKyAtYSAqIHgxICsgeTFcclxuICAgIHZhciBhID0gZHkgLyBkeDtcclxuICAgIHJldHVybiBhYnMoKC1hICogcG9zMVswXSArIHBvczFbMV0pIC8gTWF0aC5zcXJ0KE1hdGgucG93KGEsIDIpICsgMSkpO1xyXG59XHJcbmZ1bmN0aW9uIHNvbHZlUmV2ZXJzZUxpbmUoX2EpIHtcclxuICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHBvczEgPSBfYlswXSwgcG9zMiA9IF9iWzFdO1xyXG4gICAgdmFyIGR4ID0gcG9zMlswXSAtIHBvczFbMF07XHJcbiAgICB2YXIgZHkgPSBwb3MyWzFdIC0gcG9zMVsxXTtcclxuICAgIGlmICghZHgpIHtcclxuICAgICAgICByZXR1cm4gW3BvczFbMF0sIDBdO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkeSkge1xyXG4gICAgICAgIHJldHVybiBbMCwgcG9zMVsxXV07XHJcbiAgICB9XHJcbiAgICB2YXIgYSA9IGR5IC8gZHg7XHJcbiAgICAvLyB5IC0geTEgPSBhICh4ICAtIHgxKVxyXG4gICAgLy8geSA9IGF4IC0gYSAqIHgxICsgeTFcclxuICAgIHZhciBiID0gLWEgKiBwb3MxWzBdICsgcG9zMVsxXTtcclxuICAgIC8vIHkgPSBheCArIGIgPSAtMS9hIHhcclxuICAgIC8vIHggPSAtYiAvIChhICsgMSAvIGEpXHJcbiAgICAvLyB5ID0gYiAvICgxICsgMSAvIGFeMilcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgLWIgLyAoYSArIDEgLyBhKSxcclxuICAgICAgICBiIC8gKChhICogYSkgKyAxKSxcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tSb3RhdGVJbm5lckJvdW5kcyhtb3ZlYWJsZSwgcHJldlBvc2VzLCBuZXh0UG9zZXMsIG9yaWdpbiwgcm90YXRpb24pIHtcclxuICAgIHZhciBib3VuZHMgPSBtb3ZlYWJsZS5wcm9wcy5pbm5lckJvdW5kcztcclxuICAgIHZhciByYWQgPSByb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XHJcbiAgICBpZiAoIWJvdW5kcykge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHZhciBsZWZ0ID0gYm91bmRzLmxlZnQsIHRvcCA9IGJvdW5kcy50b3AsIHdpZHRoID0gYm91bmRzLndpZHRoLCBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0O1xyXG4gICAgdmFyIHJlbGF0aXZlTGVmdCA9IGxlZnQgLSBvcmlnaW5bMF07XHJcbiAgICB2YXIgcmVsYXRpdmVSaWdodCA9IGxlZnQgKyB3aWR0aCAtIG9yaWdpblswXTtcclxuICAgIHZhciByZWxhdGl2ZVRvcCA9IHRvcCAtIG9yaWdpblsxXTtcclxuICAgIHZhciByZWxhdGl2ZUJvdHRvbSA9IHRvcCArIGhlaWdodCAtIG9yaWdpblsxXTtcclxuICAgIHZhciBkb3RzID0gW1xyXG4gICAgICAgIFtyZWxhdGl2ZUxlZnQsIHJlbGF0aXZlVG9wXSxcclxuICAgICAgICBbcmVsYXRpdmVSaWdodCwgcmVsYXRpdmVUb3BdLFxyXG4gICAgICAgIFtyZWxhdGl2ZUxlZnQsIHJlbGF0aXZlQm90dG9tXSxcclxuICAgICAgICBbcmVsYXRpdmVSaWdodCwgcmVsYXRpdmVCb3R0b21dLFxyXG4gICAgXTtcclxuICAgIHZhciBjZW50ZXIgPSBnZXRQb3NCeURpcmVjdGlvbihuZXh0UG9zZXMsIFswLCAwXSk7XHJcbiAgICBpZiAoIWlzQm91bmRSb3RhdGUobmV4dFBvc2VzLCBkb3RzLCBjZW50ZXIsIDApKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgdmFyIGRvdEluZm9zID0gZG90cy5tYXAoZnVuY3Rpb24gKGRvdCkgeyByZXR1cm4gW1xyXG4gICAgICAgIGdldERpc3RTaXplKGRvdCksXHJcbiAgICAgICAgZ2V0UmFkKFswLCAwXSwgZG90KSxcclxuICAgIF07IH0pO1xyXG4gICAgW1xyXG4gICAgICAgIFtuZXh0UG9zZXNbMF0sIG5leHRQb3Nlc1sxXV0sXHJcbiAgICAgICAgW25leHRQb3Nlc1sxXSwgbmV4dFBvc2VzWzNdXSxcclxuICAgICAgICBbbmV4dFBvc2VzWzNdLCBuZXh0UG9zZXNbMl1dLFxyXG4gICAgICAgIFtuZXh0UG9zZXNbMl0sIG5leHRQb3Nlc1swXV0sXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgICB2YXIgbGluZVJhZCA9IGdldFJhZChbMCwgMF0sIHNvbHZlUmV2ZXJzZUxpbmUobGluZSkpO1xyXG4gICAgICAgIHZhciBsaW5lRGlzdCA9IGdldERpc3RQb2ludExpbmUobGluZSk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZG90SW5mb3NcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAxKSwgZG90RGlzdCA9IF9iWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gZG90RGlzdCAmJiBsaW5lRGlzdCA8PSBkb3REaXN0O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGRvdERpc3QgPSBfYlswXSwgZG90UmFkID0gX2JbMV07XHJcbiAgICAgICAgICAgIHZhciBkaXN0UmFkID0gTWF0aC5hY29zKGRvdERpc3QgPyBsaW5lRGlzdCAvIGRvdERpc3QgOiAwKTtcclxuICAgICAgICAgICAgdmFyIG5leHRSYWQxID0gZG90UmFkICsgZGlzdFJhZDtcclxuICAgICAgICAgICAgdmFyIG5leHRSYWQyID0gZG90UmFkIC0gZGlzdFJhZDtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIHJhZCArIG5leHRSYWQxIC0gbGluZVJhZCxcclxuICAgICAgICAgICAgICAgIHJhZCArIG5leHRSYWQyIC0gbGluZVJhZCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcclxuICAgICAgICAgICAgcHJldi5wdXNoLmFwcGx5KHByZXYsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChjdXIpLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgICB9LCBbXSlcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobmV4dFJhZCkgeyByZXR1cm4gIWlzQm91bmRSb3RhdGUocHJldlBvc2VzLCBkb3RzLCBjZW50ZXIsIG5leHRSYWQpOyB9KVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuZXh0UmFkKSB7IHJldHVybiB0aHJvdHRsZShuZXh0UmFkICogMTgwIC8gTWF0aC5QSSwgVElOWV9OVU0pOyB9KSksIGZhbHNlKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tJbm5lckJvdW5kUG9zZXMobW92ZWFibGUpIHtcclxuICAgIHZhciBpbm5lckJvdW5kcyA9IG1vdmVhYmxlLnByb3BzLmlubmVyQm91bmRzO1xyXG4gICAgdmFyIGJvdW5kTWFwID0gZ2V0SW5pdGlhbEJvdW5kcygpO1xyXG4gICAgaWYgKCFpbm5lckJvdW5kcykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGJvdW5kTWFwOiBib3VuZE1hcCxcclxuICAgICAgICAgICAgdmVydGljYWw6IFtdLFxyXG4gICAgICAgICAgICBob3Jpem9udGFsOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9hID0gbW92ZWFibGUuZ2V0UmVjdCgpLCBwb3MxID0gX2EucG9zMSwgcG9zMiA9IF9hLnBvczIsIHBvczMgPSBfYS5wb3MzLCBwb3M0ID0gX2EucG9zNDtcclxuICAgIHZhciBwb3NlcyA9IFtwb3MxLCBwb3MyLCBwb3MzLCBwb3M0XTtcclxuICAgIHZhciBjZW50ZXIgPSBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgWzAsIDBdKTtcclxuICAgIHZhciBsZWZ0ID0gaW5uZXJCb3VuZHMubGVmdCwgdG9wID0gaW5uZXJCb3VuZHMudG9wLCB3aWR0aCA9IGlubmVyQm91bmRzLndpZHRoLCBoZWlnaHQgPSBpbm5lckJvdW5kcy5oZWlnaHQ7XHJcbiAgICB2YXIgbGVmdExpbmUgPSBbW2xlZnQsIHRvcF0sIFtsZWZ0LCB0b3AgKyBoZWlnaHRdXTtcclxuICAgIHZhciB0b3BMaW5lID0gW1tsZWZ0LCB0b3BdLCBbbGVmdCArIHdpZHRoLCB0b3BdXTtcclxuICAgIHZhciByaWdodExpbmUgPSBbW2xlZnQgKyB3aWR0aCwgdG9wXSwgW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XV07XHJcbiAgICB2YXIgYm90dG9tTGluZSA9IFtbbGVmdCwgdG9wICsgaGVpZ2h0XSwgW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XV07XHJcbiAgICB2YXIgbGluZUluZm9zID0gZ2V0Q2hlY2tJbm5lckJvdW5kTGluZUluZm9zKG1vdmVhYmxlLCBwb3NlcywgWzAsIDBdLCBmYWxzZSk7XHJcbiAgICB2YXIgaG9yaXpvbnRhbFBvc2VzID0gW107XHJcbiAgICB2YXIgdmVydGljYWxQb3NlcyA9IFtdO1xyXG4gICAgbGluZUluZm9zLmZvckVhY2goZnVuY3Rpb24gKGxpbmVJbmZvKSB7XHJcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lSW5mby5saW5lLCBsaW5lQ29uc3RhbnRzID0gbGluZUluZm8ubGluZUNvbnN0YW50cztcclxuICAgICAgICB2YXIgX2EgPSBpc1N0YXJ0TGluZShjZW50ZXIsIGxpbmUpLCBpc0hvcml6b250YWxTdGFydCA9IF9hLmhvcml6b250YWwsIGlzVmVydGljYWxTdGFydCA9IF9hLnZlcnRpY2FsO1xyXG4gICAgICAgIC8vIHRlc3QgdmVydGljYWxcclxuICAgICAgICB2YXIgdG9wQm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgdG9wTGluZSwgaXNWZXJ0aWNhbFN0YXJ0LCAxLCB0cnVlKTtcclxuICAgICAgICB2YXIgYm90dG9tQm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgYm90dG9tTGluZSwgaXNWZXJ0aWNhbFN0YXJ0LCAxLCB0cnVlKTtcclxuICAgICAgICAvLyB0ZXN0IGhvcml6b250YWxcclxuICAgICAgICB2YXIgbGVmdEJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIGxpbmVDb25zdGFudHMsIGxlZnRMaW5lLCBpc0hvcml6b250YWxTdGFydCwgMSwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIHJpZ2h0Qm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgcmlnaHRMaW5lLCBpc0hvcml6b250YWxTdGFydCwgMSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKHRvcEJvdW5kSW5mby5pc0JvdW5kICYmICFib3VuZE1hcC50b3ApIHtcclxuICAgICAgICAgICAgaG9yaXpvbnRhbFBvc2VzLnB1c2godG9wKTtcclxuICAgICAgICAgICAgYm91bmRNYXAudG9wID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJvdHRvbUJvdW5kSW5mby5pc0JvdW5kICYmICFib3VuZE1hcC5ib3R0b20pIHtcclxuICAgICAgICAgICAgaG9yaXpvbnRhbFBvc2VzLnB1c2godG9wICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgYm91bmRNYXAuYm90dG9tID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlZnRCb3VuZEluZm8uaXNCb3VuZCAmJiAhYm91bmRNYXAubGVmdCkge1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbFBvc2VzLnB1c2gobGVmdCk7XHJcbiAgICAgICAgICAgIGJvdW5kTWFwLmxlZnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmlnaHRCb3VuZEluZm8uaXNCb3VuZCAmJiAhYm91bmRNYXAucmlnaHQpIHtcclxuICAgICAgICAgICAgdmVydGljYWxQb3Nlcy5wdXNoKGxlZnQgKyB3aWR0aCk7XHJcbiAgICAgICAgICAgIGJvdW5kTWFwLnJpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYm91bmRNYXA6IGJvdW5kTWFwLFxyXG4gICAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxQb3NlcyxcclxuICAgICAgICB2ZXJ0aWNhbDogdmVydGljYWxQb3NlcyxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gc29sdmVFcXVhdGlvbihwb3MxLCBwb3MyLCBzbmFwT2Zmc2V0LCBpc1ZlcnRpY2FsKSB7XHJcbiAgICB2YXIgZHggPSBwb3MyWzBdIC0gcG9zMVswXTtcclxuICAgIHZhciBkeSA9IHBvczJbMV0gLSBwb3MxWzFdO1xyXG4gICAgaWYgKGFicyhkeCkgPCBUSU5ZX05VTSQxKSB7XHJcbiAgICAgICAgZHggPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKGFicyhkeSkgPCBUSU5ZX05VTSQxKSB7XHJcbiAgICAgICAgZHkgPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkeCkge1xyXG4gICAgICAgIC8vIHkgPSAwICogeCArIGJcclxuICAgICAgICAvLyBvbmx5IGhvcml6b250YWxcclxuICAgICAgICBpZiAoIWlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFswLCBzbmFwT2Zmc2V0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcclxuICAgIH1cclxuICAgIGlmICghZHkpIHtcclxuICAgICAgICAvLyBvbmx5IHZlcnRpY2FsXHJcbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtzbmFwT2Zmc2V0LCAwXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcclxuICAgIH1cclxuICAgIC8vIHkgPSBheCArIGJcclxuICAgIHZhciBhID0gZHkgLyBkeDtcclxuICAgIHZhciBiID0gcG9zMVsxXSAtIGEgKiBwb3MxWzBdO1xyXG4gICAgaWYgKGlzVmVydGljYWwpIHtcclxuICAgICAgICAvLyB5ID0gYSAqIHggKyBiXHJcbiAgICAgICAgdmFyIHkgPSBhICogKHBvczJbMF0gKyBzbmFwT2Zmc2V0KSArIGI7XHJcbiAgICAgICAgcmV0dXJuIFtzbmFwT2Zmc2V0LCB5IC0gcG9zMlsxXV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyB4ID0gKHkgLSBiKSAvIGFcclxuICAgICAgICB2YXIgeCA9IChwb3MyWzFdICsgc25hcE9mZnNldCAtIGIpIC8gYTtcclxuICAgICAgICByZXR1cm4gW3ggLSBwb3MyWzBdLCBzbmFwT2Zmc2V0XTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzb2x2ZU5leHRPZmZzZXQocG9zMSwgcG9zMiwgb2Zmc2V0LCBpc1ZlcnRpY2FsLCBkYXRhcykge1xyXG4gICAgdmFyIHNpemVPZmZzZXQgPSBzb2x2ZUVxdWF0aW9uKHBvczEsIHBvczIsIG9mZnNldCwgaXNWZXJ0aWNhbCk7XHJcbiAgICBpZiAoIXNpemVPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc091dHNpZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHNpemUgPSBnZXREaXN0JDEocG9zMSwgcG9zMik7XHJcbiAgICB2YXIgZGlzdDEgPSBnZXREaXN0JDEoc2l6ZU9mZnNldCwgcG9zMSk7XHJcbiAgICB2YXIgZGlzdDIgPSBnZXREaXN0JDEoc2l6ZU9mZnNldCwgcG9zMik7XHJcbiAgICB2YXIgaXNPdXRzaWRlID0gZGlzdDEgPiBzaXplIHx8IGRpc3QyID4gc2l6ZTtcclxuICAgIHZhciBfYSA9IF9fcmVhZChnZXREcmFnRGlzdCh7XHJcbiAgICAgICAgZGF0YXM6IGRhdGFzLFxyXG4gICAgICAgIGRpc3RYOiBzaXplT2Zmc2V0WzBdLFxyXG4gICAgICAgIGRpc3RZOiBzaXplT2Zmc2V0WzFdLFxyXG4gICAgfSksIDIpLCB3aWR0aE9mZnNldCA9IF9hWzBdLCBoZWlnaHRPZmZzZXQgPSBfYVsxXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb2Zmc2V0OiBbd2lkdGhPZmZzZXQsIGhlaWdodE9mZnNldF0sXHJcbiAgICAgICAgaXNPdXRzaWRlOiBpc091dHNpZGUsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFNuYXBCb3VuZChib3VuZEluZm8sIHNuYXBJbmZvKSB7XHJcbiAgICBpZiAoYm91bmRJbmZvLmlzQm91bmQpIHtcclxuICAgICAgICByZXR1cm4gYm91bmRJbmZvLm9mZnNldDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNuYXBJbmZvLmlzU25hcCkge1xyXG4gICAgICAgIHJldHVybiBnZXROZWFyZXN0U25hcEd1aWRlbGluZUluZm8oc25hcEluZm8pLm9mZnNldDtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrVGhyb3R0bGVEcmFnUm90YXRlKHRocm90dGxlRHJhZ1JvdGF0ZSwgX2EsIF9iLCBfYywgX2QpIHtcclxuICAgIHZhciBfZSA9IF9fcmVhZChfYSwgMiksIGRpc3RYID0gX2VbMF0sIGRpc3RZID0gX2VbMV07XHJcbiAgICB2YXIgX2YgPSBfX3JlYWQoX2IsIDIpLCBpc1ZlcnRpY2FsQm91bmQgPSBfZlswXSwgaXNIb3Jpem9udGFsQm91bmQgPSBfZlsxXTtcclxuICAgIHZhciBfZyA9IF9fcmVhZChfYywgMiksIGlzVmVydGljYWxTbmFwID0gX2dbMF0sIGlzSG9yaXpvbnRhbFNuYXAgPSBfZ1sxXTtcclxuICAgIHZhciBfaCA9IF9fcmVhZChfZCwgMiksIHZlcnRpY2FsT2Zmc2V0ID0gX2hbMF0sIGhvcml6b250YWxPZmZzZXQgPSBfaFsxXTtcclxuICAgIHZhciBvZmZzZXRYID0gLXZlcnRpY2FsT2Zmc2V0O1xyXG4gICAgdmFyIG9mZnNldFkgPSAtaG9yaXpvbnRhbE9mZnNldDtcclxuICAgIGlmICh0aHJvdHRsZURyYWdSb3RhdGUgJiYgZGlzdFggJiYgZGlzdFkpIHtcclxuICAgICAgICBvZmZzZXRYID0gMDtcclxuICAgICAgICBvZmZzZXRZID0gMDtcclxuICAgICAgICB2YXIgYWRqdXN0UG9zZXMgPSBbXTtcclxuICAgICAgICBpZiAoaXNWZXJ0aWNhbEJvdW5kICYmIGlzSG9yaXpvbnRhbEJvdW5kKSB7XHJcbiAgICAgICAgICAgIGFkanVzdFBvc2VzLnB1c2goWzAsIGhvcml6b250YWxPZmZzZXRdLCBbdmVydGljYWxPZmZzZXQsIDBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNWZXJ0aWNhbEJvdW5kKSB7XHJcbiAgICAgICAgICAgIGFkanVzdFBvc2VzLnB1c2goW3ZlcnRpY2FsT2Zmc2V0LCAwXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzSG9yaXpvbnRhbEJvdW5kKSB7XHJcbiAgICAgICAgICAgIGFkanVzdFBvc2VzLnB1c2goWzAsIGhvcml6b250YWxPZmZzZXRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNWZXJ0aWNhbFNuYXAgJiYgaXNIb3Jpem9udGFsU25hcCkge1xyXG4gICAgICAgICAgICBhZGp1c3RQb3Nlcy5wdXNoKFswLCBob3Jpem9udGFsT2Zmc2V0XSwgW3ZlcnRpY2FsT2Zmc2V0LCAwXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzVmVydGljYWxTbmFwKSB7XHJcbiAgICAgICAgICAgIGFkanVzdFBvc2VzLnB1c2goW3ZlcnRpY2FsT2Zmc2V0LCAwXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzSG9yaXpvbnRhbFNuYXApIHtcclxuICAgICAgICAgICAgYWRqdXN0UG9zZXMucHVzaChbMCwgaG9yaXpvbnRhbE9mZnNldF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWRqdXN0UG9zZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFkanVzdFBvc2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZ2V0RGlzdFNpemUobWludXMoW2Rpc3RYLCBkaXN0WV0sIGEpKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0RGlzdFNpemUobWludXMoW2Rpc3RYLCBkaXN0WV0sIGIpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgYWRqdXN0UG9zID0gYWRqdXN0UG9zZXNbMF07XHJcbiAgICAgICAgICAgIGlmIChhZGp1c3RQb3NbMF0gJiYgYWJzKGRpc3RYKSA+IFRJTllfTlVNJDEpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldFggPSAtYWRqdXN0UG9zWzBdO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSA9XHJcbiAgICAgICAgICAgICAgICAgICAgKGRpc3RZICogYWJzKGRpc3RYICsgb2Zmc2V0WCkpIC8gYWJzKGRpc3RYKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFkanVzdFBvc1sxXSAmJiBhYnMoZGlzdFkpID4gVElOWV9OVU0kMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZEaXN0WSA9IGRpc3RZO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSA9IC1hZGp1c3RQb3NbMV07XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRYID1cclxuICAgICAgICAgICAgICAgICAgICAoZGlzdFggKiBhYnMoZGlzdFkgKyBvZmZzZXRZKSkgLyBhYnMocHJldkRpc3RZKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RYO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aHJvdHRsZURyYWdSb3RhdGUgJiYgaXNIb3Jpem9udGFsQm91bmQgJiYgaXNWZXJ0aWNhbEJvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWJzKG9mZnNldFgpID4gVElOWV9OVU0kMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFicyhvZmZzZXRYKSA8IGFicyh2ZXJ0aWNhbE9mZnNldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBhYnModmVydGljYWxPZmZzZXQpIC8gYWJzKG9mZnNldFgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFggKj0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WSAqPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFicyhvZmZzZXRZKSA+IFRJTllfTlVNJDEgJiZcclxuICAgICAgICAgICAgICAgICAgICBhYnMob2Zmc2V0WSkgPCBhYnMoaG9yaXpvbnRhbE9mZnNldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBhYnMoaG9yaXpvbnRhbE9mZnNldCkgLyBhYnMob2Zmc2V0WSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCAqPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZICo9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IG1heE9mZnNldCgtdmVydGljYWxPZmZzZXQsIG9mZnNldFgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFkgPSBtYXhPZmZzZXQoLWhvcml6b250YWxPZmZzZXQsIG9mZnNldFkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb2Zmc2V0WCA9IGRpc3RYIHx8IGlzVmVydGljYWxCb3VuZCA/IC12ZXJ0aWNhbE9mZnNldCA6IDA7XHJcbiAgICAgICAgb2Zmc2V0WSA9IGRpc3RZIHx8IGlzSG9yaXpvbnRhbEJvdW5kID8gLWhvcml6b250YWxPZmZzZXQgOiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtvZmZzZXRYLCBvZmZzZXRZXTtcclxufVxyXG5mdW5jdGlvbiBjaGVja1NuYXBCb3VuZHNEcmFnKG1vdmVhYmxlLCBkaXN0WCwgZGlzdFksIHRocm90dGxlRHJhZ1JvdGF0ZSwgaWdub3JlU25hcCwgZGF0YXMpIHtcclxuICAgIGlmICghaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJkcmFnZ2FibGVcIikpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpc1NuYXA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNCb3VuZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlzU25hcDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgdmFyIHBvc2VzID0gZ2V0QWJzb2x1dGVQb3NlcyhkYXRhcy5hYnNvbHV0ZVBvc2VzLCBbZGlzdFgsIGRpc3RZXSk7XHJcbiAgICB2YXIgX2EgPSBnZXRSZWN0KHBvc2VzKSwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQsIHRvcCA9IF9hLnRvcCwgYm90dG9tID0gX2EuYm90dG9tO1xyXG4gICAgdmFyIGJvdW5kUG9zZXMgPSB7XHJcbiAgICAgICAgaG9yaXpvbnRhbDogcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1sxXTsgfSksXHJcbiAgICAgICAgdmVydGljYWw6IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3NbMF07IH0pLFxyXG4gICAgfTtcclxuICAgIHZhciBzbmFwRGlyZWN0aW9ucyA9IGdldFNuYXBEaXJlY3Rpb25zKG1vdmVhYmxlLnByb3BzLnNuYXBEaXJlY3Rpb25zKTtcclxuICAgIHZhciBzbmFwUG9zZXMgPSBzcGxpdFNuYXBEaXJlY3Rpb25Qb3NlcyhzbmFwRGlyZWN0aW9ucywge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIGJvdHRvbTogYm90dG9tLFxyXG4gICAgICAgIGNlbnRlcjogKGxlZnQgKyByaWdodCkgLyAyLFxyXG4gICAgICAgIG1pZGRsZTogKHRvcCArIGJvdHRvbSkgLyAyLFxyXG4gICAgfSk7XHJcbiAgICB2YXIgX2IgPSBjaGVja01vdmVhYmxlU25hcEJvdW5kcyhtb3ZlYWJsZSwgaWdub3JlU25hcCwgc25hcFBvc2VzLCBib3VuZFBvc2VzKSwgdmVydGljYWxTbmFwQm91bmRJbmZvID0gX2IudmVydGljYWwsIGhvcml6b250YWxTbmFwQm91bmRJbmZvID0gX2IuaG9yaXpvbnRhbDtcclxuICAgIHZhciBfYyA9IGdldElubmVyQm91bmREcmFnSW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRhdGFzKSwgdmVydGljYWxJbm5lckJvdW5kSW5mbyA9IF9jLnZlcnRpY2FsLCBob3Jpem9udGFsSW5uZXJCb3VuZEluZm8gPSBfYy5ob3Jpem9udGFsO1xyXG4gICAgdmFyIGlzVmVydGljYWxTbmFwID0gdmVydGljYWxTbmFwQm91bmRJbmZvLmlzU25hcDtcclxuICAgIHZhciBpc0hvcml6b250YWxTbmFwID0gaG9yaXpvbnRhbFNuYXBCb3VuZEluZm8uaXNTbmFwO1xyXG4gICAgdmFyIGlzVmVydGljYWxCb3VuZCA9IHZlcnRpY2FsU25hcEJvdW5kSW5mby5pc0JvdW5kIHx8IHZlcnRpY2FsSW5uZXJCb3VuZEluZm8uaXNCb3VuZDtcclxuICAgIHZhciBpc0hvcml6b250YWxCb3VuZCA9IGhvcml6b250YWxTbmFwQm91bmRJbmZvLmlzQm91bmQgfHwgaG9yaXpvbnRhbElubmVyQm91bmRJbmZvLmlzQm91bmQ7XHJcbiAgICB2YXIgdmVydGljYWxPZmZzZXQgPSBtYXhPZmZzZXQodmVydGljYWxTbmFwQm91bmRJbmZvLm9mZnNldCwgdmVydGljYWxJbm5lckJvdW5kSW5mby5vZmZzZXQpO1xyXG4gICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBtYXhPZmZzZXQoaG9yaXpvbnRhbFNuYXBCb3VuZEluZm8ub2Zmc2V0LCBob3Jpem9udGFsSW5uZXJCb3VuZEluZm8ub2Zmc2V0KTtcclxuICAgIHZhciBfZCA9IF9fcmVhZChjaGVja1Rocm90dGxlRHJhZ1JvdGF0ZSh0aHJvdHRsZURyYWdSb3RhdGUsIFtkaXN0WCwgZGlzdFldLCBbaXNWZXJ0aWNhbEJvdW5kLCBpc0hvcml6b250YWxCb3VuZF0sIFtpc1ZlcnRpY2FsU25hcCwgaXNIb3Jpem9udGFsU25hcF0sIFt2ZXJ0aWNhbE9mZnNldCwgaG9yaXpvbnRhbE9mZnNldF0pLCAyKSwgb2Zmc2V0WCA9IF9kWzBdLCBvZmZzZXRZID0gX2RbMV07XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaXNCb3VuZDogaXNWZXJ0aWNhbEJvdW5kLFxyXG4gICAgICAgICAgICBpc1NuYXA6IGlzVmVydGljYWxTbmFwLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFgsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IGlzSG9yaXpvbnRhbEJvdW5kLFxyXG4gICAgICAgICAgICBpc1NuYXA6IGlzSG9yaXpvbnRhbFNuYXAsXHJcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0WSxcclxuICAgICAgICB9LFxyXG4gICAgXTtcclxufVxyXG5mdW5jdGlvbiBjaGVja01vdmVhYmxlU25hcEJvdW5kcyhtb3ZlYWJsZSwgaWdub3JlU25hcCwgcG9zZXMsIGJvdW5kUG9zZXMpIHtcclxuICAgIGlmIChib3VuZFBvc2VzID09PSB2b2lkIDApIHsgYm91bmRQb3NlcyA9IHBvc2VzOyB9XHJcbiAgICB2YXIgX2EgPSBjaGVja0JvdW5kUG9zZXMoZ2V0Qm91bmRzKG1vdmVhYmxlKSwgYm91bmRQb3Nlcy52ZXJ0aWNhbCwgYm91bmRQb3Nlcy5ob3Jpem9udGFsKSwgaG9yaXpvbnRhbEJvdW5kSW5mb3MgPSBfYS5ob3Jpem9udGFsLCB2ZXJ0aWNhbEJvdW5kSW5mb3MgPSBfYS52ZXJ0aWNhbDtcclxuICAgIHZhciBfYiA9IGlnbm9yZVNuYXAgPyB7XHJcbiAgICAgICAgaG9yaXpvbnRhbDogeyBpc1NuYXA6IGZhbHNlLCBpbmRleDogLTEgfSxcclxuICAgICAgICB2ZXJ0aWNhbDogeyBpc1NuYXA6IGZhbHNlLCBpbmRleDogLTEgfSxcclxuICAgIH0gOiBjaGVja01vdmVhYmxlU25hcFBvc2VzKG1vdmVhYmxlLCBwb3Nlcy52ZXJ0aWNhbCwgcG9zZXMuaG9yaXpvbnRhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKSwgaG9yaXpvbnRhbFNuYXBJbmZvID0gX2IuaG9yaXpvbnRhbCwgdmVydGljYWxTbmFwSW5mbyA9IF9iLnZlcnRpY2FsO1xyXG4gICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBnZXRTbmFwQm91bmQoaG9yaXpvbnRhbEJvdW5kSW5mb3NbMF0sIGhvcml6b250YWxTbmFwSW5mbyk7XHJcbiAgICB2YXIgdmVydGljYWxPZmZzZXQgPSBnZXRTbmFwQm91bmQodmVydGljYWxCb3VuZEluZm9zWzBdLCB2ZXJ0aWNhbFNuYXBJbmZvKTtcclxuICAgIHZhciBob3Jpem9udGFsRGlzdCA9IGFicyhob3Jpem9udGFsT2Zmc2V0KTtcclxuICAgIHZhciB2ZXJ0aWNhbERpc3QgPSBhYnModmVydGljYWxPZmZzZXQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBob3Jpem9udGFsOiB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IGhvcml6b250YWxCb3VuZEluZm9zWzBdLmlzQm91bmQsXHJcbiAgICAgICAgICAgIGlzU25hcDogaG9yaXpvbnRhbFNuYXBJbmZvLmlzU25hcCxcclxuICAgICAgICAgICAgc25hcEluZGV4OiBob3Jpem9udGFsU25hcEluZm8uaW5kZXgsXHJcbiAgICAgICAgICAgIG9mZnNldDogaG9yaXpvbnRhbE9mZnNldCxcclxuICAgICAgICAgICAgZGlzdDogaG9yaXpvbnRhbERpc3QsXHJcbiAgICAgICAgICAgIGJvdW5kczogaG9yaXpvbnRhbEJvdW5kSW5mb3MsXHJcbiAgICAgICAgICAgIHNuYXA6IGhvcml6b250YWxTbmFwSW5mbyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZlcnRpY2FsOiB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IHZlcnRpY2FsQm91bmRJbmZvc1swXS5pc0JvdW5kLFxyXG4gICAgICAgICAgICBpc1NuYXA6IHZlcnRpY2FsU25hcEluZm8uaXNTbmFwLFxyXG4gICAgICAgICAgICBzbmFwSW5kZXg6IHZlcnRpY2FsU25hcEluZm8uaW5kZXgsXHJcbiAgICAgICAgICAgIG9mZnNldDogdmVydGljYWxPZmZzZXQsXHJcbiAgICAgICAgICAgIGRpc3Q6IHZlcnRpY2FsRGlzdCxcclxuICAgICAgICAgICAgYm91bmRzOiB2ZXJ0aWNhbEJvdW5kSW5mb3MsXHJcbiAgICAgICAgICAgIHNuYXA6IHZlcnRpY2FsU25hcEluZm8sXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTbmFwQm91bmRzKGd1aWRlaW5lcywgYm91bmRzLCBwb3Nlc1gsIHBvc2VzWSwgc25hcEhvcml6b250YWxUaHJlc2hvbGQsIHNuYXBWZXJ0aWNhbFRocmVzaG9sZCwgbXVsdGlwbGVzKSB7XHJcbiAgICBpZiAobXVsdGlwbGVzID09PSB2b2lkIDApIHsgbXVsdGlwbGVzID0gWzEsIDFdOyB9XHJcbiAgICB2YXIgX2EgPSBjaGVja0JvdW5kUG9zZXMoYm91bmRzLCBwb3Nlc1gsIHBvc2VzWSksIGhvcml6b250YWxCb3VuZEluZm9zID0gX2EuaG9yaXpvbnRhbCwgdmVydGljYWxCb3VuZEluZm9zID0gX2EudmVydGljYWw7XHJcbiAgICAvLyBvcHRpb25zLmlzUmVxdWVzdCA/IHtcclxuICAgIC8vICAgICBob3Jpem9udGFsOiB7IGlzU25hcDogZmFsc2UsIGluZGV4OiAtMSB9IGFzIFNuYXBJbmZvLFxyXG4gICAgLy8gICAgIHZlcnRpY2FsOiB7IGlzU25hcDogZmFsc2UsIGluZGV4OiAtMSB9IGFzIFNuYXBJbmZvLFxyXG4gICAgLy8gfSA6XHJcbiAgICB2YXIgX2IgPSBjaGVja1NuYXBQb3NlcyhndWlkZWluZXMsIHBvc2VzWCwgcG9zZXNZLCBbXSwgW10sIHNuYXBIb3Jpem9udGFsVGhyZXNob2xkLCBzbmFwVmVydGljYWxUaHJlc2hvbGQsIG11bHRpcGxlcyksIGhvcml6b250YWxTbmFwSW5mbyA9IF9iLmhvcml6b250YWwsIHZlcnRpY2FsU25hcEluZm8gPSBfYi52ZXJ0aWNhbDtcclxuICAgIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gZ2V0U25hcEJvdW5kKGhvcml6b250YWxCb3VuZEluZm9zWzBdLCBob3Jpem9udGFsU25hcEluZm8pO1xyXG4gICAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gZ2V0U25hcEJvdW5kKHZlcnRpY2FsQm91bmRJbmZvc1swXSwgdmVydGljYWxTbmFwSW5mbyk7XHJcbiAgICB2YXIgaG9yaXpvbnRhbERpc3QgPSBhYnMoaG9yaXpvbnRhbE9mZnNldCk7XHJcbiAgICB2YXIgdmVydGljYWxEaXN0ID0gYWJzKHZlcnRpY2FsT2Zmc2V0KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaG9yaXpvbnRhbDoge1xyXG4gICAgICAgICAgICBpc0JvdW5kOiBob3Jpem9udGFsQm91bmRJbmZvc1swXS5pc0JvdW5kLFxyXG4gICAgICAgICAgICBpc1NuYXA6IGhvcml6b250YWxTbmFwSW5mby5pc1NuYXAsXHJcbiAgICAgICAgICAgIHNuYXBJbmRleDogaG9yaXpvbnRhbFNuYXBJbmZvLmluZGV4LFxyXG4gICAgICAgICAgICBvZmZzZXQ6IGhvcml6b250YWxPZmZzZXQsXHJcbiAgICAgICAgICAgIGRpc3Q6IGhvcml6b250YWxEaXN0LFxyXG4gICAgICAgICAgICBib3VuZHM6IGhvcml6b250YWxCb3VuZEluZm9zLFxyXG4gICAgICAgICAgICBzbmFwOiBob3Jpem9udGFsU25hcEluZm8sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB2ZXJ0aWNhbDoge1xyXG4gICAgICAgICAgICBpc0JvdW5kOiB2ZXJ0aWNhbEJvdW5kSW5mb3NbMF0uaXNCb3VuZCxcclxuICAgICAgICAgICAgaXNTbmFwOiB2ZXJ0aWNhbFNuYXBJbmZvLmlzU25hcCxcclxuICAgICAgICAgICAgc25hcEluZGV4OiB2ZXJ0aWNhbFNuYXBJbmZvLmluZGV4LFxyXG4gICAgICAgICAgICBvZmZzZXQ6IHZlcnRpY2FsT2Zmc2V0LFxyXG4gICAgICAgICAgICBkaXN0OiB2ZXJ0aWNhbERpc3QsXHJcbiAgICAgICAgICAgIGJvdW5kczogdmVydGljYWxCb3VuZEluZm9zLFxyXG4gICAgICAgICAgICBzbmFwOiB2ZXJ0aWNhbFNuYXBJbmZvLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrU25hcFJpZ2h0TGluZShzdGFydFBvcywgZW5kUG9zLCBzbmFwQm91bmRJbmZvLCBrZWVwUmF0aW8pIHtcclxuICAgIHZhciByYWQgPSAoZ2V0UmFkKHN0YXJ0UG9zLCBlbmRQb3MpIC8gTWF0aC5QSSkgKiAxODA7XHJcbiAgICB2YXIgX2EgPSBzbmFwQm91bmRJbmZvLnZlcnRpY2FsLCBpc1ZlcnRpY2FsQm91bmQgPSBfYS5pc0JvdW5kLCBpc1ZlcnRpY2FsU25hcCA9IF9hLmlzU25hcCwgdmVydGljYWxEaXN0ID0gX2EuZGlzdCwgX2IgPSBzbmFwQm91bmRJbmZvLmhvcml6b250YWwsIGlzSG9yaXpvbnRhbEJvdW5kID0gX2IuaXNCb3VuZCwgaXNIb3Jpem9udGFsU25hcCA9IF9iLmlzU25hcCwgaG9yaXpvbnRhbERpc3QgPSBfYi5kaXN0O1xyXG4gICAgdmFyIHJhZDE4MCA9IHJhZCAlIDE4MDtcclxuICAgIHZhciBpc0hvcml6b250YWxMaW5lID0gcmFkMTgwIDwgMyB8fCByYWQxODAgPiAxNzc7XHJcbiAgICB2YXIgaXNWZXJ0aWNhbExpbmUgPSByYWQxODAgPiA4NyAmJiByYWQxODAgPCA5MztcclxuICAgIGlmIChob3Jpem9udGFsRGlzdCA8IHZlcnRpY2FsRGlzdCkge1xyXG4gICAgICAgIGlmIChpc1ZlcnRpY2FsQm91bmQgfHxcclxuICAgICAgICAgICAgKGlzVmVydGljYWxTbmFwICYmXHJcbiAgICAgICAgICAgICAgICAhaXNWZXJ0aWNhbExpbmUgJiZcclxuICAgICAgICAgICAgICAgICgha2VlcFJhdGlvIHx8ICFpc0hvcml6b250YWxMaW5lKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNIb3Jpem9udGFsQm91bmQgfHxcclxuICAgICAgICAoaXNIb3Jpem9udGFsU25hcCAmJlxyXG4gICAgICAgICAgICAhaXNIb3Jpem9udGFsTGluZSAmJlxyXG4gICAgICAgICAgICAoIWtlZXBSYXRpbyB8fCAhaXNWZXJ0aWNhbExpbmUpKSkge1xyXG4gICAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcclxuICAgIH1cclxuICAgIHJldHVybiBcIlwiO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNuYXBCb3VuZEluZm8obW92ZWFibGUsIHBvc2VzLCBkaXJlY3Rpb25zLCBrZWVwUmF0aW8sIGlzUmVxdWVzdCwgZGF0YXMpIHtcclxuICAgIHJldHVybiBkaXJlY3Rpb25zLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBzdGFydERpcmVjdGlvbiA9IF9iWzBdLCBlbmREaXJlY3Rpb24gPSBfYlsxXTtcclxuICAgICAgICB2YXIgb3RoZXJTdGFydFBvcyA9IGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBzdGFydERpcmVjdGlvbik7XHJcbiAgICAgICAgdmFyIG90aGVyRW5kUG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGVuZERpcmVjdGlvbik7XHJcbiAgICAgICAgdmFyIHNuYXBCb3VuZEluZm8gPSBrZWVwUmF0aW9cclxuICAgICAgICAgICAgPyBjaGVja1NuYXBCb3VuZHNLZWVwUmF0aW8obW92ZWFibGUsIG90aGVyU3RhcnRQb3MsIG90aGVyRW5kUG9zLCBpc1JlcXVlc3QpXHJcbiAgICAgICAgICAgIDogY2hlY2tNb3ZlYWJsZVNuYXBCb3VuZHMobW92ZWFibGUsIGlzUmVxdWVzdCwge1xyXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IFtvdGhlckVuZFBvc1swXV0sXHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsOiBbb3RoZXJFbmRQb3NbMV1dLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB2YXIgX2MgPSBzbmFwQm91bmRJbmZvLmhvcml6b250YWwsIFxyXG4gICAgICAgIC8vIGRpc3Q6IG90aGVySG9yaXpvbnRhbERpc3QsXHJcbiAgICAgICAgb3RoZXJIb3Jpem9udGFsT2Zmc2V0ID0gX2Mub2Zmc2V0LCBpc090aGVySG9yaXpvbnRhbEJvdW5kID0gX2MuaXNCb3VuZCwgaXNPdGhlckhvcml6b250YWxTbmFwID0gX2MuaXNTbmFwLCBfZCA9IHNuYXBCb3VuZEluZm8udmVydGljYWwsIFxyXG4gICAgICAgIC8vIGRpc3Q6IG90aGVyVmVydGljYWxEaXN0LFxyXG4gICAgICAgIG90aGVyVmVydGljYWxPZmZzZXQgPSBfZC5vZmZzZXQsIGlzT3RoZXJWZXJ0aWNhbEJvdW5kID0gX2QuaXNCb3VuZCwgaXNPdGhlclZlcnRpY2FsU25hcCA9IF9kLmlzU25hcDtcclxuICAgICAgICB2YXIgbXVsdGlwbGUgPSBtaW51cyhlbmREaXJlY3Rpb24sIHN0YXJ0RGlyZWN0aW9uKTtcclxuICAgICAgICBpZiAoIW90aGVyVmVydGljYWxPZmZzZXQgJiYgIW90aGVySG9yaXpvbnRhbE9mZnNldCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaXNCb3VuZDogaXNPdGhlclZlcnRpY2FsQm91bmQgfHwgaXNPdGhlckhvcml6b250YWxCb3VuZCxcclxuICAgICAgICAgICAgICAgIGlzU25hcDogaXNPdGhlclZlcnRpY2FsU25hcCB8fCBpc090aGVySG9yaXpvbnRhbFNuYXAsXHJcbiAgICAgICAgICAgICAgICBzaWduOiBtdWx0aXBsZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc25hcExpbmUgPSBjaGVja1NuYXBSaWdodExpbmUob3RoZXJTdGFydFBvcywgb3RoZXJFbmRQb3MsIHNuYXBCb3VuZEluZm8sIGtlZXBSYXRpbyk7XHJcbiAgICAgICAgaWYgKCFzbmFwTGluZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2lnbjogbXVsdGlwbGUsXHJcbiAgICAgICAgICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzU25hcDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzVmVydGljYWwgPSBzbmFwTGluZSA9PT0gXCJ2ZXJ0aWNhbFwiO1xyXG4gICAgICAgIHZhciBzaXplT2Zmc2V0ID0gWzAsIDBdO1xyXG4gICAgICAgIGlmICgha2VlcFJhdGlvXHJcbiAgICAgICAgICAgICYmIGFicyhlbmREaXJlY3Rpb25bMF0pID09PSAxXHJcbiAgICAgICAgICAgICYmIGFicyhlbmREaXJlY3Rpb25bMV0pID09PSAxXHJcbiAgICAgICAgICAgICYmIHN0YXJ0RGlyZWN0aW9uWzBdICE9PSBlbmREaXJlY3Rpb25bMF1cclxuICAgICAgICAgICAgJiYgc3RhcnREaXJlY3Rpb25bMV0gIT09IGVuZERpcmVjdGlvblsxXSkge1xyXG4gICAgICAgICAgICBzaXplT2Zmc2V0ID0gZ2V0RHJhZ0Rpc3Qoe1xyXG4gICAgICAgICAgICAgICAgZGF0YXM6IGRhdGFzLFxyXG4gICAgICAgICAgICAgICAgZGlzdFg6IC1vdGhlclZlcnRpY2FsT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgZGlzdFk6IC1vdGhlckhvcml6b250YWxPZmZzZXQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2l6ZU9mZnNldCA9IHNvbHZlTmV4dE9mZnNldChvdGhlclN0YXJ0UG9zLCBvdGhlckVuZFBvcywgLShpc1ZlcnRpY2FsID8gb3RoZXJWZXJ0aWNhbE9mZnNldCA6IG90aGVySG9yaXpvbnRhbE9mZnNldCksIGlzVmVydGljYWwsIGRhdGFzKS5vZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNpemVPZmZzZXQgPSBzaXplT2Zmc2V0Lm1hcChmdW5jdGlvbiAoc2l6ZSwgaSkgeyByZXR1cm4gc2l6ZSAqIChtdWx0aXBsZVtpXSA/IDIgLyBtdWx0aXBsZVtpXSA6IDApOyB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzaWduOiBtdWx0aXBsZSxcclxuICAgICAgICAgICAgaXNCb3VuZDogaXNWZXJ0aWNhbCA/IGlzT3RoZXJWZXJ0aWNhbEJvdW5kIDogaXNPdGhlckhvcml6b250YWxCb3VuZCxcclxuICAgICAgICAgICAgaXNTbmFwOiBpc1ZlcnRpY2FsID8gaXNPdGhlclZlcnRpY2FsU25hcCA6IGlzT3RoZXJIb3Jpem9udGFsU25hcCxcclxuICAgICAgICAgICAgb2Zmc2V0OiBzaXplT2Zmc2V0LFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRTbmFwQm91bmRPZmZzZXQoYm91bmRJbmZvLCBzbmFwSW5mbykge1xyXG4gICAgaWYgKGJvdW5kSW5mby5pc0JvdW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kSW5mby5vZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzbmFwSW5mby5pc1NuYXApIHtcclxuICAgICAgICByZXR1cm4gc25hcEluZm8ub2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTbmFwQm91bmRzS2VlcFJhdGlvKG1vdmVhYmxlLCBzdGFydFBvcywgZW5kUG9zLCBpc1JlcXVlc3QpIHtcclxuICAgIHZhciBfYSA9IGNoZWNrQm91bmRLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpLCBob3Jpem9udGFsQm91bmRJbmZvID0gX2EuaG9yaXpvbnRhbCwgdmVydGljYWxCb3VuZEluZm8gPSBfYS52ZXJ0aWNhbDtcclxuICAgIHZhciBfYiA9IGlzUmVxdWVzdCA/IHtcclxuICAgICAgICBob3Jpem9udGFsOiB7IGlzU25hcDogZmFsc2UgfSxcclxuICAgICAgICB2ZXJ0aWNhbDogeyBpc1NuYXA6IGZhbHNlIH0sXHJcbiAgICB9IDogY2hlY2tTbmFwS2VlcFJhdGlvKG1vdmVhYmxlLCBzdGFydFBvcywgZW5kUG9zKSwgaG9yaXpvbnRhbFNuYXBJbmZvID0gX2IuaG9yaXpvbnRhbCwgdmVydGljYWxTbmFwSW5mbyA9IF9iLnZlcnRpY2FsO1xyXG4gICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBnZXRTbmFwQm91bmRPZmZzZXQoaG9yaXpvbnRhbEJvdW5kSW5mbywgaG9yaXpvbnRhbFNuYXBJbmZvKTtcclxuICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IGdldFNuYXBCb3VuZE9mZnNldCh2ZXJ0aWNhbEJvdW5kSW5mbywgdmVydGljYWxTbmFwSW5mbyk7XHJcbiAgICB2YXIgaG9yaXpvbnRhbERpc3QgPSBhYnMoaG9yaXpvbnRhbE9mZnNldCk7XHJcbiAgICB2YXIgdmVydGljYWxEaXN0ID0gYWJzKHZlcnRpY2FsT2Zmc2V0KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaG9yaXpvbnRhbDoge1xyXG4gICAgICAgICAgICBpc0JvdW5kOiBob3Jpem9udGFsQm91bmRJbmZvLmlzQm91bmQsXHJcbiAgICAgICAgICAgIGlzU25hcDogaG9yaXpvbnRhbFNuYXBJbmZvLmlzU25hcCxcclxuICAgICAgICAgICAgb2Zmc2V0OiBob3Jpem9udGFsT2Zmc2V0LFxyXG4gICAgICAgICAgICBkaXN0OiBob3Jpem9udGFsRGlzdCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZlcnRpY2FsOiB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IHZlcnRpY2FsQm91bmRJbmZvLmlzQm91bmQsXHJcbiAgICAgICAgICAgIGlzU25hcDogdmVydGljYWxTbmFwSW5mby5pc1NuYXAsXHJcbiAgICAgICAgICAgIG9mZnNldDogdmVydGljYWxPZmZzZXQsXHJcbiAgICAgICAgICAgIGRpc3Q6IHZlcnRpY2FsRGlzdCxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGVja01heEJvdW5kcyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZGF0YXMpIHtcclxuICAgIHZhciBmaXhlZERpcmVjdGlvbiA9IFstZGlyZWN0aW9uWzBdLCAtZGlyZWN0aW9uWzFdXTtcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICB2YXIgYm91bmRzID0gbW92ZWFibGUucHJvcHMuYm91bmRzO1xyXG4gICAgdmFyIG1heFdpZHRoID0gSW5maW5pdHk7XHJcbiAgICB2YXIgbWF4SGVpZ2h0ID0gSW5maW5pdHk7XHJcbiAgICBpZiAoYm91bmRzKSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbnMgPSBbXHJcbiAgICAgICAgICAgIFtkaXJlY3Rpb25bMF0sIC1kaXJlY3Rpb25bMV1dLFxyXG4gICAgICAgICAgICBbLWRpcmVjdGlvblswXSwgZGlyZWN0aW9uWzFdXSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBfYiA9IGJvdW5kcy5sZWZ0LCBsZWZ0XzEgPSBfYiA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2IsIF9jID0gYm91bmRzLnRvcCwgdG9wXzEgPSBfYyA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2MsIF9kID0gYm91bmRzLnJpZ2h0LCByaWdodF8xID0gX2QgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2QsIF9lID0gYm91bmRzLmJvdHRvbSwgYm90dG9tXzEgPSBfZSA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfZTtcclxuICAgICAgICBkaXJlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKG90aGVyRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0NoZWNrVmVydGljYWwgPSBvdGhlckRpcmVjdGlvblswXSAhPT0gZml4ZWREaXJlY3Rpb25bMF07XHJcbiAgICAgICAgICAgIHZhciBpc0NoZWNrSG9yaXpvbnRhbCA9IG90aGVyRGlyZWN0aW9uWzFdICE9PSBmaXhlZERpcmVjdGlvblsxXTtcclxuICAgICAgICAgICAgdmFyIG90aGVyUG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIG90aGVyRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGRlZyA9IChnZXRSYWQoZml4ZWRQb3NpdGlvbiwgb3RoZXJQb3MpICogMzYwKSAvIE1hdGguUEk7XHJcbiAgICAgICAgICAgIGlmIChpc0NoZWNrSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRPdGhlclBvcyA9IG90aGVyUG9zLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWJzKGRlZyAtIDM2MCkgPCAyIHx8IGFicyhkZWcgLSAxODApIDwgMikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRPdGhlclBvc1sxXSA9IGZpeGVkUG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBzb2x2ZU5leHRPZmZzZXQoZml4ZWRQb3NpdGlvbiwgbmV4dE90aGVyUG9zLCAoZml4ZWRQb3NpdGlvblsxXSA8IG90aGVyUG9zWzFdID8gYm90dG9tXzEgOiB0b3BfMSkgLVxyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyUG9zWzFdLCBmYWxzZSwgZGF0YXMpLCBfYiA9IF9fcmVhZChfYS5vZmZzZXQsIDIpLCBoZWlnaHRPZmZzZXQgPSBfYlsxXSwgaXNIZWlnaHRPdXRzaWRlID0gX2EuaXNPdXRzaWRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihoZWlnaHRPZmZzZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0ICsgKGlzSGVpZ2h0T3V0c2lkZSA/IDEgOiAtMSkgKiBhYnMoaGVpZ2h0T2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNDaGVja1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dE90aGVyUG9zID0gb3RoZXJQb3Muc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChhYnMoZGVnIC0gOTApIDwgMiB8fCBhYnMoZGVnIC0gMjcwKSA8IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0T3RoZXJQb3NbMF0gPSBmaXhlZFBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIF9jID0gc29sdmVOZXh0T2Zmc2V0KGZpeGVkUG9zaXRpb24sIG5leHRPdGhlclBvcywgKGZpeGVkUG9zaXRpb25bMF0gPCBvdGhlclBvc1swXSA/IHJpZ2h0XzEgOiBsZWZ0XzEpIC0gb3RoZXJQb3NbMF0sIHRydWUsIGRhdGFzKSwgX2QgPSBfX3JlYWQoX2Mub2Zmc2V0LCAxKSwgd2lkdGhPZmZzZXQgPSBfZFswXSwgaXNXaWR0aE91dHNpZGUgPSBfYy5pc091dHNpZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHdpZHRoT2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gd2lkdGggKyAoaXNXaWR0aE91dHNpZGUgPyAxIDogLTEpICogYWJzKHdpZHRoT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtYXhXaWR0aDogbWF4V2lkdGgsXHJcbiAgICAgICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbmFtZXNwYWNlIERyYWdnYWJsZVxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcclxuICogQGRlc2NyaXB0aW9uIERyYWdnYWJsZSByZWZlcnMgdG8gdGhlIGFiaWxpdHkgdG8gZHJhZyBhbmQgbW92ZSB0YXJnZXRzLlxyXG4gKi9cclxudmFyIERyYWdnYWJsZSA9IHtcclxuICAgIG5hbWU6IFwiZHJhZ2dhYmxlXCIsXHJcbiAgICBwcm9wczogW1xyXG4gICAgICAgIFwiZHJhZ2dhYmxlXCIsXHJcbiAgICAgICAgXCJ0aHJvdHRsZURyYWdcIixcclxuICAgICAgICBcInRocm90dGxlRHJhZ1JvdGF0ZVwiLFxyXG4gICAgICAgIFwiaGlkZVRocm90dGxlRHJhZ1JvdGF0ZUxpbmVcIixcclxuICAgICAgICBcInN0YXJ0RHJhZ1JvdGF0ZVwiLFxyXG4gICAgICAgIFwiZWRnZURyYWdnYWJsZVwiLFxyXG4gICAgXSxcclxuICAgIGV2ZW50czogW1xyXG4gICAgICAgIFwiZHJhZ1N0YXJ0XCIsXHJcbiAgICAgICAgXCJkcmFnXCIsXHJcbiAgICAgICAgXCJkcmFnRW5kXCIsXHJcbiAgICAgICAgXCJkcmFnR3JvdXBTdGFydFwiLFxyXG4gICAgICAgIFwiZHJhZ0dyb3VwXCIsXHJcbiAgICAgICAgXCJkcmFnR3JvdXBFbmRcIixcclxuICAgIF0sXHJcbiAgICByZXF1ZXN0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW1wibGVmdFwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCJdO1xyXG4gICAgfSxcclxuICAgIHJlcXVlc3RDaGlsZFN0eWxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcImxlZnRcIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgaGlkZVRocm90dGxlRHJhZ1JvdGF0ZUxpbmUgPSBfYS5oaWRlVGhyb3R0bGVEcmFnUm90YXRlTGluZSwgdGhyb3R0bGVEcmFnUm90YXRlID0gX2EudGhyb3R0bGVEcmFnUm90YXRlLCB6b29tID0gX2Euem9vbTtcclxuICAgICAgICB2YXIgX2IgPSBtb3ZlYWJsZS5nZXRTdGF0ZSgpLCBkcmFnSW5mbyA9IF9iLmRyYWdJbmZvLCBiZWZvcmVPcmlnaW4gPSBfYi5iZWZvcmVPcmlnaW47XHJcbiAgICAgICAgaWYgKGhpZGVUaHJvdHRsZURyYWdSb3RhdGVMaW5lIHx8ICF0aHJvdHRsZURyYWdSb3RhdGUgfHwgIWRyYWdJbmZvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpc3QgPSBkcmFnSW5mby5kaXN0O1xyXG4gICAgICAgIGlmICghZGlzdFswXSAmJiAhZGlzdFsxXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3aWR0aCA9IGdldERpc3RTaXplKGRpc3QpO1xyXG4gICAgICAgIHZhciByYWQgPSBnZXRSYWQoZGlzdCwgWzAsIDBdKTtcclxuICAgICAgICByZXR1cm4gW1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHByZWZpeChcImxpbmVcIiwgXCJob3Jpem9udGFsXCIsIFwiZHJhZ2xpbmVcIiwgXCJkYXNoZWRcIiksIGtleTogXCJkcmFnUm90YXRlR3VpZGVsaW5lXCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGJlZm9yZU9yaWdpblswXSwgXCJweCwgXCIpLmNvbmNhdChiZWZvcmVPcmlnaW5bMV0sIFwicHgpIHJvdGF0ZShcIikuY29uY2F0KHJhZCwgXCJyYWQpIHNjYWxlWShcIikuY29uY2F0KHpvb20sIFwiKVwiKSxcclxuICAgICAgICAgICAgICAgIH0gfSldO1xyXG4gICAgfSxcclxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgcGFyZW50RXZlbnQgPSBlLnBhcmVudEV2ZW50LCBwYXJlbnRHZXN0byA9IGUucGFyZW50R2VzdG87XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgdmFyIGdlc3RvcyA9IHN0YXRlLmdlc3Rvcywgc3R5bGUgPSBzdGF0ZS5zdHlsZTtcclxuICAgICAgICBpZiAoZ2VzdG9zLmRyYWdnYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdlc3Rvcy5kcmFnZ2FibGUgPSBwYXJlbnRHZXN0byB8fCBtb3ZlYWJsZS50YXJnZXRHZXN0bztcclxuICAgICAgICBkYXRhcy5kYXRhcyA9IHt9O1xyXG4gICAgICAgIGRhdGFzLmxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlLmxlZnQgfHwgXCJcIikgfHwgMDtcclxuICAgICAgICBkYXRhcy50b3AgPSBwYXJzZUZsb2F0KHN0eWxlLnRvcCB8fCBcIlwiKSB8fCAwO1xyXG4gICAgICAgIGRhdGFzLmJvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUuYm90dG9tIHx8IFwiXCIpIHx8IDA7XHJcbiAgICAgICAgZGF0YXMucmlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLnJpZ2h0IHx8IFwiXCIpIHx8IDA7XHJcbiAgICAgICAgZGF0YXMuc3RhcnRWYWx1ZSA9IFswLCAwXTtcclxuICAgICAgICBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIHNldERlZmF1bHRUcmFuc2Zvcm1JbmRleChtb3ZlYWJsZSwgZSwgXCJ0cmFuc2xhdGVcIik7XHJcbiAgICAgICAgc3RhcnRDaGVja1NuYXBEcmFnKG1vdmVhYmxlLCBkYXRhcyk7XHJcbiAgICAgICAgZGF0YXMucHJldkRpc3QgPSBbMCwgMF07XHJcbiAgICAgICAgZGF0YXMucHJldkJlZm9yZURpc3QgPSBbMCwgMF07XHJcbiAgICAgICAgZGF0YXMuaXNEcmFnID0gZmFsc2U7XHJcbiAgICAgICAgZGF0YXMuZGVsdGFPZmZzZXQgPSBbMCwgMF07XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHsgc2V0OiBmdW5jdGlvbiAodHJhbnNsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhcy5zdGFydFZhbHVlID0gdHJhbnNsYXRlO1xyXG4gICAgICAgICAgICB9IH0sIGZpbGxUcmFuc2Zvcm1TdGFydEV2ZW50KG1vdmVhYmxlLCBlKSkpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJlbnRFdmVudCB8fCB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnU3RhcnRcIiwgcGFyYW1zKTtcclxuICAgICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBkYXRhcy5pc0RyYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0UmVjdDogbW92ZWFibGUuZ2V0UmVjdCgpLFxyXG4gICAgICAgICAgICAgICAgZGlzdDogWzAsIDBdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VzdG9zLmRyYWdnYWJsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGRhdGFzLmlzUGluY2ggPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGFzLmlzRHJhZyA/IHBhcmFtcyA6IGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGRyYWc6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIGlmICghZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc29sdmVUcmFuc2Zvcm1FdmVudChtb3ZlYWJsZSwgZSwgXCJ0cmFuc2xhdGVcIik7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgcGFyZW50RXZlbnQgPSBlLnBhcmVudEV2ZW50LCBwYXJlbnRGbGFnID0gZS5wYXJlbnRGbGFnLCBpc1BpbmNoID0gZS5pc1BpbmNoLCBkZWx0YU9mZnNldCA9IGUuZGVsdGFPZmZzZXQsIHVzZVNuYXAgPSBlLnVzZVNuYXAsIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0LCBpc0dyb3VwID0gZS5pc0dyb3VwLCBwYXJlbnRUaHJvdHRsZURyYWcgPSBlLnBhcmVudFRocm90dGxlRHJhZztcclxuICAgICAgICB2YXIgZGlzdFggPSBlLmRpc3RYLCBkaXN0WSA9IGUuZGlzdFk7XHJcbiAgICAgICAgdmFyIGlzRHJhZyA9IGRhdGFzLmlzRHJhZywgcHJldkRpc3QgPSBkYXRhcy5wcmV2RGlzdCwgcHJldkJlZm9yZURpc3QgPSBkYXRhcy5wcmV2QmVmb3JlRGlzdCwgc3RhcnRWYWx1ZSA9IGRhdGFzLnN0YXJ0VmFsdWU7XHJcbiAgICAgICAgaWYgKCFpc0RyYWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVsdGFPZmZzZXQpIHtcclxuICAgICAgICAgICAgZGlzdFggKz0gZGVsdGFPZmZzZXRbMF07XHJcbiAgICAgICAgICAgIGRpc3RZICs9IGRlbHRhT2Zmc2V0WzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcclxuICAgICAgICB2YXIgcGFyZW50TW92ZWFibGUgPSBwcm9wcy5wYXJlbnRNb3ZlYWJsZTtcclxuICAgICAgICB2YXIgdGhyb3R0bGVEcmFnID0gaXNHcm91cCA/IDAgOiAocHJvcHMudGhyb3R0bGVEcmFnIHx8IHBhcmVudFRocm90dGxlRHJhZyB8fCAwKTtcclxuICAgICAgICB2YXIgdGhyb3R0bGVEcmFnUm90YXRlID0gcGFyZW50RXZlbnQgPyAwIDogKHByb3BzLnRocm90dGxlRHJhZ1JvdGF0ZSB8fCAwKTtcclxuICAgICAgICB2YXIgZHJhZ1JvdGF0ZVJhZCA9IDA7XHJcbiAgICAgICAgdmFyIGlzVmVydGljYWxTbmFwID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGlzVmVydGljYWxCb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpc0hvcml6b250YWxTbmFwID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGlzSG9yaXpvbnRhbEJvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFwYXJlbnRFdmVudCAmJiB0aHJvdHRsZURyYWdSb3RhdGUgPiAwICYmIChkaXN0WCB8fCBkaXN0WSkpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0RHJhZ1JvdGF0ZSA9IHByb3BzLnN0YXJ0RHJhZ1JvdGF0ZSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgZGVnID0gdGhyb3R0bGUoc3RhcnREcmFnUm90YXRlICsgZ2V0UmFkKFswLCAwXSwgW2Rpc3RYLCBkaXN0WV0pICogMTgwIC8gTWF0aC5QSSwgdGhyb3R0bGVEcmFnUm90YXRlKVxyXG4gICAgICAgICAgICAgICAgLSBzdGFydERyYWdSb3RhdGU7XHJcbiAgICAgICAgICAgIHZhciByeSA9IGRpc3RZICogTWF0aC5hYnMoTWF0aC5jb3MoKGRlZyAtIDkwKSAvIDE4MCAqIE1hdGguUEkpKTtcclxuICAgICAgICAgICAgdmFyIHJ4ID0gZGlzdFggKiBNYXRoLmFicyhNYXRoLmNvcyhkZWcgLyAxODAgKiBNYXRoLlBJKSk7XHJcbiAgICAgICAgICAgIHZhciByID0gZ2V0RGlzdFNpemUoW3J4LCByeV0pO1xyXG4gICAgICAgICAgICBkcmFnUm90YXRlUmFkID0gZGVnICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICAgICAgZGlzdFggPSByICogTWF0aC5jb3MoZHJhZ1JvdGF0ZVJhZCk7XHJcbiAgICAgICAgICAgIGRpc3RZID0gciAqIE1hdGguc2luKGRyYWdSb3RhdGVSYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUGluY2ggJiYgIXBhcmVudEV2ZW50ICYmICFwYXJlbnRGbGFnKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChjaGVja1NuYXBCb3VuZHNEcmFnKG1vdmVhYmxlLCBkaXN0WCwgZGlzdFksIHRocm90dGxlRHJhZ1JvdGF0ZSwgKCF1c2VTbmFwICYmIGlzUmVxdWVzdCkgfHwgZGVsdGFPZmZzZXQsIGRhdGFzKSwgMiksIHZlcnRpY2FsSW5mbyA9IF9hWzBdLCBob3Jpem9udGFsSW5mbyA9IF9hWzFdO1xyXG4gICAgICAgICAgICBpc1ZlcnRpY2FsU25hcCA9IHZlcnRpY2FsSW5mby5pc1NuYXA7XHJcbiAgICAgICAgICAgIGlzVmVydGljYWxCb3VuZCA9IHZlcnRpY2FsSW5mby5pc0JvdW5kO1xyXG4gICAgICAgICAgICBpc0hvcml6b250YWxTbmFwID0gaG9yaXpvbnRhbEluZm8uaXNTbmFwO1xyXG4gICAgICAgICAgICBpc0hvcml6b250YWxCb3VuZCA9IGhvcml6b250YWxJbmZvLmlzQm91bmQ7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IHZlcnRpY2FsSW5mby5vZmZzZXQ7XHJcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gaG9yaXpvbnRhbEluZm8ub2Zmc2V0O1xyXG4gICAgICAgICAgICBkaXN0WCArPSB2ZXJ0aWNhbE9mZnNldDtcclxuICAgICAgICAgICAgZGlzdFkgKz0gaG9yaXpvbnRhbE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJlZm9yZVRyYW5zbGF0ZSA9IHBsdXMoZ2V0QmVmb3JlRHJhZ0Rpc3QoeyBkYXRhczogZGF0YXMsIGRpc3RYOiBkaXN0WCwgZGlzdFk6IGRpc3RZIH0pLCBzdGFydFZhbHVlKTtcclxuICAgICAgICB2YXIgdHJhbnNsYXRlID0gcGx1cyhnZXRUcmFuc2Zvcm1EaXN0KHsgZGF0YXM6IGRhdGFzLCBkaXN0WDogZGlzdFgsIGRpc3RZOiBkaXN0WSB9KSwgc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgdGhyb3R0bGVBcnJheSh0cmFuc2xhdGUsIFRJTllfTlVNKTtcclxuICAgICAgICB0aHJvdHRsZUFycmF5KGJlZm9yZVRyYW5zbGF0ZSwgVElOWV9OVU0pO1xyXG4gICAgICAgIGlmICghdGhyb3R0bGVEcmFnUm90YXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNWZXJ0aWNhbFNuYXAgJiYgIWlzVmVydGljYWxCb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWzBdID0gdGhyb3R0bGUodHJhbnNsYXRlWzBdLCB0aHJvdHRsZURyYWcpO1xyXG4gICAgICAgICAgICAgICAgYmVmb3JlVHJhbnNsYXRlWzBdID0gdGhyb3R0bGUoYmVmb3JlVHJhbnNsYXRlWzBdLCB0aHJvdHRsZURyYWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNIb3Jpem9udGFsU25hcCAmJiAhaXNIb3Jpem9udGFsQm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVsxXSA9IHRocm90dGxlKHRyYW5zbGF0ZVsxXSwgdGhyb3R0bGVEcmFnKTtcclxuICAgICAgICAgICAgICAgIGJlZm9yZVRyYW5zbGF0ZVsxXSA9IHRocm90dGxlKGJlZm9yZVRyYW5zbGF0ZVsxXSwgdGhyb3R0bGVEcmFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmVmb3JlRGlzdCA9IG1pbnVzKGJlZm9yZVRyYW5zbGF0ZSwgc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgdmFyIGRpc3QgPSBtaW51cyh0cmFuc2xhdGUsIHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIHZhciBkZWx0YSA9IG1pbnVzKGRpc3QsIHByZXZEaXN0KTtcclxuICAgICAgICB2YXIgYmVmb3JlRGVsdGEgPSBtaW51cyhiZWZvcmVEaXN0LCBwcmV2QmVmb3JlRGlzdCk7XHJcbiAgICAgICAgZGF0YXMucHJldkRpc3QgPSBkaXN0O1xyXG4gICAgICAgIGRhdGFzLnByZXZCZWZvcmVEaXN0ID0gYmVmb3JlRGlzdDtcclxuICAgICAgICBkYXRhcy5wYXNzRGVsdGEgPSBkZWx0YTsgLy9kaXN0WCAtIChkYXRhcy5wYXNzRGlzdFggfHwgMCk7XHJcbiAgICAgICAgLy8gZGF0YXMucGFzc0RlbHRhWSA9IGRpc3RZIC0gKGRhdGFzLnBhc3NEaXN0WSB8fCAwKTtcclxuICAgICAgICBkYXRhcy5wYXNzRGlzdCA9IGRpc3Q7IC8vZGlzdFg7XHJcbiAgICAgICAgLy8gZGF0YXMucGFzc0Rpc3RZID0gZGlzdFk7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBkYXRhcy5sZWZ0ICsgYmVmb3JlRGlzdFswXTtcclxuICAgICAgICB2YXIgdG9wID0gZGF0YXMudG9wICsgYmVmb3JlRGlzdFsxXTtcclxuICAgICAgICB2YXIgcmlnaHQgPSBkYXRhcy5yaWdodCAtIGJlZm9yZURpc3RbMF07XHJcbiAgICAgICAgdmFyIGJvdHRvbSA9IGRhdGFzLmJvdHRvbSAtIGJlZm9yZURpc3RbMV07XHJcbiAgICAgICAgdmFyIG5leHRUcmFuc2Zvcm0gPSBjb252ZXJ0VHJhbnNmb3JtRm9ybWF0KGRhdGFzLCBcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNsYXRlWzBdLCBcInB4LCBcIikuY29uY2F0KHRyYW5zbGF0ZVsxXSwgXCJweClcIiksIFwidHJhbnNsYXRlKFwiLmNvbmNhdChkaXN0WzBdLCBcInB4LCBcIikuY29uY2F0KGRpc3RbMV0sIFwicHgpXCIpKTtcclxuICAgICAgICBmaWxsT3JpZ2luYWxUcmFuc2Zvcm0oZSwgbmV4dFRyYW5zZm9ybSk7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuZHJhZ0luZm8uZGlzdCA9IHBhcmVudEV2ZW50ID8gWzAsIDBdIDogZGlzdDtcclxuICAgICAgICBpZiAoIXBhcmVudEV2ZW50ICYmICFwYXJlbnRNb3ZlYWJsZSAmJiBkZWx0YS5ldmVyeShmdW5jdGlvbiAobnVtKSB7IHJldHVybiAhbnVtOyB9KSAmJiBiZWZvcmVEZWx0YS5zb21lKGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuICFudW07IH0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9iID0gbW92ZWFibGUuc3RhdGUsIHdpZHRoID0gX2Iud2lkdGgsIGhlaWdodCA9IF9iLmhlaWdodDtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oeyB0cmFuc2Zvcm06IG5leHRUcmFuc2Zvcm0sIGRpc3Q6IGRpc3QsIGRlbHRhOiBkZWx0YSwgdHJhbnNsYXRlOiB0cmFuc2xhdGUsIGJlZm9yZURpc3Q6IGJlZm9yZURpc3QsIGJlZm9yZURlbHRhOiBiZWZvcmVEZWx0YSwgYmVmb3JlVHJhbnNsYXRlOiBiZWZvcmVUcmFuc2xhdGUsIGxlZnQ6IGxlZnQsIHRvcDogdG9wLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBpc1BpbmNoOiBpc1BpbmNoIH0sIGZpbGxDU1NPYmplY3Qoe1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IG5leHRUcmFuc2Zvcm0sXHJcbiAgICAgICAgfSwgZSkpKTtcclxuICAgICAgICAhcGFyZW50RXZlbnQgJiYgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ1wiLCBwYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0FmdGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIHZhciBkZWx0YU9mZnNldCA9IGRhdGFzLmRlbHRhT2Zmc2V0O1xyXG4gICAgICAgIGlmIChkZWx0YU9mZnNldFswXSB8fCBkZWx0YU9mZnNldFsxXSkge1xyXG4gICAgICAgICAgICBkYXRhcy5kZWx0YU9mZnNldCA9IFswLCAwXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGRlbHRhT2Zmc2V0OiBkZWx0YU9mZnNldCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgcGFyZW50RXZlbnQgPSBlLnBhcmVudEV2ZW50LCBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuZHJhZ0luZm8gPSBudWxsO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNEcmFnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMuaXNEcmFnID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xyXG4gICAgICAgICFwYXJlbnRFdmVudCAmJiB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnRW5kXCIsIHBhcmFtKTtcclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgY2xpZW50WCA9IGUuY2xpZW50WCwgY2xpZW50WSA9IGUuY2xpZW50WTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9jID0gdHJpZ2dlckNoaWxkR2VzdG8obW92ZWFibGUsIHRoaXMsIFwiZHJhZ1N0YXJ0XCIsIFtcclxuICAgICAgICAgICAgY2xpZW50WCB8fCAwLFxyXG4gICAgICAgICAgICBjbGllbnRZIHx8IDAsXHJcbiAgICAgICAgXSwgZSwgZmFsc2UsIFwiZHJhZ2dhYmxlXCIpLCBjaGlsZEV2ZW50cyA9IF9jLmNoaWxkRXZlbnRzLCBldmVudFBhcmFtcyA9IF9jLmV2ZW50UGFyYW1zO1xyXG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtcyksIHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cywgZXZlbnRzOiBldmVudFBhcmFtcyB9KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ0dyb3VwU3RhcnRcIiwgbmV4dFBhcmFtcyk7XHJcbiAgICAgICAgZGF0YXMuaXNEcmFnID0gcmVzdWx0ICE9PSBmYWxzZTtcclxuICAgICAgICAvLyBmaW5kIGRhdGEuc3RhcnRWYWx1ZSBhbmQgYmFzZWQgb24gZmlyc3QgY2hpbGQgbW92ZWFibGVcclxuICAgICAgICB2YXIgc3RhcnRWYWx1ZSA9IChfYiA9IChfYSA9IGNoaWxkRXZlbnRzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YXMuc3RhcnRWYWx1ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogWzAsIDBdO1xyXG4gICAgICAgIGRhdGFzLnRocm90dGxlT2Zmc2V0ID0gW3N0YXJ0VmFsdWVbMF0gJSAxLCBzdGFydFZhbHVlWzFdICUgMV07XHJcbiAgICAgICAgcmV0dXJuIGRhdGFzLmlzRHJhZyA/IHBhcmFtcyA6IGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICBpZiAoIWRhdGFzLmlzRHJhZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWcobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBwYXJlbnRUaHJvdHRsZURyYWc6IG1vdmVhYmxlLnByb3BzLnRocm90dGxlRHJhZyB9KSk7XHJcbiAgICAgICAgdmFyIHBhc3NEZWx0YSA9IGUuZGF0YXMucGFzc0RlbHRhO1xyXG4gICAgICAgIHZhciBldmVudFBhcmFtcyA9IHRyaWdnZXJDaGlsZEdlc3RvKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdcIiwgcGFzc0RlbHRhLCBlLCBmYWxzZSwgXCJkcmFnZ2FibGVcIikuZXZlbnRQYXJhbXM7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cywgZXZlbnRzOiBldmVudFBhcmFtcyB9LCBwYXJhbXMpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdHcm91cFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV4dFBhcmFtcztcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBpc0RyYWcgPSBlLmlzRHJhZywgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNEcmFnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICB2YXIgZXZlbnRQYXJhbXMgPSB0cmlnZ2VyQ2hpbGRHZXN0byhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnRW5kXCIsIFswLCAwXSwgZSwgZmFsc2UsIFwiZHJhZ2dhYmxlXCIpLmV2ZW50UGFyYW1zO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdHcm91cEVuZFwiLCBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXHJcbiAgICAgICAgICAgIGV2ZW50czogZXZlbnRQYXJhbXMsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybiBpc0RyYWc7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlLkRyYWdnYWJsZSNyZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2VdIC0gdGhlIGRyYWdnYWJsZSdzIHJlcXVlc3QgcGFyYW1ldGVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2UueF0gLSB4IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2UueV0gLSB5IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2UuZGVsdGFYXSAtIFggbnVtYmVyIHRvIG1vdmVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVldIC0gWSBudW1iZXIgdG8gbW92ZVxyXG4gICAgICogQHJldHVybiB7TW92ZWFibGUuUmVxdWVzdGVyfSBNb3ZlYWJsZSBSZXF1ZXN0ZXJcclxuICAgICAqIEBleGFtcGxlXHJcblxuICAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcclxuICAgICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSwgdHJ1ZSk7XHJcbiAgICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcclxuICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9LCB0cnVlKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyByZXF1ZXN0U3RhcnRcclxuICAgICAqIGNvbnN0IHJlcXVlc3RlciA9IG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIik7XHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVxdWVzdFxyXG4gICAgICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XHJcbiAgICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcclxuICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9KTtcclxuICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyMjAsIHk6IDEwMCB9KTtcclxuICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyNDAsIHk6IDEwMCB9KTtcclxuICAgICAqXHJcbiAgICAgKiAvLyByZXF1ZXN0RW5kXHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdEVuZCgpO1xyXG4gICAgICovXHJcbiAgICByZXF1ZXN0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSB7fTtcclxuICAgICAgICB2YXIgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcclxuICAgICAgICB2YXIgZGlzdFggPSAwO1xyXG4gICAgICAgIHZhciBkaXN0WSA9IDA7XHJcbiAgICAgICAgdmFyIHVzZVNuYXAgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc0NvbnRyb2w6IGZhbHNlLFxyXG4gICAgICAgICAgICByZXF1ZXN0U3RhcnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB1c2VTbmFwID0gZS51c2VTbmFwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YXM6IGRhdGFzLCB1c2VTbmFwOiB1c2VTbmFwIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJ4XCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RYID0gZS54IC0gcmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJkZWx0YVhcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFggKz0gZS5kZWx0YVg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJ5XCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RZID0gZS55IC0gcmVjdC50b3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImRlbHRhWVwiIGluIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0WSArPSBlLmRlbHRhWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGFzOiBkYXRhcywgZGlzdFg6IGRpc3RYLCBkaXN0WTogZGlzdFksIHVzZVNuYXA6IHVzZVNuYXAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YXM6IGRhdGFzLCBpc0RyYWc6IHRydWUsIHVzZVNuYXA6IHVzZVNuYXAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICBtb3ZlYWJsZS5zdGF0ZS5nZXN0b3MuZHJhZ2dhYmxlID0gbnVsbDtcclxuICAgICAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnSW5mbyA9IG51bGw7XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBkcmFnZ2VkLiAoZGVmYXVsdDogZmFsc2UpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLkRyYWdnYWJsZSNkcmFnZ2FibGVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICovXHJcbi8qKlxyXG4gKiB0aHJvdHRsZSBvZiB4LCB5IHdoZW4gZHJhZy5cclxuICogQG5hbWUgTW92ZWFibGUuRHJhZ2dhYmxlI3Rocm90dGxlRHJhZ1xyXG4gKiBAZGVmYXVsdCAwXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnRocm90dGxlRHJhZyA9IDE7XHJcbiAqL1xyXG4vKipcclxuKiB0aHJvdHRsZSBvZiBhbmdsZSBvZiB4LCB5IHdoZW4gZHJhZy5cclxuKiBAbmFtZSBNb3ZlYWJsZS5EcmFnZ2FibGUjdGhyb3R0bGVEcmFnUm90YXRlXHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuKlxyXG4qIG1vdmVhYmxlLnRocm90dGxlRHJhZ1JvdGF0ZSA9IDQ1O1xyXG4qL1xyXG4vKipcclxuKiBzdGFydCBhbmdsZSBvZiB0aHJvdHRsZURyYWdSb3RhdGUgb2YgeCwgeSB3aGVuIGRyYWcuXHJcbiogQG5hbWUgTW92ZWFibGUuRHJhZ2dhYmxlI3N0YXJ0RHJhZ1JvdGF0ZVxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbipcclxuKiAvLyA0NSwgMTM1LCAyMjUsIDMxNVxyXG4qIG1vdmVhYmxlLnRocm90dGxlRHJhZ1JvdGF0ZSA9IDkwO1xyXG4qIG1vdmVhYmxlLnN0YXJ0RHJhZ1JvdGF0ZSA9IDQ1O1xyXG4qL1xyXG4vKipcclxuICogV2hlbiB0aGUgZHJhZyBzdGFydHMsIHRoZSBkcmFnU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXHJcbiAqIEBldmVudCBkcmFnU3RhcnRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGRyYWdTdGFydCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgZHJhZ2dhYmxlOiB0cnVlIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImRyYWdTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBkcmFnZ2luZywgdGhlIGRyYWcgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXHJcbiAqIEBldmVudCBkcmFnXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuRHJhZ2dhYmxlLk9uRHJhZ30gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZyBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgZHJhZ2dhYmxlOiB0cnVlIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImRyYWdcIiwgKHsgdGFyZ2V0LCB0cmFuc2Zvcm0gfSkgPT4ge1xyXG4gKiAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgZHJhZyBmaW5pc2hlcywgdGhlIGRyYWdFbmQgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXHJcbiAqIEBldmVudCBkcmFnRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuRHJhZ2dhYmxlLk9uRHJhZ0VuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZ0VuZCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgZHJhZ2dhYmxlOiB0cnVlIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImRyYWdFbmRcIiwgKHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0LCBpc0RyYWcpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4qIFdoZW4gdGhlIGdyb3VwIGRyYWcgc3RhcnRzLCB0aGUgYGRyYWdHcm91cFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXHJcbiogQG1lbWJlcm9mIE1vdmVhYmxlLkRyYWdnYWJsZVxyXG4qIEBldmVudCBkcmFnR3JvdXBTdGFydFxyXG4qIEBwYXJhbSB7TW92ZWFibGUuRHJhZ2dhYmxlLk9uRHJhZ0dyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnR3JvdXBTdGFydGAgZXZlbnRcclxuKiBAZXhhbXBsZVxyXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuKlxyXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuKiAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiogfSk7XHJcbiogbW92ZWFibGUub24oXCJkcmFnR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcclxuKiAgICAgY29uc29sZS5sb2coXCJvbkRyYWdHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuKiBXaGVuIHRoZSBncm91cCBkcmFnLCB0aGUgYGRyYWdHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5EcmFnZ2FibGVcclxuKiBAZXZlbnQgZHJhZ0dyb3VwXHJcbiogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnR3JvdXBgIGV2ZW50XHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiogICAgIGRyYWdnYWJsZTogdHJ1ZVxyXG4qIH0pO1xyXG4qIG1vdmVhYmxlLm9uKFwiZHJhZ0dyb3VwXCIsICh7IHRhcmdldHMsIGV2ZW50cyB9KSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKFwib25EcmFnR3JvdXBcIiwgdGFyZ2V0cyk7XHJcbiogICAgIGV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcclxuKiAgICAgICAgICAvLyBkcmFnIGV2ZW50XHJcbiogICAgICAgICAgY29uc29sZS5sb2coXCJvbkRyYWcgbGVmdCwgdG9wXCIsIGV2LmxlZnQsIGV2LnRvcCk7XHJcbiogICAgICAgICAgLy8gZXYudGFyZ2V0IS5zdHlsZS5sZWZ0ID0gYCR7ZXYubGVmdH1weGA7XHJcbiogICAgICAgICAgLy8gZXYudGFyZ2V0IS5zdHlsZS50b3AgPSBgJHtldi50b3B9cHhgO1xyXG4qICAgICAgICAgIGNvbnNvbGUubG9nKFwib25EcmFnIHRyYW5zbGF0ZVwiLCBldi5kaXN0KTtcclxuKiAgICAgICAgICBldi50YXJnZXQhLnN0eWxlLnRyYW5zZm9ybSA9IGV2LnRyYW5zZm9ybTspXHJcbiogICAgIH0pO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuICogV2hlbiB0aGUgZ3JvdXAgZHJhZyBmaW5pc2hlcywgdGhlIGBkcmFnR3JvdXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkRyYWdnYWJsZVxyXG4gKiBAZXZlbnQgZHJhZ0dyb3VwRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuRHJhZ2dhYmxlLk9uRHJhZ0dyb3VwRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgZHJhZ0dyb3VwRW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiAqICAgICBkcmFnZ2FibGU6IHRydWVcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwiZHJhZ0dyb3VwRW5kXCIsICh7IHRhcmdldHMsIGlzRHJhZyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uRHJhZ0dyb3VwRW5kXCIsIHRhcmdldHMsIGlzRHJhZyk7XHJcbiAqIH0pO1xyXG4gKi9cblxuZnVuY3Rpb24gZ2V0Rml4ZWREaXJlY3Rpb25JbmZvKHN0YXJ0UG9zaXRpb25zLCBmaXhlZERpcmVjdGlvbikge1xyXG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBnZXRQb3NCeURpcmVjdGlvbihzdGFydFBvc2l0aW9ucywgZml4ZWREaXJlY3Rpb24pO1xyXG4gICAgdmFyIGZpeGVkT2Zmc2V0ID0gWzAsIDBdO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaXhlZFBvc2l0aW9uOiBmaXhlZFBvc2l0aW9uLFxyXG4gICAgICAgIGZpeGVkRGlyZWN0aW9uOiBmaXhlZERpcmVjdGlvbixcclxuICAgICAgICBmaXhlZE9mZnNldDogZml4ZWRPZmZzZXQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldE9mZnNldEZpeGVkRGlyZWN0aW9uSW5mbyhzdGF0ZSwgZml4ZWREaXJlY3Rpb24pIHtcclxuICAgIC8vIGZvciBzdGFydFxyXG4gICAgdmFyIGFsbE1hdHJpeCA9IHN0YXRlLmFsbE1hdHJpeCwgaXMzZCA9IHN0YXRlLmlzM2QsIHdpZHRoID0gc3RhdGUud2lkdGgsIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcclxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgdmFyIG5leHRGaXhlZE9mZnNldCA9IFtcclxuICAgICAgICB3aWR0aCAvIDIgKiAoMSArIGZpeGVkRGlyZWN0aW9uWzBdKSxcclxuICAgICAgICBoZWlnaHQgLyAyICogKDEgKyBmaXhlZERpcmVjdGlvblsxXSksXHJcbiAgICBdO1xyXG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIG5leHRGaXhlZE9mZnNldCwgbik7XHJcbiAgICB2YXIgZml4ZWRPZmZzZXQgPSBbMCwgMF07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpeGVkUG9zaXRpb246IGZpeGVkUG9zaXRpb24sXHJcbiAgICAgICAgZml4ZWREaXJlY3Rpb246IGZpeGVkRGlyZWN0aW9uLFxyXG4gICAgICAgIGZpeGVkT2Zmc2V0OiBmaXhlZE9mZnNldCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0T2Zmc2V0Rml4ZWRQb3NpdGlvbkluZm8oc3RhdGUsIG9mZnNldEZpeGVkUG9zaXRpb24pIHtcclxuICAgIC8vIGZvciBzdGFydFxyXG4gICAgdmFyIGFsbE1hdHJpeCA9IHN0YXRlLmFsbE1hdHJpeCwgaXMzZCA9IHN0YXRlLmlzM2QsIHdpZHRoID0gc3RhdGUud2lkdGgsIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcclxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgdmFyIGZpeGVkRGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uQnlQb3Mob2Zmc2V0Rml4ZWRQb3NpdGlvbiwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB2YXIgbmV4dEZpeGVkUG9zaXRpb24gPSBjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIG9mZnNldEZpeGVkUG9zaXRpb24sIG4pO1xyXG4gICAgdmFyIGZpeGVkT2Zmc2V0ID0gW1xyXG4gICAgICAgIHdpZHRoID8gMCA6IG9mZnNldEZpeGVkUG9zaXRpb25bMF0sXHJcbiAgICAgICAgaGVpZ2h0ID8gMCA6IG9mZnNldEZpeGVkUG9zaXRpb25bMV0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaXhlZFBvc2l0aW9uOiBuZXh0Rml4ZWRQb3NpdGlvbixcclxuICAgICAgICBmaXhlZERpcmVjdGlvbjogZml4ZWREaXJlY3Rpb24sXHJcbiAgICAgICAgZml4ZWRPZmZzZXQ6IGZpeGVkT2Zmc2V0LFxyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogQG5hbWVzcGFjZSBSZXNpemFibGVcclxuICogQG1lbWJlcm9mIE1vdmVhYmxlXHJcbiAqIEBkZXNjcmlwdGlvbiBSZXNpemFibGUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRhcmdldCdzIHdpZHRoIGFuZCBoZWlnaHQgY2FuIGJlIGluY3JlYXNlZCBvciBkZWNyZWFzZWQuXHJcbiAqL1xyXG52YXIgZGlyZWN0aW9uQ29uZGl0aW9uJDIgPSBnZXREaXJlY3Rpb25Db25kaXRpb24oXCJyZXNpemFibGVcIik7XHJcbnZhciBSZXNpemFibGUgPSB7XHJcbiAgICBuYW1lOiBcInJlc2l6YWJsZVwiLFxyXG4gICAgYWJsZUdyb3VwOiBcInNpemVcIixcclxuICAgIGNhblBpbmNoOiB0cnVlLFxyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcInJlc2l6YWJsZVwiLFxyXG4gICAgICAgIFwidGhyb3R0bGVSZXNpemVcIixcclxuICAgICAgICBcInJlbmRlckRpcmVjdGlvbnNcIixcclxuICAgICAgICBcImRpc3BsYXlBcm91bmRDb250cm9sc1wiLFxyXG4gICAgICAgIFwia2VlcFJhdGlvXCIsXHJcbiAgICAgICAgXCJyZXNpemVGb3JtYXRcIixcclxuICAgICAgICBcImtlZXBSYXRpb0ZpbmFsbHlcIixcclxuICAgICAgICBcImVkZ2VcIixcclxuICAgICAgICBcImNoZWNrUmVzaXphYmxlRXJyb3JcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcInJlc2l6ZVN0YXJ0XCIsXHJcbiAgICAgICAgXCJiZWZvcmVSZXNpemVcIixcclxuICAgICAgICBcInJlc2l6ZVwiLFxyXG4gICAgICAgIFwicmVzaXplRW5kXCIsXHJcbiAgICAgICAgXCJyZXNpemVHcm91cFN0YXJ0XCIsXHJcbiAgICAgICAgXCJiZWZvcmVSZXNpemVHcm91cFwiLFxyXG4gICAgICAgIFwicmVzaXplR3JvdXBcIixcclxuICAgICAgICBcInJlc2l6ZUdyb3VwRW5kXCIsXHJcbiAgICBdLFxyXG4gICAgcmVuZGVyOiBnZXRSZW5kZXJEaXJlY3Rpb25zKFwicmVzaXphYmxlXCIpLFxyXG4gICAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGRpcmVjdGlvbkNvbmRpdGlvbiQyLFxyXG4gICAgdmlld0NsYXNzTmFtZTogZ2V0RGlyZWN0aW9uVmlld0NsYXNzTmFtZShcInJlc2l6YWJsZVwiKSxcclxuICAgIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudCwgaXNQaW5jaCA9IGUuaXNQaW5jaCwgaXNHcm91cCA9IGUuaXNHcm91cCwgcGFyZW50RGlyZWN0aW9uID0gZS5wYXJlbnREaXJlY3Rpb24sIHBhcmVudEdlc3RvID0gZS5wYXJlbnRHZXN0bywgZGF0YXMgPSBlLmRhdGFzLCBwYXJlbnRGaXhlZERpcmVjdGlvbiA9IGUucGFyZW50Rml4ZWREaXJlY3Rpb24sIHBhcmVudEV2ZW50ID0gZS5wYXJlbnRFdmVudDtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZ2V0VG90YWxEaXJlY3Rpb24ocGFyZW50RGlyZWN0aW9uLCBpc1BpbmNoLCBpbnB1dEV2ZW50LCBkYXRhcyk7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldCwgd2lkdGggPSBzdGF0ZS53aWR0aCwgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0LCBnZXN0b3MgPSBzdGF0ZS5nZXN0b3M7XHJcbiAgICAgICAgaWYgKCFkaXJlY3Rpb24gfHwgIXRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZXN0b3MucmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2VzdG9zLnJlc2l6YWJsZSA9IHBhcmVudEdlc3RvIHx8IG1vdmVhYmxlLmNvbnRyb2xHZXN0bztcclxuICAgICAgICAhaXNQaW5jaCAmJiBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIGRhdGFzLmRhdGFzID0ge307XHJcbiAgICAgICAgZGF0YXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGggPSB3aWR0aDtcclxuICAgICAgICBkYXRhcy5zdGFydE9mZnNldEhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBkYXRhcy5wcmV2V2lkdGggPSAwO1xyXG4gICAgICAgIGRhdGFzLnByZXZIZWlnaHQgPSAwO1xyXG4gICAgICAgIGRhdGFzLm1pblNpemUgPSBbMCwgMF07XHJcbiAgICAgICAgZGF0YXMuc3RhcnRXaWR0aCA9IHN0YXRlLmlubGluZUNTU1dpZHRoIHx8IHN0YXRlLmNzc1dpZHRoO1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0SGVpZ2h0ID0gc3RhdGUuaW5saW5lQ1NTSGVpZ2h0IHx8IHN0YXRlLmNzc0hlaWdodDtcclxuICAgICAgICBkYXRhcy5tYXhTaXplID0gW0luZmluaXR5LCBJbmZpbml0eV07XHJcbiAgICAgICAgaWYgKCFpc0dyb3VwKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLm1pblNpemUgPSBbXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5taW5PZmZzZXRXaWR0aCxcclxuICAgICAgICAgICAgICAgIHN0YXRlLm1pbk9mZnNldEhlaWdodCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgZGF0YXMubWF4U2l6ZSA9IFtcclxuICAgICAgICAgICAgICAgIHN0YXRlLm1heE9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgc3RhdGUubWF4T2Zmc2V0SGVpZ2h0LFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gbW92ZWFibGUucHJvcHMudHJhbnNmb3JtT3JpZ2luIHx8IFwiJSAlXCI7XHJcbiAgICAgICAgZGF0YXMudHJhbnNmb3JtT3JpZ2luID0gdHJhbnNmb3JtT3JpZ2luICYmIGlzU3RyaW5nKHRyYW5zZm9ybU9yaWdpbilcclxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1PcmlnaW4uc3BsaXQoXCIgXCIpXHJcbiAgICAgICAgICAgIDogdHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0T2Zmc2V0TWF0cml4ID0gc3RhdGUub2Zmc2V0TWF0cml4O1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0VHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgICAgIGRhdGFzLmlzV2lkdGggPSAoX2EgPSBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUucGFyZW50SXNXaWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKCghZGlyZWN0aW9uWzBdICYmICFkaXJlY3Rpb25bMV0pIHx8IGRpcmVjdGlvblswXSB8fCAhZGlyZWN0aW9uWzFdKTtcclxuICAgICAgICBmdW5jdGlvbiBzZXRSYXRpbyhyYXRpbykge1xyXG4gICAgICAgICAgICBkYXRhcy5yYXRpbyA9IHJhdGlvICYmIGlzRmluaXRlKHJhdGlvKSA/IHJhdGlvIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMuc3RhcnRQb3NpdGlvbnMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSk7XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0Rml4ZWREaXJlY3Rpb24oZml4ZWREaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdldEZpeGVkRGlyZWN0aW9uSW5mbyhkYXRhcy5zdGFydFBvc2l0aW9ucywgZml4ZWREaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBkYXRhcy5maXhlZERpcmVjdGlvbiA9IHJlc3VsdC5maXhlZERpcmVjdGlvbjtcclxuICAgICAgICAgICAgZGF0YXMuZml4ZWRQb3NpdGlvbiA9IHJlc3VsdC5maXhlZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBkYXRhcy5maXhlZE9mZnNldCA9IHJlc3VsdC5maXhlZE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0Rml4ZWRQb3NpdGlvbihmaXhlZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZXRPZmZzZXRGaXhlZFBvc2l0aW9uSW5mbyhtb3ZlYWJsZS5zdGF0ZSwgZml4ZWRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkRGlyZWN0aW9uID0gcmVzdWx0LmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBkYXRhcy5maXhlZFBvc2l0aW9uID0gcmVzdWx0LmZpeGVkUG9zaXRpb247XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkT2Zmc2V0ID0gcmVzdWx0LmZpeGVkT2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBzZXRNaW4obWluU2l6ZSkge1xyXG4gICAgICAgICAgICBkYXRhcy5taW5TaXplID0gW1xyXG4gICAgICAgICAgICAgICAgY29udmVydFVuaXRTaXplKFwiXCIuY29uY2F0KG1pblNpemVbMF0pLCAwKSB8fCAwLFxyXG4gICAgICAgICAgICAgICAgY29udmVydFVuaXRTaXplKFwiXCIuY29uY2F0KG1pblNpemVbMV0pLCAwKSB8fCAwLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBzZXRNYXgobWF4U2l6ZSkge1xyXG4gICAgICAgICAgICB2YXIgbmV4dE1heFNpemUgPSBbXHJcbiAgICAgICAgICAgICAgICBtYXhTaXplWzBdIHx8IEluZmluaXR5LFxyXG4gICAgICAgICAgICAgICAgbWF4U2l6ZVsxXSB8fCBJbmZpbml0eSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgaWYgKCFpc051bWJlcihuZXh0TWF4U2l6ZVswXSkgfHwgaXNGaW5pdGUobmV4dE1heFNpemVbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0TWF4U2l6ZVswXSA9IGNvbnZlcnRVbml0U2l6ZShcIlwiLmNvbmNhdChuZXh0TWF4U2l6ZVswXSksIDApIHx8IEluZmluaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIobmV4dE1heFNpemVbMV0pIHx8IGlzRmluaXRlKG5leHRNYXhTaXplWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgbmV4dE1heFNpemVbMV0gPSBjb252ZXJ0VW5pdFNpemUoXCJcIi5jb25jYXQobmV4dE1heFNpemVbMV0pLCAwKSB8fCBJbmZpbml0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRhcy5tYXhTaXplID0gbmV4dE1heFNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFJhdGlvKHdpZHRoIC8gaGVpZ2h0KTtcclxuICAgICAgICBzZXRGaXhlZERpcmVjdGlvbihwYXJlbnRGaXhlZERpcmVjdGlvbiB8fCBbLWRpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV0pO1xyXG4gICAgICAgIGRhdGFzLnNldEZpeGVkRGlyZWN0aW9uID0gc2V0Rml4ZWREaXJlY3Rpb247XHJcbiAgICAgICAgZGF0YXMuc2V0Rml4ZWRQb3NpdGlvbiA9IHNldEZpeGVkUG9zaXRpb247XHJcbiAgICAgICAgZGF0YXMuc2V0TWluID0gc2V0TWluO1xyXG4gICAgICAgIGRhdGFzLnNldE1heCA9IHNldE1heDtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcclxuICAgICAgICAgICAgc3RhcnRSYXRpbzogZGF0YXMucmF0aW8sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBzdGFydFdpZHRoID0gX2JbMF0sIHN0YXJ0SGVpZ2h0ID0gX2JbMV07XHJcbiAgICAgICAgICAgICAgICBkYXRhcy5zdGFydFdpZHRoID0gc3RhcnRXaWR0aDtcclxuICAgICAgICAgICAgICAgIGRhdGFzLnN0YXJ0SGVpZ2h0ID0gc3RhcnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldE1pbjogc2V0TWluLFxyXG4gICAgICAgICAgICBzZXRNYXg6IHNldE1heCxcclxuICAgICAgICAgICAgc2V0UmF0aW86IHNldFJhdGlvLFxyXG4gICAgICAgICAgICBzZXRGaXhlZERpcmVjdGlvbjogc2V0Rml4ZWREaXJlY3Rpb24sXHJcbiAgICAgICAgICAgIHNldEZpeGVkUG9zaXRpb246IHNldEZpeGVkUG9zaXRpb24sXHJcbiAgICAgICAgICAgIHNldE9yaWdpbjogZnVuY3Rpb24gKG9yaWdpbikge1xyXG4gICAgICAgICAgICAgICAgZGF0YXMudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IERyYWdnYWJsZS5kcmFnU3RhcnQobW92ZWFibGUsIG5ldyBDdXN0b21HZXN0bygpLmRyYWdTdGFydChbMCwgMF0sIGUpKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyZW50RXZlbnQgfHwgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplU3RhcnRcIiwgcGFyYW1zKTtcclxuICAgICAgICBkYXRhcy5zdGFydEZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb247XHJcbiAgICAgICAgZGF0YXMuc3RhcnRGaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcclxuICAgICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBkYXRhcy5pc1Jlc2l6ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGFzLmlzUmVzaXplID8gcGFyYW1zIDogZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBwYXJlbnRGbGFnID0gZS5wYXJlbnRGbGFnLCBpc1BpbmNoID0gZS5pc1BpbmNoLCBwYXJlbnRLZWVwUmF0aW8gPSBlLnBhcmVudEtlZXBSYXRpbywgZHJhZ0NsaWVudCA9IGUuZHJhZ0NsaWVudCwgcGFyZW50RGlzdCA9IGUucGFyZW50RGlzdCwgdXNlU25hcCA9IGUudXNlU25hcCwgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3QsIGlzR3JvdXAgPSBlLmlzR3JvdXAsIHBhcmVudEV2ZW50ID0gZS5wYXJlbnRFdmVudCwgcmVzb2x2ZU1hdHJpeCA9IGUucmVzb2x2ZU1hdHJpeDtcclxuICAgICAgICB2YXIgaXNSZXNpemUgPSBkYXRhcy5pc1Jlc2l6ZSwgdHJhbnNmb3JtT3JpZ2luID0gZGF0YXMudHJhbnNmb3JtT3JpZ2luLCBzdGFydFdpZHRoID0gZGF0YXMuc3RhcnRXaWR0aCwgc3RhcnRIZWlnaHQgPSBkYXRhcy5zdGFydEhlaWdodCwgcHJldldpZHRoID0gZGF0YXMucHJldldpZHRoLCBwcmV2SGVpZ2h0ID0gZGF0YXMucHJldkhlaWdodCwgbWluU2l6ZSA9IGRhdGFzLm1pblNpemUsIG1heFNpemUgPSBkYXRhcy5tYXhTaXplLCByYXRpbyA9IGRhdGFzLnJhdGlvLCBzdGFydE9mZnNldFdpZHRoID0gZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCwgc3RhcnRPZmZzZXRIZWlnaHQgPSBkYXRhcy5zdGFydE9mZnNldEhlaWdodCwgaXNXaWR0aCA9IGRhdGFzLmlzV2lkdGg7XHJcbiAgICAgICAgaWYgKCFpc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXNvbHZlTWF0cml4KSB7XHJcbiAgICAgICAgICAgIHZhciBpczNkID0gbW92ZWFibGUuc3RhdGUuaXMzZDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0TWF0cml4ID0gZGF0YXMuc3RhcnRPZmZzZXRNYXRyaXgsIHN0YXJ0VHJhbnNmb3JtT3JpZ2luID0gZGF0YXMuc3RhcnRUcmFuc2Zvcm1PcmlnaW47XHJcbiAgICAgICAgICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWF0cml4ID0gcGFyc2VNYXQoZ2V0TmV4dFRyYW5zZm9ybXMoZSkpO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0TiA9IE1hdGguc3FydCh0YXJnZXRNYXRyaXgubGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKG4gIT09IHRhcmdldE4pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldE1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24odGFyZ2V0TWF0cml4LCB0YXJnZXROLCBuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV4dEFsbE1hdHJpeCA9IGdldE5leHRNYXRyaXgoc3RhcnRPZmZzZXRNYXRyaXgsIHRhcmdldE1hdHJpeCwgc3RhcnRUcmFuc2Zvcm1PcmlnaW4sIG4pO1xyXG4gICAgICAgICAgICB2YXIgcG9zZXMgPSBjYWxjdWxhdGVQb3NlcyhuZXh0QWxsTWF0cml4LCBzdGFydE9mZnNldFdpZHRoLCBzdGFydE9mZnNldEhlaWdodCwgbik7XHJcbiAgICAgICAgICAgIGRhdGFzLnN0YXJ0UG9zaXRpb25zID0gcG9zZXM7XHJcbiAgICAgICAgICAgIGRhdGFzLm5leHRUYXJnZXRNYXRyaXggPSB0YXJnZXRNYXRyaXg7XHJcbiAgICAgICAgICAgIGRhdGFzLm5leHRBbGxNYXRyaXggPSBuZXh0QWxsTWF0cml4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvcHMgPSBnZXRQcm9wcyhtb3ZlYWJsZS5wcm9wcywgXCJyZXNpemFibGVcIik7XHJcbiAgICAgICAgdmFyIHJlc2l6ZUZvcm1hdCA9IHByb3BzLnJlc2l6ZUZvcm1hdCwgX2IgPSBwcm9wcy50aHJvdHRsZVJlc2l6ZSwgdGhyb3R0bGVSZXNpemUgPSBfYiA9PT0gdm9pZCAwID8gcGFyZW50RmxhZyA/IDAgOiAxIDogX2IsIHBhcmVudE1vdmVhYmxlID0gcHJvcHMucGFyZW50TW92ZWFibGUsIGtlZXBSYXRpb0ZpbmFsbHkgPSBwcm9wcy5rZWVwUmF0aW9GaW5hbGx5O1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkYXRhcy5kaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIHNpemVEaXJlY3Rpb24gPSBkaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIGRpc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgdmFyIGRpc3RIZWlnaHQgPSAwO1xyXG4gICAgICAgIGlmICghZGlyZWN0aW9uWzBdICYmICFkaXJlY3Rpb25bMV0pIHtcclxuICAgICAgICAgICAgc2l6ZURpcmVjdGlvbiA9IFsxLCAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGtlZXBSYXRpbyA9IChyYXRpbyAmJiAocGFyZW50S2VlcFJhdGlvICE9IG51bGwgPyBwYXJlbnRLZWVwUmF0aW8gOiBwcm9wcy5rZWVwUmF0aW8pKSB8fCBmYWxzZTtcclxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0Qm91bmRpbmdTaXplKCkge1xyXG4gICAgICAgICAgICB2YXIgZml4ZWREaXJlY3Rpb24gPSBkYXRhcy5maXhlZERpcmVjdGlvbjtcclxuICAgICAgICAgICAgdmFyIG5leHRTaXplID0gZ2V0T2Zmc2V0U2l6ZURpc3Qoc2l6ZURpcmVjdGlvbiwga2VlcFJhdGlvLCBkYXRhcywgZSk7XHJcbiAgICAgICAgICAgIGRpc3RXaWR0aCA9IG5leHRTaXplLmRpc3RXaWR0aDtcclxuICAgICAgICAgICAgZGlzdEhlaWdodCA9IG5leHRTaXplLmRpc3RIZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBuZXh0V2lkdGggPSAoc2l6ZURpcmVjdGlvblswXSAtIGZpeGVkRGlyZWN0aW9uWzBdKSB8fCBrZWVwUmF0aW9cclxuICAgICAgICAgICAgICAgID8gTWF0aC5tYXgoc3RhcnRPZmZzZXRXaWR0aCArIGRpc3RXaWR0aCwgVElOWV9OVU0pIDogc3RhcnRPZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgdmFyIG5leHRIZWlnaHQgPSAoc2l6ZURpcmVjdGlvblsxXSAtIGZpeGVkRGlyZWN0aW9uWzFdKSB8fCBrZWVwUmF0aW9cclxuICAgICAgICAgICAgICAgID8gTWF0aC5tYXgoc3RhcnRPZmZzZXRIZWlnaHQgKyBkaXN0SGVpZ2h0LCBUSU5ZX05VTSkgOiBzdGFydE9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgaWYgKGtlZXBSYXRpbyAmJiBzdGFydE9mZnNldFdpZHRoICYmIHN0YXJ0T2Zmc2V0SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzdGFydE9mZnNldFdpZHRoIDogc3RhcnRPZmZzZXRIZWlnaHQgPSBuZXh0V2lkdGggOiBuZXh0SGVpZ2h0XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRIZWlnaHQgPSBuZXh0V2lkdGggLyByYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRXaWR0aCA9IG5leHRIZWlnaHQgKiByYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW25leHRXaWR0aCwgbmV4dEhlaWdodF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYyA9IF9fcmVhZChnZXROZXh0Qm91bmRpbmdTaXplKCksIDIpLCBib3VuZGluZ1dpZHRoID0gX2NbMF0sIGJvdW5kaW5nSGVpZ2h0ID0gX2NbMV07XHJcbiAgICAgICAgaWYgKCFwYXJlbnRFdmVudCkge1xyXG4gICAgICAgICAgICBkYXRhcy5zZXRGaXhlZERpcmVjdGlvbihkYXRhcy5maXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlc2l6ZVwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgICAgICBzdGFydEZpeGVkRGlyZWN0aW9uOiBkYXRhcy5zdGFydEZpeGVkRGlyZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRGaXhlZFBvc2l0aW9uOiBkYXRhcy5zdGFydEZpeGVkUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICBzZXRGaXhlZERpcmVjdGlvbjogZnVuY3Rpb24gKG5leHRGaXhlZERpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhcy5zZXRGaXhlZERpcmVjdGlvbihuZXh0Rml4ZWREaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hID0gX19yZWFkKGdldE5leHRCb3VuZGluZ1NpemUoKSwgMiksIGJvdW5kaW5nV2lkdGggPSBfYVswXSwgYm91bmRpbmdIZWlnaHQgPSBfYVsxXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2JvdW5kaW5nV2lkdGgsIGJvdW5kaW5nSGVpZ2h0XTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXRGaXhlZFBvc2l0aW9uOiBmdW5jdGlvbiAobmV4dEZpeGVkUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXMuc2V0Rml4ZWRQb3NpdGlvbihuZXh0Rml4ZWRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBfX3JlYWQoZ2V0TmV4dEJvdW5kaW5nU2l6ZSgpLCAyKSwgYm91bmRpbmdXaWR0aCA9IF9hWzBdLCBib3VuZGluZ0hlaWdodCA9IF9hWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYm91bmRpbmdXaWR0aCwgYm91bmRpbmdIZWlnaHRdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nV2lkdGg6IGJvdW5kaW5nV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ0hlaWdodDogYm91bmRpbmdIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBzZXRTaXplOiBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IF9fcmVhZChzaXplLCAyKSwgYm91bmRpbmdXaWR0aCA9IF9hWzBdLCBib3VuZGluZ0hlaWdodCA9IF9hWzFdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSwgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGRyYWdDbGllbnQ7XHJcbiAgICAgICAgaWYgKCFkcmFnQ2xpZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghcGFyZW50RmxhZyAmJiBpc1BpbmNoKSB7XHJcbiAgICAgICAgICAgICAgICBmaXhlZFBvc2l0aW9uID0gZ2V0QWJzb2x1dGVQb3NpdGlvbihtb3ZlYWJsZSwgWzAsIDBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzbmFwRGlzdCA9IFswLCAwXTtcclxuICAgICAgICBpZiAoIWlzUGluY2gpIHtcclxuICAgICAgICAgICAgc25hcERpc3QgPSBjaGVja1NuYXBSZXNpemUobW92ZWFibGUsIGJvdW5kaW5nV2lkdGgsIGJvdW5kaW5nSGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sICF1c2VTbmFwICYmIGlzUmVxdWVzdCwgZGF0YXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyZW50RGlzdCkge1xyXG4gICAgICAgICAgICAhcGFyZW50RGlzdFswXSAmJiAoc25hcERpc3RbMF0gPSAwKTtcclxuICAgICAgICAgICAgIXBhcmVudERpc3RbMV0gJiYgKHNuYXBEaXN0WzFdID0gMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVTaXplKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGlmIChyZXNpemVGb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgIF9hID0gX19yZWFkKHJlc2l6ZUZvcm1hdChbYm91bmRpbmdXaWR0aCwgYm91bmRpbmdIZWlnaHRdKSwgMiksIGJvdW5kaW5nV2lkdGggPSBfYVswXSwgYm91bmRpbmdIZWlnaHQgPSBfYVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBib3VuZGluZ1dpZHRoID0gdGhyb3R0bGUoYm91bmRpbmdXaWR0aCwgdGhyb3R0bGVSZXNpemUpO1xyXG4gICAgICAgICAgICBib3VuZGluZ0hlaWdodCA9IHRocm90dGxlKGJvdW5kaW5nSGVpZ2h0LCB0aHJvdHRsZVJlc2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZWVwUmF0aW8pIHtcclxuICAgICAgICAgICAgaWYgKHNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSAmJiBzbmFwRGlzdFswXSAmJiBzbmFwRGlzdFsxXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFicyhzbmFwRGlzdFswXSkgPiBhYnMoc25hcERpc3RbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc25hcERpc3RbMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc25hcERpc3RbMF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc05vU25hcCA9ICFzbmFwRGlzdFswXSAmJiAhc25hcERpc3RbMV07XHJcbiAgICAgICAgICAgIGlmIChpc05vU25hcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlLWNvbXB1dGUgYmVmb3JlIG1haW50YWluaW5nIHRoZSByYXRpb1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVNpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHNpemVEaXJlY3Rpb25bMF0gJiYgIXNpemVEaXJlY3Rpb25bMV0pXHJcbiAgICAgICAgICAgICAgICB8fCAoc25hcERpc3RbMF0gJiYgIXNuYXBEaXN0WzFdKVxyXG4gICAgICAgICAgICAgICAgfHwgKGlzTm9TbmFwICYmIGlzV2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1dpZHRoICs9IHNuYXBEaXN0WzBdO1xyXG4gICAgICAgICAgICAgICAgYm91bmRpbmdIZWlnaHQgPSBib3VuZGluZ1dpZHRoIC8gcmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKCFzaXplRGlyZWN0aW9uWzBdICYmIHNpemVEaXJlY3Rpb25bMV0pXHJcbiAgICAgICAgICAgICAgICB8fCAoIXNuYXBEaXN0WzBdICYmIHNuYXBEaXN0WzFdKVxyXG4gICAgICAgICAgICAgICAgfHwgKGlzTm9TbmFwICYmICFpc1dpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgYm91bmRpbmdIZWlnaHQgKz0gc25hcERpc3RbMV07XHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1dpZHRoID0gYm91bmRpbmdIZWlnaHQgKiByYXRpbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYm91bmRpbmdXaWR0aCArPSBzbmFwRGlzdFswXTtcclxuICAgICAgICAgICAgYm91bmRpbmdIZWlnaHQgKz0gc25hcERpc3RbMV07XHJcbiAgICAgICAgICAgIGJvdW5kaW5nV2lkdGggPSBNYXRoLm1heCgwLCBib3VuZGluZ1dpZHRoKTtcclxuICAgICAgICAgICAgYm91bmRpbmdIZWlnaHQgPSBNYXRoLm1heCgwLCBib3VuZGluZ0hlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9hID0gX19yZWFkKGNhbGN1bGF0ZUJvdW5kU2l6ZShbYm91bmRpbmdXaWR0aCwgYm91bmRpbmdIZWlnaHRdLCBtaW5TaXplLCBtYXhTaXplLCBrZWVwUmF0aW8gPyByYXRpbyA6IGZhbHNlKSwgMiksIGJvdW5kaW5nV2lkdGggPSBfYVswXSwgYm91bmRpbmdIZWlnaHQgPSBfYVsxXTtcclxuICAgICAgICBjb21wdXRlU2l6ZSgpO1xyXG4gICAgICAgIGlmIChrZWVwUmF0aW8gJiYgKGlzR3JvdXAgfHwga2VlcFJhdGlvRmluYWxseSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nSGVpZ2h0ID0gYm91bmRpbmdXaWR0aCAvIHJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYm91bmRpbmdXaWR0aCA9IGJvdW5kaW5nSGVpZ2h0ICogcmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzdFdpZHRoID0gYm91bmRpbmdXaWR0aCAtIHN0YXJ0T2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgZGlzdEhlaWdodCA9IGJvdW5kaW5nSGVpZ2h0IC0gc3RhcnRPZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgdmFyIGRlbHRhID0gW2Rpc3RXaWR0aCAtIHByZXZXaWR0aCwgZGlzdEhlaWdodCAtIHByZXZIZWlnaHRdO1xyXG4gICAgICAgIGRhdGFzLnByZXZXaWR0aCA9IGRpc3RXaWR0aDtcclxuICAgICAgICBkYXRhcy5wcmV2SGVpZ2h0ID0gZGlzdEhlaWdodDtcclxuICAgICAgICB2YXIgaW52ZXJzZURlbHRhID0gZ2V0UmVzaXplRGlzdChtb3ZlYWJsZSwgYm91bmRpbmdXaWR0aCwgYm91bmRpbmdIZWlnaHQsIGZpeGVkUG9zaXRpb24sIHRyYW5zZm9ybU9yaWdpbiwgZGF0YXMpO1xyXG4gICAgICAgIGlmICghcGFyZW50TW92ZWFibGUgJiYgZGVsdGEuZXZlcnkoZnVuY3Rpb24gKG51bSkgeyByZXR1cm4gIW51bTsgfSkgJiYgaW52ZXJzZURlbHRhLmV2ZXJ5KGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuICFudW07IH0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRyYWcgPSBEcmFnZ2FibGUuZHJhZyhtb3ZlYWJsZSwgc2V0Q3VzdG9tRHJhZyhlLCBtb3ZlYWJsZS5zdGF0ZSwgaW52ZXJzZURlbHRhLCAhIWlzUGluY2gsIGZhbHNlLCBcImRyYWdnYWJsZVwiKSk7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGRyYWcudHJhbnNmb3JtO1xyXG4gICAgICAgIHZhciBuZXh0V2lkdGggPSBzdGFydFdpZHRoICsgZGlzdFdpZHRoO1xyXG4gICAgICAgIHZhciBuZXh0SGVpZ2h0ID0gc3RhcnRIZWlnaHQgKyBkaXN0SGVpZ2h0O1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7IHdpZHRoOiBuZXh0V2lkdGgsIGhlaWdodDogbmV4dEhlaWdodCwgb2Zmc2V0V2lkdGg6IE1hdGgucm91bmQoYm91bmRpbmdXaWR0aCksIG9mZnNldEhlaWdodDogTWF0aC5yb3VuZChib3VuZGluZ0hlaWdodCksIHN0YXJ0UmF0aW86IHJhdGlvLCBib3VuZGluZ1dpZHRoOiBib3VuZGluZ1dpZHRoLCBib3VuZGluZ0hlaWdodDogYm91bmRpbmdIZWlnaHQsIGRpcmVjdGlvbjogZGlyZWN0aW9uLCBkaXN0OiBbZGlzdFdpZHRoLCBkaXN0SGVpZ2h0XSwgZGVsdGE6IGRlbHRhLCBpc1BpbmNoOiAhIWlzUGluY2gsIGRyYWc6IGRyYWcgfSwgZmlsbEFmdGVyVHJhbnNmb3JtKHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdChuZXh0V2lkdGgsIFwicHhcIiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KG5leHRIZWlnaHQsIFwicHhcIiksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxyXG4gICAgICAgIH0sIGRyYWcsIGUpKSk7XHJcbiAgICAgICAgIXBhcmVudEV2ZW50ICYmIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlc2l6ZVwiLCBwYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xBZnRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICB2YXIgaXNSZXNpemUgPSBkYXRhcy5pc1Jlc2l6ZSwgc3RhcnRPZmZzZXRXaWR0aCA9IGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGgsIHN0YXJ0T2Zmc2V0SGVpZ2h0ID0gZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQsIHByZXZXaWR0aCA9IGRhdGFzLnByZXZXaWR0aCwgcHJldkhlaWdodCA9IGRhdGFzLnByZXZIZWlnaHQ7XHJcbiAgICAgICAgaWYgKCFpc1Jlc2l6ZSB8fCBtb3ZlYWJsZS5wcm9wcy5jaGVja1Jlc2l6YWJsZUVycm9yID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGVycm9yV2lkdGggPSB3aWR0aCAtIChzdGFydE9mZnNldFdpZHRoICsgcHJldldpZHRoKTtcclxuICAgICAgICB2YXIgZXJyb3JIZWlnaHQgPSBoZWlnaHQgLSAoc3RhcnRPZmZzZXRIZWlnaHQgKyBwcmV2SGVpZ2h0KTtcclxuICAgICAgICB2YXIgaXNFcnJvcldpZHRoID0gYWJzKGVycm9yV2lkdGgpID4gMztcclxuICAgICAgICB2YXIgaXNFcnJvckhlaWdodCA9IGFicyhlcnJvckhlaWdodCkgPiAzO1xyXG4gICAgICAgIGlmIChpc0Vycm9yV2lkdGgpIHtcclxuICAgICAgICAgICAgZGF0YXMuc3RhcnRXaWR0aCArPSBlcnJvcldpZHRoO1xyXG4gICAgICAgICAgICBkYXRhcy5zdGFydE9mZnNldFdpZHRoICs9IGVycm9yV2lkdGg7XHJcbiAgICAgICAgICAgIGRhdGFzLnByZXZXaWR0aCArPSBlcnJvcldpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNFcnJvckhlaWdodCkge1xyXG4gICAgICAgICAgICBkYXRhcy5zdGFydEhlaWdodCArPSBlcnJvckhlaWdodDtcclxuICAgICAgICAgICAgZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQgKz0gZXJyb3JIZWlnaHQ7XHJcbiAgICAgICAgICAgIGRhdGFzLnByZXZIZWlnaHQgKz0gZXJyb3JIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Vycm9yV2lkdGggfHwgaXNFcnJvckhlaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBwYXJlbnRFdmVudCA9IGUucGFyZW50RXZlbnQ7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFzLmlzUmVzaXplID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KTtcclxuICAgICAgICAhcGFyZW50RXZlbnQgJiYgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplRW5kXCIsIHBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sQ29uZGl0aW9uOiBkaXJlY3Rpb25Db25kaXRpb24kMixcclxuICAgIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgaXNHcm91cDogdHJ1ZSB9KSk7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxFdmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwicmVzaXphYmxlXCIsIGUpO1xyXG4gICAgICAgIHZhciBwYXJlbnRTdGFydE9mZnNldFdpZHRoID0gZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCwgcGFyZW50U3RhcnRPZmZzZXRIZWlnaHQgPSBkYXRhcy5zdGFydE9mZnNldEhlaWdodDtcclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVHcm91cE1pbigpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsTWluU2l6ZSA9IGRhdGFzLm1pblNpemU7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBldi5kYXRhcywgY2hpbGRNaW5TaXplID0gX2EubWluU2l6ZSwgY2hpbGRTdGFydE9mZnNldFdpZHRoID0gX2Euc3RhcnRPZmZzZXRXaWR0aCwgY2hpbGRTdGFydE9mZnNldEhlaWdodCA9IF9hLnN0YXJ0T2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE1pbldpZHRoID0gcGFyZW50U3RhcnRPZmZzZXRXaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICogKGNoaWxkU3RhcnRPZmZzZXRXaWR0aCA/IGNoaWxkTWluU2l6ZVswXSAvIGNoaWxkU3RhcnRPZmZzZXRXaWR0aCA6IDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE1pbkhlaWdodCA9IHBhcmVudFN0YXJ0T2Zmc2V0SGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgKiAoY2hpbGRTdGFydE9mZnNldEhlaWdodCA/IGNoaWxkTWluU2l6ZVsxXSAvIGNoaWxkU3RhcnRPZmZzZXRIZWlnaHQgOiAwKTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWluU2l6ZVswXSA9IE1hdGgubWF4KG9yaWdpbmFsTWluU2l6ZVswXSwgcGFyZW50TWluV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxNaW5TaXplWzFdID0gTWF0aC5tYXgob3JpZ2luYWxNaW5TaXplWzFdLCBwYXJlbnRNaW5IZWlnaHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlR3JvdXBNYXgoKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbE1heFNpemUgPSBkYXRhcy5tYXhTaXplO1xyXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZXYuZGF0YXMsIGNoaWxkTWF4U2l6ZSA9IF9hLm1heFNpemUsIGNoaWxkU3RhcnRPZmZzZXRXaWR0aCA9IF9hLnN0YXJ0T2Zmc2V0V2lkdGgsIGNoaWxkU3RhcnRPZmZzZXRIZWlnaHQgPSBfYS5zdGFydE9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRNYXhXaWR0aCA9IHBhcmVudFN0YXJ0T2Zmc2V0V2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAqIChjaGlsZFN0YXJ0T2Zmc2V0V2lkdGggPyBjaGlsZE1heFNpemVbMF0gLyBjaGlsZFN0YXJ0T2Zmc2V0V2lkdGggOiAwKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRNYXhIZWlnaHQgPSBwYXJlbnRTdGFydE9mZnNldEhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICogKGNoaWxkU3RhcnRPZmZzZXRIZWlnaHQgPyBjaGlsZE1heFNpemVbMV0gLyBjaGlsZFN0YXJ0T2Zmc2V0SGVpZ2h0IDogMCk7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1heFNpemVbMF0gPSBNYXRoLm1pbihvcmlnaW5hbE1heFNpemVbMF0sIHBhcmVudE1heFdpZHRoKTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWF4U2l6ZVsxXSA9IE1hdGgubWluKG9yaWdpbmFsTWF4U2l6ZVsxXSwgcGFyZW50TWF4SGVpZ2h0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbFN0YXJ0XCIsIGUsIGZ1bmN0aW9uIChjaGlsZCwgZXYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0Q2hpbGREaXN0KG1vdmVhYmxlLCBjaGlsZCwgZGF0YXMsIGV2KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB1cGRhdGVHcm91cE1pbigpO1xyXG4gICAgICAgIHVwZGF0ZUdyb3VwTWF4KCk7XHJcbiAgICAgICAgdmFyIHNldEZpeGVkRGlyZWN0aW9uID0gZnVuY3Rpb24gKGZpeGVkRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5zZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldiwgaSkge1xyXG4gICAgICAgICAgICAgICAgZXYuc2V0Rml4ZWREaXJlY3Rpb24oZml4ZWREaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRDaGlsZERpc3QobW92ZWFibGUsIGV2Lm1vdmVhYmxlLCBkYXRhcywgb3JpZ2luYWxFdmVudHNbaV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGRhdGFzLnNldEZpeGVkRGlyZWN0aW9uID0gc2V0Rml4ZWREaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1zKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV2KSwgeyBzZXRNaW46IGZ1bmN0aW9uIChtaW5TaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LnNldE1pbihtaW5TaXplKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlR3JvdXBNaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBzZXRNYXg6IGZ1bmN0aW9uIChtYXhTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LnNldE1heChtYXhTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlR3JvdXBNYXgoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IH0pO1xyXG4gICAgICAgICAgICB9KSwgc2V0Rml4ZWREaXJlY3Rpb246IHNldEZpeGVkRGlyZWN0aW9uLCBzZXRNaW46IGZ1bmN0aW9uIChtaW5TaXplKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2V0TWluKG1pblNpemUpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlR3JvdXBNaW4oKTtcclxuICAgICAgICAgICAgfSwgc2V0TWF4OiBmdW5jdGlvbiAobWF4U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnNldE1heChtYXhTaXplKTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUdyb3VwTWF4KCk7XHJcbiAgICAgICAgICAgIH0gfSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlc2l6ZUdyb3VwU3RhcnRcIiwgbmV4dFBhcmFtcyk7XHJcbiAgICAgICAgZGF0YXMuaXNSZXNpemUgPSByZXN1bHQgIT09IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBkYXRhcy5pc1Jlc2l6ZSA/IHBhcmFtcyA6IGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wcyA9IGdldFByb3BzKG1vdmVhYmxlLnByb3BzLCBcInJlc2l6YWJsZVwiKTtcclxuICAgICAgICBjYXRjaEV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVzaXplXCIsIGZ1bmN0aW9uIChwYXJlbnRFdmVudCkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZXNpemVHcm91cFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyZW50RXZlbnQpLCB7IHRhcmdldHM6IHByb3BzLnRhcmdldHMgfSksIHRydWUpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGlzR3JvdXA6IHRydWUgfSkpO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nV2lkdGggPSBwYXJhbXMuYm91bmRpbmdXaWR0aCwgYm91bmRpbmdIZWlnaHQgPSBwYXJhbXMuYm91bmRpbmdIZWlnaHQsIGRpc3QgPSBwYXJhbXMuZGlzdDtcclxuICAgICAgICB2YXIga2VlcFJhdGlvID0gcHJvcHMua2VlcFJhdGlvO1xyXG4gICAgICAgIHZhciBwYXJlbnRTY2FsZSA9IFtcclxuICAgICAgICAgICAgYm91bmRpbmdXaWR0aCAvIChib3VuZGluZ1dpZHRoIC0gZGlzdFswXSksXHJcbiAgICAgICAgICAgIGJvdW5kaW5nSGVpZ2h0IC8gKGJvdW5kaW5nSGVpZ2h0IC0gZGlzdFsxXSksXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGRhdGFzLmZpeGVkUG9zaXRpb247XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sXCIsIGUsIGZ1bmN0aW9uIChfLCBldikge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoY2FsY3VsYXRlKGNyZWF0ZVJvdGF0ZU1hdHJpeChtb3ZlYWJsZS5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUEksIDMpLCBbXHJcbiAgICAgICAgICAgICAgICBldi5kYXRhcy5vcmlnaW5hbFggKiBwYXJlbnRTY2FsZVswXSxcclxuICAgICAgICAgICAgICAgIGV2LmRhdGFzLm9yaWdpbmFsWSAqIHBhcmVudFNjYWxlWzFdLFxyXG4gICAgICAgICAgICAgICAgMSxcclxuICAgICAgICAgICAgXSwgMyksIDIpLCBjbGllbnRYID0gX2FbMF0sIGNsaWVudFkgPSBfYVsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHsgcGFyZW50RGlzdDogbnVsbCwgcGFyZW50U2NhbGU6IHBhcmVudFNjYWxlLCBkcmFnQ2xpZW50OiBwbHVzKGZpeGVkUG9zaXRpb24sIFtjbGllbnRYLCBjbGllbnRZXSksIHBhcmVudEtlZXBSYXRpbzoga2VlcFJhdGlvIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oeyB0YXJnZXRzOiBwcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50cyB9LCBwYXJhbXMpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlc2l6ZUdyb3VwXCIsIG5leHRQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXh0UGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBpc0RyYWcgPSBlLmlzRHJhZywgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNSZXNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRyYWdDb250cm9sRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xFbmRcIiwgZSk7XHJcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXHJcbiAgICAgICAgICAgIGV2ZW50czogZXZlbnRzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlc2l6ZUdyb3VwRW5kXCIsIG5leHRQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBpc0RyYWc7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlLlJlc2l6YWJsZSNyZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5SZXNpemFibGVSZXF1ZXN0UGFyYW19IGUgLSB0aGUgUmVzaXphYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcclxuICAgICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG5cbiAgICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXHJcbiAgICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcclxuICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0sIHRydWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IG9mZnNldFdpZHRoOiAxMDAsIG9mZnNldEhlaWdodDogMTAwIH0sIHRydWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHJlcXVlc3RTdGFydFxyXG4gICAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyByZXF1ZXN0XHJcbiAgICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcclxuICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBvZmZzZXRXaWR0aDogMTAwLCBvZmZzZXRIZWlnaHQ6IDEwMCB9KTtcclxuICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBvZmZzZXRXaWR0aDogMTEwLCBvZmZzZXRIZWlnaHQ6IDEwMCB9KTtcclxuICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBvZmZzZXRXaWR0aDogMTIwLCBvZmZzZXRIZWlnaHQ6IDEwMCB9KTtcclxuICAgICAqXHJcbiAgICAgKiAvLyByZXF1ZXN0RW5kXHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdEVuZCgpO1xyXG4gICAgICovXHJcbiAgICByZXF1ZXN0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSB7fTtcclxuICAgICAgICB2YXIgZGlzdFdpZHRoID0gMDtcclxuICAgICAgICB2YXIgZGlzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgdmFyIHVzZVNuYXAgPSBmYWxzZTtcclxuICAgICAgICB2YXIgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc0NvbnRyb2w6IHRydWUsXHJcbiAgICAgICAgICAgIHJlcXVlc3RTdGFydDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHVzZVNuYXAgPSBlLnVzZVNuYXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzOiBkYXRhcyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnREaXJlY3Rpb246IGUuZGlyZWN0aW9uIHx8IFsxLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJc1dpZHRoOiAoX2EgPSBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuaG9yaXpvbnRhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB1c2VTbmFwOiB1c2VTbmFwLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcIm9mZnNldFdpZHRoXCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RXaWR0aCA9IGUub2Zmc2V0V2lkdGggLSByZWN0Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJkZWx0YVdpZHRoXCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RXaWR0aCArPSBlLmRlbHRhV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJvZmZzZXRIZWlnaHRcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdEhlaWdodCA9IGUub2Zmc2V0SGVpZ2h0IC0gcmVjdC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImRlbHRhSGVpZ2h0XCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RIZWlnaHQgKz0gZS5kZWx0YUhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXM6IGRhdGFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudERpc3Q6IFtkaXN0V2lkdGgsIGRpc3RIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEtlZXBSYXRpbzogZS5rZWVwUmF0aW8sXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlU25hcDogdXNlU25hcCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGFzOiBkYXRhcywgaXNEcmFnOiB0cnVlLCB1c2VTbmFwOiB1c2VTbmFwIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuZ2VzdG9zLnJlc2l6YWJsZSA9IG51bGw7XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSByZXNpemVkLlxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5SZXNpemFibGUjcmVzaXphYmxlXHJcbiAqIEBkZWZhdWx0IGZhbHNlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgcmVzaXphYmxlOiBmYWxzZSxcclxuICogfSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnJlc2l6YWJsZSA9IHRydWU7XHJcbiAqL1xyXG4vKipcclxuICogdGhyb3R0bGUgb2Ygd2lkdGgsIGhlaWdodCB3aGVuIHJlc2l6ZS4gSWYgdGhyb3R0bGVSZXNpemUgaXMgc2V0IHRvIGxlc3MgdGhhbiAxLCB0aGUgdGFyZ2V0IG1heSBzaGFrZS5cclxuICogQG5hbWUgTW92ZWFibGUuUmVzaXphYmxlI3Rocm90dGxlUmVzaXplXHJcbiAqIEBkZWZhdWx0IDFcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgcmVzaXphYmxlOiB0cnVlLFxyXG4gKiAgIHRocm90dGxlUmVzaXplOiAxLFxyXG4gKiB9KTtcclxuICpcclxuICogbW92ZWFibGUudGhyb3R0bGVSZXNpemUgPSAwO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gcmVzaXplIG9yIHNjYWxlLCBrZWVwcyBhIHJhdGlvIG9mIHRoZSB3aWR0aCwgaGVpZ2h0LlxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5SZXNpemFibGUja2VlcFJhdGlvXHJcbiAqIEBkZWZhdWx0IGZhbHNlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgIHJlc2l6YWJsZTogdHJ1ZSxcclxuICogfSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLmtlZXBSYXRpbyA9IHRydWU7XHJcbiAqL1xyXG4vKipcclxuICogU2V0IGRpcmVjdGlvbnMgdG8gc2hvdyB0aGUgY29udHJvbCBib3guXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJlc2l6YWJsZSNyZW5kZXJEaXJlY3Rpb25zXHJcbiAqIEBkZWZhdWx0IFtcIm5cIiwgXCJud1wiLCBcIm5lXCIsIFwic1wiLCBcInNlXCIsIFwic3dcIiwgXCJlXCIsIFwid1wiXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICByZXNpemFibGU6IHRydWUsXHJcbiAqICAgcmVuZGVyRGlyZWN0aW9uczogW1wiblwiLCBcIm53XCIsIFwibmVcIiwgXCJzXCIsIFwic2VcIiwgXCJzd1wiLCBcImVcIiwgXCJ3XCJdLFxyXG4gKiB9KTtcclxuICpcclxuICogbW92ZWFibGUucmVuZGVyRGlyZWN0aW9ucyA9IFtcIm53XCIsIFwibmVcIiwgXCJzd1wiLCBcInNlXCJdO1xyXG4gKi9cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIHRvIGNvbnZlcnQgc2l6ZSBmb3IgcmVzaXplXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJlc2l6YWJsZSNyZXNpemVGb3JtYXRcclxuICogQGRlZmF1bHQgb25lc2VsZlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICByZXNpemFibGU6IHRydWUsXHJcbiAqICAgcmVzaXplRm9ybWF0OiB2ID0+IHYsXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5yZXNpemVGb3JtYXQgPSAoc2l6ZTogbnVtYmVyW10pID0+IChbTWF0aC50cnVuYyhzaXplWzBdKSwgTWF0aC50cnVuYyhzaXplWzFdKV07XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgcmVzaXplIHN0YXJ0cywgdGhlIHJlc2l6ZVN0YXJ0IGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJlc2l6YWJsZVxyXG4gKiBAZXZlbnQgcmVzaXplU3RhcnRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUuT25SZXNpemVTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcmVzaXplU3RhcnQgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJlc2l6YWJsZTogdHJ1ZSB9KTtcclxuICogbW92ZWFibGUub24oXCJyZXNpemVTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiByZXNpemluZywgYGJlZm9yZVJlc2l6ZWAgaXMgY2FsbGVkIGJlZm9yZSBgcmVzaXplYCBvY2N1cnMuIEluIGBiZWZvcmVSZXNpemVgLCB5b3UgY2FuIGdldCBhbmQgc2V0IHRoZSBwcmUtdmFsdWUgYmVmb3JlIHJlc2l6aW5nLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXHJcbiAqIEBldmVudCBiZWZvcmVSZXNpemVcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUuT25CZWZvcmVSZXNpemV9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBiZWZvcmVSZXNpemVgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByZXNpemFibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwiYmVmb3JlUmVzaXplXCIsICh7IHNldEZpeGVkRGlyZWN0aW9uIH0pID0+IHtcclxuICogICAgIGlmIChzaGlmdEtleSkge1xyXG4gKiAgICAgICAgc2V0Rml4ZWREaXJlY3Rpb24oWzAsIDBdKTtcclxuICogICAgIH1cclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicmVzaXplXCIsICh7IHRhcmdldCwgd2lkdGgsIGhlaWdodCwgZHJhZyB9KSA9PiB7XHJcbiAqICAgICB0YXJnZXQuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XHJcbiAqICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcclxuICogICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBkcmFnLnRyYW5zZm9ybTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiByZXNpemluZywgdGhlIHJlc2l6ZSBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcclxuICogQGV2ZW50IHJlc2l6ZVxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5PblJlc2l6ZX0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcmVzaXplIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByZXNpemFibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicmVzaXplXCIsICh7IHRhcmdldCwgd2lkdGgsIGhlaWdodCB9KSA9PiB7XHJcbiAqICAgICB0YXJnZXQuc3R5bGUud2lkdGggPSBgJHtlLndpZHRofXB4YDtcclxuICogICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBgJHtlLmhlaWdodH1weGA7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gdGhlIHJlc2l6ZSBmaW5pc2hlcywgdGhlIHJlc2l6ZUVuZCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcclxuICogQGV2ZW50IHJlc2l6ZUVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5PblJlc2l6ZUVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcmVzaXplRW5kIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByZXNpemFibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicmVzaXplRW5kXCIsICh7IHRhcmdldCwgaXNEcmFnIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCwgaXNEcmFnKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuKiBXaGVuIHRoZSBncm91cCByZXNpemUgc3RhcnRzLCB0aGUgYHJlc2l6ZUdyb3VwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXHJcbiogQGV2ZW50IHJlc2l6ZUdyb3VwU3RhcnRcclxuKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5PblJlc2l6ZUdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZXNpemVHcm91cFN0YXJ0YCBldmVudFxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4qICAgICByZXNpemFibGU6IHRydWVcclxuKiB9KTtcclxuKiBtb3ZlYWJsZS5vbihcInJlc2l6ZUdyb3VwU3RhcnRcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKFwib25SZXNpemVHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuKiBXaGVuIHRoZSBncm91cCByZXNpemUsIHRoZSBgcmVzaXplR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXHJcbiogQGV2ZW50IHJlc2l6ZUdyb3VwXHJcbiogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUub25SZXNpemVHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlc2l6ZUdyb3VwYCBldmVudFxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4qICAgICByZXNpemFibGU6IHRydWVcclxuKiB9KTtcclxuKiBtb3ZlYWJsZS5vbihcInJlc2l6ZUdyb3VwXCIsICh7IHRhcmdldHMsIGV2ZW50cyB9KSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKFwib25SZXNpemVHcm91cFwiLCB0YXJnZXRzKTtcclxuKiAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xyXG4qICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gW1xyXG4qICAgICAgICAgICAgIGRpcmVjdGlvblswXSA8IDAgPyAtZXYuZGVsdGFbMF0gOiAwLFxyXG4qICAgICAgICAgICAgIGRpcmVjdGlvblsxXSA8IDAgPyAtZXYuZGVsdGFbMV0gOiAwLFxyXG4qICAgICAgICAgXTtcclxuKiAgICAgICAgIC8vIGV2LmRyYWcgaXMgYSBkcmFnIGV2ZW50IHRoYXQgb2NjdXJzIHdoZW4gdGhlIGdyb3VwIHJlc2l6ZS5cclxuKiAgICAgICAgIGNvbnN0IGxlZnQgPSBvZmZzZXRbMF0gKyBldi5kcmFnLmJlZm9yZURpc3RbMF07XHJcbiogICAgICAgICBjb25zdCB0b3AgPSBvZmZzZXRbMV0gKyBldi5kcmFnLmJlZm9yZURpc3RbMV07XHJcbiogICAgICAgICBjb25zdCB3aWR0aCA9IGV2LndpZHRoO1xyXG4qICAgICAgICAgY29uc3QgdG9wID0gZXYudG9wO1xyXG4qICAgICB9KTtcclxuKiB9KTtcclxuKi9cclxuLyoqXHJcbiAqIFdoZW4gdGhlIGdyb3VwIHJlc2l6ZSBmaW5pc2hlcywgdGhlIGByZXNpemVHcm91cEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXHJcbiAqIEBldmVudCByZXNpemVHcm91cEVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5PblJlc2l6ZUdyb3VwRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVzaXplR3JvdXBFbmRgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuICogICAgIHJlc2l6YWJsZTogdHJ1ZVxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyZXNpemVHcm91cEVuZFwiLCAoeyB0YXJnZXRzLCBpc0RyYWcgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlc2l6ZUdyb3VwRW5kXCIsIHRhcmdldHMsIGlzRHJhZyk7XHJcbiAqIH0pO1xyXG4gKi9cblxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgUm90YXRhYmxlXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxyXG4gKiBAZGVzY3JpcHRpb24gUm90YXRhYmxlIGluZGljYXRlcyB3aGV0aGVyIHRoZSB0YXJnZXQgY2FuIGJlIHJvdGF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRSb3RhdGVTdGFydEluZm8obW92ZWFibGUsIGRhdGFzLCBjbGllbnRYLCBjbGllbnRZLCByZWN0KSB7XHJcbiAgICB2YXIgZ3JvdXBhYmxlID0gbW92ZWFibGUucHJvcHMuZ3JvdXBhYmxlO1xyXG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICB2YXIgbiA9IHN0YXRlLmlzM2QgPyA0IDogMztcclxuICAgIHZhciBvcmlnaW4gPSBkYXRhcy5vcmlnaW47XHJcbiAgICB2YXIgbmV4dE9yaWdpbiA9IGNhbGN1bGF0ZVBvc2l0aW9uKG1vdmVhYmxlLnN0YXRlLnJvb3RNYXRyaXgsIFxyXG4gICAgLy8gVE8tRE8gIzcxMFxyXG4gICAgbWludXMoW29yaWdpblswXSwgb3JpZ2luWzFdXSwgZ3JvdXBhYmxlID8gWzAsIDBdIDogW3N0YXRlLmxlZnQsIHN0YXRlLnRvcF0pLCBuKTtcclxuICAgIHZhciBzdGFydEFic29sdXRlT3JpZ2luID0gcGx1cyhbcmVjdC5sZWZ0LCByZWN0LnRvcF0sIG5leHRPcmlnaW4pO1xyXG4gICAgZGF0YXMuc3RhcnRBYnNvbHV0ZU9yaWdpbiA9IHN0YXJ0QWJzb2x1dGVPcmlnaW47XHJcbiAgICBkYXRhcy5wcmV2RGVnID0gZ2V0UmFkKHN0YXJ0QWJzb2x1dGVPcmlnaW4sIFtjbGllbnRYLCBjbGllbnRZXSkgLyBNYXRoLlBJICogMTgwO1xyXG4gICAgZGF0YXMuZGVmYXVsdERlZyA9IGRhdGFzLnByZXZEZWc7XHJcbiAgICBkYXRhcy5wcmV2U25hcERlZyA9IDA7XHJcbiAgICBkYXRhcy5sb29wID0gMDtcclxuICAgIGRhdGFzLnN0YXJ0RGlzdCA9IGdldERpc3QkMShzdGFydEFic29sdXRlT3JpZ2luLCBbY2xpZW50WCwgY2xpZW50WV0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFic29sdXRlRGlzdChkZWcsIGRpcmVjdGlvbiwgZGF0YXMpIHtcclxuICAgIHZhciBkZWZhdWx0RGVnID0gZGF0YXMuZGVmYXVsdERlZywgcHJldkRlZyA9IGRhdGFzLnByZXZEZWc7XHJcbiAgICB2YXIgbm9ybWFsaXplZFByZXZEZWcgPSBwcmV2RGVnICUgMzYwO1xyXG4gICAgdmFyIGxvb3AgPSBNYXRoLmZsb29yKHByZXZEZWcgLyAzNjApO1xyXG4gICAgaWYgKG5vcm1hbGl6ZWRQcmV2RGVnIDwgMCkge1xyXG4gICAgICAgIG5vcm1hbGl6ZWRQcmV2RGVnICs9IDM2MDtcclxuICAgIH1cclxuICAgIGlmIChub3JtYWxpemVkUHJldkRlZyA+IGRlZyAmJiBub3JtYWxpemVkUHJldkRlZyA+IDI3MCAmJiBkZWcgPCA5MCkge1xyXG4gICAgICAgIC8vIDM2MCA9PiAwXHJcbiAgICAgICAgKytsb29wO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9ybWFsaXplZFByZXZEZWcgPCBkZWcgJiYgbm9ybWFsaXplZFByZXZEZWcgPCA5MCAmJiBkZWcgPiAyNzApIHtcclxuICAgICAgICAvLyAwID0+IDM2MFxyXG4gICAgICAgIC0tbG9vcDtcclxuICAgIH1cclxuICAgIHZhciBkaXN0ID0gZGlyZWN0aW9uICogKGxvb3AgKiAzNjAgKyBkZWcgLSBkZWZhdWx0RGVnKTtcclxuICAgIGRhdGFzLnByZXZEZWcgPSBkZWZhdWx0RGVnICsgZGlzdDtcclxuICAgIHJldHVybiBkaXN0O1xyXG59XHJcbmZ1bmN0aW9uIGdldEFic29sdXRlRGlzdEJ5Q2xpZW50KGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbiwgZGF0YXMpIHtcclxuICAgIHJldHVybiBnZXRBYnNvbHV0ZURpc3QoZ2V0UmFkKGRhdGFzLnN0YXJ0QWJzb2x1dGVPcmlnaW4sIFtjbGllbnRYLCBjbGllbnRZXSkgLyBNYXRoLlBJICogMTgwLCBkaXJlY3Rpb24sIGRhdGFzKTtcclxufVxyXG5mdW5jdGlvbiBnZXRSb3RhdGVJbmZvKG1vdmVhYmxlLCBtb3ZlYWJsZVJlY3QsIGRhdGFzLCBkaXN0LCBzdGFydFZhbHVlLCBjaGVja1NuYXApIHtcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLnRocm90dGxlUm90YXRlLCB0aHJvdHRsZVJvdGF0ZSA9IF9hID09PSB2b2lkIDAgPyAwIDogX2E7XHJcbiAgICB2YXIgcHJldlNuYXBEZWcgPSBkYXRhcy5wcmV2U25hcERlZztcclxuICAgIHZhciBzbmFwUm90YXRpb24gPSAwO1xyXG4gICAgdmFyIGlzU25hcCA9IGZhbHNlO1xyXG4gICAgaWYgKGNoZWNrU25hcCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBjaGVja1NuYXBSb3RhdGUobW92ZWFibGUsIG1vdmVhYmxlUmVjdCwgZGlzdCwgc3RhcnRWYWx1ZSArIGRpc3QpO1xyXG4gICAgICAgIGlzU25hcCA9IHJlc3VsdC5pc1NuYXA7XHJcbiAgICAgICAgc25hcFJvdGF0aW9uID0gc3RhcnRWYWx1ZSArIHJlc3VsdC5kaXN0O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1NuYXApIHtcclxuICAgICAgICBzbmFwUm90YXRpb24gPSB0aHJvdHRsZShzdGFydFZhbHVlICsgZGlzdCwgdGhyb3R0bGVSb3RhdGUpO1xyXG4gICAgfVxyXG4gICAgdmFyIHNuYXBEZWcgPSBzbmFwUm90YXRpb24gLSBzdGFydFZhbHVlO1xyXG4gICAgZGF0YXMucHJldlNuYXBEZWcgPSBzbmFwRGVnO1xyXG4gICAgcmV0dXJuIFtzbmFwRGVnIC0gcHJldlNuYXBEZWcsIHNuYXBEZWcsIHNuYXBSb3RhdGlvbl07XHJcbn1cclxuZnVuY3Rpb24gZ2V0Um90YXRpb25Qb3NpdGlvbnMocm90YXRpb25Qb3NpdGlvbiwgX2EsIGRpcmVjdGlvbikge1xyXG4gICAgdmFyIF9iID0gX19yZWFkKF9hLCA0KSwgcG9zMSA9IF9iWzBdLCBwb3MyID0gX2JbMV0sIHBvczMgPSBfYlsyXSwgcG9zNCA9IF9iWzNdO1xyXG4gICAgaWYgKHJvdGF0aW9uUG9zaXRpb24gPT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocm90YXRpb25Qb3NpdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gcm90YXRpb25Qb3NpdGlvbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBnZXRSb3RhdGlvblBvc2l0aW9ucyhjaGlsZCwgW3BvczEsIHBvczIsIHBvczMsIHBvczRdLCBkaXJlY3Rpb24pWzBdOyB9KTtcclxuICAgIH1cclxuICAgIHZhciBfYyA9IF9fcmVhZCgocm90YXRpb25Qb3NpdGlvbiB8fCBcInRvcFwiKS5zcGxpdChcIi1cIiksIDIpLCBkaXIxID0gX2NbMF0sIGRpcjIgPSBfY1sxXTtcclxuICAgIHZhciByYWRQb3NlcyA9IFtwb3MxLCBwb3MyXTtcclxuICAgIGlmIChkaXIxID09PSBcImxlZnRcIikge1xyXG4gICAgICAgIHJhZFBvc2VzID0gW3BvczMsIHBvczFdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGlyMSA9PT0gXCJyaWdodFwiKSB7XHJcbiAgICAgICAgcmFkUG9zZXMgPSBbcG9zMiwgcG9zNF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkaXIxID09PSBcImJvdHRvbVwiKSB7XHJcbiAgICAgICAgcmFkUG9zZXMgPSBbcG9zNCwgcG9zM107XHJcbiAgICB9XHJcbiAgICB2YXIgcG9zID0gW1xyXG4gICAgICAgIChyYWRQb3Nlc1swXVswXSArIHJhZFBvc2VzWzFdWzBdKSAvIDIsXHJcbiAgICAgICAgKHJhZFBvc2VzWzBdWzFdICsgcmFkUG9zZXNbMV1bMV0pIC8gMixcclxuICAgIF07XHJcbiAgICB2YXIgcmFkID0gZ2V0Um90YXRpb25SYWQocmFkUG9zZXMsIGRpcmVjdGlvbik7XHJcbiAgICBpZiAoZGlyMikge1xyXG4gICAgICAgIHZhciBpc1N0YXJ0ID0gZGlyMiA9PT0gXCJ0b3BcIiB8fCBkaXIyID09PSBcImxlZnRcIjtcclxuICAgICAgICB2YXIgaXNSZXZlcnNlID0gZGlyMSA9PT0gXCJib3R0b21cIiB8fCBkaXIxID09PSBcImxlZnRcIjtcclxuICAgICAgICBwb3MgPSByYWRQb3Nlc1soaXNTdGFydCAmJiAhaXNSZXZlcnNlKSB8fCAoIWlzU3RhcnQgJiYgaXNSZXZlcnNlKSA/IDAgOiAxXTtcclxuICAgIH1cclxuICAgIHJldHVybiBbW3BvcywgcmFkXV07XHJcbn1cclxuZnVuY3Rpb24gZHJhZ0NvbnRyb2xDb25kaXRpb24obW92ZWFibGUsIGUpIHtcclxuICAgIGlmIChlLmlzUmVxdWVzdCkge1xyXG4gICAgICAgIHJldHVybiBlLnJlcXVlc3RBYmxlID09PSBcInJvdGF0YWJsZVwiO1xyXG4gICAgfVxyXG4gICAgdmFyIHRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7XHJcbiAgICBpZiAoaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJyb3RhdGlvbi1jb250cm9sXCIpKVxyXG4gICAgICAgIHx8IChtb3ZlYWJsZS5wcm9wcy5yb3RhdGVBcm91bmRDb250cm9scyAmJiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcImFyb3VuZC1jb250cm9sXCIpKSlcclxuICAgICAgICB8fCAoaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJjb250cm9sXCIpKSAmJiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcInJvdGF0YWJsZVwiKSkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICB2YXIgcm90YXRpb25UYXJnZXQgPSBtb3ZlYWJsZS5wcm9wcy5yb3RhdGlvblRhcmdldDtcclxuICAgIGlmIChyb3RhdGlvblRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBnZXRSZWZUYXJnZXRzKHJvdGF0aW9uVGFyZ2V0LCB0cnVlKS5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgPT09IGVsZW1lbnQgfHwgdGFyZ2V0LmNvbnRhaW5zKGVsZW1lbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbnZhciBjc3MgPSBcIi5yb3RhdGlvbiB7XFxucG9zaXRpb246IGFic29sdXRlO1xcbmhlaWdodDogNDBweDtcXG53aWR0aDogMXB4O1xcbnRyYW5zZm9ybS1vcmlnaW46IDUwJSAxMDAlO1xcbmhlaWdodDogY2FsYyg0MHB4ICogdmFyKC0tem9vbSkpO1xcbnRvcDogYXV0bztcXG5sZWZ0OiAwO1xcbmJvdHRvbTogMTAwJTtcXG53aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbn1cXG4ucm90YXRpb24gLnJvdGF0aW9uLWxpbmUge1xcbmRpc3BsYXk6IGJsb2NrO1xcbndpZHRoOiAxMDAlO1xcbmhlaWdodDogMTAwJTtcXG50cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbn1cXG4ucm90YXRpb24gLnJvdGF0aW9uLWNvbnRyb2wge1xcbmJvcmRlci1jb2xvcjogIzRhZjtcXG5ib3JkZXItY29sb3I6IHZhcigtLW1vdmVhYmxlLWNvbG9yKTtcXG5iYWNrZ3JvdW5kOiNmZmY7XFxuY3Vyc29yOiBhbGlhcztcXG59XFxuOmdsb2JhbCAudmlldy1yb3RhdGlvbi1kcmFnZ2luZywgLnJvdGF0YWJsZS5kaXJlY3Rpb24uY29udHJvbCB7XFxuY3Vyc29yOiBhbGlhcztcXG59XFxuLnJvdGF0YWJsZS5kaXJlY3Rpb24uY29udHJvbC5tb3ZlIHtcXG5jdXJzb3I6IG1vdmU7XFxufVxcblwiO1xyXG52YXIgUm90YXRhYmxlID0ge1xyXG4gICAgbmFtZTogXCJyb3RhdGFibGVcIixcclxuICAgIGNhblBpbmNoOiB0cnVlLFxyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcInJvdGF0YWJsZVwiLFxyXG4gICAgICAgIFwicm90YXRpb25Qb3NpdGlvblwiLFxyXG4gICAgICAgIFwidGhyb3R0bGVSb3RhdGVcIixcclxuICAgICAgICBcInJlbmRlckRpcmVjdGlvbnNcIixcclxuICAgICAgICBcInJvdGF0aW9uVGFyZ2V0XCIsXHJcbiAgICAgICAgXCJyb3RhdGVBcm91bmRDb250cm9sc1wiLFxyXG4gICAgICAgIFwiZWRnZVwiLFxyXG4gICAgICAgIFwicmVzb2x2ZUFibGVzV2l0aFJvdGF0YWJsZVwiLFxyXG4gICAgICAgIFwiZGlzcGxheUFyb3VuZENvbnRyb2xzXCIsXHJcbiAgICBdLFxyXG4gICAgZXZlbnRzOiBbXHJcbiAgICAgICAgXCJyb3RhdGVTdGFydFwiLFxyXG4gICAgICAgIFwiYmVmb3JlUm90YXRlXCIsXHJcbiAgICAgICAgXCJyb3RhdGVcIixcclxuICAgICAgICBcInJvdGF0ZUVuZFwiLFxyXG4gICAgICAgIFwicm90YXRlR3JvdXBTdGFydFwiLFxyXG4gICAgICAgIFwiYmVmb3JlUm90YXRlR3JvdXBcIixcclxuICAgICAgICBcInJvdGF0ZUdyb3VwXCIsXHJcbiAgICAgICAgXCJyb3RhdGVHcm91cEVuZFwiLFxyXG4gICAgXSxcclxuICAgIGNzczogW2Nzc10sXHJcbiAgICB2aWV3Q2xhc3NOYW1lOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICBpZiAoIW1vdmVhYmxlLmlzRHJhZ2dpbmcoXCJyb3RhdGFibGVcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcmVmaXgoXCJ2aWV3LXJvdGF0aW9uLWRyYWdnaW5nXCIpO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xyXG4gICAgICAgIHZhciBfYSA9IGdldFByb3BzKG1vdmVhYmxlLnByb3BzLCBcInJvdGF0YWJsZVwiKSwgcm90YXRhYmxlID0gX2Eucm90YXRhYmxlLCByb3RhdGlvblBvc2l0aW9uID0gX2Eucm90YXRpb25Qb3NpdGlvbiwgem9vbSA9IF9hLnpvb20sIHJlbmRlckRpcmVjdGlvbnMgPSBfYS5yZW5kZXJEaXJlY3Rpb25zLCByb3RhdGVBcm91bmRDb250cm9scyA9IF9hLnJvdGF0ZUFyb3VuZENvbnRyb2xzLCByZXNvbHZlQWJsZXNXaXRoUm90YXRhYmxlID0gX2EucmVzb2x2ZUFibGVzV2l0aFJvdGF0YWJsZTtcclxuICAgICAgICB2YXIgX2IgPSBtb3ZlYWJsZS5nZXRTdGF0ZSgpLCByZW5kZXJQb3NlcyA9IF9iLnJlbmRlclBvc2VzLCBkaXJlY3Rpb24gPSBfYi5kaXJlY3Rpb247XHJcbiAgICAgICAgaWYgKCFyb3RhdGFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBnZXRSb3RhdGlvblBvc2l0aW9ucyhyb3RhdGlvblBvc2l0aW9uLCByZW5kZXJQb3NlcywgZGlyZWN0aW9uKTtcclxuICAgICAgICB2YXIganN4cyA9IFtdO1xyXG4gICAgICAgIHBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgaSkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBwb3MgPSBfYlswXSwgcmFkID0gX2JbMV07XHJcbiAgICAgICAgICAgIGpzeHMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcInJvdGF0aW9uXCIuY29uY2F0KGkpLCBjbGFzc05hbWU6IHByZWZpeChcInJvdGF0aW9uXCIpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWxpbmUtbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlKSB0cmFuc2xhdGUoXCIuY29uY2F0KHBvc1swXSwgXCJweCwgXCIpLmNvbmNhdChwb3NbMV0sIFwicHgpIHJvdGF0ZShcIikuY29uY2F0KHJhZCwgXCJyYWQpXCIpLFxyXG4gICAgICAgICAgICAgICAgfSB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogcHJlZml4KFwibGluZSByb3RhdGlvbi1saW5lXCIpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGVYKFwiLmNvbmNhdCh6b29tLCBcIilcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2wgcm90YXRpb24tY29udHJvbFwiKSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgwLjVweCkgc2NhbGUoXCIuY29uY2F0KHpvb20sIFwiKVwiKSxcclxuICAgICAgICAgICAgICAgICAgICB9IH0pKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHJlbmRlckRpcmVjdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGFibGVzID0gZ2V0S2V5cyhyZXNvbHZlQWJsZXNXaXRoUm90YXRhYmxlIHx8IHt9KTtcclxuICAgICAgICAgICAgdmFyIHJlc29sdmVNYXBfMSA9IHt9O1xyXG4gICAgICAgICAgICBhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlQWJsZXNXaXRoUm90YXRhYmxlW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVNYXBfMVtkaXJlY3Rpb25dID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbkNvbnRyb2xJbmZvcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShyZW5kZXJEaXJlY3Rpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uQ29udHJvbEluZm9zID0gcmVuZGVyRGlyZWN0aW9ucy5tYXAoZnVuY3Rpb24gKGRpcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhYmxlID0gcmVzb2x2ZU1hcF8xW2Rpcl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogYWJsZSA/IHsgcmVzb2x2ZTogYWJsZSB9IDoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IGFibGUgPyBbXCJtb3ZlXCJdIDogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcjogZGlyLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBqc3hzLnB1c2guYXBwbHkoanN4cywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHJlbmRlckRpcmVjdGlvbkNvbnRyb2xzQnlJbmZvcyhtb3ZlYWJsZSwgXCJyb3RhdGFibGVcIiwgZGlyZWN0aW9uQ29udHJvbEluZm9zLCBSZWFjdCkpLCBmYWxzZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm90YXRlQXJvdW5kQ29udHJvbHMpIHtcclxuICAgICAgICAgICAganN4cy5wdXNoLmFwcGx5KGpzeHMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChyZW5kZXJBcm91bmRDb250cm9scyhtb3ZlYWJsZSwgUmVhY3QpKSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGpzeHM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGRyYWdDb250cm9sQ29uZGl0aW9uLFxyXG4gICAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfYjtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBjbGllbnRYID0gZS5jbGllbnRYLCBjbGllbnRZID0gZS5jbGllbnRZLCBwYXJlbnRSb3RhdGUgPSBlLnBhcmVudFJvdGF0ZSwgcGFyZW50RmxhZyA9IGUucGFyZW50RmxhZywgaXNQaW5jaCA9IGUuaXNQaW5jaCwgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldCwgbGVmdCA9IHN0YXRlLmxlZnQsIHRvcCA9IHN0YXRlLnRvcCwgZGlyZWN0aW9uID0gc3RhdGUuZGlyZWN0aW9uLCBiZWZvcmVEaXJlY3Rpb24gPSBzdGF0ZS5iZWZvcmVEaXJlY3Rpb24sIHRhcmdldFRyYW5zZm9ybSA9IHN0YXRlLnRhcmdldFRyYW5zZm9ybSwgbW92ZWFibGVDbGllbnRSZWN0ID0gc3RhdGUubW92ZWFibGVDbGllbnRSZWN0LCBvZmZzZXRNYXRyaXggPSBzdGF0ZS5vZmZzZXRNYXRyaXgsIHRhcmdldE1hdHJpeCA9IHN0YXRlLnRhcmdldE1hdHJpeCwgYWxsTWF0cml4ID0gc3RhdGUuYWxsTWF0cml4LCB3aWR0aCA9IHN0YXRlLndpZHRoLCBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKCFpc1JlcXVlc3QgJiYgIXRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWN0ID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xyXG4gICAgICAgIGRhdGFzLnJlY3QgPSByZWN0O1xyXG4gICAgICAgIGRhdGFzLnRyYW5zZm9ybSA9IHRhcmdldFRyYW5zZm9ybTtcclxuICAgICAgICBkYXRhcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICBkYXRhcy50b3AgPSB0b3A7XHJcbiAgICAgICAgdmFyIHNldEZpeGVkUG9zaXRpb24gPSBmdW5jdGlvbiAoZml4ZWRQb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0T2Zmc2V0Rml4ZWRQb3NpdGlvbkluZm8obW92ZWFibGUuc3RhdGUsIGZpeGVkUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBkYXRhcy5maXhlZERpcmVjdGlvbiA9IHJlc3VsdC5maXhlZERpcmVjdGlvbjtcclxuICAgICAgICAgICAgZGF0YXMuZml4ZWRPZmZzZXQgPSByZXN1bHQuZml4ZWRPZmZzZXQ7XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkUG9zaXRpb24gPSByZXN1bHQuZml4ZWRQb3NpdGlvbjtcclxuICAgICAgICAgICAgaWYgKHJlc2l6ZVN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICByZXNpemVTdGFydC5zZXRGaXhlZFBvc2l0aW9uKGZpeGVkUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc2V0Rml4ZWREaXJlY3Rpb24gPSBmdW5jdGlvbiAoZml4ZWREaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdldE9mZnNldEZpeGVkRGlyZWN0aW9uSW5mbyhtb3ZlYWJsZS5zdGF0ZSwgZml4ZWREaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBkYXRhcy5maXhlZERpcmVjdGlvbiA9IHJlc3VsdC5maXhlZERpcmVjdGlvbjtcclxuICAgICAgICAgICAgZGF0YXMuZml4ZWRPZmZzZXQgPSByZXN1bHQuZml4ZWRPZmZzZXQ7XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkUG9zaXRpb24gPSByZXN1bHQuZml4ZWRQb3NpdGlvbjtcclxuICAgICAgICAgICAgaWYgKHJlc2l6ZVN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICByZXNpemVTdGFydC5zZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzdGFydENsaWVudFggPSBjbGllbnRYO1xyXG4gICAgICAgIHZhciBzdGFydENsaWVudFkgPSBjbGllbnRZO1xyXG4gICAgICAgIGlmIChpc1JlcXVlc3QgfHwgaXNQaW5jaCB8fCBwYXJlbnRGbGFnKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRlcm5hbFJvdGF0ZSA9IHBhcmVudFJvdGF0ZSB8fCAwO1xyXG4gICAgICAgICAgICBkYXRhcy5iZWZvcmVJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luOiByZWN0LmJlZm9yZU9yaWdpbixcclxuICAgICAgICAgICAgICAgIHByZXZEZWc6IGV4dGVybmFsUm90YXRlLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdERlZzogZXh0ZXJuYWxSb3RhdGUsXHJcbiAgICAgICAgICAgICAgICBwcmV2U25hcERlZzogMCxcclxuICAgICAgICAgICAgICAgIHN0YXJ0RGlzdDogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZGF0YXMuYWZ0ZXJJbmZvID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGFzLmJlZm9yZUluZm8pLCB7IG9yaWdpbjogcmVjdC5vcmlnaW4gfSk7XHJcbiAgICAgICAgICAgIGRhdGFzLmFic29sdXRlSW5mbyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhcy5iZWZvcmVJbmZvKSwgeyBvcmlnaW46IHJlY3Qub3JpZ2luLCBzdGFydFZhbHVlOiBleHRlcm5hbFJvdGF0ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dFRhcmdldCA9IChfYiA9IGUuaW5wdXRFdmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRhcmdldDtcclxuICAgICAgICAgICAgaWYgKGlucHV0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnaW9uRGlyZWN0aW9uID0gaW5wdXRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1kaXJlY3Rpb25cIikgfHwgXCJcIjtcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sRGlyZWN0aW9uID0gRElSRUNUSU9OX1JFR0lPTl9UT19ESVJFQ1RJT05bcmVnaW9uRGlyZWN0aW9uXTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXMuaXNDb250cm9sID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhcy5pc0Fyb3VuZENvbnRyb2wgPSBoYXNDbGFzcyhpbnB1dFRhcmdldCwgcHJlZml4KFwiYXJvdW5kLWNvbnRyb2xcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzLmNvbnRyb2xEaXJlY3Rpb24gPSBjb250cm9sRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlID0gaW5wdXRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZXNvbHZlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzLnJlc29sdmVBYmxlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaWVudFBvc2VzID0gY2FsY3VsYXRlTW92ZWFibGVDbGllbnRQb3NpdGlvbnMoc3RhdGUucm9vdE1hdHJpeCwgc3RhdGUucmVuZGVyUG9zZXMsIG1vdmVhYmxlQ2xpZW50UmVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBfX3JlYWQoZ2V0UG9zQnlEaXJlY3Rpb24oY2xpZW50UG9zZXMsIGNvbnRyb2xEaXJlY3Rpb24pLCAyKSwgc3RhcnRDbGllbnRYID0gX2FbMF0sIHN0YXJ0Q2xpZW50WSA9IF9hWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGFzLmJlZm9yZUluZm8gPSB7IG9yaWdpbjogcmVjdC5iZWZvcmVPcmlnaW4gfTtcclxuICAgICAgICAgICAgZGF0YXMuYWZ0ZXJJbmZvID0geyBvcmlnaW46IHJlY3Qub3JpZ2luIH07XHJcbiAgICAgICAgICAgIGRhdGFzLmFic29sdXRlSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbjogcmVjdC5vcmlnaW4sXHJcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiByZWN0LnJvdGF0aW9uLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxGaXhlZFBvc2l0aW9uXzEgPSBzZXRGaXhlZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBzZXRGaXhlZFBvc2l0aW9uID0gZnVuY3Rpb24gKGZpeGVkUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gc3RhdGUuaXMzZCA/IDQgOiAzO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHBsdXMoZ2V0T3JpZ2luKHRhcmdldE1hdHJpeCwgbiksIGZpeGVkUG9zaXRpb24pLCAyKSwgb3JpZ2luWCA9IF9hWzBdLCBvcmlnaW5ZID0gX2FbMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZml4ZWRCZWZvcmVPcmlnaW4gPSBjYWxjdWxhdGUob2Zmc2V0TWF0cml4LCBjb252ZXJ0UG9zaXRpb25NYXRyaXgoW29yaWdpblgsIG9yaWdpblldLCBuKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZml4ZWRBZnRlck9yaWdpbiA9IGNhbGN1bGF0ZShhbGxNYXRyaXgsIGNvbnZlcnRQb3NpdGlvbk1hdHJpeChbZml4ZWRQb3NpdGlvblswXSwgZml4ZWRQb3NpdGlvblsxXV0sIG4pKTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRml4ZWRQb3NpdGlvbl8xKGZpeGVkUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc0RlbHRhID0gc3RhdGUucG9zRGVsdGE7XHJcbiAgICAgICAgICAgICAgICBkYXRhcy5iZWZvcmVJbmZvLm9yaWdpbiA9IG1pbnVzKGZpeGVkQmVmb3JlT3JpZ2luLCBwb3NEZWx0YSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhcy5hZnRlckluZm8ub3JpZ2luID0gbWludXMoZml4ZWRBZnRlck9yaWdpbiwgcG9zRGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgZGF0YXMuYWJzb2x1dGVJbmZvLm9yaWdpbiA9IG1pbnVzKGZpeGVkQWZ0ZXJPcmlnaW4sIHBvc0RlbHRhKTtcclxuICAgICAgICAgICAgICAgIHNldFJvdGF0ZVN0YXJ0SW5mbyhtb3ZlYWJsZSwgZGF0YXMuYmVmb3JlSW5mbywgc3RhcnRDbGllbnRYLCBzdGFydENsaWVudFksIG1vdmVhYmxlQ2xpZW50UmVjdCk7XHJcbiAgICAgICAgICAgICAgICBzZXRSb3RhdGVTdGFydEluZm8obW92ZWFibGUsIGRhdGFzLmFmdGVySW5mbywgc3RhcnRDbGllbnRYLCBzdGFydENsaWVudFksIG1vdmVhYmxlQ2xpZW50UmVjdCk7XHJcbiAgICAgICAgICAgICAgICBzZXRSb3RhdGVTdGFydEluZm8obW92ZWFibGUsIGRhdGFzLmFic29sdXRlSW5mbywgc3RhcnRDbGllbnRYLCBzdGFydENsaWVudFksIG1vdmVhYmxlQ2xpZW50UmVjdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNldEZpeGVkRGlyZWN0aW9uID0gZnVuY3Rpb24gKGZpeGVkRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGdldFBvc0J5RGlyZWN0aW9uKFtcclxuICAgICAgICAgICAgICAgICAgICBbMCwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgW3dpZHRoLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbMCwgaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICBbd2lkdGgsIGhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICBdLCBmaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzZXRGaXhlZFBvc2l0aW9uKGZpeGVkUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhcy5zdGFydENsaWVudFggPSBzdGFydENsaWVudFg7XHJcbiAgICAgICAgZGF0YXMuc3RhcnRDbGllbnRZID0gc3RhcnRDbGllbnRZO1xyXG4gICAgICAgIGRhdGFzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgICAgICBkYXRhcy5iZWZvcmVEaXJlY3Rpb24gPSBiZWZvcmVEaXJlY3Rpb247XHJcbiAgICAgICAgZGF0YXMuc3RhcnRWYWx1ZSA9IDA7XHJcbiAgICAgICAgZGF0YXMuZGF0YXMgPSB7fTtcclxuICAgICAgICBzZXREZWZhdWx0VHJhbnNmb3JtSW5kZXgobW92ZWFibGUsIGUsIFwicm90YXRlXCIpO1xyXG4gICAgICAgIHZhciBkcmFnU3RhcnQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgcmVzaXplU3RhcnQgPSBmYWxzZTtcclxuICAgICAgICBpZiAoZGF0YXMuaXNDb250cm9sICYmIGRhdGFzLnJlc29sdmVBYmxlKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNvbHZlQWJsZSA9IGRhdGFzLnJlc29sdmVBYmxlO1xyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZUFibGUgPT09IFwicmVzaXphYmxlXCIpIHtcclxuICAgICAgICAgICAgICAgIHJlc2l6ZVN0YXJ0ID0gUmVzaXphYmxlLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCAobmV3IEN1c3RvbUdlc3RvKFwicmVzaXphYmxlXCIpLmRyYWdTdGFydChbMCwgMF0sIGUpKSksIHsgcGFyZW50UG9zaXRpb246IGRhdGFzLmNvbnRyb2xQb3NpdGlvbiwgcGFyZW50Rml4ZWRQb3NpdGlvbjogZGF0YXMuZml4ZWRQb3NpdGlvbiB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZXNpemVTdGFydCkge1xyXG4gICAgICAgICAgICBkcmFnU3RhcnQgPSBEcmFnZ2FibGUuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBuZXcgQ3VzdG9tR2VzdG8oKS5kcmFnU3RhcnQoWzAsIDBdLCBlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldEZpeGVkUG9zaXRpb24oZ2V0VG90YWxPcmlnaW4obW92ZWFibGUpKTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oX19hc3NpZ24oeyBzZXQ6IGZ1bmN0aW9uIChyb3RhdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhcy5zdGFydFZhbHVlID0gcm90YXRhdGlvbiAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgICAgIH0sIHNldEZpeGVkRGlyZWN0aW9uOiBzZXRGaXhlZERpcmVjdGlvbiwgc2V0Rml4ZWRQb3NpdGlvbjogc2V0Rml4ZWRQb3NpdGlvbiB9LCBmaWxsVHJhbnNmb3JtU3RhcnRFdmVudChtb3ZlYWJsZSwgZSkpLCB7IGRyYWdTdGFydDogZHJhZ1N0YXJ0LCByZXNpemVTdGFydDogcmVzaXplU3RhcnQgfSkpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVTdGFydFwiLCBwYXJhbXMpO1xyXG4gICAgICAgIGRhdGFzLmlzUm90YXRlID0gcmVzdWx0ICE9PSBmYWxzZTtcclxuICAgICAgICBzdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcclxuICAgICAgICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZGF0YXMuaXNSb3RhdGUgPyBwYXJhbXMgOiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgY2xpZW50RGlzdFggPSBlLmNsaWVudERpc3RYLCBjbGllbnREaXN0WSA9IGUuY2xpZW50RGlzdFksIHBhcmVudFJvdGF0ZSA9IGUucGFyZW50Um90YXRlLCBwYXJlbnRGbGFnID0gZS5wYXJlbnRGbGFnLCBpc1BpbmNoID0gZS5pc1BpbmNoLCBncm91cERlbHRhID0gZS5ncm91cERlbHRhLCByZXNvbHZlTWF0cml4ID0gZS5yZXNvbHZlTWF0cml4O1xyXG4gICAgICAgIHZhciBiZWZvcmVEaXJlY3Rpb24gPSBkYXRhcy5iZWZvcmVEaXJlY3Rpb24sIGJlZm9yZUluZm8gPSBkYXRhcy5iZWZvcmVJbmZvLCBhZnRlckluZm8gPSBkYXRhcy5hZnRlckluZm8sIGFic29sdXRlSW5mbyA9IGRhdGFzLmFic29sdXRlSW5mbywgaXNSb3RhdGUgPSBkYXRhcy5pc1JvdGF0ZSwgc3RhcnRWYWx1ZSA9IGRhdGFzLnN0YXJ0VmFsdWUsIHJlY3QgPSBkYXRhcy5yZWN0LCBzdGFydENsaWVudFggPSBkYXRhcy5zdGFydENsaWVudFgsIHN0YXJ0Q2xpZW50WSA9IGRhdGFzLnN0YXJ0Q2xpZW50WTtcclxuICAgICAgICBpZiAoIWlzUm90YXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KG1vdmVhYmxlLCBlLCBcInJvdGF0ZVwiKTtcclxuICAgICAgICB2YXIgdGFyZ2V0RGlyZWN0aW9uID0gZ2V0VHJhbnNmb3JtRGlyZWN0aW9uKGUpO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBiZWZvcmVEaXJlY3Rpb24gKiB0YXJnZXREaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIHBhcmVudE1vdmVhYmxlID0gbW92ZWFibGUucHJvcHMucGFyZW50TW92ZWFibGU7XHJcbiAgICAgICAgdmFyIGJlZm9yZURlbHRhID0gMDtcclxuICAgICAgICB2YXIgYmVmb3JlRGlzdDtcclxuICAgICAgICB2YXIgYmVmb3JlUm90YXRpb247XHJcbiAgICAgICAgdmFyIGRlbHRhID0gMDtcclxuICAgICAgICB2YXIgZGlzdDtcclxuICAgICAgICB2YXIgcm90YXRpb247XHJcbiAgICAgICAgdmFyIGFic29sdXRlRGVsdGEgPSAwO1xyXG4gICAgICAgIHZhciBhYnNvbHV0ZURpc3Q7XHJcbiAgICAgICAgdmFyIGFic29sdXRlUm90YXRpb247XHJcbiAgICAgICAgdmFyIHN0YXJ0Um90YXRpb24gPSAxODAgLyBNYXRoLlBJICogc3RhcnRWYWx1ZTtcclxuICAgICAgICB2YXIgYWJzb2x1dGVTdGFydFJvdGF0aW9uID0gYWJzb2x1dGVJbmZvLnN0YXJ0VmFsdWU7XHJcbiAgICAgICAgdmFyIGlzU25hcCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBuZXh0Q2xpZW50WCA9IHN0YXJ0Q2xpZW50WCArIGNsaWVudERpc3RYO1xyXG4gICAgICAgIHZhciBuZXh0Q2xpZW50WSA9IHN0YXJ0Q2xpZW50WSArIGNsaWVudERpc3RZO1xyXG4gICAgICAgIGlmICghcGFyZW50RmxhZyAmJiBcInBhcmVudERpc3RcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnREaXN0ID0gZS5wYXJlbnREaXN0O1xyXG4gICAgICAgICAgICBiZWZvcmVEaXN0ID0gcGFyZW50RGlzdDtcclxuICAgICAgICAgICAgZGlzdCA9IHBhcmVudERpc3Q7XHJcbiAgICAgICAgICAgIGFic29sdXRlRGlzdCA9IHBhcmVudERpc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUGluY2ggfHwgcGFyZW50RmxhZykge1xyXG4gICAgICAgICAgICBiZWZvcmVEaXN0ID0gZ2V0QWJzb2x1dGVEaXN0KHBhcmVudFJvdGF0ZSwgYmVmb3JlRGlyZWN0aW9uLCBiZWZvcmVJbmZvKTtcclxuICAgICAgICAgICAgZGlzdCA9IGdldEFic29sdXRlRGlzdChwYXJlbnRSb3RhdGUsIGRpcmVjdGlvbiwgYWZ0ZXJJbmZvKTtcclxuICAgICAgICAgICAgYWJzb2x1dGVEaXN0ID0gZ2V0QWJzb2x1dGVEaXN0KHBhcmVudFJvdGF0ZSwgZGlyZWN0aW9uLCBhYnNvbHV0ZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYmVmb3JlRGlzdCA9IGdldEFic29sdXRlRGlzdEJ5Q2xpZW50KG5leHRDbGllbnRYLCBuZXh0Q2xpZW50WSwgYmVmb3JlRGlyZWN0aW9uLCBiZWZvcmVJbmZvKTtcclxuICAgICAgICAgICAgZGlzdCA9IGdldEFic29sdXRlRGlzdEJ5Q2xpZW50KG5leHRDbGllbnRYLCBuZXh0Q2xpZW50WSwgZGlyZWN0aW9uLCBhZnRlckluZm8pO1xyXG4gICAgICAgICAgICBhYnNvbHV0ZURpc3QgPSBnZXRBYnNvbHV0ZURpc3RCeUNsaWVudChuZXh0Q2xpZW50WCwgbmV4dENsaWVudFksIGRpcmVjdGlvbiwgYWJzb2x1dGVJbmZvKTtcclxuICAgICAgICAgICAgaXNTbmFwID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmVmb3JlUm90YXRpb24gPSBzdGFydFJvdGF0aW9uICsgYmVmb3JlRGlzdDtcclxuICAgICAgICByb3RhdGlvbiA9IHN0YXJ0Um90YXRpb24gKyBkaXN0O1xyXG4gICAgICAgIGFic29sdXRlUm90YXRpb24gPSBhYnNvbHV0ZVN0YXJ0Um90YXRpb24gKyBhYnNvbHV0ZURpc3Q7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUm90YXRlXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgYmVmb3JlUm90YXRpb246IGJlZm9yZVJvdGF0aW9uLFxyXG4gICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXHJcbiAgICAgICAgICAgIGFic29sdXRlUm90YXRpb246IGFic29sdXRlUm90YXRpb24sXHJcbiAgICAgICAgICAgIHNldFJvdGF0aW9uOiBmdW5jdGlvbiAobmV4dFJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0ID0gbmV4dFJvdGF0aW9uIC0gc3RhcnRSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIGJlZm9yZURpc3QgPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVEaXN0ID0gZGlzdDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LCB0cnVlKSk7XHJcbiAgICAgICAgX2EgPSBfX3JlYWQoZ2V0Um90YXRlSW5mbyhtb3ZlYWJsZSwgcmVjdCwgYmVmb3JlSW5mbywgYmVmb3JlRGlzdCwgc3RhcnRSb3RhdGlvbiwgaXNTbmFwKSwgMyksIGJlZm9yZURlbHRhID0gX2FbMF0sIGJlZm9yZURpc3QgPSBfYVsxXSwgYmVmb3JlUm90YXRpb24gPSBfYVsyXTtcclxuICAgICAgICBfYiA9IF9fcmVhZChnZXRSb3RhdGVJbmZvKG1vdmVhYmxlLCByZWN0LCBhZnRlckluZm8sIGRpc3QsIHN0YXJ0Um90YXRpb24sIGlzU25hcCksIDMpLCBkZWx0YSA9IF9iWzBdLCBkaXN0ID0gX2JbMV0sIHJvdGF0aW9uID0gX2JbMl07XHJcbiAgICAgICAgX2MgPSBfX3JlYWQoZ2V0Um90YXRlSW5mbyhtb3ZlYWJsZSwgcmVjdCwgYWJzb2x1dGVJbmZvLCBhYnNvbHV0ZURpc3QsIGFic29sdXRlU3RhcnRSb3RhdGlvbiwgaXNTbmFwKSwgMyksIGFic29sdXRlRGVsdGEgPSBfY1swXSwgYWJzb2x1dGVEaXN0ID0gX2NbMV0sIGFic29sdXRlUm90YXRpb24gPSBfY1syXTtcclxuICAgICAgICBpZiAoIWFic29sdXRlRGVsdGEgJiYgIWRlbHRhICYmICFiZWZvcmVEZWx0YSAmJiAhcGFyZW50TW92ZWFibGUgJiYgIXJlc29sdmVNYXRyaXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dFRyYW5zZm9ybSA9IGNvbnZlcnRUcmFuc2Zvcm1Gb3JtYXQoZGF0YXMsIFwicm90YXRlKFwiLmNvbmNhdChyb3RhdGlvbiwgXCJkZWcpXCIpLCBcInJvdGF0ZShcIi5jb25jYXQoZGlzdCwgXCJkZWcpXCIpKTtcclxuICAgICAgICBpZiAocmVzb2x2ZU1hdHJpeCkge1xyXG4gICAgICAgICAgICBkYXRhcy5maXhlZFBvc2l0aW9uID0gZ2V0VHJhbnNsYXRlRml4ZWRQb3NpdGlvbihtb3ZlYWJsZSwgZGF0YXMudGFyZ2V0QWxsVHJhbnNmb3JtLCBkYXRhcy5maXhlZERpcmVjdGlvbiwgZGF0YXMuZml4ZWRPZmZzZXQsIGRhdGFzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGludmVyc2VEaXN0ID0gZ2V0Um90YXRlRGlzdChtb3ZlYWJsZSwgZGlzdCwgZGF0YXMpO1xyXG4gICAgICAgIHZhciBpbnZlcnNlRGVsdGEgPSBtaW51cyhwbHVzKGdyb3VwRGVsdGEgfHwgWzAsIDBdLCBpbnZlcnNlRGlzdCksIGRhdGFzLnByZXZJbnZlcnNlRGlzdCB8fCBbMCwgMF0pO1xyXG4gICAgICAgIGRhdGFzLnByZXZJbnZlcnNlRGlzdCA9IGludmVyc2VEaXN0O1xyXG4gICAgICAgIGRhdGFzLnJlcXVlc3RWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGRyYWdFdmVudCA9IGZpbGxUcmFuc2Zvcm1FdmVudChtb3ZlYWJsZSwgbmV4dFRyYW5zZm9ybSwgaW52ZXJzZURlbHRhLCBpc1BpbmNoLCBlKTtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtRXZlbnQgPSBkcmFnRXZlbnQ7XHJcbiAgICAgICAgdmFyIHBhcmVudERpc3RhbmNlID0gZ2V0RGlzdCQxKFtuZXh0Q2xpZW50WCwgbmV4dENsaWVudFldLCBhYnNvbHV0ZUluZm8uc3RhcnRBYnNvbHV0ZU9yaWdpbikgLSBhYnNvbHV0ZUluZm8uc3RhcnREaXN0O1xyXG4gICAgICAgIHZhciByZXNpemUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGRhdGFzLnJlc29sdmVBYmxlID09PSBcInJlc2l6YWJsZVwiKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNpemVFdmVudCA9IFJlc2l6YWJsZS5kcmFnQ29udHJvbChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIHNldEN1c3RvbURyYWcoZSwgbW92ZWFibGUuc3RhdGUsIFtlLmRlbHRhWCwgZS5kZWx0YVldLCAhIWlzUGluY2gsIGZhbHNlLCBcInJlc2l6YWJsZVwiKSksIHsgcmVzb2x2ZU1hdHJpeDogdHJ1ZSwgcGFyZW50RGlzdGFuY2U6IHBhcmVudERpc3RhbmNlIH0pKTtcclxuICAgICAgICAgICAgaWYgKHJlc2l6ZUV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXNpemUgPSByZXNpemVFdmVudDtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUV2ZW50ID0gZmlsbEFmdGVyVHJhbnNmb3JtKHRyYW5zZm9ybUV2ZW50LCByZXNpemVFdmVudCwgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKF9fYXNzaWduKHsgZGVsdGE6IGRlbHRhLCBkaXN0OiBkaXN0LCByb3RhdGU6IHJvdGF0aW9uLCByb3RhdGlvbjogcm90YXRpb24sIGJlZm9yZURpc3Q6IGJlZm9yZURpc3QsIGJlZm9yZURlbHRhOiBiZWZvcmVEZWx0YSwgYmVmb3JlUm90YXRlOiBiZWZvcmVSb3RhdGlvbiwgYmVmb3JlUm90YXRpb246IGJlZm9yZVJvdGF0aW9uLCBhYnNvbHV0ZURpc3Q6IGFic29sdXRlRGlzdCwgYWJzb2x1dGVEZWx0YTogYWJzb2x1dGVEZWx0YSwgYWJzb2x1dGVSb3RhdGU6IGFic29sdXRlUm90YXRpb24sIGFic29sdXRlUm90YXRpb246IGFic29sdXRlUm90YXRpb24sIGlzUGluY2g6ICEhaXNQaW5jaCwgcmVzaXplOiByZXNpemUgfSwgZHJhZ0V2ZW50KSwgdHJhbnNmb3JtRXZlbnQpKTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVcIiwgcGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNSb3RhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhcy5pc1JvdGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm90YXRlRW5kXCIsIHBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sQ29uZGl0aW9uOiBkcmFnQ29udHJvbENvbmRpdGlvbixcclxuICAgIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSwgcGFyZW50TGVmdCA9IF9hLmxlZnQsIHBhcmVudFRvcCA9IF9hLnRvcCwgcGFyZW50QmVmb3JlT3JpZ2luID0gX2EuYmVmb3JlT3JpZ2luO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1zLnNldChkYXRhcy5iZWZvcmVEaXJlY3Rpb24gKiBtb3ZlYWJsZS5yb3RhdGlvbik7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sU3RhcnRcIiwgZSwgZnVuY3Rpb24gKGNoaWxkLCBldikge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBjaGlsZC5zdGF0ZSwgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcCwgYmVmb3JlT3JpZ2luID0gX2EuYmVmb3JlT3JpZ2luO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRDbGllbnQgPSBwbHVzKG1pbnVzKFtsZWZ0LCB0b3BdLCBbcGFyZW50TGVmdCwgcGFyZW50VG9wXSksIG1pbnVzKGJlZm9yZU9yaWdpbiwgcGFyZW50QmVmb3JlT3JpZ2luKSk7XHJcbiAgICAgICAgICAgIGV2LmRhdGFzLnN0YXJ0R3JvdXBDbGllbnQgPSBjaGlsZENsaWVudDtcclxuICAgICAgICAgICAgZXYuZGF0YXMuZ3JvdXBDbGllbnQgPSBjaGlsZENsaWVudDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHsgcGFyZW50Um90YXRlOiAwIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtcyksIHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cywgZXZlbnRzOiBldmVudHMgfSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdGF0ZUdyb3VwU3RhcnRcIiwgbmV4dFBhcmFtcyk7XHJcbiAgICAgICAgZGF0YXMuaXNSb3RhdGUgPSByZXN1bHQgIT09IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBkYXRhcy5pc1JvdGF0ZSA/IHBhcmFtcyA6IGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1JvdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSb3RhdGVcIiwgZnVuY3Rpb24gKHBhcmVudEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJvdGF0ZUdyb3VwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJlbnRFdmVudCksIHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyB9KSwgdHJ1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkYXRhcy5iZWZvcmVEaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIHBhcmVudFJvdGF0ZSA9IHBhcmFtcy5iZWZvcmVEaXN0O1xyXG4gICAgICAgIHZhciByYWQgPSBwYXJlbnRSb3RhdGUgLyAxODAgKiBNYXRoLlBJO1xyXG4gICAgICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbFwiLCBlLCBmdW5jdGlvbiAoXywgZXYpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0R3JvdXBDbGllbnQgPSBldi5kYXRhcy5zdGFydEdyb3VwQ2xpZW50O1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZXYuZGF0YXMuZ3JvdXBDbGllbnQsIDIpLCBwcmV2Q2xpZW50WCA9IF9hWzBdLCBwcmV2Q2xpZW50WSA9IF9hWzFdO1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQocm90YXRlKHN0YXJ0R3JvdXBDbGllbnQsIHJhZCAqIGRpcmVjdGlvbiksIDIpLCBjbGllbnRYID0gX2JbMF0sIGNsaWVudFkgPSBfYlsxXTtcclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gW2NsaWVudFggLSBwcmV2Q2xpZW50WCwgY2xpZW50WSAtIHByZXZDbGllbnRZXTtcclxuICAgICAgICAgICAgZXYuZGF0YXMuZ3JvdXBDbGllbnQgPSBbY2xpZW50WCwgY2xpZW50WV07XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7IHBhcmVudFJvdGF0ZTogcGFyZW50Um90YXRlLCBncm91cERlbHRhOiBkZWx0YSB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBtb3ZlYWJsZS5yb3RhdGlvbiA9IGRpcmVjdGlvbiAqIHBhcmFtcy5iZWZvcmVSb3RhdGlvbjtcclxuICAgICAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cywgZXZlbnRzOiBldmVudHMsIHNldDogZnVuY3Rpb24gKHJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlYWJsZS5yb3RhdGlvbiA9IHJvdGF0aW9uO1xyXG4gICAgICAgICAgICB9LCBzZXRHcm91cFJvdGF0aW9uOiBmdW5jdGlvbiAocm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIG1vdmVhYmxlLnJvdGF0aW9uID0gcm90YXRpb247XHJcbiAgICAgICAgICAgIH0gfSwgcGFyYW1zKTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVHcm91cFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV4dFBhcmFtcztcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgaXNEcmFnID0gZS5pc0RyYWcsIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICBpZiAoIWRhdGFzLmlzUm90YXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sRW5kXCIsIGUpO1xyXG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxyXG4gICAgICAgICAgICBldmVudHM6IGV2ZW50cyxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVHcm91cEVuZFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gaXNEcmFnO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBNb3ZlYWJsZS5Sb3RhdGFibGUjcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtlXSAtIHRoZSBSZXNpemFibGUncyByZXF1ZXN0IHBhcmFtZXRlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhUm90YXRlPTBdIC0gIGRlbHRhIG51bWJlciBvZiByb3RhdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLnJvdGF0ZT0wXSAtIGFic29sdXRlIG51bWJlciBvZiBtb3ZlYWJsZSdzIHJvdGF0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHtNb3ZlYWJsZS5SZXF1ZXN0ZXJ9IE1vdmVhYmxlIFJlcXVlc3RlclxyXG4gICAgICogQGV4YW1wbGVcclxuXG4gICAgICogLy8gSW5zdGFudGx5IFJlcXVlc3QgKHJlcXVlc3RTdGFydCAtIHJlcXVlc3QgLSByZXF1ZXN0RW5kKVxyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcInJvdGF0YWJsZVwiLCB7IGRlbHRhUm90YXRlOiAxMCB9LCB0cnVlKTtcclxuICAgICAqXHJcbiAgICAgKiAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyb3RhdGFibGVcIiwgeyByb3RhdGU6IDEwIH0sIHRydWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHJlcXVlc3RTdGFydFxyXG4gICAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcInJvdGF0YWJsZVwiKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyByZXF1ZXN0XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhUm90YXRlOiAxMCB9KTtcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFSb3RhdGU6IDEwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVJvdGF0ZTogMTAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyByb3RhdGU6IDEwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyByb3RhdGU6IDIwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyByb3RhdGU6IDMwIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIHJlcXVlc3RFbmRcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0RW5kKCk7XHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IHt9O1xyXG4gICAgICAgIHZhciBkaXN0Um90YXRlID0gMDtcclxuICAgICAgICB2YXIgc3RhcnRSb3RhdGlvbiA9IG1vdmVhYmxlLmdldFJvdGF0aW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXNDb250cm9sOiB0cnVlLFxyXG4gICAgICAgICAgICByZXF1ZXN0U3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGFzOiBkYXRhcyB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwiZGVsdGFSb3RhdGVcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFJvdGF0ZSArPSBlLmRlbHRhUm90YXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJyb3RhdGVcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFJvdGF0ZSA9IGUucm90YXRlIC0gc3RhcnRSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGFzOiBkYXRhcywgcGFyZW50RGlzdDogZGlzdFJvdGF0ZSB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhczogZGF0YXMsIGlzRHJhZzogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSByb3RhdGVkLiAoZGVmYXVsdDogZmFsc2UpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdGF0YWJsZSNyb3RhdGFibGVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUucm90YXRhYmxlID0gdHJ1ZTtcclxuICovXHJcbi8qKlxyXG4gKiBZb3UgY2FuIHNwZWNpZnkgdGhlIHBvc2l0aW9uIG9mIHRoZSByb3RhdGlvbi4gKGRlZmF1bHQ6IFwidG9wXCIpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdGF0YWJsZSNyb3RhdGlvblBvc2l0aW9uXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgIHJvdGF0aW9uUG9zaXRpb246IFwidG9wXCIsXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5yb3RhdGlvblBvc2l0aW9uID0gXCJib3R0b21cIlxyXG4gKi9cclxuLyoqXHJcbiAqIHRocm90dGxlIG9mIGFuZ2xlKGRlZ3JlZSkgd2hlbiByb3RhdGUuXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdGF0YWJsZSN0aHJvdHRsZVJvdGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS50aHJvdHRsZVJvdGF0ZSA9IDE7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgcm90YXRlIHN0YXJ0cywgdGhlIHJvdGF0ZVN0YXJ0IGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdGF0YWJsZVxyXG4gKiBAZXZlbnQgcm90YXRlU3RhcnRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3RhdGFibGUuT25Sb3RhdGVTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcm90YXRlU3RhcnQgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJvdGF0YWJsZTogdHJ1ZSB9KTtcclxuICogbW92ZWFibGUub24oXCJyb3RhdGVTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuKiBXaGVuIHJvdGF0aW5nLCB0aGUgcm90YXRlIGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUm90YXRhYmxlXHJcbiogQGV2ZW50IHJvdGF0ZVxyXG4qIEBwYXJhbSB7TW92ZWFibGUuUm90YXRhYmxlLk9uUm90YXRlfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByb3RhdGUgZXZlbnRcclxuKiBAZXhhbXBsZVxyXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuKlxyXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgcm90YXRhYmxlOiB0cnVlIH0pO1xyXG4qIG1vdmVhYmxlLm9uKFwicm90YXRlXCIsICh7IHRhcmdldCwgdHJhbnNmb3JtLCBkaXN0IH0pID0+IHtcclxuKiAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuKiB9KTtcclxuKi9cclxuLyoqXHJcbiAqIFdoZW4gdGhlIHJvdGF0ZSBmaW5pc2hlcywgdGhlIHJvdGF0ZUVuZCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcclxuICogQGV2ZW50IHJvdGF0ZUVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZUVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcm90YXRlRW5kIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByb3RhdGFibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlRW5kXCIsICh7IHRhcmdldCwgaXNEcmFnIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCwgaXNEcmFnKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgZ3JvdXAgcm90YXRlIHN0YXJ0cywgdGhlIGByb3RhdGVHcm91cFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcclxuICogQGV2ZW50IHJvdGF0ZUdyb3VwU3RhcnRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3RhdGFibGUuT25Sb3RhdGVHcm91cFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm90YXRlR3JvdXBTdGFydGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4gKiAgICAgcm90YXRhYmxlOiB0cnVlXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJvdGF0ZUdyb3VwU3RhcnRcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUm90YXRlR3JvdXBTdGFydFwiLCB0YXJnZXRzKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuKiBXaGVuIHRoZSBncm91cCByb3RhdGUsIHRoZSBgcm90YXRlR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUm90YXRhYmxlXHJcbiogQGV2ZW50IHJvdGF0ZUdyb3VwXHJcbiogQHBhcmFtIHtNb3ZlYWJsZS5Sb3RhdGFibGUuT25Sb3RhdGVHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdGF0ZUdyb3VwYCBldmVudFxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4qICAgICByb3RhdGFibGU6IHRydWVcclxuKiB9KTtcclxuKiBtb3ZlYWJsZS5vbihcInJvdGF0ZUdyb3VwXCIsICh7IHRhcmdldHMsIGV2ZW50cyB9KSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKFwib25Sb3RhdGVHcm91cFwiLCB0YXJnZXRzKTtcclxuKiAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xyXG4qICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4qICAgICAgICAgLy8gZXYuZHJhZyBpcyBhIGRyYWcgZXZlbnQgdGhhdCBvY2N1cnMgd2hlbiB0aGUgZ3JvdXAgcm90YXRlLlxyXG4qICAgICAgICAgY29uc3QgbGVmdCA9IGV2LmRyYWcuYmVmb3JlRGlzdFswXTtcclxuKiAgICAgICAgIGNvbnN0IHRvcCA9IGV2LmRyYWcuYmVmb3JlRGlzdFsxXTtcclxuKiAgICAgICAgIGNvbnN0IGRlZyA9IGV2LmJlZm9yZURpc3Q7XHJcbiogICAgIH0pO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuICogV2hlbiB0aGUgZ3JvdXAgcm90YXRlIGZpbmlzaGVzLCB0aGUgYHJvdGF0ZUdyb3VwRW5kYCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcclxuICogQGV2ZW50IHJvdGF0ZUdyb3VwRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm90YXRhYmxlLk9uUm90YXRlR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3RhdGVHcm91cEVuZGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4gKiAgICAgcm90YXRhYmxlOiB0cnVlXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJvdGF0ZUdyb3VwRW5kXCIsICh7IHRhcmdldHMsIGlzRHJhZyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUm90YXRlR3JvdXBFbmRcIiwgdGFyZ2V0cywgaXNEcmFnKTtcclxuICogfSk7XHJcbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJHdWlkZWxpbmUoaW5mbywgUmVhY3QpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBkaXJlY3Rpb24gPSBpbmZvLmRpcmVjdGlvbiwgY2xhc3NOYW1lcyA9IGluZm8uY2xhc3NOYW1lcywgc2l6ZSA9IGluZm8uc2l6ZSwgcG9zID0gaW5mby5wb3MsIHpvb20gPSBpbmZvLnpvb20sIGtleSA9IGluZm8ua2V5O1xyXG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XHJcbiAgICB2YXIgc2NhbGVUeXBlID0gaXNIb3Jpem9udGFsID8gXCJZXCIgOiBcIlhcIjtcclxuICAgIC8vIGNvbnN0IHNjYWxlVHlwZTIgPSBpc0hvcml6b250YWwgPyBcIllcIiA6IFwiWFwiO1xyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xyXG4gICAgICAgIGtleToga2V5LFxyXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKFwiIFwiKSxcclxuICAgICAgICBzdHlsZTogKF9hID0ge30sXHJcbiAgICAgICAgICAgIF9hW2lzSG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdID0gXCJcIi5jb25jYXQoc2l6ZSksXHJcbiAgICAgICAgICAgIF9hLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChwb3NbMF0sIFwiLCBcIikuY29uY2F0KHBvc1sxXSwgXCIpIHRyYW5zbGF0ZVwiKS5jb25jYXQoc2NhbGVUeXBlLCBcIigtNTAlKSBzY2FsZVwiKS5jb25jYXQoc2NhbGVUeXBlLCBcIihcIikuY29uY2F0KHpvb20sIFwiKVwiKSxcclxuICAgICAgICAgICAgX2EpLFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVySW5uZXJHdWlkZWxpbmUoaW5mbywgUmVhY3QpIHtcclxuICAgIHJldHVybiByZW5kZXJHdWlkZWxpbmUoX19hc3NpZ24oX19hc3NpZ24oe30sIGluZm8pLCB7IGNsYXNzTmFtZXM6IF9fc3ByZWFkQXJyYXkoW1xyXG4gICAgICAgICAgICBwcmVmaXgoXCJsaW5lXCIsIFwiZ3VpZGVsaW5lXCIsIGluZm8uZGlyZWN0aW9uKVxyXG4gICAgICAgIF0sIF9fcmVhZChpbmZvLmNsYXNzTmFtZXMpLCBmYWxzZSkuZmlsdGVyKGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuIGNsYXNzTmFtZTsgfSksIHNpemU6IGluZm8uc2l6ZSB8fCBcIlwiLmNvbmNhdChpbmZvLnNpemVWYWx1ZSwgXCJweFwiKSwgcG9zOiBpbmZvLnBvcyB8fCBpbmZvLnBvc1ZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gXCJcIi5jb25jYXQodGhyb3R0bGUodiwgMC4xKSwgXCJweFwiKTsgfSkgfSksIFJlYWN0KTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJTbmFwUG9zZXMobW92ZWFibGUsIGRpcmVjdGlvbiwgc25hcFBvc2VzLCBtaW5Qb3MsIHRhcmdldFBvcywgc2l6ZSwgaW5kZXgsIFJlYWN0KSB7XHJcbiAgICB2YXIgem9vbSA9IG1vdmVhYmxlLnByb3BzLnpvb207XHJcbiAgICByZXR1cm4gc25hcFBvc2VzLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIHBvcyA9IF9hLnBvcztcclxuICAgICAgICB2YXIgcmVuZGVyUG9zID0gWzAsIDBdO1xyXG4gICAgICAgIHJlbmRlclBvc1tpbmRleF0gPSBtaW5Qb3M7XHJcbiAgICAgICAgcmVuZGVyUG9zW2luZGV4ID8gMCA6IDFdID0gLXRhcmdldFBvcyArIHBvcztcclxuICAgICAgICByZXR1cm4gcmVuZGVySW5uZXJHdWlkZWxpbmUoe1xyXG4gICAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KGRpcmVjdGlvbiwgXCJUYXJnZXRHdWlkZWxpbmVcIikuY29uY2F0KGkpLFxyXG4gICAgICAgICAgICBjbGFzc05hbWVzOiBbcHJlZml4KFwidGFyZ2V0XCIsIFwiYm9sZFwiLCB0eXBlKV0sXHJcbiAgICAgICAgICAgIHBvc1ZhbHVlOiByZW5kZXJQb3MsXHJcbiAgICAgICAgICAgIHNpemVWYWx1ZTogc2l6ZSxcclxuICAgICAgICAgICAgem9vbTogem9vbSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXHJcbiAgICAgICAgfSwgUmVhY3QpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyR3VpZGVsaW5lcyhtb3ZlYWJsZSwgdHlwZSwgZ3VpZGVsaW5lcywgdGFyZ2V0UG9zLCB0YXJnZXRSZWN0LCBSZWFjdCkge1xyXG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsIHpvb20gPSBfYS56b29tLCBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCA9IF9hLmlzRGlzcGxheUlubmVyU25hcERpZ2l0O1xyXG4gICAgdmFyIG1haW5OYW1lcyA9IHR5cGUgPT09IFwiaG9yaXpvbnRhbFwiID8gVkVSVElDQUxfTkFNRVNfTUFQIDogSE9SSVpPTlRBTF9OQU1FU19NQVA7XHJcbiAgICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5zdGFydF07XHJcbiAgICB2YXIgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuZW5kXTtcclxuICAgIHJldHVybiBndWlkZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGlkZSA9IF9hLmhpZGUsIGVsZW1lbnRSZWN0ID0gX2EuZWxlbWVudFJlY3Q7XHJcbiAgICAgICAgaWYgKGhpZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQgJiYgZWxlbWVudFJlY3QpIHtcclxuICAgICAgICAgICAgLy8gaW5uZXJcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50UmVjdC5yZWN0O1xyXG4gICAgICAgICAgICBpZiAocmVjdFttYWluTmFtZXMuc3RhcnRdIDw9IHRhcmdldFN0YXJ0ICYmIHRhcmdldEVuZCA8PSByZWN0W21haW5OYW1lcy5lbmRdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGd1aWRlbGluZSwgaSkge1xyXG4gICAgICAgIHZhciBwb3MgPSBndWlkZWxpbmUucG9zLCBzaXplID0gZ3VpZGVsaW5lLnNpemUsIGVsZW1lbnQgPSBndWlkZWxpbmUuZWxlbWVudCwgY2xhc3NOYW1lID0gZ3VpZGVsaW5lLmNsYXNzTmFtZTtcclxuICAgICAgICB2YXIgcmVuZGVyUG9zID0gW1xyXG4gICAgICAgICAgICAtdGFyZ2V0UG9zWzBdICsgcG9zWzBdLFxyXG4gICAgICAgICAgICAtdGFyZ2V0UG9zWzFdICsgcG9zWzFdLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcklubmVyR3VpZGVsaW5lKHtcclxuICAgICAgICAgICAga2V5OiBcIlwiLmNvbmNhdCh0eXBlLCBcIi1kZWZhdWx0LWd1aWRlbGluZS1cIikuY29uY2F0KGkpLFxyXG4gICAgICAgICAgICBjbGFzc05hbWVzOiBlbGVtZW50ID8gW3ByZWZpeChcImJvbGRcIiksIGNsYXNzTmFtZV0gOiBbcHJlZml4KFwibm9ybWFsXCIpLCBjbGFzc05hbWVdLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IHR5cGUsXHJcbiAgICAgICAgICAgIHBvc1ZhbHVlOiByZW5kZXJQb3MsXHJcbiAgICAgICAgICAgIHNpemVWYWx1ZTogc2l6ZSxcclxuICAgICAgICAgICAgem9vbTogem9vbSxcclxuICAgICAgICB9LCBSZWFjdCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIHR5cGUsIGxpbmVUeXBlLCBpbmRleCwgZ2FwLCByZW5kZXJQb3MsIGNsYXNzTmFtZSwgUmVhY3QpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBfYiA9IG1vdmVhYmxlLnByb3BzLCBfYyA9IF9iLnNuYXBEaWdpdCwgc25hcERpZ2l0ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYywgX2QgPSBfYi5pc0Rpc3BsYXlTbmFwRGlnaXQsIGlzRGlzcGxheVNuYXBEaWdpdCA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsIF9lID0gX2Iuc25hcERpc3RGb3JtYXQsIHNuYXBEaXN0Rm9ybWF0ID0gX2UgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh2LCB0eXBlKSB7XHJcbiAgICAgICAgLy8gVHlwZSBjYW4gYmUgdXNlZCByZW5kZXIgZGlmZmVyZW50IHZhbHVlcy5cclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9IDogX2UsIHpvb20gPSBfYi56b29tO1xyXG4gICAgdmFyIHNjYWxlVHlwZSA9IHR5cGUgPT09IFwiaG9yaXpvbnRhbFwiID8gXCJYXCIgOiBcIllcIjtcclxuICAgIHZhciBzaXplTmFtZSA9IHR5cGUgPT09IFwidmVydGljYWxcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XHJcbiAgICB2YXIgYWJzR2FwID0gTWF0aC5hYnMoZ2FwKTtcclxuICAgIHZhciBzbmFwU2l6ZSA9IGlzRGlzcGxheVNuYXBEaWdpdFxyXG4gICAgICAgID8gcGFyc2VGbG9hdChhYnNHYXAudG9GaXhlZChzbmFwRGlnaXQpKVxyXG4gICAgICAgIDogMDtcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcIlwiLmNvbmNhdCh0eXBlLCBcIi1cIikuY29uY2F0KGxpbmVUeXBlLCBcIi1ndWlkZWxpbmUtXCIpLmNvbmNhdChpbmRleCksIGNsYXNzTmFtZTogcHJlZml4KFwiZ3VpZGVsaW5lLWdyb3VwXCIsIHR5cGUpLCBzdHlsZTogKF9hID0ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogXCJcIi5jb25jYXQocmVuZGVyUG9zWzBdLCBcInB4XCIpLFxyXG4gICAgICAgICAgICAgICAgdG9wOiBcIlwiLmNvbmNhdChyZW5kZXJQb3NbMV0sIFwicHhcIilcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX2Fbc2l6ZU5hbWVdID0gXCJcIi5jb25jYXQoYWJzR2FwLCBcInB4XCIpLFxyXG4gICAgICAgICAgICBfYSkgfSxcclxuICAgICAgICByZW5kZXJJbm5lckd1aWRlbGluZSh7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdHlwZSxcclxuICAgICAgICAgICAgY2xhc3NOYW1lczogW3ByZWZpeChsaW5lVHlwZSksIGNsYXNzTmFtZV0sXHJcbiAgICAgICAgICAgIHNpemU6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBwb3NWYWx1ZTogWzAsIDBdLFxyXG4gICAgICAgICAgICBzaXplVmFsdWU6IGFic0dhcCxcclxuICAgICAgICAgICAgem9vbTogem9vbSxcclxuICAgICAgICB9LCBSZWFjdCksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogcHJlZml4KFwic2l6ZS12YWx1ZVwiLCBcImdhcFwiKSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVcIi5jb25jYXQoc2NhbGVUeXBlLCBcIigtNTAlKSBzY2FsZShcIikuY29uY2F0KHpvb20sIFwiKVwiKSxcclxuICAgICAgICAgICAgfSB9LCBzbmFwU2l6ZSA+IDAgPyBzbmFwRGlzdEZvcm1hdChzbmFwU2l6ZSwgdHlwZSkgOiBcIlwiKSk7XHJcbn1cclxuZnVuY3Rpb24gZ3JvdXBCeUVsZW1lbnRHdWlkZWxpbmVzKHR5cGUsIGd1aWRlbGluZXMsIHRhcmdldFJlY3QsIGlzRGlzcGxheUlubmVyU25hcERpZ2l0KSB7XHJcbiAgICB2YXIgaW5kZXggPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyAwIDogMTtcclxuICAgIHZhciBvdGhlckluZGV4ID0gdHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gMSA6IDA7XHJcbiAgICB2YXIgbmFtZXMgPSBpbmRleCA/IFZFUlRJQ0FMX05BTUVTX01BUCA6IEhPUklaT05UQUxfTkFNRVNfTUFQO1xyXG4gICAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFtuYW1lcy5zdGFydF07XHJcbiAgICB2YXIgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFtuYW1lcy5lbmRdO1xyXG4gICAgcmV0dXJuIGdyb3VwQnkoZ3VpZGVsaW5lcywgZnVuY3Rpb24gKGd1aWRlbGluZSkge1xyXG4gICAgICAgIHJldHVybiBndWlkZWxpbmUucG9zW2luZGV4XTtcclxuICAgIH0pLm1hcChmdW5jdGlvbiAobmV4dEd1aWRlbGluZXMpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBbXTtcclxuICAgICAgICB2YXIgZW5kID0gW107XHJcbiAgICAgICAgdmFyIGlubmVyID0gW107XHJcbiAgICAgICAgbmV4dEd1aWRlbGluZXMuZm9yRWFjaChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZ3VpZGVsaW5lLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gZ3VpZGVsaW5lLmVsZW1lbnRSZWN0LnJlY3Q7XHJcbiAgICAgICAgICAgIGlmIChyZWN0W25hbWVzLmVuZF0gPCB0YXJnZXRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQucHVzaChndWlkZWxpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldEVuZCA8IHJlY3RbbmFtZXMuc3RhcnRdKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQucHVzaChndWlkZWxpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY3RbbmFtZXMuc3RhcnRdIDw9IHRhcmdldFN0YXJ0ICYmIHRhcmdldEVuZCA8PSByZWN0W25hbWVzLmVuZF0gJiYgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBndWlkZWxpbmUucG9zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRSZWN0MSA9IHsgZWxlbWVudDogZWxlbWVudCwgcmVjdDogX19hc3NpZ24oX19hc3NpZ24oe30sIHJlY3QpLCAoX2EgPSB7fSwgX2FbbmFtZXMuZW5kXSA9IHJlY3RbbmFtZXMuc3RhcnRdLCBfYSkpIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFJlY3QyID0geyBlbGVtZW50OiBlbGVtZW50LCByZWN0OiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVjdCksIChfYiA9IHt9LCBfYltuYW1lcy5zdGFydF0gPSByZWN0W25hbWVzLmVuZF0sIF9iKSkgfTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0UG9zMSA9IFswLCAwXTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0UG9zMiA9IFswLCAwXTtcclxuICAgICAgICAgICAgICAgIG5leHRQb3MxW2luZGV4XSA9IHBvc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICBuZXh0UG9zMVtvdGhlckluZGV4XSA9IHBvc1tvdGhlckluZGV4XTtcclxuICAgICAgICAgICAgICAgIG5leHRQb3MyW2luZGV4XSA9IHBvc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICBuZXh0UG9zMltvdGhlckluZGV4XSA9IHBvc1tvdGhlckluZGV4XSArIGd1aWRlbGluZS5zaXplO1xyXG4gICAgICAgICAgICAgICAgc3RhcnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBwb3M6IG5leHRQb3MxLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFJlY3Q6IGVsZW1lbnRSZWN0MSxcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudERpcmVjdGlvbjogXCJlbmRcIixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZW5kLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBuZXh0UG9zMixcclxuICAgICAgICAgICAgICAgICAgICBzaXplOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRSZWN0OiBlbGVtZW50UmVjdDIsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnREaXJlY3Rpb246IFwic3RhcnRcIixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5uZXIucHVzaChndWlkZWxpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RhcnQuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5wb3Nbb3RoZXJJbmRleF0gLSBhLnBvc1tvdGhlckluZGV4XTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBlbmQuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5wb3Nbb3RoZXJJbmRleF0gLSBiLnBvc1tvdGhlckluZGV4XTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b3RhbDogbmV4dEd1aWRlbGluZXMsXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgZW5kOiBlbmQsXHJcbiAgICAgICAgICAgIGlubmVyOiBpbm5lcixcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyRGFzaGVkR3VpZGVsaW5lcyhtb3ZlYWJsZSwgZ3VpZGVsaW5lcywgdGFyZ2V0UG9zLCB0YXJnZXRSZWN0LCBSZWFjdCkge1xyXG4gICAgdmFyIGlzRGlzcGxheUlubmVyU25hcERpZ2l0ID0gbW92ZWFibGUucHJvcHMuaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQ7XHJcbiAgICB2YXIgcmVuZGVyZWQgPSBbXTtcclxuICAgIFtcInZlcnRpY2FsXCIsIFwiaG9yaXpvbnRhbFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIG5leHRHdWlkZWxpbmVzID0gZ3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGd1aWRlbGluZSkgeyByZXR1cm4gZ3VpZGVsaW5lLnR5cGUgPT09IHR5cGU7IH0pO1xyXG4gICAgICAgIHZhciBpbmRleCA9IHR5cGUgPT09IFwidmVydGljYWxcIiA/IDEgOiAwO1xyXG4gICAgICAgIHZhciBvdGhlckluZGV4ID0gaW5kZXggPyAwIDogMTtcclxuICAgICAgICB2YXIgZ3JvdXBzID0gZ3JvdXBCeUVsZW1lbnRHdWlkZWxpbmVzKHR5cGUsIG5leHRHdWlkZWxpbmVzLCB0YXJnZXRSZWN0LCBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCk7XHJcbiAgICAgICAgdmFyIG1haW5OYW1lcyA9IGluZGV4ID8gSE9SSVpPTlRBTF9OQU1FU19NQVAgOiBWRVJUSUNBTF9OQU1FU19NQVA7XHJcbiAgICAgICAgdmFyIHNpZGVOYW1lcyA9IGluZGV4ID8gVkVSVElDQUxfTkFNRVNfTUFQIDogSE9SSVpPTlRBTF9OQU1FU19NQVA7XHJcbiAgICAgICAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuc3RhcnRdO1xyXG4gICAgICAgIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5lbmRdO1xyXG4gICAgICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgdG90YWwgPSBfYS50b3RhbCwgc3RhcnQgPSBfYS5zdGFydCwgZW5kID0gX2EuZW5kLCBpbm5lciA9IF9hLmlubmVyO1xyXG4gICAgICAgICAgICB2YXIgc2lkZVBvcyA9IHRhcmdldFBvc1tvdGhlckluZGV4XSArIHRvdGFsWzBdLnBvc1tvdGhlckluZGV4XSAtIHRhcmdldFJlY3Rbc2lkZU5hbWVzLnN0YXJ0XTtcclxuICAgICAgICAgICAgdmFyIHByZXZSZWN0ID0gdGFyZ2V0UmVjdDtcclxuICAgICAgICAgICAgc3RhcnQuZm9yRWFjaChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFJlY3QgPSBndWlkZWxpbmUuZWxlbWVudFJlY3QucmVjdDtcclxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gcHJldlJlY3RbbWFpbk5hbWVzLnN0YXJ0XSAtIG5leHRSZWN0W21haW5OYW1lcy5lbmRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmRlclBvcyA9IFswLCAwXTtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJQb3NbaW5kZXhdID0gdGFyZ2V0UG9zW2luZGV4XSArIHByZXZSZWN0W21haW5OYW1lcy5zdGFydF0gLSB0YXJnZXRTdGFydCAtIHNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyUG9zW290aGVySW5kZXhdID0gc2lkZVBvcztcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZC5wdXNoKHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgdHlwZSwgXCJkYXNoZWRcIiwgcmVuZGVyZWQubGVuZ3RoLCBzaXplLCByZW5kZXJQb3MsIGd1aWRlbGluZS5jbGFzc05hbWUsIFJlYWN0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmV2UmVjdCA9IG5leHRSZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcHJldlJlY3QgPSB0YXJnZXRSZWN0O1xyXG4gICAgICAgICAgICBlbmQuZm9yRWFjaChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFJlY3QgPSBndWlkZWxpbmUuZWxlbWVudFJlY3QucmVjdDtcclxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gbmV4dFJlY3RbbWFpbk5hbWVzLnN0YXJ0XSAtIHByZXZSZWN0W21haW5OYW1lcy5lbmRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmRlclBvcyA9IFswLCAwXTtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJQb3NbaW5kZXhdID0gdGFyZ2V0UG9zW2luZGV4XSArIHByZXZSZWN0W21haW5OYW1lcy5lbmRdIC0gdGFyZ2V0U3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyUG9zW290aGVySW5kZXhdID0gc2lkZVBvcztcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZC5wdXNoKHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgdHlwZSwgXCJkYXNoZWRcIiwgcmVuZGVyZWQubGVuZ3RoLCBzaXplLCByZW5kZXJQb3MsIGd1aWRlbGluZS5jbGFzc05hbWUsIFJlYWN0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmV2UmVjdCA9IG5leHRSZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaW5uZXIuZm9yRWFjaChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFJlY3QgPSBndWlkZWxpbmUuZWxlbWVudFJlY3QucmVjdDtcclxuICAgICAgICAgICAgICAgIHZhciBzaXplMSA9IHRhcmdldFN0YXJ0IC0gbmV4dFJlY3RbbWFpbk5hbWVzLnN0YXJ0XTtcclxuICAgICAgICAgICAgICAgIHZhciBzaXplMiA9IG5leHRSZWN0W21haW5OYW1lcy5lbmRdIC0gdGFyZ2V0RW5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlclBvczEgPSBbMCwgMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyUG9zMiA9IFswLCAwXTtcclxuICAgICAgICAgICAgICAgIHJlbmRlclBvczFbaW5kZXhdID0gdGFyZ2V0UG9zW2luZGV4XSAtIHNpemUxO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyUG9zMVtvdGhlckluZGV4XSA9IHNpZGVQb3M7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJQb3MyW2luZGV4XSA9IHRhcmdldFBvc1tpbmRleF0gKyB0YXJnZXRFbmQgLSB0YXJnZXRTdGFydDtcclxuICAgICAgICAgICAgICAgIHJlbmRlclBvczJbb3RoZXJJbmRleF0gPSBzaWRlUG9zO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQucHVzaChyZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIHR5cGUsIFwiZGFzaGVkXCIsIHJlbmRlcmVkLmxlbmd0aCwgc2l6ZTEsIHJlbmRlclBvczEsIGd1aWRlbGluZS5jbGFzc05hbWUsIFJlYWN0KSk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZC5wdXNoKHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgdHlwZSwgXCJkYXNoZWRcIiwgcmVuZGVyZWQubGVuZ3RoLCBzaXplMiwgcmVuZGVyUG9zMiwgZ3VpZGVsaW5lLmNsYXNzTmFtZSwgUmVhY3QpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZW5kZXJlZDtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJHYXBHdWlkZWxpbmVzKG1vdmVhYmxlLCBndWlkZWxpbmVzLCB0YXJnZXRQb3MsIHRhcmdldFJlY3QsIFJlYWN0KSB7XHJcbiAgICB2YXIgcmVuZGVyZWQgPSBbXTtcclxuICAgIFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIG5leHRHdWlkZWxpbmVzID0gZ3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGd1aWRlbGluZSkgeyByZXR1cm4gZ3VpZGVsaW5lLnR5cGUgPT09IHR5cGU7IH0pLnNsaWNlKDAsIDEpO1xyXG4gICAgICAgIHZhciBpbmRleCA9IHR5cGUgPT09IFwidmVydGljYWxcIiA/IDAgOiAxO1xyXG4gICAgICAgIHZhciBvdGhlckluZGV4ID0gaW5kZXggPyAwIDogMTtcclxuICAgICAgICB2YXIgbWFpbk5hbWVzID0gaW5kZXggPyBIT1JJWk9OVEFMX05BTUVTX01BUCA6IFZFUlRJQ0FMX05BTUVTX01BUDtcclxuICAgICAgICB2YXIgc2lkZU5hbWVzID0gaW5kZXggPyBWRVJUSUNBTF9OQU1FU19NQVAgOiBIT1JJWk9OVEFMX05BTUVTX01BUDtcclxuICAgICAgICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5zdGFydF07XHJcbiAgICAgICAgdmFyIHRhcmdldEVuZCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLmVuZF07XHJcbiAgICAgICAgdmFyIHRhcmdldFNpZGVTdGFydCA9IHRhcmdldFJlY3Rbc2lkZU5hbWVzLnN0YXJ0XTtcclxuICAgICAgICB2YXIgdGFyZ2V0U2lkZUVuZCA9IHRhcmdldFJlY3Rbc2lkZU5hbWVzLmVuZF07XHJcbiAgICAgICAgbmV4dEd1aWRlbGluZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIGdhcCA9IF9hLmdhcCwgZ2FwUmVjdHMgPSBfYS5nYXBSZWN0cztcclxuICAgICAgICAgICAgdmFyIHNpZGVTdGFydFBvcyA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW3RhcmdldFNpZGVTdGFydF0sIF9fcmVhZChnYXBSZWN0cy5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IF9hLnJlY3Q7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFtzaWRlTmFtZXMuc3RhcnRdO1xyXG4gICAgICAgICAgICB9KSksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIHZhciBzaWRlRW5kUG9zID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX19zcHJlYWRBcnJheShbdGFyZ2V0U2lkZUVuZF0sIF9fcmVhZChnYXBSZWN0cy5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IF9hLnJlY3Q7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFtzaWRlTmFtZXMuZW5kXTtcclxuICAgICAgICAgICAgfSkpLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICB2YXIgc2lkZUNlbnRlclBvcyA9IChzaWRlU3RhcnRQb3MgKyBzaWRlRW5kUG9zKSAvIDI7XHJcbiAgICAgICAgICAgIGlmIChzaWRlU3RhcnRQb3MgPT09IHNpZGVFbmRQb3MgfHwgc2lkZUNlbnRlclBvcyA9PT0gKHRhcmdldFNpZGVTdGFydCArIHRhcmdldFNpZGVFbmQpIC8gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdhcFJlY3RzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IF9hLnJlY3QsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciByZW5kZXJQb3MgPSBbdGFyZ2V0UG9zWzBdLCB0YXJnZXRQb3NbMV1dO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY3RbbWFpbk5hbWVzLmVuZF0gPCB0YXJnZXRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclBvc1tpbmRleF0gKz0gcmVjdFttYWluTmFtZXMuZW5kXSAtIHRhcmdldFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RW5kIDwgcmVjdFttYWluTmFtZXMuc3RhcnRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyUG9zW2luZGV4XSArPSByZWN0W21haW5OYW1lcy5zdGFydF0gLSB0YXJnZXRTdGFydCAtIGdhcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbmRlclBvc1tvdGhlckluZGV4XSArPSBzaWRlQ2VudGVyUG9zIC0gdGFyZ2V0U2lkZVN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQucHVzaChyZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIGluZGV4ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIsIFwiZ2FwXCIsIHJlbmRlcmVkLmxlbmd0aCwgZ2FwLCByZW5kZXJQb3MsIGNsYXNzTmFtZSwgUmVhY3QpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZW5kZXJlZDtcclxufVxuXG5mdW5jdGlvbiBnZXRUb3RhbEd1aWRlbGluZXMobW92ZWFibGUpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgIHZhciBjb250YWluZXJDbGllbnRSZWN0ID0gc3RhdGUuY29udGFpbmVyQ2xpZW50UmVjdCwgaGFzRml4ZWQgPSBzdGF0ZS5oYXNGaXhlZDtcclxuICAgIHZhciBvdmVyZmxvdyA9IGNvbnRhaW5lckNsaWVudFJlY3Qub3ZlcmZsb3csIGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lckNsaWVudFJlY3Quc2Nyb2xsSGVpZ2h0LCBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lckNsaWVudFJlY3Quc2Nyb2xsV2lkdGgsIGNvbnRhaW5lckNsaWVudEhlaWdodCA9IGNvbnRhaW5lckNsaWVudFJlY3QuY2xpZW50SGVpZ2h0LCBjb250YWluZXJDbGllbnRXaWR0aCA9IGNvbnRhaW5lckNsaWVudFJlY3QuY2xpZW50V2lkdGgsIGNsaWVudExlZnQgPSBjb250YWluZXJDbGllbnRSZWN0LmNsaWVudExlZnQsIGNsaWVudFRvcCA9IGNvbnRhaW5lckNsaWVudFJlY3QuY2xpZW50VG9wO1xyXG4gICAgdmFyIF9jID0gbW92ZWFibGUucHJvcHMsIF9kID0gX2Muc25hcEdhcCwgc25hcEdhcCA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsIHZlcnRpY2FsR3VpZGVsaW5lcyA9IF9jLnZlcnRpY2FsR3VpZGVsaW5lcywgaG9yaXpvbnRhbEd1aWRlbGluZXMgPSBfYy5ob3Jpem9udGFsR3VpZGVsaW5lcywgX2UgPSBfYy5zbmFwVGhyZXNob2xkLCBzbmFwVGhyZXNob2xkID0gX2UgPT09IHZvaWQgMCA/IDUgOiBfZSwgX2YgPSBfYy5tYXhTbmFwRWxlbWVudEd1aWRlbGluZURpc3RhbmNlLCBtYXhTbmFwRWxlbWVudEd1aWRlbGluZURpc3RhbmNlID0gX2YgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2YsIGlzRGlzcGxheUdyaWRHdWlkZWxpbmVzID0gX2MuaXNEaXNwbGF5R3JpZEd1aWRlbGluZXM7XHJcbiAgICB2YXIgX2cgPSBnZXRSZWN0KGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKSksIHRvcCA9IF9nLnRvcCwgbGVmdCA9IF9nLmxlZnQsIGJvdHRvbSA9IF9nLmJvdHRvbSwgcmlnaHQgPSBfZy5yaWdodDtcclxuICAgIHZhciB0YXJnZXRSZWN0ID0geyB0b3A6IHRvcCwgbGVmdDogbGVmdCwgYm90dG9tOiBib3R0b20sIHJpZ2h0OiByaWdodCwgY2VudGVyOiAobGVmdCArIHJpZ2h0KSAvIDIsIG1pZGRsZTogKHRvcCArIGJvdHRvbSkgLyAyIH07XHJcbiAgICB2YXIgZWxlbWVudEd1aWRlbGluZXMgPSBnZXRFbGVtZW50R3VpZGVsaW5lcyhtb3ZlYWJsZSk7XHJcbiAgICB2YXIgdG90YWxHdWlkZWxpbmVzID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGVsZW1lbnRHdWlkZWxpbmVzKSwgZmFsc2UpO1xyXG4gICAgdmFyIHNuYXBUaHJlc2hvbGRNdWx0aXBsZXMgPSAoKF9iID0gKF9hID0gc3RhdGUuc25hcFRocmVzaG9sZEluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tdWx0aXBsZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFsxLCAxXSkubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuICogc25hcFRocmVzaG9sZDsgfSk7XHJcbiAgICBpZiAoc25hcEdhcCkge1xyXG4gICAgICAgIHRvdGFsR3VpZGVsaW5lcy5wdXNoLmFwcGx5KHRvdGFsR3VpZGVsaW5lcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGdldEdhcEd1aWRlbGluZXMobW92ZWFibGUsIHRhcmdldFJlY3QsIHNuYXBUaHJlc2hvbGRNdWx0aXBsZXMpKSwgZmFsc2UpKTtcclxuICAgIH1cclxuICAgIHZhciBzbmFwT2Zmc2V0ID0gX19hc3NpZ24oe30sIChzdGF0ZS5zbmFwT2Zmc2V0IHx8IHtcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICB9KSk7XHJcbiAgICB0b3RhbEd1aWRlbGluZXMucHVzaC5hcHBseSh0b3RhbEd1aWRlbGluZXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChnZXRHcmlkR3VpZGVsaW5lcyhtb3ZlYWJsZSwgb3ZlcmZsb3cgPyBjb250YWluZXJXaWR0aCA6IGNvbnRhaW5lckNsaWVudFdpZHRoLCBvdmVyZmxvdyA/IGNvbnRhaW5lckhlaWdodCA6IGNvbnRhaW5lckNsaWVudEhlaWdodCwgY2xpZW50TGVmdCwgY2xpZW50VG9wLCBzbmFwT2Zmc2V0LCBpc0Rpc3BsYXlHcmlkR3VpZGVsaW5lcykpLCBmYWxzZSkpO1xyXG4gICAgaWYgKGhhc0ZpeGVkKSB7XHJcbiAgICAgICAgdmFyIGxlZnRfMSA9IGNvbnRhaW5lckNsaWVudFJlY3QubGVmdCwgdG9wXzEgPSBjb250YWluZXJDbGllbnRSZWN0LnRvcDtcclxuICAgICAgICBzbmFwT2Zmc2V0LmxlZnQgKz0gbGVmdF8xO1xyXG4gICAgICAgIHNuYXBPZmZzZXQudG9wICs9IHRvcF8xO1xyXG4gICAgICAgIHNuYXBPZmZzZXQucmlnaHQgKz0gbGVmdF8xO1xyXG4gICAgICAgIHNuYXBPZmZzZXQuYm90dG9tICs9IHRvcF8xO1xyXG4gICAgfVxyXG4gICAgdG90YWxHdWlkZWxpbmVzLnB1c2guYXBwbHkodG90YWxHdWlkZWxpbmVzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZ2V0RGVmYXVsdEd1aWRlbGluZXMoaG9yaXpvbnRhbEd1aWRlbGluZXMgfHwgZmFsc2UsIHZlcnRpY2FsR3VpZGVsaW5lcyB8fCBmYWxzZSwgb3ZlcmZsb3cgPyBjb250YWluZXJXaWR0aCA6IGNvbnRhaW5lckNsaWVudFdpZHRoLCBvdmVyZmxvdyA/IGNvbnRhaW5lckhlaWdodCA6IGNvbnRhaW5lckNsaWVudEhlaWdodCwgY2xpZW50TGVmdCwgY2xpZW50VG9wLCBzbmFwT2Zmc2V0KSksIGZhbHNlKSk7XHJcbiAgICB0b3RhbEd1aWRlbGluZXMgPSB0b3RhbEd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gX2EuZWxlbWVudCwgZWxlbWVudFJlY3QgPSBfYS5lbGVtZW50UmVjdCwgdHlwZSA9IF9hLnR5cGU7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50UmVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50UmVjdC5yZWN0O1xyXG4gICAgICAgIHJldHVybiBjaGVja0JldHdlZW5SZWN0cyh0YXJnZXRSZWN0LCByZWN0LCB0eXBlLCBtYXhTbmFwRWxlbWVudEd1aWRlbGluZURpc3RhbmNlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRvdGFsR3VpZGVsaW5lcztcclxufVxyXG5mdW5jdGlvbiBnZXRHYXBHdWlkZWxpbmVzKG1vdmVhYmxlLCB0YXJnZXRSZWN0LCBzbmFwVGhyZXNob2xkcykge1xyXG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsIF9iID0gX2EubWF4U25hcEVsZW1lbnRHdWlkZWxpbmVEaXN0YW5jZSwgbWF4U25hcEVsZW1lbnRHdWlkZWxpbmVEaXN0YW5jZSA9IF9iID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9iLCBfYyA9IF9hLm1heFNuYXBFbGVtZW50R2FwRGlzdGFuY2UsIG1heFNuYXBFbGVtZW50R2FwRGlzdGFuY2UgPSBfYyA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfYztcclxuICAgIHZhciBlbGVtZW50UmVjdHMgPSBtb3ZlYWJsZS5zdGF0ZS5lbGVtZW50UmVjdHM7XHJcbiAgICB2YXIgZ2FwR3VpZGVsaW5lcyA9IFtdO1xyXG4gICAgW1xyXG4gICAgICAgIFtcInZlcnRpY2FsXCIsIFZFUlRJQ0FMX05BTUVTX01BUCwgSE9SSVpPTlRBTF9OQU1FU19NQVBdLFxyXG4gICAgICAgIFtcImhvcml6b250YWxcIiwgSE9SSVpPTlRBTF9OQU1FU19NQVAsIFZFUlRJQ0FMX05BTUVTX01BUF0sXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAzKSwgdHlwZSA9IF9iWzBdLCBtYWluTmFtZXMgPSBfYlsxXSwgc2lkZU5hbWVzID0gX2JbMl07XHJcbiAgICAgICAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuc3RhcnRdO1xyXG4gICAgICAgIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5lbmRdO1xyXG4gICAgICAgIHZhciB0YXJnZXRDZW50ZXIgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5jZW50ZXJdO1xyXG4gICAgICAgIHZhciB0YXJnZXRTdGFydDIgPSB0YXJnZXRSZWN0W3NpZGVOYW1lcy5zdGFydF07XHJcbiAgICAgICAgdmFyIHRhcmdldEVuZDIgPSB0YXJnZXRSZWN0W3NpZGVOYW1lcy5lbmRdO1xyXG4gICAgICAgIC8vIGVsZW1lbnQgOiBtb3ZlYWJsZVxyXG4gICAgICAgIHZhciBzbmFwVGhyZXNob2xkTWFwID0ge1xyXG4gICAgICAgICAgICBsZWZ0OiBzbmFwVGhyZXNob2xkc1swXSxcclxuICAgICAgICAgICAgdG9wOiBzbmFwVGhyZXNob2xkc1sxXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldERpc3QoZWxlbWVudFJlY3QpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50UmVjdC5yZWN0O1xyXG4gICAgICAgICAgICB2YXIgc25hcFRocmVzaG9sZCA9IHNuYXBUaHJlc2hvbGRNYXBbbWFpbk5hbWVzLnN0YXJ0XTtcclxuICAgICAgICAgICAgaWYgKHJlY3RbbWFpbk5hbWVzLmVuZF0gPCB0YXJnZXRTdGFydCArIHNuYXBUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRTdGFydCAtIHJlY3RbbWFpbk5hbWVzLmVuZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RW5kIC0gc25hcFRocmVzaG9sZCA8IHJlY3RbbWFpbk5hbWVzLnN0YXJ0XSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3RbbWFpbk5hbWVzLnN0YXJ0XSAtIHRhcmdldEVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dEVsZW1lbnRSZWN0cyA9IGVsZW1lbnRSZWN0cy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnRSZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWxlbWVudFJlY3QucmVjdDtcclxuICAgICAgICAgICAgaWYgKHJlY3Rbc2lkZU5hbWVzLnN0YXJ0XSA+IHRhcmdldEVuZDIgfHwgcmVjdFtzaWRlTmFtZXMuZW5kXSA8IHRhcmdldFN0YXJ0Mikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBnZXREaXN0KGVsZW1lbnRSZWN0KSA+IDA7XHJcbiAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0RGlzdChhKSAtIGdldERpc3QoYik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xyXG4gICAgICAgIG5leHRFbGVtZW50UmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoc25hcFJlY3QxKSB7XHJcbiAgICAgICAgICAgIG5leHRFbGVtZW50UmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoc25hcFJlY3QyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc25hcFJlY3QxID09PSBzbmFwUmVjdDIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdDEgPSBzbmFwUmVjdDEucmVjdDtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0MiA9IHNuYXBSZWN0Mi5yZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QxU3RhcnQgPSByZWN0MVtzaWRlTmFtZXMuc3RhcnRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QxRW5kID0gcmVjdDFbc2lkZU5hbWVzLmVuZF07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdDJTdGFydCA9IHJlY3QyW3NpZGVOYW1lcy5zdGFydF07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdDJFbmQgPSByZWN0MltzaWRlTmFtZXMuZW5kXTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWN0MVN0YXJ0ID4gcmVjdDJFbmQgfHwgcmVjdDJTdGFydCA+IHJlY3QxRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goW3NuYXBSZWN0MSwgc25hcFJlY3QyXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBzbmFwUmVjdDEgPSBfYlswXSwgc25hcFJlY3QyID0gX2JbMV07XHJcbiAgICAgICAgICAgIHZhciByZWN0MSA9IHNuYXBSZWN0MS5yZWN0O1xyXG4gICAgICAgICAgICB2YXIgcmVjdDIgPSBzbmFwUmVjdDIucmVjdDtcclxuICAgICAgICAgICAgdmFyIHJlY3QxU3RhcnQgPSByZWN0MVttYWluTmFtZXMuc3RhcnRdO1xyXG4gICAgICAgICAgICB2YXIgcmVjdDFFbmQgPSByZWN0MVttYWluTmFtZXMuZW5kXTtcclxuICAgICAgICAgICAgdmFyIHJlY3QyU3RhcnQgPSByZWN0MlttYWluTmFtZXMuc3RhcnRdO1xyXG4gICAgICAgICAgICB2YXIgcmVjdDJFbmQgPSByZWN0MlttYWluTmFtZXMuZW5kXTtcclxuICAgICAgICAgICAgdmFyIHNuYXBUaHJlc2hvbGQgPSBzbmFwVGhyZXNob2xkTWFwW21haW5OYW1lcy5zdGFydF07XHJcbiAgICAgICAgICAgIHZhciBnYXAgPSAwO1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gMDtcclxuICAgICAgICAgICAgdmFyIGlzU3RhcnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGlzQ2VudGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBpc0VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAocmVjdDFFbmQgPD0gdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0RW5kIDw9IHJlY3QyU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIChsKWVsZW1lbnQxKHIpIDogKGwpdGFyZ2V0KHIpIDogKGwpZWxlbWVudDIocilcclxuICAgICAgICAgICAgICAgIGlzQ2VudGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGdhcCA9ICgocmVjdDJTdGFydCAtIHJlY3QxRW5kKSAtICh0YXJnZXRFbmQgLSB0YXJnZXRTdGFydCkpIC8gMjtcclxuICAgICAgICAgICAgICAgIHBvcyA9IHJlY3QxRW5kICsgZ2FwICsgKHRhcmdldEVuZCAtIHRhcmdldFN0YXJ0KSAvIDI7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWJzKHBvcyAtIHRhcmdldENlbnRlcikgPiBzbmFwVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QxRW5kIDwgcmVjdDJTdGFydCAmJiByZWN0MkVuZCA8IHRhcmdldFN0YXJ0ICsgc25hcFRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gKGwpZWxlbWVudDEocikgOiAobCllbGVtZW50MihyKSA6IChsKXRhcmdldFxyXG4gICAgICAgICAgICAgICAgaXNTdGFydCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBnYXAgPSByZWN0MlN0YXJ0IC0gcmVjdDFFbmQ7XHJcbiAgICAgICAgICAgICAgICBwb3MgPSByZWN0MkVuZCArIGdhcDtcclxuICAgICAgICAgICAgICAgIGlmIChhYnMocG9zIC0gdGFyZ2V0U3RhcnQpID4gc25hcFRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZWN0MUVuZCA8IHJlY3QyU3RhcnQgJiYgdGFyZ2V0RW5kIC0gc25hcFRocmVzaG9sZCA8IHJlY3QxU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldChyKSA6IChsKWVsZW1lbnQxKHIpIDogKGwpZWxlbWVudDIocilcclxuICAgICAgICAgICAgICAgIGlzRW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGdhcCA9IHJlY3QyU3RhcnQgLSByZWN0MUVuZDtcclxuICAgICAgICAgICAgICAgIHBvcyA9IHJlY3QxU3RhcnQgLSBnYXA7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWJzKHBvcyAtIHRhcmdldEVuZCkgPiBzbmFwVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZ2FwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjaGVja0JldHdlZW5SZWN0cyh0YXJnZXRSZWN0LCByZWN0MiwgdHlwZSwgbWF4U25hcEVsZW1lbnRHdWlkZWxpbmVEaXN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ2FwID4gbWF4U25hcEVsZW1lbnRHYXBEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdhcEd1aWRlbGluZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgcG9zOiB0eXBlID09PSBcInZlcnRpY2FsXCIgPyBbcG9zLCAwXSA6IFswLCBwb3NdLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogc25hcFJlY3QyLmVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBzaXplOiAwLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBzbmFwUmVjdDIuY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgaXNTdGFydDogaXNTdGFydCxcclxuICAgICAgICAgICAgICAgIGlzQ2VudGVyOiBpc0NlbnRlcixcclxuICAgICAgICAgICAgICAgIGlzRW5kOiBpc0VuZCxcclxuICAgICAgICAgICAgICAgIGdhcDogZ2FwLFxyXG4gICAgICAgICAgICAgICAgaGlkZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdhcFJlY3RzOiBbc25hcFJlY3QxLCBzbmFwUmVjdDJdLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudERpcmVjdGlvbjogXCJcIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBnYXBHdWlkZWxpbmVzO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0R3JpZEdyb3VwR3VpZGVsaW5lcyhtb3ZlYWJsZSwgY2xpZW50TGVmdCwgY2xpZW50VG9wLCBzbmFwT2Zmc2V0KSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgIHZhciBzbmFwR3JpZEFsbCA9IHByb3BzLnNuYXBHcmlkQWxsO1xyXG4gICAgdmFyIF9jID0gcHJvcHMuc25hcEdyaWRXaWR0aCwgc25hcEdyaWRXaWR0aCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIF9kID0gcHJvcHMuc25hcEdyaWRIZWlnaHQsIHNuYXBHcmlkSGVpZ2h0ID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZDtcclxuICAgIHZhciBzbmFwUmVuZGVySW5mbyA9IHN0YXRlLnNuYXBSZW5kZXJJbmZvO1xyXG4gICAgdmFyIGhhc0RpcmVjdGlvbiA9IHNuYXBSZW5kZXJJbmZvICYmICgoKF9hID0gc25hcFJlbmRlckluZm8uZGlyZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pIHx8ICgoX2IgPSBzbmFwUmVuZGVySW5mby5kaXJlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsxXSkpO1xyXG4gICAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcclxuICAgIC8vIHNuYXAgZ3JvdXAncyBhbGwgY2hpbGQgdG8gZ3JpZC5cclxuICAgIGlmIChzbmFwR3JpZEFsbFxyXG4gICAgICAgICYmIG1vdmVhYmxlc1xyXG4gICAgICAgICYmIGhhc0RpcmVjdGlvblxyXG4gICAgICAgICYmIChzbmFwR3JpZFdpZHRoIHx8IHNuYXBHcmlkSGVpZ2h0KSkge1xyXG4gICAgICAgIGlmIChzdGF0ZS5zbmFwVGhyZXNob2xkSW5mbykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLnNuYXBUaHJlc2hvbGRJbmZvID0ge1xyXG4gICAgICAgICAgICBtdWx0aXBsZXM6IFsxLCAxXSxcclxuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVjdF8xID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbl8xID0gcmVjdF8xLmNoaWxkcmVuO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBzbmFwUmVuZGVySW5mby5kaXJlY3Rpb247XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuXzEpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGRpcmVjdGlvbi5tYXAoZnVuY3Rpb24gKGRpciwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gaSA9PT0gMCA/IHtcclxuICAgICAgICAgICAgICAgICAgICBzbmFwU2l6ZTogc25hcEdyaWRXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBwb3NOYW1lOiBcImxlZnRcIixcclxuICAgICAgICAgICAgICAgICAgICBzaXplTmFtZTogXCJ3aWR0aFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogc25hcE9mZnNldC5sZWZ0IC0gY2xpZW50TGVmdCxcclxuICAgICAgICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc25hcFNpemU6IHNuYXBHcmlkSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc05hbWU6IFwidG9wXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZU5hbWU6IFwiaGVpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBzbmFwT2Zmc2V0LnRvcCAtIGNsaWVudFRvcCxcclxuICAgICAgICAgICAgICAgIH0sIHNuYXBTaXplID0gX2Euc25hcFNpemUsIHBvc05hbWUgPSBfYS5wb3NOYW1lLCBzaXplTmFtZSA9IF9hLnNpemVOYW1lLCBjbGllbnRPZmZzZXQgPSBfYS5jbGllbnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNuYXBTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyOiBkaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwU2l6ZTogc25hcFNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBPZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZWN0U2l6ZSA9IHJlY3RfMVtzaXplTmFtZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdFBvcyA9IHJlY3RfMVtwb3NOYW1lXTtcclxuICAgICAgICAgICAgICAgIC8vIOyCrOydtOymiOuztOuLpCDrp4zslb0g7J6R64uk66m0IOyWtOuWu+qyjCDtlbTslbzrkJjso6A/XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRTaXplcyA9IGZsYXQkMShjaGlsZHJlbl8xLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGRbcG9zTmFtZV0gLSByZWN0UG9zKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNoaWxkW3NpemVOYW1lXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZWN0U2l6ZSAtIGNoaWxkW3NpemVOYW1lXSAtIGNoaWxkW3Bvc05hbWVdICsgcmVjdFBvcyksXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIH0pKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHY7IH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdENoaWxkU2l6ZSA9IGNoaWxkU2l6ZXNbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRTbmFwU2l6ZXMgPSBjaGlsZFNpemVzLm1hcChmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gdGhyb3R0bGUoc2l6ZSAvIGZpcnN0Q2hpbGRTaXplLCAwLjEpICogc25hcFNpemU7IH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3RSYXRpbyA9IHRocm90dGxlKHJlY3RTaXplIC8gZmlyc3RDaGlsZFNpemUsIDAuMSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKG4gPSAxOyBuIDw9IDEwOyArK24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRTbmFwU2l6ZXMuZXZlcnkoZnVuY3Rpb24gKGNoaWxkU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRTaXplICogbiAlIDEgPT09IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZGlyIDEgKGZpeGVkIC0xKVxyXG4gICAgICAgICAgICAgICAgLy8gZGlyIDAgKGZpeGVkIDApXHJcbiAgICAgICAgICAgICAgICAvLyBkaXIgLTEgKGZpeGVkIDEpXHJcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSAoLWRpciArIDEpIC8gMjtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRQb3MgPSBkb3QocmVjdFBvcyAtIGNsaWVudE9mZnNldCwgcmVjdFBvcyAtIGNsaWVudE9mZnNldCArIHJlY3RTaXplLCByYXRpbywgMSAtIHJhdGlvKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGU6IHJlY3RSYXRpbyAqIG4sXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyOiBkaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcFNpemU6IHNuYXBTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIHNuYXBPZmZzZXQ6IE1hdGgucm91bmQob2Zmc2V0UG9zIC8gc25hcFNpemUpLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBtdWx0aXBsZXMgPSByZXN1bHQubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLm11bHRpcGxlIHx8IDE7IH0pO1xyXG4gICAgICAgICAgICBzdGF0ZS5zbmFwVGhyZXNob2xkSW5mby5tdWx0aXBsZXMgPSBtdWx0aXBsZXM7XHJcbiAgICAgICAgICAgIHN0YXRlLnNuYXBUaHJlc2hvbGRJbmZvLm9mZnNldCA9IHJlc3VsdC5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuc25hcE9mZnNldDsgfSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoci5zbmFwU2l6ZSkgO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzdGF0ZS5zbmFwVGhyZXNob2xkSW5mbyA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0R3JpZEd1aWRlbGluZXMobW92ZWFibGUsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQsIGNsaWVudExlZnQsIGNsaWVudFRvcCwgc25hcE9mZnNldCwgaXNEaXNwbGF5R3JpZEd1aWRlbGluZXMpIHtcclxuICAgIGlmIChjbGllbnRMZWZ0ID09PSB2b2lkIDApIHsgY2xpZW50TGVmdCA9IDA7IH1cclxuICAgIGlmIChjbGllbnRUb3AgPT09IHZvaWQgMCkgeyBjbGllbnRUb3AgPSAwOyB9XHJcbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcclxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgdmFyIF9hID0gcHJvcHMuc25hcEdyaWRXaWR0aCwgc25hcEdyaWRXaWR0aCA9IF9hID09PSB2b2lkIDAgPyAwIDogX2EsIF9iID0gcHJvcHMuc25hcEdyaWRIZWlnaHQsIHNuYXBHcmlkSGVpZ2h0ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYjtcclxuICAgIHZhciBndWlkZWxpbmVzID0gW107XHJcbiAgICB2YXIgc25hcE9mZnNldExlZnQgPSBzbmFwT2Zmc2V0LmxlZnQsIHNuYXBPZmZzZXRUb3AgPSBzbmFwT2Zmc2V0LnRvcDtcclxuICAgIHZhciBzdGFydE9mZnNldCA9IFswLCAwXTtcclxuICAgIHN0YXJ0R3JpZEdyb3VwR3VpZGVsaW5lcyhtb3ZlYWJsZSwgY2xpZW50TGVmdCwgY2xpZW50VG9wLCBzbmFwT2Zmc2V0KTtcclxuICAgIHZhciBzbmFwVGhyZXNob2xkSW5mbyA9IHN0YXRlLnNuYXBUaHJlc2hvbGRJbmZvO1xyXG4gICAgdmFyIGRlZmF1bHRTbmFwR3JpZFdpZHRoID0gc25hcEdyaWRXaWR0aDtcclxuICAgIHZhciBkZWZhdWx0U25hcEdyaWRIZWlnaHQgPSBzbmFwR3JpZEhlaWdodDtcclxuICAgIGlmIChzbmFwVGhyZXNob2xkSW5mbykge1xyXG4gICAgICAgIHNuYXBHcmlkV2lkdGggKj0gc25hcFRocmVzaG9sZEluZm8ubXVsdGlwbGVzWzBdIHx8IDE7XHJcbiAgICAgICAgc25hcEdyaWRIZWlnaHQgKj0gc25hcFRocmVzaG9sZEluZm8ubXVsdGlwbGVzWzFdIHx8IDE7XHJcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBzbmFwVGhyZXNob2xkSW5mby5vZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBpZiAoc25hcEdyaWRIZWlnaHQpIHtcclxuICAgICAgICB2YXIgcHVzaEd1aWRlbGluZSA9IGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgICAgICAgZ3VpZGVsaW5lcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcE9mZnNldExlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoc3RhcnRPZmZzZXRbMV0gKiBkZWZhdWx0U25hcEdyaWRIZWlnaHQgKyBwb3MgLSBjbGllbnRUb3AgKyBzbmFwT2Zmc2V0VG9wLCAwLjEpLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiZ3JpZC1ndWlkZWxpbmVcIiksXHJcbiAgICAgICAgICAgICAgICBzaXplOiBjb250YWluZXJXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhpZGU6ICFpc0Rpc3BsYXlHcmlkR3VpZGVsaW5lcyxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJcIixcclxuICAgICAgICAgICAgICAgIGdyaWQ6IHRydWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yICh2YXIgcG9zID0gMDsgcG9zIDw9IGNvbnRhaW5lckhlaWdodCAqIDI7IHBvcyArPSBzbmFwR3JpZEhlaWdodCkge1xyXG4gICAgICAgICAgICBwdXNoR3VpZGVsaW5lKHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIHBvcyA9IC1zbmFwR3JpZEhlaWdodDsgcG9zID49IC1jb250YWluZXJIZWlnaHQ7IHBvcyAtPSBzbmFwR3JpZEhlaWdodCkge1xyXG4gICAgICAgICAgICBwdXNoR3VpZGVsaW5lKHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNuYXBHcmlkV2lkdGgpIHtcclxuICAgICAgICB2YXIgcHVzaEd1aWRlbGluZSA9IGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgICAgICAgZ3VpZGVsaW5lcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidmVydGljYWxcIixcclxuICAgICAgICAgICAgICAgIHBvczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlKHN0YXJ0T2Zmc2V0WzBdICogZGVmYXVsdFNuYXBHcmlkV2lkdGggKyBwb3MgLSBjbGllbnRMZWZ0ICsgc25hcE9mZnNldExlZnQsIDAuMSksXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcE9mZnNldFRvcCxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHByZWZpeChcImdyaWQtZ3VpZGVsaW5lXCIpLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogY29udGFpbmVySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgaGlkZTogIWlzRGlzcGxheUdyaWRHdWlkZWxpbmVzLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgZ3JpZDogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPD0gY29udGFpbmVyV2lkdGggKiAyOyBwb3MgKz0gc25hcEdyaWRXaWR0aCkge1xyXG4gICAgICAgICAgICBwdXNoR3VpZGVsaW5lKHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIHBvcyA9IC1zbmFwR3JpZFdpZHRoOyBwb3MgPj0gLWNvbnRhaW5lcldpZHRoOyBwb3MgLT0gc25hcEdyaWRXaWR0aCkge1xyXG4gICAgICAgICAgICBwdXNoR3VpZGVsaW5lKHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGd1aWRlbGluZXM7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tCZXR3ZWVuUmVjdHMocmVjdDEsIHJlY3QyLCB0eXBlLCBkaXN0YW5jZSkge1xyXG4gICAgaWYgKHR5cGUgPT09IFwiaG9yaXpvbnRhbFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGFicyhyZWN0MS5yaWdodCAtIHJlY3QyLmxlZnQpIDw9IGRpc3RhbmNlXHJcbiAgICAgICAgICAgIHx8IGFicyhyZWN0MS5sZWZ0IC0gcmVjdDIucmlnaHQpIDw9IGRpc3RhbmNlXHJcbiAgICAgICAgICAgIHx8IHJlY3QxLmxlZnQgPD0gcmVjdDIucmlnaHQgJiYgcmVjdDIubGVmdCA8PSByZWN0MS5yaWdodDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwidmVydGljYWxcIikge1xyXG4gICAgICAgIHJldHVybiBhYnMocmVjdDEuYm90dG9tIC0gcmVjdDIudG9wKSA8PSBkaXN0YW5jZVxyXG4gICAgICAgICAgICB8fCBhYnMocmVjdDEudG9wIC0gcmVjdDIuYm90dG9tKSA8PSBkaXN0YW5jZVxyXG4gICAgICAgICAgICB8fCByZWN0MS50b3AgPD0gcmVjdDIuYm90dG9tICYmIHJlY3QyLnRvcCA8PSByZWN0MS5ib3R0b207XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBnZXRFbGVtZW50R3VpZGVsaW5lcyhtb3ZlYWJsZSkge1xyXG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcy5lbGVtZW50R3VpZGVsaW5lcywgZWxlbWVudEd1aWRlbGluZXMgPSBfYSA9PT0gdm9pZCAwID8gW10gOiBfYTtcclxuICAgIGlmICghZWxlbWVudEd1aWRlbGluZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgc3RhdGUuZWxlbWVudFJlY3RzID0gW107XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdmFyIHByZXZWYWx1ZXMgPSAoc3RhdGUuZWxlbWVudFJlY3RzIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKHNuYXBSZWN0KSB7IHJldHVybiAhc25hcFJlY3QucmVmcmVzaDsgfSk7XHJcbiAgICB2YXIgbmV4dEVsZW1lbnRHdWlkZWxpbmVzID0gZWxlbWVudEd1aWRlbGluZXMubWFwKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIGlmIChpc09iamVjdChlbCkgJiYgXCJlbGVtZW50XCIgaW4gZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlbCksIHsgZWxlbWVudDogZ2V0UmVmVGFyZ2V0KGVsLmVsZW1lbnQsIHRydWUpIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBlbGVtZW50OiBnZXRSZWZUYXJnZXQoZWwsIHRydWUpLFxyXG4gICAgICAgIH07XHJcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmVsZW1lbnQ7XHJcbiAgICB9KTtcclxuICAgIHZhciBfYiA9IGRpZmYocHJldlZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuZWxlbWVudDsgfSksIG5leHRFbGVtZW50R3VpZGVsaW5lcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuZWxlbWVudDsgfSkpLCBtYWludGFpbmVkID0gX2IubWFpbnRhaW5lZCwgYWRkZWQgPSBfYi5hZGRlZDtcclxuICAgIHZhciBuZXh0VmFsdWVzID0gW107XHJcbiAgICBtYWludGFpbmVkLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgcHJldkluZGV4ID0gX2JbMF0sIG5leHRJbmRleCA9IF9iWzFdO1xyXG4gICAgICAgIG5leHRWYWx1ZXNbbmV4dEluZGV4XSA9IHByZXZWYWx1ZXNbcHJldkluZGV4XTtcclxuICAgIH0pO1xyXG4gICAgZ2V0U25hcEVsZW1lbnRSZWN0cyhtb3ZlYWJsZSwgYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gbmV4dEVsZW1lbnRHdWlkZWxpbmVzW2luZGV4XTsgfSkpLm1hcChmdW5jdGlvbiAocmVjdCwgaSkge1xyXG4gICAgICAgIG5leHRWYWx1ZXNbYWRkZWRbaV1dID0gcmVjdDtcclxuICAgIH0pO1xyXG4gICAgc3RhdGUuZWxlbWVudFJlY3RzID0gbmV4dFZhbHVlcztcclxuICAgIHZhciBlbGVtZW50U25hcERpcmVjdGlvbnMgPSBnZXRTbmFwRGlyZWN0aW9ucyhtb3ZlYWJsZS5wcm9wcy5lbGVtZW50U25hcERpcmVjdGlvbnMpO1xyXG4gICAgdmFyIG5leHRHdWlkZWxpbmVzID0gW107XHJcbiAgICBuZXh0VmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHNuYXBSZWN0KSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBzbmFwUmVjdC5lbGVtZW50LCBfYSA9IHNuYXBSZWN0LnRvcCwgdG9wVmFsdWUgPSBfYSA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLnRvcCA6IF9hLCBfYiA9IHNuYXBSZWN0LmxlZnQsIGxlZnRWYWx1ZSA9IF9iID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMubGVmdCA6IF9iLCBfYyA9IHNuYXBSZWN0LnJpZ2h0LCByaWdodFZhbHVlID0gX2MgPT09IHZvaWQgMCA/IGVsZW1lbnRTbmFwRGlyZWN0aW9ucy5yaWdodCA6IF9jLCBfZCA9IHNuYXBSZWN0LmJvdHRvbSwgYm90dG9tVmFsdWUgPSBfZCA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLmJvdHRvbSA6IF9kLCBfZSA9IHNuYXBSZWN0LmNlbnRlciwgY2VudGVyVmFsdWUgPSBfZSA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLmNlbnRlciA6IF9lLCBfZiA9IHNuYXBSZWN0Lm1pZGRsZSwgbWlkZGxlVmFsdWUgPSBfZiA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLm1pZGRsZSA6IF9mLCBjbGFzc05hbWUgPSBzbmFwUmVjdC5jbGFzc05hbWUsIHJlY3QgPSBzbmFwUmVjdC5yZWN0O1xyXG4gICAgICAgIHZhciBfZyA9IHNwbGl0U25hcERpcmVjdGlvblBvc2VzKHtcclxuICAgICAgICAgICAgdG9wOiB0b3BWYWx1ZSxcclxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0VmFsdWUsXHJcbiAgICAgICAgICAgIGxlZnQ6IGxlZnRWYWx1ZSxcclxuICAgICAgICAgICAgYm90dG9tOiBib3R0b21WYWx1ZSxcclxuICAgICAgICAgICAgY2VudGVyOiBjZW50ZXJWYWx1ZSxcclxuICAgICAgICAgICAgbWlkZGxlOiBtaWRkbGVWYWx1ZSxcclxuICAgICAgICB9LCByZWN0KSwgaG9yaXpvbnRhbCA9IF9nLmhvcml6b250YWwsIHZlcnRpY2FsID0gX2cudmVydGljYWwsIGhvcml6b250YWxOYW1lcyA9IF9nLmhvcml6b250YWxOYW1lcywgdmVydGljYWxOYW1lcyA9IF9nLnZlcnRpY2FsTmFtZXM7XHJcbiAgICAgICAgdmFyIHJlY3RUb3AgPSByZWN0LnRvcDtcclxuICAgICAgICB2YXIgcmVjdExlZnQgPSByZWN0LmxlZnQ7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC5yaWdodCAtIHJlY3RMZWZ0O1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3RUb3A7XHJcbiAgICAgICAgdmFyIHNpemVzID0gW3dpZHRoLCBoZWlnaHRdO1xyXG4gICAgICAgIHZlcnRpY2FsLmZvckVhY2goZnVuY3Rpb24gKHBvcywgaSkge1xyXG4gICAgICAgICAgICBuZXh0R3VpZGVsaW5lcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidmVydGljYWxcIixcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBwb3M6IFtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZShwb3MsIDAuMSksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdFRvcCxcclxuICAgICAgICAgICAgICAgIF0sIHNpemU6IGhlaWdodCxcclxuICAgICAgICAgICAgICAgIHNpemVzOiBzaXplcyxcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudFJlY3Q6IHNuYXBSZWN0LFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudERpcmVjdGlvbjogU05BUF9TS0lQX05BTUVTX01BUFt2ZXJ0aWNhbE5hbWVzW2ldXSB8fCB2ZXJ0aWNhbE5hbWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcIlwiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBob3Jpem9udGFsLmZvckVhY2goZnVuY3Rpb24gKHBvcywgaSkge1xyXG4gICAgICAgICAgICBuZXh0R3VpZGVsaW5lcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHBvczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3RMZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlKHBvcywgMC4xKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBzaXplOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIHNpemVzOiBzaXplcyxcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudFJlY3Q6IHNuYXBSZWN0LFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudERpcmVjdGlvbjogU05BUF9TS0lQX05BTUVTX01BUFtob3Jpem9udGFsTmFtZXNbaV1dIHx8IGhvcml6b250YWxOYW1lc1tpXSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJcIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXh0R3VpZGVsaW5lcztcclxufVxyXG5mdW5jdGlvbiBnZXRPYmplY3RHdWlkZWxpbmVzKGd1aWRlbGluZXMsIGNvbnRhaW5lclNpemUpIHtcclxuICAgIHJldHVybiBndWlkZWxpbmVzID8gZ3VpZGVsaW5lcy5tYXAoZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICB2YXIgcG9zR3VpZGVsaW5lID0gaXNPYmplY3QoaW5mbykgPyBpbmZvIDogeyBwb3M6IGluZm8gfTtcclxuICAgICAgICB2YXIgcG9zID0gcG9zR3VpZGVsaW5lLnBvcztcclxuICAgICAgICBpZiAoaXNOdW1iZXIocG9zKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcG9zR3VpZGVsaW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwb3NHdWlkZWxpbmUpLCB7IHBvczogY29udmVydFVuaXRTaXplKHBvcywgY29udGFpbmVyU2l6ZSkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSkgOiBbXTtcclxufVxyXG5mdW5jdGlvbiBnZXREZWZhdWx0R3VpZGVsaW5lcyhob3Jpem9udGFsR3VpZGVsaW5lcywgdmVydGljYWxHdWlkZWxpbmVzLCB3aWR0aCwgaGVpZ2h0LCBjbGllbnRMZWZ0LCBjbGllbnRUb3AsIHNuYXBPZmZzZXQpIHtcclxuICAgIGlmIChjbGllbnRMZWZ0ID09PSB2b2lkIDApIHsgY2xpZW50TGVmdCA9IDA7IH1cclxuICAgIGlmIChjbGllbnRUb3AgPT09IHZvaWQgMCkgeyBjbGllbnRUb3AgPSAwOyB9XHJcbiAgICBpZiAoc25hcE9mZnNldCA9PT0gdm9pZCAwKSB7IHNuYXBPZmZzZXQgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9OyB9XHJcbiAgICB2YXIgZ3VpZGVsaW5lcyA9IFtdO1xyXG4gICAgdmFyIHNuYXBPZmZzZXRMZWZ0ID0gc25hcE9mZnNldC5sZWZ0LCBzbmFwT2Zmc2V0VG9wID0gc25hcE9mZnNldC50b3AsIHNuYXBPZmZzZXRCb3R0b20gPSBzbmFwT2Zmc2V0LmJvdHRvbSwgc25hcE9mZnNldFJpZ2h0ID0gc25hcE9mZnNldC5yaWdodDtcclxuICAgIHZhciBzbmFwV2lkdGggPSB3aWR0aCArIHNuYXBPZmZzZXRSaWdodCAtIHNuYXBPZmZzZXRMZWZ0O1xyXG4gICAgdmFyIHNuYXBIZWlnaHQgPSBoZWlnaHQgKyBzbmFwT2Zmc2V0Qm90dG9tIC0gc25hcE9mZnNldFRvcDtcclxuICAgIGdldE9iamVjdEd1aWRlbGluZXMoaG9yaXpvbnRhbEd1aWRlbGluZXMsIHNuYXBIZWlnaHQpLmZvckVhY2goZnVuY3Rpb24gKHBvc0luZm8pIHtcclxuICAgICAgICBndWlkZWxpbmVzLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiBcImhvcml6b250YWxcIixcclxuICAgICAgICAgICAgcG9zOiBbXHJcbiAgICAgICAgICAgICAgICBzbmFwT2Zmc2V0TGVmdCxcclxuICAgICAgICAgICAgICAgIHRocm90dGxlKHBvc0luZm8ucG9zIC0gY2xpZW50VG9wICsgc25hcE9mZnNldFRvcCwgMC4xKSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgc2l6ZTogc25hcFdpZHRoLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IHBvc0luZm8uY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIGdldE9iamVjdEd1aWRlbGluZXModmVydGljYWxHdWlkZWxpbmVzLCBzbmFwV2lkdGgpLmZvckVhY2goZnVuY3Rpb24gKHBvc0luZm8pIHtcclxuICAgICAgICBndWlkZWxpbmVzLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiBcInZlcnRpY2FsXCIsXHJcbiAgICAgICAgICAgIHBvczogW1xyXG4gICAgICAgICAgICAgICAgdGhyb3R0bGUocG9zSW5mby5wb3MgLSBjbGllbnRMZWZ0ICsgc25hcE9mZnNldExlZnQsIDAuMSksXHJcbiAgICAgICAgICAgICAgICBzbmFwT2Zmc2V0VG9wLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBzaXplOiBzbmFwSGVpZ2h0LFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IHBvc0luZm8uY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBndWlkZWxpbmVzO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNuYXBFbGVtZW50UmVjdHMobW92ZWFibGUsIHZhbHVlcykge1xyXG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdmFyIGdyb3VwYWJsZSA9IG1vdmVhYmxlLnByb3BzLmdyb3VwYWJsZTtcclxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgdmFyIGNvbnRhaW5lckNsaWVudFJlY3QgPSBzdGF0ZS5jb250YWluZXJDbGllbnRSZWN0LCBcclxuICAgIC8vIHRhcmdldENsaWVudFJlY3Q6IHtcclxuICAgIC8vICAgICB0b3A6IGNsaWVudFRvcCxcclxuICAgIC8vICAgICBsZWZ0OiBjbGllbnRMZWZ0LFxyXG4gICAgLy8gfSxcclxuICAgIHJvb3RNYXRyaXggPSBzdGF0ZS5yb290TWF0cml4LCBpczNkID0gc3RhdGUuaXMzZCwgb2Zmc2V0RGVsdGEgPSBzdGF0ZS5vZmZzZXREZWx0YTtcclxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgdmFyIF9hID0gX19yZWFkKGNhbGN1bGF0ZUNvbnRhaW5lclBvcyhyb290TWF0cml4LCBjb250YWluZXJDbGllbnRSZWN0LCBuKSwgMiksIGNvbnRhaW5lckxlZnQgPSBfYVswXSwgY29udGFpbmVyVG9wID0gX2FbMV07XHJcbiAgICAvLyBjb25zdCBwb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKHN0YXRlKTtcclxuICAgIC8vIGNvbnN0IHtcclxuICAgIC8vICAgICBtaW5YOiB0YXJnZXRMZWZ0LFxyXG4gICAgLy8gICAgIG1pblk6IHRhcmdldFRvcCxcclxuICAgIC8vIH0gPSBnZXRNaW5NYXhzKHBvc2VzKTtcclxuICAgIC8vIGNvbnN0IFtkaXN0TGVmdCwgZGlzdFRvcF0gPSBtaW51cyhbdGFyZ2V0TGVmdCwgdGFyZ2V0VG9wXSwgY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKHJvb3RNYXRyaXgsIFtcclxuICAgIC8vICAgICBjbGllbnRMZWZ0IC0gY29udGFpbmVyTGVmdCxcclxuICAgIC8vICAgICBjbGllbnRUb3AgLSBjb250YWluZXJUb3AsXHJcbiAgICAvLyBdLCBuKSkubWFwKHBvcyA9PiByb3VuZFNpZ24ocG9zKSk7XHJcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IGdyb3VwYWJsZSA/IDAgOiBvZmZzZXREZWx0YVswXTtcclxuICAgIHZhciBvZmZzZXRUb3AgPSBncm91cGFibGUgPyAwIDogb2Zmc2V0RGVsdGFbMV07XHJcbiAgICByZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHZhbHVlLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgdmFyIGxlZnQgPSByZWN0LmxlZnQgLSBjb250YWluZXJMZWZ0IC0gb2Zmc2V0TGVmdDtcclxuICAgICAgICB2YXIgdG9wID0gcmVjdC50b3AgLSBjb250YWluZXJUb3AgLSBvZmZzZXRUb3A7XHJcbiAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHZhciByaWdodCA9IGxlZnQgKyByZWN0LndpZHRoO1xyXG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2xlZnQsIHRvcF0sIG4pLCAyKSwgZWxlbWVudExlZnQgPSBfYVswXSwgZWxlbWVudFRvcCA9IF9hWzFdO1xyXG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW3JpZ2h0LCBib3R0b21dLCBuKSwgMiksIGVsZW1lbnRSaWdodCA9IF9iWzBdLCBlbGVtZW50Qm90dG9tID0gX2JbMV07XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB2YWx1ZSksIHsgcmVjdDoge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogZWxlbWVudExlZnQsXHJcbiAgICAgICAgICAgICAgICByaWdodDogZWxlbWVudFJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgdG9wOiBlbGVtZW50VG9wLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiBlbGVtZW50Qm90dG9tLFxyXG4gICAgICAgICAgICAgICAgY2VudGVyOiAoZWxlbWVudExlZnQgKyBlbGVtZW50UmlnaHQpIC8gMixcclxuICAgICAgICAgICAgICAgIG1pZGRsZTogKGVsZW1lbnRUb3AgKyBlbGVtZW50Qm90dG9tKSAvIDIsXHJcbiAgICAgICAgICAgIH0gfSk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBjaGVja1NuYXBJbmZvKG1vdmVhYmxlKSB7XHJcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgIHZhciBjb250YWluZXIgPSBzdGF0ZS5jb250YWluZXI7XHJcbiAgICB2YXIgc25hcENvbnRhaW5lciA9IG1vdmVhYmxlLnByb3BzLnNuYXBDb250YWluZXIgfHwgY29udGFpbmVyO1xyXG4gICAgaWYgKHN0YXRlLnNuYXBDb250YWluZXIgPT09IHNuYXBDb250YWluZXIgJiYgc3RhdGUuZ3VpZGVsaW5lcyAmJiBzdGF0ZS5ndWlkZWxpbmVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBjb250YWluZXJDbGllbnRSZWN0ID0gc3RhdGUuY29udGFpbmVyQ2xpZW50UmVjdDtcclxuICAgIHZhciBzbmFwT2Zmc2V0ID0ge1xyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICByaWdodDogMCxcclxuICAgIH07XHJcbiAgICBpZiAoY29udGFpbmVyICE9PSBzbmFwQ29udGFpbmVyKSB7XHJcbiAgICAgICAgdmFyIHNuYXBDb250YWluZXJUYXJnZXQgPSBnZXRSZWZUYXJnZXQoc25hcENvbnRhaW5lciwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKHNuYXBDb250YWluZXJUYXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIHNuYXBDb250YWluZXJSZWN0ID0gZ2V0Q2xpZW50UmVjdChzbmFwQ29udGFpbmVyVGFyZ2V0KTtcclxuICAgICAgICAgICAgdmFyIG9mZnNldDEgPSBnZXREcmFnRGlzdEJ5U3RhdGUoc3RhdGUsIFtcclxuICAgICAgICAgICAgICAgIHNuYXBDb250YWluZXJSZWN0LmxlZnQgLSBjb250YWluZXJDbGllbnRSZWN0LmxlZnQsXHJcbiAgICAgICAgICAgICAgICBzbmFwQ29udGFpbmVyUmVjdC50b3AgLSBjb250YWluZXJDbGllbnRSZWN0LnRvcCxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQyID0gZ2V0RHJhZ0Rpc3RCeVN0YXRlKHN0YXRlLCBbXHJcbiAgICAgICAgICAgICAgICBzbmFwQ29udGFpbmVyUmVjdC5yaWdodCAtIGNvbnRhaW5lckNsaWVudFJlY3QucmlnaHQsXHJcbiAgICAgICAgICAgICAgICBzbmFwQ29udGFpbmVyUmVjdC5ib3R0b20gLSBjb250YWluZXJDbGllbnRSZWN0LmJvdHRvbSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHNuYXBPZmZzZXQubGVmdCA9IHRocm90dGxlKG9mZnNldDFbMF0sIDAuMDAwMDEpO1xyXG4gICAgICAgICAgICBzbmFwT2Zmc2V0LnRvcCA9IHRocm90dGxlKG9mZnNldDFbMV0sIDAuMDAwMDEpO1xyXG4gICAgICAgICAgICBzbmFwT2Zmc2V0LnJpZ2h0ID0gdGhyb3R0bGUob2Zmc2V0MlswXSwgMC4wMDAwMSk7XHJcbiAgICAgICAgICAgIHNuYXBPZmZzZXQuYm90dG9tID0gdGhyb3R0bGUob2Zmc2V0MlsxXSwgMC4wMDAwMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGUuc25hcENvbnRhaW5lciA9IHNuYXBDb250YWluZXI7XHJcbiAgICBzdGF0ZS5zbmFwT2Zmc2V0ID0gc25hcE9mZnNldDtcclxuICAgIHN0YXRlLmd1aWRlbGluZXMgPSBnZXRUb3RhbEd1aWRlbGluZXMobW92ZWFibGUpO1xyXG4gICAgc3RhdGUuZW5hYmxlU25hcCA9IHRydWU7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBnZXROZXh0Rml4ZWRQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvcywgaXMzZCkge1xyXG4gICAgdmFyIG5leHRQb3NlcyA9IGNhbGN1bGF0ZVBvc2VzKG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgaXMzZCA/IDQgOiAzKTtcclxuICAgIHZhciBuZXh0Rml4ZWRQb3MgPSBnZXRQb3NCeURpcmVjdGlvbihuZXh0UG9zZXMsIGZpeGVkRGlyZWN0aW9uKTtcclxuICAgIHJldHVybiBnZXRBYnNvbHV0ZVBvc2VzKG5leHRQb3NlcywgbWludXMoZml4ZWRQb3MsIG5leHRGaXhlZFBvcykpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZWQodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlIC8gYWJzKHZhbHVlKSA6IDA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2l6ZU9mZnNldEluZm8obW92ZWFibGUsIHBvc2VzLCBkaXJlY3Rpb24sIGtlZXBSYXRpbywgaXNSZXF1ZXN0LCBkYXRhcykge1xyXG4gICAgdmFyIGZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb247XHJcbiAgICB2YXIgZGlyZWN0aW9ucyA9IGdldENoZWNrU25hcERpcmVjdGlvbnMoZGlyZWN0aW9uLCBmaXhlZERpcmVjdGlvbiwga2VlcFJhdGlvKTtcclxuICAgIHZhciBpbm5lckJvdW5kTGluZUluZm9zID0gZ2V0Q2hlY2tJbm5lckJvdW5kTGluZUluZm9zKG1vdmVhYmxlLCBwb3NlcywgZGlyZWN0aW9uLCBrZWVwUmF0aW8pO1xyXG4gICAgdmFyIG9mZnNldHMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChnZXRTbmFwQm91bmRJbmZvKG1vdmVhYmxlLCBwb3NlcywgZGlyZWN0aW9ucywga2VlcFJhdGlvLCBpc1JlcXVlc3QsIGRhdGFzKSksIGZhbHNlKSwgX19yZWFkKGdldElubmVyQm91bmRJbmZvKG1vdmVhYmxlLCBpbm5lckJvdW5kTGluZUluZm9zLCBkYXRhcykpLCBmYWxzZSk7XHJcbiAgICB2YXIgd2lkdGhPZmZzZXRJbmZvID0gZ2V0TmVhck9mZnNldEluZm8ob2Zmc2V0cywgMCk7XHJcbiAgICB2YXIgaGVpZ2h0T2Zmc2V0SW5mbyA9IGdldE5lYXJPZmZzZXRJbmZvKG9mZnNldHMsIDEpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDoge1xyXG4gICAgICAgICAgICBpc0JvdW5kOiB3aWR0aE9mZnNldEluZm8uaXNCb3VuZCxcclxuICAgICAgICAgICAgb2Zmc2V0OiB3aWR0aE9mZnNldEluZm8ub2Zmc2V0WzBdLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGVpZ2h0OiB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IGhlaWdodE9mZnNldEluZm8uaXNCb3VuZCxcclxuICAgICAgICAgICAgb2Zmc2V0OiBoZWlnaHRPZmZzZXRJbmZvLm9mZnNldFsxXSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZWNoZWNrU2l6ZUJ5VHdvRGlyZWN0aW9uKG1vdmVhYmxlLCBwb3Nlcywgd2lkdGgsIGhlaWdodCwgbWF4V2lkdGgsIG1heEhlaWdodCwgZGlyZWN0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKSB7XHJcbiAgICB2YXIgc25hcFBvcyA9IGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXJlY3Rpb24pO1xyXG4gICAgdmFyIF9hID0gY2hlY2tNb3ZlYWJsZVNuYXBCb3VuZHMobW92ZWFibGUsIGlzUmVxdWVzdCwge1xyXG4gICAgICAgIHZlcnRpY2FsOiBbc25hcFBvc1swXV0sXHJcbiAgICAgICAgaG9yaXpvbnRhbDogW3NuYXBQb3NbMV1dLFxyXG4gICAgfSksIGhvcml6b250YWxPZmZzZXQgPSBfYS5ob3Jpem9udGFsLm9mZnNldCwgdmVydGljYWxPZmZzZXQgPSBfYS52ZXJ0aWNhbC5vZmZzZXQ7XHJcbiAgICBpZiAodGhyb3R0bGUodmVydGljYWxPZmZzZXQsIEZMT0FUX1BPSU5UX05VTSkgfHwgdGhyb3R0bGUoaG9yaXpvbnRhbE9mZnNldCwgRkxPQVRfUE9JTlRfTlVNKSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChnZXREcmFnRGlzdCh7XHJcbiAgICAgICAgICAgIGRhdGFzOiBkYXRhcyxcclxuICAgICAgICAgICAgZGlzdFg6IC12ZXJ0aWNhbE9mZnNldCxcclxuICAgICAgICAgICAgZGlzdFk6IC1ob3Jpem9udGFsT2Zmc2V0LFxyXG4gICAgICAgIH0pLCAyKSwgbmV4dFdpZHRoT2Zmc2V0ID0gX2JbMF0sIG5leHRIZWlnaHRPZmZzZXQgPSBfYlsxXTtcclxuICAgICAgICB2YXIgbmV4dFdpZHRoID0gTWF0aC5taW4obWF4V2lkdGggfHwgSW5maW5pdHksIHdpZHRoICsgZGlyZWN0aW9uWzBdICogbmV4dFdpZHRoT2Zmc2V0KTtcclxuICAgICAgICB2YXIgbmV4dEhlaWdodCA9IE1hdGgubWluKG1heEhlaWdodCB8fCBJbmZpbml0eSwgaGVpZ2h0ICsgZGlyZWN0aW9uWzFdICogbmV4dEhlaWdodE9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIFtuZXh0V2lkdGggLSB3aWR0aCwgbmV4dEhlaWdodCAtIGhlaWdodF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gWzAsIDBdO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrU2l6ZURpc3QobW92ZWFibGUsIGdldE5leHRQb3Nlcywgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKSB7XHJcbiAgICB2YXIgcG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSk7XHJcbiAgICB2YXIga2VlcFJhdGlvID0gbW92ZWFibGUucHJvcHMua2VlcFJhdGlvO1xyXG4gICAgdmFyIHdpZHRoT2Zmc2V0ID0gMDtcclxuICAgIHZhciBoZWlnaHRPZmZzZXQgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcclxuICAgICAgICB2YXIgbmV4dFBvc2VzID0gZ2V0TmV4dFBvc2VzKHdpZHRoT2Zmc2V0LCBoZWlnaHRPZmZzZXQpO1xyXG4gICAgICAgIHZhciBfYSA9IGdldFNpemVPZmZzZXRJbmZvKG1vdmVhYmxlLCBuZXh0UG9zZXMsIGRpcmVjdGlvbiwga2VlcFJhdGlvLCBpc1JlcXVlc3QsIGRhdGFzKSwgd2lkdGhPZmZzZXRJbmZvID0gX2Eud2lkdGgsIGhlaWdodE9mZnNldEluZm8gPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGlzV2lkdGhCb3VuZCA9IHdpZHRoT2Zmc2V0SW5mby5pc0JvdW5kO1xyXG4gICAgICAgIHZhciBpc0hlaWdodEJvdW5kID0gaGVpZ2h0T2Zmc2V0SW5mby5pc0JvdW5kO1xyXG4gICAgICAgIHZhciBuZXh0V2lkdGhPZmZzZXQgPSB3aWR0aE9mZnNldEluZm8ub2Zmc2V0O1xyXG4gICAgICAgIHZhciBuZXh0SGVpZ2h0T2Zmc2V0ID0gaGVpZ2h0T2Zmc2V0SW5mby5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKGkgPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1dpZHRoQm91bmQpIHtcclxuICAgICAgICAgICAgICAgIG5leHRXaWR0aE9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0hlaWdodEJvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0SGVpZ2h0T2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA9PT0gMCAmJiBpc1JlcXVlc3QgJiYgIWlzV2lkdGhCb3VuZCAmJiAhaXNIZWlnaHRCb3VuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWzAsIDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2VlcFJhdGlvKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aERpc3QgPSBhYnMobmV4dFdpZHRoT2Zmc2V0KSAqICh3aWR0aCA/IDEgLyB3aWR0aCA6IDEpO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0RGlzdCA9IGFicyhuZXh0SGVpZ2h0T2Zmc2V0KSAqIChoZWlnaHQgPyAxIC8gaGVpZ2h0IDogMSk7XHJcbiAgICAgICAgICAgIHZhciBpc0dldFdpZHRoT2Zmc2V0ID0gaXNXaWR0aEJvdW5kICYmIGlzSGVpZ2h0Qm91bmRcclxuICAgICAgICAgICAgICAgID8gd2lkdGhEaXN0IDwgaGVpZ2h0RGlzdFxyXG4gICAgICAgICAgICAgICAgOiBpc0hlaWdodEJvdW5kIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKCFpc1dpZHRoQm91bmQgJiYgd2lkdGhEaXN0IDwgaGVpZ2h0RGlzdCk7XHJcbiAgICAgICAgICAgIGlmIChpc0dldFdpZHRoT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aWR0aCA6IGhlaWdodCA9ID8gOiBoZWlnaHRPZmZzZXRcclxuICAgICAgICAgICAgICAgIG5leHRXaWR0aE9mZnNldCA9ICh3aWR0aCAqIG5leHRIZWlnaHRPZmZzZXQpIC8gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gd2lkdGggOiBoZWlnaHQgPSB3aWR0aE9mZnNldCA6ID9cclxuICAgICAgICAgICAgICAgIG5leHRIZWlnaHRPZmZzZXQgPSAoaGVpZ2h0ICogbmV4dFdpZHRoT2Zmc2V0KSAvIHdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdpZHRoT2Zmc2V0ICs9IG5leHRXaWR0aE9mZnNldDtcclxuICAgICAgICBoZWlnaHRPZmZzZXQgKz0gbmV4dEhlaWdodE9mZnNldDtcclxuICAgIH1cclxuICAgIGlmICgha2VlcFJhdGlvICYmIGRpcmVjdGlvblswXSAmJiBkaXJlY3Rpb25bMV0pIHtcclxuICAgICAgICB2YXIgX2IgPSBjaGVja01heEJvdW5kcyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZGF0YXMpLCBtYXhXaWR0aCA9IF9iLm1heFdpZHRoLCBtYXhIZWlnaHQgPSBfYi5tYXhIZWlnaHQ7XHJcbiAgICAgICAgdmFyIF9jID0gX19yZWFkKHJlY2hlY2tTaXplQnlUd29EaXJlY3Rpb24obW92ZWFibGUsIGdldE5leHRQb3Nlcyh3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0KS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gdGhyb3R0bGUocCwgRkxPQVRfUE9JTlRfTlVNKTsgfSk7IH0pLCB3aWR0aCArIHdpZHRoT2Zmc2V0LCBoZWlnaHQgKyBoZWlnaHRPZmZzZXQsIG1heFdpZHRoLCBtYXhIZWlnaHQsIGRpcmVjdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcyksIDIpLCBuZXh0V2lkdGhPZmZzZXQgPSBfY1swXSwgbmV4dEhlaWdodE9mZnNldCA9IF9jWzFdO1xyXG4gICAgICAgIHdpZHRoT2Zmc2V0ICs9IG5leHRXaWR0aE9mZnNldDtcclxuICAgICAgICBoZWlnaHRPZmZzZXQgKz0gbmV4dEhlaWdodE9mZnNldDtcclxuICAgIH1cclxuICAgIHJldHVybiBbd2lkdGhPZmZzZXQsIGhlaWdodE9mZnNldF07XHJcbn1cclxuZnVuY3Rpb24gYWJzRGVncmVlKGRlZykge1xyXG4gICAgaWYgKGRlZyA8IDApIHtcclxuICAgICAgICBkZWcgPSBkZWcgJSAzNjAgKyAzNjA7XHJcbiAgICB9XHJcbiAgICBkZWcgJT0gMzYwO1xyXG4gICAgcmV0dXJuIGRlZztcclxufVxyXG5mdW5jdGlvbiBidW1wRGVncmVlKGJhc2VEZWcsIHNuYXBEZWcpIHtcclxuICAgIC8vIGJhc2VEZWcgLTgwXHJcbiAgICAvLyBzbmFwRGVnIDI3MFxyXG4gICAgLy8gcmV0dXJuIC05MFxyXG4gICAgc25hcERlZyA9IGFic0RlZ3JlZShzbmFwRGVnKTtcclxuICAgIHZhciBjb3VudCA9IE1hdGguZmxvb3IoYmFzZURlZyAvIDM2MCk7XHJcbiAgICB2YXIgZGVnMSA9IGNvdW50ICogMzYwICsgMzYwIC0gc25hcERlZztcclxuICAgIHZhciBkZWcyID0gY291bnQgKiAzNjAgKyBzbmFwRGVnO1xyXG4gICAgcmV0dXJuIGFicyhiYXNlRGVnIC0gZGVnMSkgPCBhYnMoYmFzZURlZyAtIGRlZzIpID8gZGVnMSA6IGRlZzI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TWluRGVncmVlRGlzdGFuY2UoZGVnMSwgZGVnMikge1xyXG4gICAgZGVnMSA9IGFic0RlZ3JlZShkZWcxKTtcclxuICAgIGRlZzIgPSBhYnNEZWdyZWUoZGVnMik7XHJcbiAgICB2YXIgZGVnMyA9IGFic0RlZ3JlZShkZWcxIC0gZGVnMik7XHJcbiAgICByZXR1cm4gTWF0aC5taW4oZGVnMywgMzYwIC0gZGVnMyk7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTbmFwUm90YXRlKG1vdmVhYmxlLCByZWN0LCBkaXN0LCByb3RhdGlvbikge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICB2YXIgc25hcFJvdGF0aW9uVGhyZXNob2xkID0gKF9hID0gcHJvcHNbTkFNRV9zbmFwUm90YXRpb25UaHJlc2hvbGRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiA1O1xyXG4gICAgdmFyIHNuYXBSb3RhdGlvbkRlZ3JlZXMgPSBwcm9wc1tOQU1FX3NuYXBSb3RhdGlvbkRlZ3JlZXNdO1xyXG4gICAgaWYgKGhhc0d1aWRlbGluZXMobW92ZWFibGUsIFwicm90YXRhYmxlXCIpKSB7XHJcbiAgICAgICAgdmFyIHBvczEgPSByZWN0LnBvczEsIHBvczIgPSByZWN0LnBvczIsIHBvczMgPSByZWN0LnBvczMsIHBvczQgPSByZWN0LnBvczQsIG9yaWdpbjJfMSA9IHJlY3Qub3JpZ2luO1xyXG4gICAgICAgIHZhciByYWRfMSA9IChkaXN0ICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICAgICAgdmFyIHByZXZQb3NlcyA9IFtwb3MxLCBwb3MyLCBwb3MzLCBwb3M0XS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gbWludXMocG9zLCBvcmlnaW4yXzEpOyB9KTtcclxuICAgICAgICB2YXIgbmV4dFBvc2VzID0gcHJldlBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiByb3RhdGUocG9zLCByYWRfMSk7IH0pO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG1vdmVhYmxlLnN0YXRlLmxlZnQsIG1vdmVhYmxlLnN0YXRlLnRvcCwgbW92ZWFibGUuc3RhdGUub3JpZ2luKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhwb3MxLCBwb3MyLCBwb3MzLCBwb3M0LCBvcmlnaW4sIHJhZCwgcHJldlBvc2VzLCBuZXh0UG9zZXMpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChjaGVja1JvdGF0ZUJvdW5kcyhtb3ZlYWJsZSwgcHJldlBvc2VzLCBuZXh0UG9zZXMsIG9yaWdpbjJfMSwgZGlzdCkpLCBmYWxzZSksIF9fcmVhZChjaGVja1JvdGF0ZUlubmVyQm91bmRzKG1vdmVhYmxlLCBwcmV2UG9zZXMsIG5leHRQb3Nlcywgb3JpZ2luMl8xLCBkaXN0KSksIGZhbHNlKTtcclxuICAgICAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYWJzKGEgLSBkaXN0KSAtIGFicyhiIC0gZGlzdCk7IH0pO1xyXG4gICAgICAgIHZhciBpc1NuYXAgPSByZXN1bHQubGVuZ3RoID4gMDtcclxuICAgICAgICBpZiAoaXNTbmFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpc1NuYXA6IGlzU25hcCxcclxuICAgICAgICAgICAgICAgIGRpc3Q6IGlzU25hcCA/IHJlc3VsdFswXSA6IGRpc3QsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKChzbmFwUm90YXRpb25EZWdyZWVzID09PSBudWxsIHx8IHNuYXBSb3RhdGlvbkRlZ3JlZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNuYXBSb3RhdGlvbkRlZ3JlZXMubGVuZ3RoKSAmJiBzbmFwUm90YXRpb25UaHJlc2hvbGQpIHtcclxuICAgICAgICB2YXIgc29ydGVkID0gc25hcFJvdGF0aW9uRGVncmVlcy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldE1pbkRlZ3JlZURpc3RhbmNlKGEsIHJvdGF0aW9uKSAtIGdldE1pbkRlZ3JlZURpc3RhbmNlKGIsIHJvdGF0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgZmlyc3REZWdyZWUgPSBzb3J0ZWRbMF07XHJcbiAgICAgICAgaWYgKGdldE1pbkRlZ3JlZURpc3RhbmNlKGZpcnN0RGVncmVlLCByb3RhdGlvbikgPD0gc25hcFJvdGF0aW9uVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpc1NuYXA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBkaXN0OiBkaXN0ICsgYnVtcERlZ3JlZShyb3RhdGlvbiwgZmlyc3REZWdyZWUpIC0gcm90YXRpb24sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc1NuYXA6IGZhbHNlLFxyXG4gICAgICAgIGRpc3Q6IGRpc3QsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrU25hcFJlc2l6ZShtb3ZlYWJsZSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKSB7XHJcbiAgICBpZiAoIWhhc0d1aWRlbGluZXMobW92ZWFibGUsIFwicmVzaXphYmxlXCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcclxuICAgIH1cclxuICAgIHZhciBmaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uLCBuZXh0QWxsTWF0cml4ID0gZGF0YXMubmV4dEFsbE1hdHJpeDtcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCBhbGxNYXRyaXggPSBfYS5hbGxNYXRyaXgsIGlzM2QgPSBfYS5pczNkO1xyXG4gICAgcmV0dXJuIGNoZWNrU2l6ZURpc3QobW92ZWFibGUsIGZ1bmN0aW9uICh3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5leHRGaXhlZFBvc2VzKG5leHRBbGxNYXRyaXggfHwgYWxsTWF0cml4LCB3aWR0aCArIHdpZHRoT2Zmc2V0LCBoZWlnaHQgKyBoZWlnaHRPZmZzZXQsIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBpczNkKTtcclxuICAgIH0sIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcyk7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTbmFwU2NhbGUobW92ZWFibGUsIHNjYWxlLCBkaXJlY3Rpb24sIGlzUmVxdWVzdCwgZGF0YXMpIHtcclxuICAgIGlmICghaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJzY2FsYWJsZVwiKSkge1xyXG4gICAgICAgIHJldHVybiBbMCwgMF07XHJcbiAgICB9XHJcbiAgICB2YXIgc3RhcnRPZmZzZXRXaWR0aCA9IGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGgsIHN0YXJ0T2Zmc2V0SGVpZ2h0ID0gZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQsIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uLCBmaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uLCBpczNkID0gZGF0YXMuaXMzZDtcclxuICAgIHZhciBzaXplRGlzdCA9IGNoZWNrU2l6ZURpc3QobW92ZWFibGUsIGZ1bmN0aW9uICh3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5leHRGaXhlZFBvc2VzKHNjYWxlTWF0cml4KGRhdGFzLCBwbHVzKHNjYWxlLCBbd2lkdGhPZmZzZXQgLyBzdGFydE9mZnNldFdpZHRoLCBoZWlnaHRPZmZzZXQgLyBzdGFydE9mZnNldEhlaWdodF0pKSwgc3RhcnRPZmZzZXRXaWR0aCwgc3RhcnRPZmZzZXRIZWlnaHQsIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBpczNkKTtcclxuICAgIH0sIHN0YXJ0T2Zmc2V0V2lkdGgsIHN0YXJ0T2Zmc2V0SGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzUmVxdWVzdCwgZGF0YXMpO1xyXG4gICAgcmV0dXJuIFtzaXplRGlzdFswXSAvIHN0YXJ0T2Zmc2V0V2lkdGgsIHNpemVEaXN0WzFdIC8gc3RhcnRPZmZzZXRIZWlnaHRdO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0Q2hlY2tTbmFwRHJhZyhtb3ZlYWJsZSwgZGF0YXMpIHtcclxuICAgIGRhdGFzLmFic29sdXRlUG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U25hcEd1aWRlbGluZXMocG9zSW5mb3MpIHtcclxuICAgIHZhciBndWlkZWxpbmVzID0gW107XHJcbiAgICBwb3NJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChwb3NJbmZvKSB7XHJcbiAgICAgICAgcG9zSW5mby5ndWlkZWxpbmVJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgZ3VpZGVsaW5lID0gX2EuZ3VpZGVsaW5lO1xyXG4gICAgICAgICAgICBpZiAoZmluZChndWlkZWxpbmVzLCBmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5ndWlkZWxpbmUgPT09IGd1aWRlbGluZTsgfSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBndWlkZWxpbmUuZGlyZWN0aW9uID0gXCJcIjtcclxuICAgICAgICAgICAgZ3VpZGVsaW5lcy5wdXNoKHsgZ3VpZGVsaW5lOiBndWlkZWxpbmUsIHBvc0luZm86IHBvc0luZm8gfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBndWlkZWxpbmVzLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgZ3VpZGVsaW5lID0gX2EuZ3VpZGVsaW5lLCBwb3NJbmZvID0gX2EucG9zSW5mbztcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGd1aWRlbGluZSksIHsgZGlyZWN0aW9uOiBwb3NJbmZvLmRpcmVjdGlvbiB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGFkZEJvdW5kR3VpZGVsaW5lcyhtb3ZlYWJsZSwgdmVydGljYWxQb3NlcywgaG9yaXpvbnRhbFBvc2VzLCB2ZXJ0aWNhbFNuYXBQb3NlcywgaG9yaXpvbnRhbFNuYXBQb3NlcywgZXh0ZXJuYWxCb3VuZHMpIHtcclxuICAgIHZhciBfYSA9IGNoZWNrQm91bmRQb3NlcyhnZXRCb3VuZHMobW92ZWFibGUsIGV4dGVybmFsQm91bmRzKSwgdmVydGljYWxQb3NlcywgaG9yaXpvbnRhbFBvc2VzKSwgdmVydGljYWxCb3VuZEluZm9zID0gX2EudmVydGljYWwsIGhvcml6b250YWxCb3VuZEluZm9zID0gX2EuaG9yaXpvbnRhbDtcclxuICAgIHZhciBib3VuZE1hcCA9IGdldEluaXRpYWxCb3VuZHMoKTtcclxuICAgIHZlcnRpY2FsQm91bmRJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgaWYgKGluZm8uaXNCb3VuZCkge1xyXG4gICAgICAgICAgICBpZiAoaW5mby5kaXJlY3Rpb24gPT09IFwic3RhcnRcIikge1xyXG4gICAgICAgICAgICAgICAgYm91bmRNYXAubGVmdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGluZm8uZGlyZWN0aW9uID09PSBcImVuZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZE1hcC5yaWdodCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmVydGljYWxTbmFwUG9zZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvdW5kc1wiLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBpbmZvLnBvcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBob3Jpem9udGFsQm91bmRJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgaWYgKGluZm8uaXNCb3VuZCkge1xyXG4gICAgICAgICAgICBpZiAoaW5mby5kaXJlY3Rpb24gPT09IFwic3RhcnRcIikge1xyXG4gICAgICAgICAgICAgICAgYm91bmRNYXAudG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW5mby5kaXJlY3Rpb24gPT09IFwiZW5kXCIpIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kTWFwLmJvdHRvbSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaG9yaXpvbnRhbFNuYXBQb3Nlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm91bmRzXCIsXHJcbiAgICAgICAgICAgICAgICBwb3M6IGluZm8ucG9zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciBfYiA9IGNoZWNrSW5uZXJCb3VuZFBvc2VzKG1vdmVhYmxlKSwgaW5uZXJCb3VuZE1hcCA9IF9iLmJvdW5kTWFwLCB2ZXJ0aWNhbElubmVyQm91bmRQb3NlcyA9IF9iLnZlcnRpY2FsLCBob3Jpem9udGFsSW5uZXJCb3VuZFBvc2VzID0gX2IuaG9yaXpvbnRhbDtcclxuICAgIHZlcnRpY2FsSW5uZXJCb3VuZFBvc2VzLmZvckVhY2goZnVuY3Rpb24gKGlubmVyUG9zKSB7XHJcbiAgICAgICAgaWYgKGZpbmRJbmRleCh2ZXJ0aWNhbFNuYXBQb3NlcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZSwgcG9zID0gX2EucG9zO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJib3VuZHNcIiAmJiBwb3MgPT09IGlubmVyUG9zO1xyXG4gICAgICAgIH0pID49IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZXJ0aWNhbFNuYXBQb3Nlcy5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogXCJib3VuZHNcIixcclxuICAgICAgICAgICAgcG9zOiBpbm5lclBvcyxcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgaG9yaXpvbnRhbElubmVyQm91bmRQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbm5lclBvcykge1xyXG4gICAgICAgIGlmIChmaW5kSW5kZXgoaG9yaXpvbnRhbFNuYXBQb3NlcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZSwgcG9zID0gX2EucG9zO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJib3VuZHNcIiAmJiBwb3MgPT09IGlubmVyUG9zO1xyXG4gICAgICAgIH0pID49IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3Jpem9udGFsU25hcFBvc2VzLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiBcImJvdW5kc1wiLFxyXG4gICAgICAgICAgICBwb3M6IGlubmVyUG9zLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJvdW5kTWFwOiBib3VuZE1hcCxcclxuICAgICAgICBpbm5lckJvdW5kTWFwOiBpbm5lckJvdW5kTWFwLFxyXG4gICAgfTtcclxufVxyXG52YXIgZGlyZWN0aW9uQ29uZGl0aW9uJDEgPSBnZXREaXJlY3Rpb25Db25kaXRpb24oXCJcIiwgW1wicmVzaXphYmxlXCIsIFwic2NhbGFibGVcIl0pO1xyXG4vKipcclxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5TbmFwcGFibGVcclxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgc25hcHBlZCB0byB0aGUgZ3VpZGVsaW5lLiAoZGVmYXVsdDogZmFsc2UpXHJcbiAqIEBzb3J0IDJcclxuICovXHJcbnZhciBTbmFwcGFibGUgPSB7XHJcbiAgICBuYW1lOiBcInNuYXBwYWJsZVwiLFxyXG4gICAgZHJhZ1JlbGF0aW9uOiBcInN0cm9uZ1wiLFxyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcInNuYXBwYWJsZVwiLFxyXG4gICAgICAgIFwic25hcENvbnRhaW5lclwiLFxyXG4gICAgICAgIFwic25hcERpcmVjdGlvbnNcIixcclxuICAgICAgICBcImVsZW1lbnRTbmFwRGlyZWN0aW9uc1wiLFxyXG4gICAgICAgIFwic25hcEdhcFwiLFxyXG4gICAgICAgIFwic25hcEdyaWRXaWR0aFwiLFxyXG4gICAgICAgIFwic25hcEdyaWRIZWlnaHRcIixcclxuICAgICAgICBcImlzRGlzcGxheVNuYXBEaWdpdFwiLFxyXG4gICAgICAgIFwiaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXRcIixcclxuICAgICAgICBcImlzRGlzcGxheUdyaWRHdWlkZWxpbmVzXCIsXHJcbiAgICAgICAgXCJzbmFwRGlnaXRcIixcclxuICAgICAgICBcInNuYXBUaHJlc2hvbGRcIixcclxuICAgICAgICBcInNuYXBSZW5kZXJUaHJlc2hvbGRcIixcclxuICAgICAgICBcInNuYXBHcmlkQWxsXCIsXHJcbiAgICAgICAgTkFNRV9zbmFwUm90YXRpb25UaHJlc2hvbGQsXHJcbiAgICAgICAgTkFNRV9zbmFwUm90YXRpb25EZWdyZWVzLFxyXG4gICAgICAgIE5BTUVfc25hcEhvcml6b250YWxUaHJlc2hvbGQsXHJcbiAgICAgICAgTkFNRV9zbmFwVmVydGljYWxUaHJlc2hvbGQsXHJcbiAgICAgICAgXCJob3Jpem9udGFsR3VpZGVsaW5lc1wiLFxyXG4gICAgICAgIFwidmVydGljYWxHdWlkZWxpbmVzXCIsXHJcbiAgICAgICAgXCJlbGVtZW50R3VpZGVsaW5lc1wiLFxyXG4gICAgICAgIFwiYm91bmRzXCIsXHJcbiAgICAgICAgXCJpbm5lckJvdW5kc1wiLFxyXG4gICAgICAgIFwic25hcERpc3RGb3JtYXRcIixcclxuICAgICAgICBcIm1heFNuYXBFbGVtZW50R3VpZGVsaW5lRGlzdGFuY2VcIixcclxuICAgICAgICBcIm1heFNuYXBFbGVtZW50R2FwRGlzdGFuY2VcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcInNuYXBcIiwgXCJib3VuZFwiXSxcclxuICAgIGNzczogW1xyXG4gICAgICAgIFwiOmhvc3Qge1xcbi0tYm91bmRzLWNvbG9yOiAjZDY2O1xcbn1cXG4uZ3VpZGVsaW5lIHtcXG5wb2ludGVyLWV2ZW50czogbm9uZTtcXG56LWluZGV4OiAyO1xcbn1cXG4uZ3VpZGVsaW5lLmJvdW5kcyB7XFxuYmFja2dyb3VuZDogI2Q2NjtcXG5iYWNrZ3JvdW5kOiB2YXIoLS1ib3VuZHMtY29sb3IpO1xcbn1cXG4uZ3VpZGVsaW5lLWdyb3VwIHtcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxudG9wOiAwO1xcbmxlZnQ6IDA7XFxufVxcbi5ndWlkZWxpbmUtZ3JvdXAgLnNpemUtdmFsdWUge1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5jb2xvcjogI2Y1NTtcXG5mb250LXNpemU6IDEycHg7XFxuZm9udC1zaXplOiBjYWxjKDEycHggKiB2YXIoLS16b29tKSk7XFxuZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi5ndWlkZWxpbmUtZ3JvdXAuaG9yaXpvbnRhbCAuc2l6ZS12YWx1ZSB7XFxudHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxudHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xcbmxlZnQ6IDUwJTtcXG5ib3R0b206IDVweDtcXG5ib3R0b206IGNhbGMoMnB4ICsgM3B4ICogdmFyKC0tem9vbSkpO1xcbn1cXG4uZ3VpZGVsaW5lLWdyb3VwLnZlcnRpY2FsIC5zaXplLXZhbHVlIHtcXG50cmFuc2Zvcm0tb3JpZ2luOiAwJSA1MCU7XFxudG9wOiA1MCU7XFxudHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xcbmxlZnQ6IDVweDtcXG5sZWZ0OiBjYWxjKDJweCArIDNweCAqIHZhcigtLXpvb20pKTtcXG59XFxuLmd1aWRlbGluZS5nYXAge1xcbmJhY2tncm91bmQ6ICNmNTU7XFxufVxcbi5zaXplLXZhbHVlLmdhcCB7XFxuY29sb3I6ICNmNTU7XFxufVxcblwiLFxyXG4gICAgXSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgICAgIHZhciB0YXJnZXRUb3AgPSBzdGF0ZS50b3AsIHRhcmdldExlZnQgPSBzdGF0ZS5sZWZ0LCBwb3MxID0gc3RhdGUucG9zMSwgcG9zMiA9IHN0YXRlLnBvczIsIHBvczMgPSBzdGF0ZS5wb3MzLCBwb3M0ID0gc3RhdGUucG9zNCwgc25hcFJlbmRlckluZm8gPSBzdGF0ZS5zbmFwUmVuZGVySW5mbztcclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcy5zbmFwUmVuZGVyVGhyZXNob2xkLCBzbmFwUmVuZGVyVGhyZXNob2xkID0gX2EgPT09IHZvaWQgMCA/IDEgOiBfYTtcclxuICAgICAgICBpZiAoIXNuYXBSZW5kZXJJbmZvIHx8ICFzbmFwUmVuZGVySW5mby5yZW5kZXIgfHwgIWhhc0d1aWRlbGluZXMobW92ZWFibGUsIFwiXCIpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHN0b3JlXHJcbiAgICAgICAgICAgIHdhdGNoVmFsdWUobW92ZWFibGUsIFwiYm91bmRNYXBcIiwgZ2V0SW5pdGlhbEJvdW5kcygpLCBmdW5jdGlvbiAodikgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7IH0pO1xyXG4gICAgICAgICAgICB3YXRjaFZhbHVlKG1vdmVhYmxlLCBcImlubmVyQm91bmRNYXBcIiwgZ2V0SW5pdGlhbEJvdW5kcygpLCBmdW5jdGlvbiAodikgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7IH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLmd1aWRlbGluZXMgPSBnZXRUb3RhbEd1aWRlbGluZXMobW92ZWFibGUpO1xyXG4gICAgICAgIHZhciBtaW5MZWZ0ID0gTWF0aC5taW4ocG9zMVswXSwgcG9zMlswXSwgcG9zM1swXSwgcG9zNFswXSk7XHJcbiAgICAgICAgdmFyIG1pblRvcCA9IE1hdGgubWluKHBvczFbMV0sIHBvczJbMV0sIHBvczNbMV0sIHBvczRbMV0pO1xyXG4gICAgICAgIHZhciBleHRlcm5hbFBvc2VzID0gc25hcFJlbmRlckluZm8uZXh0ZXJuYWxQb3NlcyB8fCBbXTtcclxuICAgICAgICB2YXIgcG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSk7XHJcbiAgICAgICAgdmFyIHZlcnRpY2FsU25hcFBvc2VzID0gW107XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxTbmFwUG9zZXMgPSBbXTtcclxuICAgICAgICB2YXIgdmVydGljYWxHdWlkZWxpbmVzID0gW107XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxHdWlkZWxpbmVzID0gW107XHJcbiAgICAgICAgdmFyIHNuYXBJbmZvcyA9IFtdO1xyXG4gICAgICAgIHZhciBfYiA9IGdldFJlY3QocG9zZXMpLCB3aWR0aCA9IF9iLndpZHRoLCBoZWlnaHQgPSBfYi5oZWlnaHQsIHRvcCA9IF9iLnRvcCwgbGVmdCA9IF9iLmxlZnQsIGJvdHRvbSA9IF9iLmJvdHRvbSwgcmlnaHQgPSBfYi5yaWdodDtcclxuICAgICAgICB2YXIgdGFyZ2V0UmVjdCA9IHsgbGVmdDogbGVmdCwgcmlnaHQ6IHJpZ2h0LCB0b3A6IHRvcCwgYm90dG9tOiBib3R0b20sIGNlbnRlcjogKGxlZnQgKyByaWdodCkgLyAyLCBtaWRkbGU6ICh0b3AgKyBib3R0b20pIC8gMiB9O1xyXG4gICAgICAgIHZhciBoYXNFeHRlcm5hbFBvc2VzID0gZXh0ZXJuYWxQb3Nlcy5sZW5ndGggPiAwO1xyXG4gICAgICAgIHZhciBleHRlcm5hbFJlY3QgPSBoYXNFeHRlcm5hbFBvc2VzXHJcbiAgICAgICAgICAgID8gZ2V0UmVjdChleHRlcm5hbFBvc2VzKVxyXG4gICAgICAgICAgICA6IHt9O1xyXG4gICAgICAgIGlmICghc25hcFJlbmRlckluZm8ucmVxdWVzdCkge1xyXG4gICAgICAgICAgICBpZiAoc25hcFJlbmRlckluZm8uZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBzbmFwSW5mb3MucHVzaChnZXRTbmFwSW5mb3NCeURpcmVjdGlvbihtb3ZlYWJsZSwgcG9zZXMsIHNuYXBSZW5kZXJJbmZvLmRpcmVjdGlvbiwgc25hcFJlbmRlclRocmVzaG9sZCwgc25hcFJlbmRlclRocmVzaG9sZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzbmFwUmVuZGVySW5mby5zbmFwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGdldFJlY3QocG9zZXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNuYXBSZW5kZXJJbmZvLmNlbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3QubWlkZGxlID0gKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICByZWN0LmNlbnRlciA9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzbmFwSW5mb3MucHVzaChjaGVja1NuYXBzKG1vdmVhYmxlLCByZWN0LCBzbmFwUmVuZGVyVGhyZXNob2xkLCBzbmFwUmVuZGVyVGhyZXNob2xkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhhc0V4dGVybmFsUG9zZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzbmFwUmVuZGVySW5mby5jZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbFJlY3QubWlkZGxlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKGV4dGVybmFsUmVjdC50b3AgKyBleHRlcm5hbFJlY3QuYm90dG9tKSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWxSZWN0LmNlbnRlciA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChleHRlcm5hbFJlY3QubGVmdCArIGV4dGVybmFsUmVjdC5yaWdodCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc25hcEluZm9zLnB1c2goY2hlY2tTbmFwcyhtb3ZlYWJsZSwgZXh0ZXJuYWxSZWN0LCBzbmFwUmVuZGVyVGhyZXNob2xkLCBzbmFwUmVuZGVyVGhyZXNob2xkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc25hcEluZm9zLmZvckVhY2goZnVuY3Rpb24gKHNuYXBJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljYWxQb3NJbmZvcyA9IHNuYXBJbmZvLnZlcnRpY2FsLnBvc0luZm9zLCBob3Jpem9udGFsUG9zSW5mb3MgPSBzbmFwSW5mby5ob3Jpem9udGFsLnBvc0luZm9zO1xyXG4gICAgICAgICAgICAgICAgdmVydGljYWxTbmFwUG9zZXMucHVzaC5hcHBseSh2ZXJ0aWNhbFNuYXBQb3NlcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHZlcnRpY2FsUG9zSW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBndWlkZWxpbmVJbmZvcyA9IF9hLmd1aWRlbGluZUluZm9zO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBndWlkZWxpbmVJbmZvcy5zb21lKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3VpZGVsaW5lID0gX2EuZ3VpZGVsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWd1aWRlbGluZS5oaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChwb3NJbmZvKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic25hcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvczogcG9zSW5mby5wb3MsXHJcbiAgICAgICAgICAgICAgICB9KTsgfSkpLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbFNuYXBQb3Nlcy5wdXNoLmFwcGx5KGhvcml6b250YWxTbmFwUG9zZXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChob3Jpem9udGFsUG9zSW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBndWlkZWxpbmVJbmZvcyA9IF9hLmd1aWRlbGluZUluZm9zO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBndWlkZWxpbmVJbmZvcy5zb21lKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3VpZGVsaW5lID0gX2EuZ3VpZGVsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWd1aWRlbGluZS5oaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChwb3NJbmZvKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic25hcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvczogcG9zSW5mby5wb3MsXHJcbiAgICAgICAgICAgICAgICB9KTsgfSkpLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICAgICAgdmVydGljYWxHdWlkZWxpbmVzLnB1c2guYXBwbHkodmVydGljYWxHdWlkZWxpbmVzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZ2V0U25hcEd1aWRlbGluZXModmVydGljYWxQb3NJbmZvcykpLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEd1aWRlbGluZXMucHVzaC5hcHBseShob3Jpem9udGFsR3VpZGVsaW5lcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGdldFNuYXBHdWlkZWxpbmVzKGhvcml6b250YWxQb3NJbmZvcykpLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9jID0gYWRkQm91bmRHdWlkZWxpbmVzKG1vdmVhYmxlLCBbbGVmdCwgcmlnaHRdLCBbdG9wLCBib3R0b21dLCB2ZXJ0aWNhbFNuYXBQb3NlcywgaG9yaXpvbnRhbFNuYXBQb3NlcyksIGJvdW5kTWFwID0gX2MuYm91bmRNYXAsIGlubmVyQm91bmRNYXAgPSBfYy5pbm5lckJvdW5kTWFwO1xyXG4gICAgICAgIGlmIChoYXNFeHRlcm5hbFBvc2VzKSB7XHJcbiAgICAgICAgICAgIGFkZEJvdW5kR3VpZGVsaW5lcyhtb3ZlYWJsZSwgW2V4dGVybmFsUmVjdC5sZWZ0LCBleHRlcm5hbFJlY3QucmlnaHRdLCBbZXh0ZXJuYWxSZWN0LnRvcCwgZXh0ZXJuYWxSZWN0LmJvdHRvbV0sIHZlcnRpY2FsU25hcFBvc2VzLCBob3Jpem9udGFsU25hcFBvc2VzLCBzbmFwUmVuZGVySW5mby5leHRlcm5hbEJvdW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhbGxHdWlkZWxpbmVzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodmVydGljYWxHdWlkZWxpbmVzKSwgZmFsc2UpLCBfX3JlYWQoaG9yaXpvbnRhbEd1aWRlbGluZXMpLCBmYWxzZSk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRHdWlkZWxpbmVzID0gYWxsR3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGd1aWRlbGluZSkgeyByZXR1cm4gZ3VpZGVsaW5lLmVsZW1lbnQgJiYgIWd1aWRlbGluZS5nYXBSZWN0czsgfSk7XHJcbiAgICAgICAgdmFyIGdhcEd1aWRlbGluZXMgPSBhbGxHdWlkZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7IHJldHVybiBndWlkZWxpbmUuZ2FwUmVjdHM7IH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuZ2FwIC0gYi5nYXA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uU25hcFwiLCB7XHJcbiAgICAgICAgICAgIGd1aWRlbGluZXM6IGFsbEd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfYS5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFlbGVtZW50O1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRHdWlkZWxpbmVzLFxyXG4gICAgICAgICAgICBnYXBzOiBnYXBHdWlkZWxpbmVzLFxyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIHZhciBuZXh0Qm91bmRNYXAgPSB3YXRjaFZhbHVlKG1vdmVhYmxlLCBcImJvdW5kTWFwXCIsIGJvdW5kTWFwLCBmdW5jdGlvbiAodikgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7IH0sIGdldEluaXRpYWxCb3VuZHMoKSk7XHJcbiAgICAgICAgdmFyIG5leHRJbm5lckJvdW5kTWFwID0gd2F0Y2hWYWx1ZShtb3ZlYWJsZSwgXCJpbm5lckJvdW5kTWFwXCIsIGlubmVyQm91bmRNYXAsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTsgfSwgZ2V0SW5pdGlhbEJvdW5kcygpKTtcclxuICAgICAgICBpZiAoYm91bmRNYXAgPT09IG5leHRCb3VuZE1hcCB8fCBpbm5lckJvdW5kTWFwID09PSBuZXh0SW5uZXJCb3VuZE1hcCkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Cb3VuZFwiLCB7XHJcbiAgICAgICAgICAgICAgICBib3VuZHM6IGJvdW5kTWFwLFxyXG4gICAgICAgICAgICAgICAgaW5uZXJCb3VuZHM6IGlubmVyQm91bmRNYXAsXHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB2ZXJ0aWNhbFNuYXBQb3Nlcy5cclxuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChyZW5kZXJEYXNoZWRHdWlkZWxpbmVzKG1vdmVhYmxlLCBlbGVtZW50R3VpZGVsaW5lcywgW21pbkxlZnQsIG1pblRvcF0sIHRhcmdldFJlY3QsIFJlYWN0KSksIGZhbHNlKSwgX19yZWFkKHJlbmRlckdhcEd1aWRlbGluZXMobW92ZWFibGUsIGdhcEd1aWRlbGluZXMsIFttaW5MZWZ0LCBtaW5Ub3BdLCB0YXJnZXRSZWN0LCBSZWFjdCkpLCBmYWxzZSksIF9fcmVhZChyZW5kZXJHdWlkZWxpbmVzKG1vdmVhYmxlLCBcImhvcml6b250YWxcIiwgaG9yaXpvbnRhbEd1aWRlbGluZXMsIFt0YXJnZXRMZWZ0LCB0YXJnZXRUb3BdLCB0YXJnZXRSZWN0LCBSZWFjdCkpLCBmYWxzZSksIF9fcmVhZChyZW5kZXJHdWlkZWxpbmVzKG1vdmVhYmxlLCBcInZlcnRpY2FsXCIsIHZlcnRpY2FsR3VpZGVsaW5lcywgW3RhcmdldExlZnQsIHRhcmdldFRvcF0sIHRhcmdldFJlY3QsIFJlYWN0KSksIGZhbHNlKSwgX19yZWFkKHJlbmRlclNuYXBQb3Nlcyhtb3ZlYWJsZSwgXCJob3Jpem9udGFsXCIsIGhvcml6b250YWxTbmFwUG9zZXMsIG1pbkxlZnQsIHRhcmdldFRvcCwgd2lkdGgsIDAsIFJlYWN0KSksIGZhbHNlKSwgX19yZWFkKHJlbmRlclNuYXBQb3Nlcyhtb3ZlYWJsZSwgXCJ2ZXJ0aWNhbFwiLCB2ZXJ0aWNhbFNuYXBQb3NlcywgbWluVG9wLCB0YXJnZXRMZWZ0LCBoZWlnaHQsIDEsIFJlYWN0KSksIGZhbHNlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xyXG4gICAgICAgICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdCxcclxuICAgICAgICAgICAgc25hcDogdHJ1ZSxcclxuICAgICAgICAgICAgY2VudGVyOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2hlY2tTbmFwSW5mbyhtb3ZlYWJsZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgaWYgKCFjaGVja1NuYXBJbmZvKG1vdmVhYmxlKSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5ndWlkZWxpbmVzID0gZ2V0VG90YWxHdWlkZWxpbmVzKG1vdmVhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLnNuYXBSZW5kZXJJbmZvKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLnNuYXBSZW5kZXJJbmZvLnJlbmRlciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHBpbmNoU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uQ29uZGl0aW9uJDEobW92ZWFibGUsIGUpIHx8IGRyYWdDb250cm9sQ29uZGl0aW9uKG1vdmVhYmxlLCBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFlLmlzUmVxdWVzdCAmJiBlLmlucHV0RXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc0NsYXNzKGUuaW5wdXRFdmVudC50YXJnZXQsIHByZWZpeChcInNuYXAtY29udHJvbFwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0gbnVsbDtcclxuICAgICAgICBjaGVja1NuYXBJbmZvKG1vdmVhYmxlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnKG1vdmVhYmxlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHRoaXMuZHJhZyhtb3ZlYWJsZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB0aGlzLnVuc2V0KG1vdmVhYmxlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0gbnVsbDtcclxuICAgICAgICBjaGVja1NuYXBJbmZvKG1vdmVhYmxlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB0aGlzLmRyYWcobW92ZWFibGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xyXG4gICAgfSxcclxuICAgIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICBzdGF0ZS5lbmFibGVTbmFwID0gZmFsc2U7XHJcbiAgICAgICAgc3RhdGUuZ3VpZGVsaW5lcyA9IFtdO1xyXG4gICAgICAgIHN0YXRlLnNuYXBSZW5kZXJJbmZvID0gbnVsbDtcclxuICAgICAgICBzdGF0ZS5lbGVtZW50UmVjdHMgPSBbXTtcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHNuYXBwZWQgdG8gdGhlIGd1aWRlbGluZS4gKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcHBhYmxlXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUuc25hcHBhYmxlID0gdHJ1ZTtcclxuICovXHJcbi8qKlxyXG4gKiAgQSBzbmFwIGNvbnRhaW5lciB0aGF0IGlzIHRoZSBiYXNpcyBmb3Igc25hcCwgYm91bmRzLCBhbmQgaW5uZXJCb3VuZHMuIChkZWZhdWx0OiBudWxsID0gY29udGFpbmVyKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcENvbnRhaW5lclxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5jb250YWluZXJcIikpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5zbmFwQ29udGFpbmVyID0gZG9jdW1lbnQuYm9keTtcclxuICovXHJcbi8qKlxyXG4gKiBZb3UgY2FuIHNwZWNpZnkgdGhlIGRpcmVjdGlvbnMgdG8gc25hcCB0byB0aGUgdGFyZ2V0LiAoZGVmYXVsdDogeyBsZWZ0OiB0cnVlLCB0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUgfSlcclxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBEaXJlY3Rpb25zXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgc25hcHBhYmxlOiB0cnVlLFxyXG4gKiAgIHNuYXBEaXJlY3Rpb25zOiB0cnVlLFxyXG4gKiB9KTtcclxuICogLy8gc25hcCBjZW50ZXJcclxuICogbW92ZWFibGUuc25hcERpcmVjdGlvbnMgPSB7IGxlZnQ6IHRydWUsIHRvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgY2VudGVyOiB0cnVlLCBtaWRkbGU6IHRydWUgfTtcclxuICovXHJcbi8qKlxyXG4gKiBZb3UgY2FuIHNwZWNpZnkgdGhlIHNuYXAgZGlyZWN0aW9ucyBvZiBlbGVtZW50cy4gKGRlZmF1bHQ6IHsgbGVmdDogdHJ1ZSwgZnRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUgfSlcclxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2VsZW1lbnRTbmFwRGlyZWN0aW9uc1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgIHNuYXBwYWJsZTogdHJ1ZSxcclxuICogICBlbGVtZW50U25hcERpcmVjdGlvbnM6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiAvLyBzbmFwIGNlbnRlclxyXG4gKiBtb3ZlYWJsZS5lbGVtZW50U25hcERpcmVjdGlvbnMgPSB7IGxlZnQ6IHRydWUsIHRvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgY2VudGVyOiB0cnVlLCBtaWRkbGU6IHRydWUgfTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHlvdSBkcmFnLCBtYWtlIHRoZSBnYXAgc25hcCBpbiB0aGUgZWxlbWVudCBndWlkZWxpbmVzLiAoZGVmYXVsdDogdHJ1ZSlcclxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBHYXBcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICBzbmFwcGFibGU6IHRydWUsXHJcbiAqICAgc25hcEVsZW1lbnQ6IHRydWUsXHJcbiAqICAgc25hcEdhcDogdHJ1ZSxcclxuICogfSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnNuYXBHYXAgPSBmYWxzZTtcclxuICovXHJcbi8qKlxyXG4gKiBEaXN0YW5jZSB2YWx1ZSB0aGF0IGNhbiBzbmFwIHRvIGd1aWRlbGluZXMuIChkZWZhdWx0OiA1KVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcFRocmVzaG9sZFxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnNuYXBUaHJlc2hvbGQgPSA1O1xyXG4gKi9cclxuLyoqXHJcbiAqIEFkZCBndWlkZWxpbmVzIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbi4gKGRlZmF1bHQ6IFtdKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjaG9yaXpvbnRhbEd1aWRlbGluZXNcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5ob3Jpem9udGFsR3VpZGVsaW5lcyA9IFsxMDAsIDIwMCwgNTAwXTtcclxuICovXHJcbi8qKlxyXG4gKiBBZGQgZ3VpZGVsaW5lcyBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uLiAoZGVmYXVsdDogW10pXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSN2ZXJ0aWNhbEd1aWRlbGluZXNcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS52ZXJ0aWNhbEd1aWRlbGluZXMgPSBbMTAwLCAyMDAsIDUwMF07XHJcbiAqL1xyXG4vKipcclxuICogQWRkIGd1aWRlbGluZXMgZm9yIHRoZSBlbGVtZW50LiAoZGVmYXVsdDogW10pXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNlbGVtZW50R3VpZGVsaW5lc1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLmVsZW1lbnRHdWlkZWxpbmVzID0gW1xyXG4gKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZWxlbWVudFwiKSxcclxuICogXTtcclxuICovXHJcbi8qKlxyXG4gKiBZb3UgY2FuIHNldCB1cCBib3VuZGFyaWVzLlxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjYm91bmRzXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGRlZmF1bHQgbnVsbFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5ib3VuZHMgPSB7IGxlZnQ6IDAsIHJpZ2h0OiAxMDAwLCB0b3A6IDAsIGJvdHRvbTogMTAwMH07XHJcbiAqL1xyXG4vKipcclxuICogWW91IGNhbiBzZXQgdXAgaW5uZXIgYm91bmRhcmllcy5cclxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2lubmVyQm91bmRzXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGRlZmF1bHQgbnVsbFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5pbm5lckJvdW5kcyA9IHsgbGVmdDogNTAwLCB0b3A6IDUwMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDB9O1xyXG4gKi9cclxuLyoqXHJcbiAqIHNuYXAgZGlzdGFuY2UgZGlnaXRzIChkZWZhdWx0OiAwKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcERpZ2l0XHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUuc25hcERpZ2l0ID0gMFxyXG4gKi9cclxuLyoqXHJcbiAqIElmIHdpZHRoIHNpemUgaXMgZ3JlYXRlciB0aGFuIDAsIHlvdSBjYW4gdmVydGljYWwgc25hcCB0byB0aGUgZ3JpZC4gKGRlZmF1bHQ6IDApXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwR3JpZFdpZHRoXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUuc25hcEdyaWRXaWR0aCA9IDU7XHJcbiAqL1xyXG4vKipcclxuICogSWYgaGVpZ2h0IHNpemUgaXMgZ3JlYXRlciB0aGFuIDAsIHlvdSBjYW4gaG9yaXpvbnRhbCBzbmFwIHRvIHRoZSBncmlkLiAoZGVmYXVsdDogMClcclxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBHcmlkSGVpZ2h0XHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUuc25hcEdyaWRIZWlnaHQgPSA1O1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZXRoZXIgdG8gc2hvdyBzbmFwIGRpc3RhbmNlIChkZWZhdWx0OiB0cnVlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjaXNEaXNwbGF5U25hcERpZ2l0XHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUuaXNEaXNwbGF5U25hcERpZ2l0ID0gdHJ1ZTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRvIHNob3cgZWxlbWVudCBpbm5lciBzbmFwIGRpc3RhbmNlIChkZWZhdWx0OiBmYWxzZSlcclxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2lzRGlzcGxheUlubmVyU25hcERpZ2l0XHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUuaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqIFlvdSBjYW4gc2V0IHRoZSB0ZXh0IGZvcm1hdCBvZiB0aGUgZGlzdGFuY2Ugc2hvd24gaW4gdGhlIGd1aWRlbGluZXMuIChkZWZhdWx0OiBzZWxmKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcERpc3RGb3JtYXRcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogIHNuYXBwYWJsZTogdHJ1ZSxcclxuICogIHNuYXBEaXN0Rm9ybWF0OiAodiwgdHlwZSkgPT4gdixcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLnNuYXBEaXN0Rm9ybWF0ID0gKHYsIHR5cGUpID0+IGAke3Z9cHhgO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4geW91IGRyYWcgb3IgZHJhZ0NvbnRyb2wsIHRoZSBgc25hcGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU25hcHBhYmxlXHJcbiAqIEBldmVudCBzbmFwXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuU25hcHBhYmxlLk9uU25hcH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNuYXBgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgc25hcHBhYmxlOiB0cnVlXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInNuYXBcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uU25hcFwiLCBlKTtcclxuICogfSk7XHJcbiAqL1xuXG5mdW5jdGlvbiBtdWx0aXBseTIocG9zMSwgcG9zMikge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBwb3MxWzBdICogcG9zMlswXSxcclxuICAgICAgICBwb3MxWzFdICogcG9zMlsxXSxcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gcHJlZml4KCkge1xyXG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgY2xhc3NOYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByZWZpeE5hbWVzLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbUFJFRklYXSwgX19yZWFkKGNsYXNzTmFtZXMpLCBmYWxzZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmF1bHRTeW5jKGZuKSB7XHJcbiAgICBmbigpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zZm9ybU1hdHJpeCh0cmFuc2Zvcm0pIHtcclxuICAgIGlmICghdHJhbnNmb3JtIHx8IHRyYW5zZm9ybSA9PT0gXCJub25lXCIpIHtcclxuICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JqZWN0KHRyYW5zZm9ybSkpIHtcclxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnNlTWF0KHRyYW5zZm9ybSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVNYXRyaXgobWF0cml4LCBuLCBvcmlnaW4pIHtcclxuICAgIHJldHVybiBtdWx0aXBsaWVzKG4sIGNyZWF0ZU9yaWdpbk1hdHJpeChvcmlnaW4sIG4pLCBtYXRyaXgsIGNyZWF0ZU9yaWdpbk1hdHJpeChvcmlnaW4ubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAtYTsgfSksIG4pKTtcclxufVxyXG5mdW5jdGlvbiBtZWFzdXJlU1ZHU2l6ZShlbCwgdW5pdCwgaXNIb3Jpem9udGFsKSB7XHJcbiAgICBpZiAodW5pdCA9PT0gXCIlXCIpIHtcclxuICAgICAgICB2YXIgdmlld0JveCA9IGdldFNWR1ZpZXdCb3goZWwub3duZXJTVkdFbGVtZW50KTtcclxuICAgICAgICByZXR1cm4gdmlld0JveFtpc0hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSAvIDEwMDtcclxuICAgIH1cclxuICAgIHJldHVybiAxO1xyXG59XHJcbmZ1bmN0aW9uIGdldEJlZm9yZVRyYW5zZm9ybU9yaWdpbihlbCkge1xyXG4gICAgdmFyIHJlbGF0aXZlT3JpZ2luID0gZ2V0VHJhbnNmb3JtT3JpZ2luKGdldENvbXB1dGVkU3R5bGUoZWwsIFwiOmJlZm9yZVwiKSk7XHJcbiAgICByZXR1cm4gcmVsYXRpdmVPcmlnaW4ubWFwKGZ1bmN0aW9uIChvLCBpKSB7XHJcbiAgICAgICAgdmFyIF9hID0gc3BsaXRVbml0KG8pLCB2YWx1ZSA9IF9hLnZhbHVlLCB1bml0ID0gX2EudW5pdDtcclxuICAgICAgICByZXR1cm4gdmFsdWUgKiBtZWFzdXJlU1ZHU2l6ZShlbCwgdW5pdCwgaSA9PT0gMCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1PcmlnaW5BcnJheSh0cmFuc2Zvcm1PcmlnaW4pIHtcclxuICAgIHJldHVybiB0cmFuc2Zvcm1PcmlnaW4gPyB0cmFuc2Zvcm1PcmlnaW4uc3BsaXQoXCIgXCIpIDogW1wiMFwiLCBcIjBcIl07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtT3JpZ2luKHN0eWxlKSB7XHJcbiAgICByZXR1cm4gZ2V0VHJhbnNmb3JtT3JpZ2luQXJyYXkoc3R5bGUudHJhbnNmb3JtT3JpZ2luKTtcclxufVxyXG5mdW5jdGlvbiBnZXRFbGVtZW50VHJhbnNmb3JtKHRhcmdldCkge1xyXG4gICAgdmFyIGdldFN0eWxlID0gZ2V0Q2FjaGVkU3R5bGUodGFyZ2V0KTtcclxuICAgIHZhciBjb21wdXRlZFRyYW5zZm9ybSA9IGdldFN0eWxlKFwidHJhbnNmb3JtXCIpO1xyXG4gICAgaWYgKGNvbXB1dGVkVHJhbnNmb3JtICYmIGNvbXB1dGVkVHJhbnNmb3JtICE9PSBcIm5vbmVcIikge1xyXG4gICAgICAgIHJldHVybiBjb21wdXRlZFRyYW5zZm9ybTtcclxuICAgIH1cclxuICAgIGlmIChcInRyYW5zZm9ybVwiIGluIHRhcmdldCkge1xyXG4gICAgICAgIHZhciBsaXN0ID0gdGFyZ2V0LnRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgYmFzZVZhbCA9IGxpc3QuYmFzZVZhbDtcclxuICAgICAgICBpZiAoIWJhc2VWYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZW5ndGhfMSA9IGJhc2VWYWwubGVuZ3RoO1xyXG4gICAgICAgIGlmICghbGVuZ3RoXzEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtYXRyaXhlcyA9IFtdO1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IGJhc2VWYWxbaV0ubWF0cml4O1xyXG4gICAgICAgICAgICBtYXRyaXhlcy5wdXNoKFwibWF0cml4KFwiLmNvbmNhdChbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIl0ubWFwKGZ1bmN0aW9uIChjaHIpIHsgcmV0dXJuIG1hdHJpeFtjaHJdOyB9KS5qb2luKFwiLCBcIiksIFwiKVwiKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF8xOyArK2kpIHtcclxuICAgICAgICAgICAgX2xvb3BfMShpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeGVzLmpvaW4oXCIgXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiXCI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0T2Zmc2V0SW5mbyhlbCwgbGFzdFBhcmVudCwgaXNQYXJlbnQsIGNoZWNrWm9vbSwgZ2V0VGFyZ2V0U3R5bGUpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsKSB8fCBnZXREb2N1bWVudEJvZHkoZWwpO1xyXG4gICAgdmFyIGhhc1Nsb3QgPSBmYWxzZTtcclxuICAgIHZhciB0YXJnZXQ7XHJcbiAgICB2YXIgcGFyZW50U2xvdEVsZW1lbnQ7XHJcbiAgICBpZiAoIWVsIHx8IGlzUGFyZW50KSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gZWw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgYXNzaWduZWRTbG90UGFyZW50RWxlbWVudCA9IChfYSA9IGVsID09PSBudWxsIHx8IGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbC5hc3NpZ25lZFNsb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gZWwucGFyZW50RWxlbWVudDtcclxuICAgICAgICBpZiAoYXNzaWduZWRTbG90UGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICBoYXNTbG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcGFyZW50U2xvdEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBhc3NpZ25lZFNsb3RQYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gcGFyZW50RWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgaXNDdXN0b21FbGVtZW50ID0gZmFsc2U7XHJcbiAgICB2YXIgaXNFbmQgPSBlbCA9PT0gbGFzdFBhcmVudCB8fCB0YXJnZXQgPT09IGxhc3RQYXJlbnQ7XHJcbiAgICB2YXIgcG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICB2YXIgb2Zmc2V0Wm9vbSA9IDE7XHJcbiAgICB2YXIgdGFyZ2V0Wm9vbSA9IHBhcnNlRmxvYXQoZ2V0VGFyZ2V0U3R5bGUgPT09IG51bGwgfHwgZ2V0VGFyZ2V0U3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldFRhcmdldFN0eWxlKFwiem9vbVwiKSkgfHwgMTtcclxuICAgIHZhciB0YXJnZXRQb3NpdGlvbiA9IGdldFRhcmdldFN0eWxlID09PSBudWxsIHx8IGdldFRhcmdldFN0eWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRUYXJnZXRTdHlsZShcInBvc2l0aW9uXCIpO1xyXG4gICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IGRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgIGlmIChsYXN0UGFyZW50ID09PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgaXNFbmQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZ2V0U3R5bGUgPSBnZXRDYWNoZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgICAgIHZhciB0YWdOYW1lID0gdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gZ2V0RWxlbWVudFRyYW5zZm9ybSh0YXJnZXQpO1xyXG4gICAgICAgIHZhciB3aWxsQ2hhbmdlID0gZ2V0U3R5bGUoXCJ3aWxsQ2hhbmdlXCIpO1xyXG4gICAgICAgIHZhciB6b29tID0gcGFyc2VGbG9hdChnZXRTdHlsZShcInpvb21cIikpIHx8IDE7XHJcbiAgICAgICAgcG9zaXRpb24gPSBnZXRTdHlsZShcInBvc2l0aW9uXCIpO1xyXG4gICAgICAgIGlmIChjaGVja1pvb20gJiYgem9vbSAhPT0gMSkge1xyXG4gICAgICAgICAgICBvZmZzZXRab29tID0gem9vbTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAvLyBvZmZzZXRQYXJlbnQgaXMgdGhlIHBhcmVudEVsZW1lbnQgaWYgdGhlIHRhcmdldCdzIHpvb20gaXMgbm90IDEgYW5kIG5vdCBhYnNvbHV0ZS5cclxuICAgICAgICAhaXNQYXJlbnQgJiYgY2hlY2tab29tICYmIHRhcmdldFpvb20gIT09IDEgJiYgdGFyZ2V0UG9zaXRpb24gJiYgdGFyZ2V0UG9zaXRpb24gIT09IFwiYWJzb2x1dGVcIlxyXG4gICAgICAgICAgICB8fCB0YWdOYW1lID09PSBcInN2Z1wiXHJcbiAgICAgICAgICAgIHx8IHRhZ05hbWUgPT09IFwiZm9yZWlnbm9iamVjdFwiXHJcbiAgICAgICAgICAgIHx8IHBvc2l0aW9uICE9PSBcInN0YXRpY1wiXHJcbiAgICAgICAgICAgIHx8ICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSBcIm5vbmVcIilcclxuICAgICAgICAgICAgfHwgd2lsbENoYW5nZSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNsb3RQYXJlbnROb2RlID0gKF9iID0gZWwgPT09IG51bGwgfHwgZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsLmFzc2lnbmVkU2xvdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcmVudE5vZGU7XHJcbiAgICAgICAgdmFyIHRhcmdldFBhcmVudE5vZGUgPSB0YXJnZXQucGFyZW50Tm9kZTtcclxuICAgICAgICBpZiAoc2xvdFBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgaGFzU2xvdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHBhcmVudFNsb3RFbGVtZW50ID0gdGFyZ2V0UGFyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSB0YXJnZXRQYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUubm9kZVR5cGUgPT09IDExKSB7XHJcbiAgICAgICAgICAgIC8vIFNoYWRvdyBSb290XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHBhcmVudE5vZGUuaG9zdDtcclxuICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBnZXRDYWNoZWRTdHlsZSh0YXJnZXQpKFwicG9zaXRpb25cIik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXQgPSBwYXJlbnROb2RlO1xyXG4gICAgICAgIHBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBvZmZzZXRab29tOiBvZmZzZXRab29tLFxyXG4gICAgICAgIGhhc1Nsb3Q6IGhhc1Nsb3QsXHJcbiAgICAgICAgcGFyZW50U2xvdEVsZW1lbnQ6IHBhcmVudFNsb3RFbGVtZW50LFxyXG4gICAgICAgIGlzQ3VzdG9tRWxlbWVudDogaXNDdXN0b21FbGVtZW50LFxyXG4gICAgICAgIGlzU3RhdGljOiBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIixcclxuICAgICAgICBpc0VuZDogaXNFbmQgfHwgIXRhcmdldCB8fCB0YXJnZXQgPT09IGRvY3VtZW50RWxlbWVudCxcclxuICAgICAgICBvZmZzZXRQYXJlbnQ6IHRhcmdldCB8fCBkb2N1bWVudEVsZW1lbnQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldE9mZnNldFBvc0luZm8oZWwsIHRhcmdldCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgdmFyIHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IGVsLm9mZnNldExlZnQ7XHJcbiAgICB2YXIgb2Zmc2V0VG9wID0gZWwub2Zmc2V0VG9wO1xyXG4gICAgdmFyIGdldFN0eWxlID0gZ2V0Q2FjaGVkU3R5bGUoZWwpO1xyXG4gICAgLy8gc3ZnXHJcbiAgICB2YXIgaXNTVkcgPSBpc1VuZGVmaW5lZChvZmZzZXRMZWZ0KTtcclxuICAgIHZhciBoYXNPZmZzZXQgPSAhaXNTVkc7XHJcbiAgICB2YXIgb3JpZ2luO1xyXG4gICAgdmFyIHRhcmdldE9yaWdpbjtcclxuICAgIC8vIGlubmVyIHN2ZyBlbGVtZW50XHJcbiAgICBpZiAoIWhhc09mZnNldCAmJiAodGFnTmFtZSAhPT0gXCJzdmdcIiB8fCBlbC5vd25lclNWR0VsZW1lbnQpKSB7XHJcbiAgICAgICAgb3JpZ2luID0gSVNfV0VCS0lUNjA1XHJcbiAgICAgICAgICAgID8gZ2V0QmVmb3JlVHJhbnNmb3JtT3JpZ2luKGVsKVxyXG4gICAgICAgICAgICA6IGdldFRyYW5zZm9ybU9yaWdpbkFycmF5KGdldFN0eWxlKFwidHJhbnNmb3JtT3JpZ2luXCIpKS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcGFyc2VGbG9hdChwb3MpOyB9KTtcclxuICAgICAgICB0YXJnZXRPcmlnaW4gPSBvcmlnaW4uc2xpY2UoKTtcclxuICAgICAgICBoYXNPZmZzZXQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0YWdOYW1lID09PSBcInN2Z1wiKSB7XHJcbiAgICAgICAgICAgIG9mZnNldExlZnQgPSAwO1xyXG4gICAgICAgICAgICBvZmZzZXRUb3AgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX2EgPSBfX3JlYWQoZ2V0U1ZHR3JhcGhpY3NPZmZzZXQoZWwsIG9yaWdpbiwgZWwgPT09IHRhcmdldCAmJiB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImdcIiksIDQpLCBvZmZzZXRMZWZ0ID0gX2FbMF0sIG9mZnNldFRvcCA9IF9hWzFdLCBvcmlnaW5bMF0gPSBfYVsyXSwgb3JpZ2luWzFdID0gX2FbM107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb3JpZ2luID0gZ2V0VHJhbnNmb3JtT3JpZ2luQXJyYXkoZ2V0U3R5bGUoXCJ0cmFuc2Zvcm1PcmlnaW5cIikpLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwYXJzZUZsb2F0KHBvcyk7IH0pO1xyXG4gICAgICAgIHRhcmdldE9yaWdpbiA9IG9yaWdpbi5zbGljZSgpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGdldFN0eWxlKFwidHJhbnNmb3JtT3JpZ2luXCIpLCB0YXJnZXRPcmlnaW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxyXG4gICAgICAgIGlzU1ZHOiBpc1NWRyxcclxuICAgICAgICBoYXNPZmZzZXQ6IGhhc09mZnNldCxcclxuICAgICAgICBvZmZzZXQ6IFtvZmZzZXRMZWZ0IHx8IDAsIG9mZnNldFRvcCB8fCAwXSxcclxuICAgICAgICBvcmlnaW46IG9yaWdpbixcclxuICAgICAgICB0YXJnZXRPcmlnaW46IHRhcmdldE9yaWdpbixcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0Qm9keU9mZnNldChlbCwgaXNTVkcpIHtcclxuICAgIHZhciBnZXRTdHlsZSA9IGdldENhY2hlZFN0eWxlKGVsKTtcclxuICAgIHZhciBnZXRCb2R5U3R5bGUgPSBnZXRDYWNoZWRTdHlsZShnZXREb2N1bWVudEJvZHkoZWwpKTtcclxuICAgIHZhciBib2R5UG9zaXRpb24gPSBnZXRCb2R5U3R5bGUoXCJwb3NpdGlvblwiKTtcclxuICAgIGlmICghaXNTVkcgJiYgKCFib2R5UG9zaXRpb24gfHwgYm9keVBvc2l0aW9uID09PSBcInN0YXRpY1wiKSkge1xyXG4gICAgICAgIHJldHVybiBbMCwgMF07XHJcbiAgICB9XHJcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlSW50KGdldEJvZHlTdHlsZShcIm1hcmdpbkxlZnRcIiksIDEwKTtcclxuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUludChnZXRCb2R5U3R5bGUoXCJtYXJnaW5Ub3BcIiksIDEwKTtcclxuICAgIGlmIChnZXRTdHlsZShcInBvc2l0aW9uXCIpID09PSBcImFic29sdXRlXCIpIHtcclxuICAgICAgICBpZiAoZ2V0U3R5bGUoXCJ0b3BcIikgIT09IFwiYXV0b1wiIHx8IGdldFN0eWxlKFwiYm90dG9tXCIpICE9PSBcImF1dG9cIikge1xyXG4gICAgICAgICAgICBtYXJnaW5Ub3AgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ2V0U3R5bGUoXCJsZWZ0XCIpICE9PSBcImF1dG9cIiB8fCBnZXRTdHlsZShcInJpZ2h0XCIpICE9PSBcImF1dG9cIikge1xyXG4gICAgICAgICAgICBtYXJnaW5MZWZ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW21hcmdpbkxlZnQsIG1hcmdpblRvcF07XHJcbn1cclxuZnVuY3Rpb24gY29udmVydDNETWF0cml4ZXMobWF0cml4ZXMpIHtcclxuICAgIG1hdHJpeGVzLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gaW5mby5tYXRyaXg7XHJcbiAgICAgICAgaWYgKG1hdHJpeCkge1xyXG4gICAgICAgICAgICBpbmZvLm1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24obWF0cml4LCAzLCA0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbkZpeGVkSW5mbyhlbCkge1xyXG4gICAgdmFyIGZpeGVkQ29udGFpbmVyID0gZWwucGFyZW50RWxlbWVudDtcclxuICAgIHZhciBoYXNUcmFuc2Zvcm0gPSBmYWxzZTtcclxuICAgIHZhciBib2R5ID0gZ2V0RG9jdW1lbnRCb2R5KGVsKTtcclxuICAgIHdoaWxlIChmaXhlZENvbnRhaW5lcikge1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBnZXRDb21wdXRlZFN0eWxlKGZpeGVkQ29udGFpbmVyKS50cmFuc2Zvcm07XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0gIT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgICAgIGhhc1RyYW5zZm9ybSA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZml4ZWRDb250YWluZXIgPT09IGJvZHkpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpeGVkQ29udGFpbmVyID0gZml4ZWRDb250YWluZXIucGFyZW50RWxlbWVudDtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZml4ZWRDb250YWluZXI6IGZpeGVkQ29udGFpbmVyIHx8IGJvZHksXHJcbiAgICAgICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm0sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG1ha2VNYXRyaXhDU1MobWF0cml4LCBpczNkKSB7XHJcbiAgICBpZiAoaXMzZCA9PT0gdm9pZCAwKSB7IGlzM2QgPSBtYXRyaXgubGVuZ3RoID4gOTsgfVxyXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGlzM2QgPyBcIm1hdHJpeDNkXCIgOiBcIm1hdHJpeFwiLCBcIihcIikuY29uY2F0KGNvbnZlcnRNYXRyaXh0b0NTUyhtYXRyaXgsICFpczNkKS5qb2luKFwiLFwiKSwgXCIpXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNWR1ZpZXdCb3goZWwpIHtcclxuICAgIHZhciBjbGllbnRXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xyXG4gICAgdmFyIGNsaWVudEhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcclxuICAgIGlmICghZWwpIHtcclxuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBjbGllbnRXaWR0aDogY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY2xpZW50SGVpZ2h0IH07XHJcbiAgICB9XHJcbiAgICB2YXIgdmlld0JveCA9IGVsLnZpZXdCb3g7XHJcbiAgICB2YXIgYmFzZVZhbCA9ICh2aWV3Qm94ICYmIHZpZXdCb3guYmFzZVZhbCkgfHwgeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGJhc2VWYWwueCxcclxuICAgICAgICB5OiBiYXNlVmFsLnksXHJcbiAgICAgICAgd2lkdGg6IGJhc2VWYWwud2lkdGggfHwgY2xpZW50V2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBiYXNlVmFsLmhlaWdodCB8fCBjbGllbnRIZWlnaHQsXHJcbiAgICAgICAgY2xpZW50V2lkdGg6IGNsaWVudFdpZHRoLFxyXG4gICAgICAgIGNsaWVudEhlaWdodDogY2xpZW50SGVpZ2h0LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRTVkdNYXRyaXgoZWwsIG4pIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBfYiA9IGdldFNWR1ZpZXdCb3goZWwpLCB2aWV3Qm94V2lkdGggPSBfYi53aWR0aCwgdmlld0JveEhlaWdodCA9IF9iLmhlaWdodCwgY2xpZW50V2lkdGggPSBfYi5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0ID0gX2IuY2xpZW50SGVpZ2h0O1xyXG4gICAgdmFyIHNjYWxlWCA9IGNsaWVudFdpZHRoIC8gdmlld0JveFdpZHRoO1xyXG4gICAgdmFyIHNjYWxlWSA9IGNsaWVudEhlaWdodCAvIHZpZXdCb3hIZWlnaHQ7XHJcbiAgICB2YXIgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGVsLnByZXNlcnZlQXNwZWN0UmF0aW8uYmFzZVZhbDtcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvcHJlc2VydmVBc3BlY3RSYXRpb1xyXG4gICAgdmFyIGFsaWduID0gcHJlc2VydmVBc3BlY3RSYXRpby5hbGlnbjtcclxuICAgIC8vIDEgOiBtZWV0IDI6IHNsaWNlXHJcbiAgICB2YXIgbWVldE9yU2xpY2UgPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlO1xyXG4gICAgdmFyIHN2Z09yaWdpbiA9IFswLCAwXTtcclxuICAgIHZhciBzY2FsZSA9IFtzY2FsZVgsIHNjYWxlWV07XHJcbiAgICB2YXIgdHJhbnNsYXRlID0gWzAsIDBdO1xyXG4gICAgaWYgKGFsaWduICE9PSAxKSB7XHJcbiAgICAgICAgdmFyIHhBbGlnbiA9IChhbGlnbiAtIDIpICUgMztcclxuICAgICAgICB2YXIgeUFsaWduID0gTWF0aC5mbG9vcigoYWxpZ24gLSAyKSAvIDMpO1xyXG4gICAgICAgIHN2Z09yaWdpblswXSA9IHZpZXdCb3hXaWR0aCAqIHhBbGlnbiAvIDI7XHJcbiAgICAgICAgc3ZnT3JpZ2luWzFdID0gdmlld0JveEhlaWdodCAqIHlBbGlnbiAvIDI7XHJcbiAgICAgICAgdmFyIHNjYWxlRGltZW5zaW9uID0gbWVldE9yU2xpY2UgPT09IDIgPyBNYXRoLm1heChzY2FsZVksIHNjYWxlWCkgOiBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XHJcbiAgICAgICAgc2NhbGVbMF0gPSBzY2FsZURpbWVuc2lvbjtcclxuICAgICAgICBzY2FsZVsxXSA9IHNjYWxlRGltZW5zaW9uO1xyXG4gICAgICAgIHRyYW5zbGF0ZVswXSA9IChjbGllbnRXaWR0aCAtIHZpZXdCb3hXaWR0aCkgLyAyICogeEFsaWduO1xyXG4gICAgICAgIHRyYW5zbGF0ZVsxXSA9IChjbGllbnRIZWlnaHQgLSB2aWV3Qm94SGVpZ2h0KSAvIDIgKiB5QWxpZ247XHJcbiAgICB9XHJcbiAgICB2YXIgc2NhbGVNYXRyaXggPSBjcmVhdGVTY2FsZU1hdHJpeChzY2FsZSwgbik7XHJcbiAgICBfYSA9IF9fcmVhZCh0cmFuc2xhdGUsIDIpLCBzY2FsZU1hdHJpeFtuICogKG4gLSAxKV0gPSBfYVswXSwgc2NhbGVNYXRyaXhbbiAqIChuIC0gMSkgKyAxXSA9IF9hWzFdO1xyXG4gICAgcmV0dXJuIGdldEFic29sdXRlTWF0cml4KHNjYWxlTWF0cml4LCBuLCBzdmdPcmlnaW4pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNWR0dyYXBoaWNzT2Zmc2V0KGVsLCBvcmlnaW4sIGlzR1RhcmdldCkge1xyXG4gICAgdmFyIHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoIWVsLmdldEJCb3ggfHwgIWlzR1RhcmdldCAmJiB0YWdOYW1lID09PSBcImdcIikge1xyXG4gICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XHJcbiAgICB9XHJcbiAgICB2YXIgZ2V0U3R5bGUgPSBnZXRDYWNoZWRTdHlsZShlbCk7XHJcbiAgICB2YXIgaXNGaWxsQm94ID0gZ2V0U3R5bGUoXCJ0cmFuc2Zvcm0tYm94XCIpID09PSBcImZpbGwtYm94XCI7XHJcbiAgICB2YXIgYmJveCA9IGVsLmdldEJCb3goKTtcclxuICAgIHZhciB2aWV3Qm94ID0gZ2V0U1ZHVmlld0JveChlbC5vd25lclNWR0VsZW1lbnQpO1xyXG4gICAgdmFyIHggPSBiYm94Lng7XHJcbiAgICB2YXIgeSA9IGJib3gueTtcclxuICAgIC8vIHgsIHnqsIAgMOycvOuhnCDrgpjtg4DrgpjripQg67KE6re4XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gXCJmb3JlaWdub2JqZWN0XCIgJiYgKCF4ICYmICF5KSkge1xyXG4gICAgICAgIHggPSBwYXJzZUZsb2F0KGVsLmdldEF0dHJpYnV0ZShcInhcIikpIHx8IDA7XHJcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoZWwuZ2V0QXR0cmlidXRlKFwieVwiKSkgfHwgMDtcclxuICAgIH1cclxuICAgIHZhciBsZWZ0ID0geCAtIHZpZXdCb3gueDtcclxuICAgIHZhciB0b3AgPSB5IC0gdmlld0JveC55O1xyXG4gICAgdmFyIG9yaWdpblggPSBpc0ZpbGxCb3ggPyBvcmlnaW5bMF0gOiBvcmlnaW5bMF0gLSBsZWZ0O1xyXG4gICAgdmFyIG9yaWdpblkgPSBpc0ZpbGxCb3ggPyBvcmlnaW5bMV0gOiBvcmlnaW5bMV0gLSB0b3A7XHJcbiAgICAvLyBpZiAoaXNGaWxsQm94KSB7XHJcbiAgICAvLyAgICAgY29uc3QgYmJveCA9IChlbCBhcyBTVkdHcmFwaGljc0VsZW1lbnQpLmdldEJCb3goKTtcclxuICAgIC8vICAgICBjb25zdCB4ID0gcGFyc2VGbG9hdChnZXRTdHlsZShcInhcIikpIHx8IGJib3gueDtcclxuICAgIC8vICAgICBjb25zdCB5ID0gcGFyc2VGbG9hdChnZXRTdHlsZShcInlcIikpIHx8IGJib3gueTtcclxuICAgIC8vICAgICBjb25zdCB4U2NhbGUgPSBiYm94LnggLyB4O1xyXG4gICAgLy8gICAgIGNvbnN0IHlTY2FsZSA9IGJib3gueSAvIHk7XHJcbiAgICAvLyAgICAgY29uc29sZS5sb2coeCwgeSk7XHJcbiAgICAvLyAgICAgb3JpZ2luWCAqPSB4U2NhbGU7XHJcbiAgICAvLyAgICAgb3JpZ2luWSAqPSB5U2NhbGU7XHJcbiAgICAvLyB9XHJcbiAgICByZXR1cm4gW2xlZnQsIHRvcCwgb3JpZ2luWCwgb3JpZ2luWV07XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb24obWF0cml4LCBwb3MsIG4pIHtcclxuICAgIHJldHVybiBjYWxjdWxhdGUobWF0cml4LCBjb252ZXJ0UG9zaXRpb25NYXRyaXgocG9zLCBuKSwgbik7XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuKSB7XHJcbiAgICByZXR1cm4gW1swLCAwXSwgW3dpZHRoLCAwXSwgWzAsIGhlaWdodF0sIFt3aWR0aCwgaGVpZ2h0XV0ubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIGNhbGN1bGF0ZVBvc2l0aW9uKG1hdHJpeCwgcG9zLCBuKTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVjdChwb3Nlcykge1xyXG4gICAgdmFyIHBvc2VzWCA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3NbMF07IH0pO1xyXG4gICAgdmFyIHBvc2VzWSA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3NbMV07IH0pO1xyXG4gICAgdmFyIGxlZnQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocG9zZXNYKSwgZmFsc2UpKTtcclxuICAgIHZhciB0b3AgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocG9zZXNZKSwgZmFsc2UpKTtcclxuICAgIHZhciByaWdodCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwb3Nlc1gpLCBmYWxzZSkpO1xyXG4gICAgdmFyIGJvdHRvbSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwb3Nlc1kpLCBmYWxzZSkpO1xyXG4gICAgdmFyIHJlY3RXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcclxuICAgIHZhciByZWN0SGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIHJpZ2h0OiByaWdodCxcclxuICAgICAgICBib3R0b206IGJvdHRvbSxcclxuICAgICAgICB3aWR0aDogcmVjdFdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogcmVjdEhlaWdodCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlUmVjdChtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pIHtcclxuICAgIHZhciBwb3NlcyA9IGNhbGN1bGF0ZVBvc2VzKG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgbik7XHJcbiAgICByZXR1cm4gZ2V0UmVjdChwb3Nlcyk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U1ZHT2Zmc2V0KG9mZnNldEluZm8sIHRhcmdldEluZm8sIGNvbnRhaW5lciwgbiwgYmVmb3JlTWF0cml4KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgdGFyZ2V0ID0gb2Zmc2V0SW5mby50YXJnZXQ7XHJcbiAgICB2YXIgb3JpZ2luID0gb2Zmc2V0SW5mby5vcmlnaW47XHJcbiAgICB2YXIgdGFyZ2V0TWF0cml4ID0gdGFyZ2V0SW5mby5tYXRyaXg7XHJcbiAgICB2YXIgX2IgPSBnZXRTaXplKHRhcmdldCksIHdpZHRoID0gX2Iub2Zmc2V0V2lkdGgsIGhlaWdodCA9IF9iLm9mZnNldEhlaWdodDtcclxuICAgIHZhciBjb250YWluZXJDbGllbnRSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIG1hcmdpbiA9IFswLCAwXTtcclxuICAgIGlmIChjb250YWluZXIgPT09IGdldERvY3VtZW50Qm9keShjb250YWluZXIpKSB7XHJcbiAgICAgICAgbWFyZ2luID0gZ2V0Qm9keU9mZnNldCh0YXJnZXQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgcmVjdExlZnQgPSByZWN0LmxlZnQgLSBjb250YWluZXJDbGllbnRSZWN0LmxlZnQgKyBjb250YWluZXIuc2Nyb2xsTGVmdFxyXG4gICAgICAgIC0gKGNvbnRhaW5lci5jbGllbnRMZWZ0IHx8IDApICsgbWFyZ2luWzBdO1xyXG4gICAgdmFyIHJlY3RUb3AgPSByZWN0LnRvcCAtIGNvbnRhaW5lckNsaWVudFJlY3QudG9wICsgY29udGFpbmVyLnNjcm9sbFRvcFxyXG4gICAgICAgIC0gKGNvbnRhaW5lci5jbGllbnRUb3AgfHwgMCkgKyBtYXJnaW5bMV07XHJcbiAgICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICB2YXIgbWF0ID0gbXVsdGlwbGllcyhuLCBiZWZvcmVNYXRyaXgsIHRhcmdldE1hdHJpeCk7XHJcbiAgICB2YXIgX2MgPSBjYWxjdWxhdGVSZWN0KG1hdCwgd2lkdGgsIGhlaWdodCwgbiksIHByZXZMZWZ0ID0gX2MubGVmdCwgcHJldlRvcCA9IF9jLnRvcCwgcHJldldpZHRoID0gX2Mud2lkdGgsIHByZXZIZWlnaHQgPSBfYy5oZWlnaHQ7XHJcbiAgICB2YXIgcG9zT3JpZ2luID0gY2FsY3VsYXRlUG9zaXRpb24obWF0LCBvcmlnaW4sIG4pO1xyXG4gICAgdmFyIHByZXZPcmlnaW4gPSBtaW51cyhwb3NPcmlnaW4sIFtwcmV2TGVmdCwgcHJldlRvcF0pO1xyXG4gICAgdmFyIHJlY3RPcmlnaW4gPSBbXHJcbiAgICAgICAgcmVjdExlZnQgKyBwcmV2T3JpZ2luWzBdICogcmVjdFdpZHRoIC8gcHJldldpZHRoLFxyXG4gICAgICAgIHJlY3RUb3AgKyBwcmV2T3JpZ2luWzFdICogcmVjdEhlaWdodCAvIHByZXZIZWlnaHQsXHJcbiAgICBdO1xyXG4gICAgdmFyIG9mZnNldCA9IFswLCAwXTtcclxuICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICB3aGlsZSAoKytjb3VudCA8IDEwKSB7XHJcbiAgICAgICAgdmFyIGludmVyc2VCZWZvcmVNYXRyaXggPSBpbnZlcnQoYmVmb3JlTWF0cml4LCBuKTtcclxuICAgICAgICBfYSA9IF9fcmVhZChtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihpbnZlcnNlQmVmb3JlTWF0cml4LCByZWN0T3JpZ2luLCBuKSwgY2FsY3VsYXRlUG9zaXRpb24oaW52ZXJzZUJlZm9yZU1hdHJpeCwgcG9zT3JpZ2luLCBuKSksIDIpLCBvZmZzZXRbMF0gPSBfYVswXSwgb2Zmc2V0WzFdID0gX2FbMV07XHJcbiAgICAgICAgdmFyIG1hdDIgPSBtdWx0aXBsaWVzKG4sIGJlZm9yZU1hdHJpeCwgY3JlYXRlT3JpZ2luTWF0cml4KG9mZnNldCwgbiksIHRhcmdldE1hdHJpeCk7XHJcbiAgICAgICAgdmFyIF9kID0gY2FsY3VsYXRlUmVjdChtYXQyLCB3aWR0aCwgaGVpZ2h0LCBuKSwgbmV4dExlZnQgPSBfZC5sZWZ0LCBuZXh0VG9wID0gX2QudG9wO1xyXG4gICAgICAgIHZhciBkaXN0TGVmdCA9IG5leHRMZWZ0IC0gcmVjdExlZnQ7XHJcbiAgICAgICAgdmFyIGRpc3RUb3AgPSBuZXh0VG9wIC0gcmVjdFRvcDtcclxuICAgICAgICBpZiAoYWJzKGRpc3RMZWZ0KSA8IDIgJiYgYWJzKGRpc3RUb3ApIDwgMikge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVjdE9yaWdpblswXSAtPSBkaXN0TGVmdDtcclxuICAgICAgICByZWN0T3JpZ2luWzFdIC09IGRpc3RUb3A7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0Lm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gTWF0aC5yb3VuZChwKTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlTW92ZWFibGVDbGllbnRQb3NpdGlvbnMocm9vdE1hdHJpeCwgcG9zZXMsIHJvb3RDbGllbnRSZWN0KSB7XHJcbiAgICB2YXIgaXMzZCA9IHJvb3RNYXRyaXgubGVuZ3RoID09PSAxNjtcclxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgdmFyIHJvb3RQb3NlcyA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBjYWxjdWxhdGVQb3NpdGlvbihyb290TWF0cml4LCBwb3MsIG4pOyB9KTtcclxuICAgIHZhciBsZWZ0ID0gcm9vdENsaWVudFJlY3QubGVmdCwgdG9wID0gcm9vdENsaWVudFJlY3QudG9wO1xyXG4gICAgcmV0dXJuIHJvb3RQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgIHJldHVybiBbcG9zWzBdICsgbGVmdCwgcG9zWzFdICsgdG9wXTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldERpc3RTaXplKHZlYykge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCh2ZWNbMF0gKiB2ZWNbMF0gKyB2ZWNbMV0gKiB2ZWNbMV0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldERpYWdvbmFsU2l6ZShwb3MxLCBwb3MyKSB7XHJcbiAgICByZXR1cm4gZ2V0RGlzdFNpemUoW1xyXG4gICAgICAgIHBvczJbMF0gLSBwb3MxWzBdLFxyXG4gICAgICAgIHBvczJbMV0gLSBwb3MxWzFdLFxyXG4gICAgXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TGluZVN0eWxlKHBvczEsIHBvczIsIHpvb20sIHJhZCkge1xyXG4gICAgaWYgKHpvb20gPT09IHZvaWQgMCkgeyB6b29tID0gMTsgfVxyXG4gICAgaWYgKHJhZCA9PT0gdm9pZCAwKSB7IHJhZCA9IGdldFJhZChwb3MxLCBwb3MyKTsgfVxyXG4gICAgdmFyIHdpZHRoID0gZ2V0RGlhZ29uYWxTaXplKHBvczEsIHBvczIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtNTAlKSB0cmFuc2xhdGUoXCIuY29uY2F0KHBvczFbMF0sIFwicHgsIFwiKS5jb25jYXQocG9zMVsxXSwgXCJweCkgcm90YXRlKFwiKS5jb25jYXQocmFkLCBcInJhZCkgc2NhbGVZKFwiKS5jb25jYXQoem9vbSwgXCIpXCIpLFxyXG4gICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29udHJvbFRyYW5zZm9ybShyb3RhdGlvbiwgem9vbSkge1xyXG4gICAgdmFyIHBvc2VzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHBvc2VzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGxlbmd0aCA9IHBvc2VzLmxlbmd0aDtcclxuICAgIHZhciB4ID0gcG9zZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBwb3MpIHsgcmV0dXJuIHByZXYgKyBwb3NbMF07IH0sIDApIC8gbGVuZ3RoO1xyXG4gICAgdmFyIHkgPSBwb3Nlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHBvcykgeyByZXR1cm4gcHJldiArIHBvc1sxXTsgfSwgMCkgLyBsZW5ndGg7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVaKDBweCkgdHJhbnNsYXRlKFwiLmNvbmNhdCh4LCBcInB4LCBcIikuY29uY2F0KHksIFwicHgpIHJvdGF0ZShcIikuY29uY2F0KHJvdGF0aW9uLCBcInJhZCkgc2NhbGUoXCIpLmNvbmNhdCh6b29tLCBcIilcIiksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFByb3BzKHByb3BzLCBhYmxlTmFtZSkge1xyXG4gICAgdmFyIHNlbGYgPSBwcm9wc1thYmxlTmFtZV07XHJcbiAgICBpZiAoaXNPYmplY3Qoc2VsZikpIHtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHByb3BzKSwgc2VsZik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2l6ZSh0YXJnZXQpIHtcclxuICAgIHZhciBoYXNPZmZzZXQgPSB0YXJnZXQgJiYgIWlzVW5kZWZpbmVkKHRhcmdldC5vZmZzZXRXaWR0aCk7XHJcbiAgICB2YXIgb2Zmc2V0V2lkdGggPSAwO1xyXG4gICAgdmFyIG9mZnNldEhlaWdodCA9IDA7XHJcbiAgICB2YXIgY2xpZW50V2lkdGggPSAwO1xyXG4gICAgdmFyIGNsaWVudEhlaWdodCA9IDA7XHJcbiAgICB2YXIgY3NzV2lkdGggPSAwO1xyXG4gICAgdmFyIGNzc0hlaWdodCA9IDA7XHJcbiAgICB2YXIgY29udGVudFdpZHRoID0gMDtcclxuICAgIHZhciBjb250ZW50SGVpZ2h0ID0gMDtcclxuICAgIHZhciBtaW5XaWR0aCA9IDA7XHJcbiAgICB2YXIgbWluSGVpZ2h0ID0gMDtcclxuICAgIHZhciBtaW5PZmZzZXRXaWR0aCA9IDA7XHJcbiAgICB2YXIgbWluT2Zmc2V0SGVpZ2h0ID0gMDtcclxuICAgIHZhciBtYXhXaWR0aCA9IEluZmluaXR5O1xyXG4gICAgdmFyIG1heEhlaWdodCA9IEluZmluaXR5O1xyXG4gICAgdmFyIG1heE9mZnNldFdpZHRoID0gSW5maW5pdHk7XHJcbiAgICB2YXIgbWF4T2Zmc2V0SGVpZ2h0ID0gSW5maW5pdHk7XHJcbiAgICB2YXIgaW5saW5lQ1NTV2lkdGggPSAwO1xyXG4gICAgdmFyIGlubGluZUNTU0hlaWdodCA9IDA7XHJcbiAgICB2YXIgc3ZnID0gZmFsc2U7XHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFoYXNPZmZzZXQgJiYgdGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCkge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBzdmcgZWxlbWVudHNcclxuICAgICAgICAgICAgdmFyIGJib3ggPSB0YXJnZXQuZ2V0QkJveCgpO1xyXG4gICAgICAgICAgICBzdmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBvZmZzZXRXaWR0aCA9IGJib3gud2lkdGg7XHJcbiAgICAgICAgICAgIG9mZnNldEhlaWdodCA9IGJib3guaGVpZ2h0O1xyXG4gICAgICAgICAgICBjc3NXaWR0aCA9IG9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICBjc3NIZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnRlbnRXaWR0aCA9IG9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICBjb250ZW50SGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICBjbGllbnRXaWR0aCA9IG9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBodG1sIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIHZhciBnZXRTdHlsZSA9IGdldENhY2hlZFN0eWxlKHRhcmdldCk7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRTdHlsZSA9IHRhcmdldC5zdHlsZTtcclxuICAgICAgICAgICAgdmFyIGJveFNpemluZyA9IGdldFN0eWxlKFwiYm94U2l6aW5nXCIpID09PSBcImJvcmRlci1ib3hcIjtcclxuICAgICAgICAgICAgdmFyIGJvcmRlckxlZnQgPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwiYm9yZGVyTGVmdFdpZHRoXCIpKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgYm9yZGVyUmlnaHQgPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwiYm9yZGVyUmlnaHRXaWR0aFwiKSkgfHwgMDtcclxuICAgICAgICAgICAgdmFyIGJvcmRlclRvcCA9IHBhcnNlRmxvYXQoZ2V0U3R5bGUoXCJib3JkZXJUb3BXaWR0aFwiKSkgfHwgMDtcclxuICAgICAgICAgICAgdmFyIGJvcmRlckJvdHRvbSA9IHBhcnNlRmxvYXQoZ2V0U3R5bGUoXCJib3JkZXJCb3R0b21XaWR0aFwiKSkgfHwgMDtcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VGbG9hdChnZXRTdHlsZShcInBhZGRpbmdMZWZ0XCIpKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VGbG9hdChnZXRTdHlsZShcInBhZGRpbmdSaWdodFwiKSkgfHwgMDtcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwicGFkZGluZ1RvcFwiKSkgfHwgMDtcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmdCb3R0b20gPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwicGFkZGluZ0JvdHRvbVwiKSkgfHwgMDtcclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxQYWRkaW5nID0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQ7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbTtcclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxCb3JkZXIgPSBib3JkZXJMZWZ0ICsgYm9yZGVyUmlnaHQ7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEJvcmRlciA9IGJvcmRlclRvcCArIGJvcmRlckJvdHRvbTtcclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBob3Jpem9udGFsUGFkZGluZyArIGhvcml6b250YWxCb3JkZXI7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IHZlcnRpY2FsUGFkZGluZyArIHZlcnRpY2FsQm9yZGVyO1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBnZXRTdHlsZShcInBvc2l0aW9uXCIpO1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSAwO1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgLy8gU1ZHU1ZHRWxlbWVudCwgSFRNTEVsZW1lbnRcclxuICAgICAgICAgICAgaWYgKFwiY2xpZW50TGVmdFwiIGluIHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBcImFic29sdXRlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0SW5mbyA9IGdldE9mZnNldEluZm8odGFyZ2V0LCBnZXREb2N1bWVudEJvZHkodGFyZ2V0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudCA9IG9mZnNldEluZm8ub2Zmc2V0UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UGFyZW50U3R5bGUgPSBnZXRDYWNoZWRTdHlsZShwYXJlbnRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJXaWR0aCA9IHBhcnNlRmxvYXQoZ2V0UGFyZW50U3R5bGUoXCJ3aWR0aFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gcGFyc2VGbG9hdChnZXRQYXJlbnRTdHlsZShcImhlaWdodFwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWluV2lkdGggPSBNYXRoLm1heChob3Jpem9udGFsUGFkZGluZywgY29udmVydFVuaXRTaXplKGdldFN0eWxlKFwibWluV2lkdGhcIiksIGNvbnRhaW5lcldpZHRoKSB8fCAwKTtcclxuICAgICAgICAgICAgbWluSGVpZ2h0ID0gTWF0aC5tYXgodmVydGljYWxQYWRkaW5nLCBjb252ZXJ0VW5pdFNpemUoZ2V0U3R5bGUoXCJtaW5IZWlnaHRcIiksIGNvbnRhaW5lckhlaWdodCkgfHwgMCk7XHJcbiAgICAgICAgICAgIG1heFdpZHRoID0gY29udmVydFVuaXRTaXplKGdldFN0eWxlKFwibWF4V2lkdGhcIiksIGNvbnRhaW5lcldpZHRoKTtcclxuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gY29udmVydFVuaXRTaXplKGdldFN0eWxlKFwibWF4SGVpZ2h0XCIpLCBjb250YWluZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4obWF4V2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc05hTihtYXhIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbmxpbmVDU1NXaWR0aCA9IGNvbnZlcnRVbml0U2l6ZSh0YXJnZXRTdHlsZS53aWR0aCwgMCkgfHwgMDtcclxuICAgICAgICAgICAgaW5saW5lQ1NTSGVpZ2h0ID0gY29udmVydFVuaXRTaXplKHRhcmdldFN0eWxlLmhlaWdodCwgMCkgfHwgMDtcclxuICAgICAgICAgICAgY3NzV2lkdGggPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwid2lkdGhcIikpIHx8IDA7XHJcbiAgICAgICAgICAgIGNzc0hlaWdodCA9IHBhcnNlRmxvYXQoZ2V0U3R5bGUoXCJoZWlnaHRcIikpIHx8IDA7XHJcbiAgICAgICAgICAgIGNvbnRlbnRXaWR0aCA9IGFicyhjc3NXaWR0aCAtIGlubGluZUNTU1dpZHRoKSA8IDFcclxuICAgICAgICAgICAgICAgID8gYmV0d2VlbihtaW5XaWR0aCwgaW5saW5lQ1NTV2lkdGggfHwgY3NzV2lkdGgsIG1heFdpZHRoKVxyXG4gICAgICAgICAgICAgICAgOiBjc3NXaWR0aDtcclxuICAgICAgICAgICAgY29udGVudEhlaWdodCA9IGFicyhjc3NIZWlnaHQgLSBpbmxpbmVDU1NIZWlnaHQpIDwgMVxyXG4gICAgICAgICAgICAgICAgPyBiZXR3ZWVuKG1pbkhlaWdodCwgaW5saW5lQ1NTSGVpZ2h0IHx8IGNzc0hlaWdodCwgbWF4SGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgOiBjc3NIZWlnaHQ7XHJcbiAgICAgICAgICAgIG9mZnNldFdpZHRoID0gY29udGVudFdpZHRoO1xyXG4gICAgICAgICAgICBvZmZzZXRIZWlnaHQgPSBjb250ZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICBjbGllbnRXaWR0aCA9IGNvbnRlbnRXaWR0aDtcclxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0ID0gY29udGVudEhlaWdodDtcclxuICAgICAgICAgICAgaWYgKGJveFNpemluZykge1xyXG4gICAgICAgICAgICAgICAgbWF4T2Zmc2V0V2lkdGggPSBtYXhXaWR0aDtcclxuICAgICAgICAgICAgICAgIG1heE9mZnNldEhlaWdodCA9IG1heEhlaWdodDtcclxuICAgICAgICAgICAgICAgIG1pbk9mZnNldFdpZHRoID0gbWluV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBtaW5PZmZzZXRIZWlnaHQgPSBtaW5IZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50V2lkdGggPSBvZmZzZXRXaWR0aCAtIGhvcml6b250YWxPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50SGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0IC0gdmVydGljYWxPZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXhPZmZzZXRXaWR0aCA9IG1heFdpZHRoICsgaG9yaXpvbnRhbE9mZnNldDtcclxuICAgICAgICAgICAgICAgIG1heE9mZnNldEhlaWdodCA9IG1heEhlaWdodCArIHZlcnRpY2FsT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgbWluT2Zmc2V0V2lkdGggPSBtaW5XaWR0aCArIGhvcml6b250YWxPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBtaW5PZmZzZXRIZWlnaHQgPSBtaW5IZWlnaHQgKyB2ZXJ0aWNhbE9mZnNldDtcclxuICAgICAgICAgICAgICAgIG9mZnNldFdpZHRoID0gY29udGVudFdpZHRoICsgaG9yaXpvbnRhbE9mZnNldDtcclxuICAgICAgICAgICAgICAgIG9mZnNldEhlaWdodCA9IGNvbnRlbnRIZWlnaHQgKyB2ZXJ0aWNhbE9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjbGllbnRXaWR0aCA9IGNvbnRlbnRXaWR0aCArIGhvcml6b250YWxQYWRkaW5nO1xyXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQgPSBjb250ZW50SGVpZ2h0ICsgdmVydGljYWxQYWRkaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3ZnOiBzdmcsXHJcbiAgICAgICAgb2Zmc2V0V2lkdGg6IG9mZnNldFdpZHRoLFxyXG4gICAgICAgIG9mZnNldEhlaWdodDogb2Zmc2V0SGVpZ2h0LFxyXG4gICAgICAgIGNsaWVudFdpZHRoOiBjbGllbnRXaWR0aCxcclxuICAgICAgICBjbGllbnRIZWlnaHQ6IGNsaWVudEhlaWdodCxcclxuICAgICAgICBjb250ZW50V2lkdGg6IGNvbnRlbnRXaWR0aCxcclxuICAgICAgICBjb250ZW50SGVpZ2h0OiBjb250ZW50SGVpZ2h0LFxyXG4gICAgICAgIGlubGluZUNTU1dpZHRoOiBpbmxpbmVDU1NXaWR0aCxcclxuICAgICAgICBpbmxpbmVDU1NIZWlnaHQ6IGlubGluZUNTU0hlaWdodCxcclxuICAgICAgICBjc3NXaWR0aDogY3NzV2lkdGgsXHJcbiAgICAgICAgY3NzSGVpZ2h0OiBjc3NIZWlnaHQsXHJcbiAgICAgICAgbWluV2lkdGg6IG1pbldpZHRoLFxyXG4gICAgICAgIG1pbkhlaWdodDogbWluSGVpZ2h0LFxyXG4gICAgICAgIG1heFdpZHRoOiBtYXhXaWR0aCxcclxuICAgICAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCxcclxuICAgICAgICBtaW5PZmZzZXRXaWR0aDogbWluT2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgbWluT2Zmc2V0SGVpZ2h0OiBtaW5PZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgbWF4T2Zmc2V0V2lkdGg6IG1heE9mZnNldFdpZHRoLFxyXG4gICAgICAgIG1heE9mZnNldEhlaWdodDogbWF4T2Zmc2V0SGVpZ2h0LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRSb3RhdGlvblJhZChwb3NlcywgZGlyZWN0aW9uKSB7XHJcbiAgICByZXR1cm4gZ2V0UmFkKGRpcmVjdGlvbiA+IDAgPyBwb3Nlc1swXSA6IHBvc2VzWzFdLCBkaXJlY3Rpb24gPiAwID8gcG9zZXNbMV0gOiBwb3Nlc1swXSk7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRDbGllbnRSZWN0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiAwLCB0b3A6IDAsXHJcbiAgICAgICAgd2lkdGg6IDAsIGhlaWdodDogMCxcclxuICAgICAgICByaWdodDogMCxcclxuICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgY2xpZW50TGVmdDogMCwgY2xpZW50VG9wOiAwLFxyXG4gICAgICAgIGNsaWVudFdpZHRoOiAwLCBjbGllbnRIZWlnaHQ6IDAsXHJcbiAgICAgICAgc2Nyb2xsV2lkdGg6IDAsIHNjcm9sbEhlaWdodDogMCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0RXh0ZW5kc1JlY3QoZWwsIHJlY3QpIHtcclxuICAgIHZhciBpc1Jvb3QgPSBlbCA9PT0gZ2V0RG9jdW1lbnRCb2R5KGVsKSB8fCBlbCA9PT0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsKTtcclxuICAgIHZhciBleHRlbmRzUmVjdCA9IHtcclxuICAgICAgICBjbGllbnRMZWZ0OiBlbC5jbGllbnRMZWZ0LFxyXG4gICAgICAgIGNsaWVudFRvcDogZWwuY2xpZW50VG9wLFxyXG4gICAgICAgIGNsaWVudFdpZHRoOiBlbC5jbGllbnRXaWR0aCxcclxuICAgICAgICBjbGllbnRIZWlnaHQ6IGVsLmNsaWVudEhlaWdodCxcclxuICAgICAgICBzY3JvbGxXaWR0aDogZWwuc2Nyb2xsV2lkdGgsXHJcbiAgICAgICAgc2Nyb2xsSGVpZ2h0OiBlbC5zY3JvbGxIZWlnaHQsXHJcbiAgICAgICAgb3ZlcmZsb3c6IGZhbHNlLFxyXG4gICAgfTtcclxuICAgIGlmIChpc1Jvb3QpIHtcclxuICAgICAgICBleHRlbmRzUmVjdC5jbGllbnRIZWlnaHQgPSBNYXRoLm1heChyZWN0LmhlaWdodCwgZXh0ZW5kc1JlY3QuY2xpZW50SGVpZ2h0KTtcclxuICAgICAgICBleHRlbmRzUmVjdC5zY3JvbGxIZWlnaHQgPSBNYXRoLm1heChyZWN0LmhlaWdodCwgZXh0ZW5kc1JlY3Quc2Nyb2xsSGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGV4dGVuZHNSZWN0Lm92ZXJmbG93ID0gZ2V0Q2FjaGVkU3R5bGUoZWwpKFwib3ZlcmZsb3dcIikgIT09IFwidmlzaWJsZVwiO1xyXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCByZWN0KSwgZXh0ZW5kc1JlY3QpO1xyXG59XHJcbmZ1bmN0aW9uIGdldENsaWVudFJlY3RCeVBvc2l0aW9uKHBvc2l0aW9uLCBiYXNlLCBlbCwgaXNFeHRlbmRzKSB7XHJcbiAgICB2YXIgbGVmdCA9IHBvc2l0aW9uLmxlZnQsIHJpZ2h0ID0gcG9zaXRpb24ucmlnaHQsIHRvcCA9IHBvc2l0aW9uLnRvcCwgYm90dG9tID0gcG9zaXRpb24uYm90dG9tO1xyXG4gICAgdmFyIGJhc2VUb3AgPSBiYXNlLnRvcDtcclxuICAgIHZhciBiYXNlTGVmdCA9IGJhc2UubGVmdDtcclxuICAgIHZhciByZWN0ID0ge1xyXG4gICAgICAgIGxlZnQ6IGJhc2VMZWZ0ICsgbGVmdCxcclxuICAgICAgICB0b3A6IGJhc2VUb3AgKyB0b3AsXHJcbiAgICAgICAgcmlnaHQ6IGJhc2VMZWZ0ICsgcmlnaHQsXHJcbiAgICAgICAgYm90dG9tOiBiYXNlVG9wICsgYm90dG9tLFxyXG4gICAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXHJcbiAgICAgICAgaGVpZ2h0OiBib3R0b20gLSB0b3AsXHJcbiAgICB9O1xyXG4gICAgaWYgKGVsICYmIGlzRXh0ZW5kcykge1xyXG4gICAgICAgIHJldHVybiBnZXRFeHRlbmRzUmVjdChlbCwgcmVjdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVjdDtcclxufVxyXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KGVsLCBpc0V4dGVuZHMpIHtcclxuICAgIHZhciBsZWZ0ID0gMDtcclxuICAgIHZhciB0b3AgPSAwO1xyXG4gICAgdmFyIHdpZHRoID0gMDtcclxuICAgIHZhciBoZWlnaHQgPSAwO1xyXG4gICAgLy8gbGV0IGlzUm9vdCA9IGZhbHNlO1xyXG4gICAgaWYgKGVsKSB7XHJcbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0O1xyXG4gICAgICAgIHRvcCA9IGNsaWVudFJlY3QudG9wO1xyXG4gICAgICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcclxuICAgICAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcclxuICAgIH1cclxuICAgIHZhciByZWN0ID0ge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIHJpZ2h0OiBsZWZ0ICsgd2lkdGgsXHJcbiAgICAgICAgYm90dG9tOiB0b3AgKyBoZWlnaHQsXHJcbiAgICB9O1xyXG4gICAgaWYgKGVsICYmIGlzRXh0ZW5kcykge1xyXG4gICAgICAgIHJldHVybiBnZXRFeHRlbmRzUmVjdChlbCwgcmVjdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVjdDtcclxufVxyXG5mdW5jdGlvbiBnZXRUb3RhbE9yaWdpbihtb3ZlYWJsZSkge1xyXG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsIGdyb3VwYWJsZSA9IF9hLmdyb3VwYWJsZSwgc3ZnT3JpZ2luID0gX2Euc3ZnT3JpZ2luO1xyXG4gICAgdmFyIF9iID0gbW92ZWFibGUuZ2V0U3RhdGUoKSwgb2Zmc2V0V2lkdGggPSBfYi5vZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0ID0gX2Iub2Zmc2V0SGVpZ2h0LCBzdmcgPSBfYi5zdmcsIHRyYW5zZm9ybU9yaWdpbiA9IF9iLnRyYW5zZm9ybU9yaWdpbjtcclxuICAgIGlmICghZ3JvdXBhYmxlICYmIHN2ZyAmJiBzdmdPcmlnaW4pIHtcclxuICAgICAgICByZXR1cm4gY29udmVydFRyYW5zZm9ybU9yaWdpbkFycmF5KHN2Z09yaWdpbiwgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNmb3JtT3JpZ2luO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRvdGFsRGlyZWN0aW9uKHBhcmVudERpcmVjdGlvbiwgaXNQaW5jaCwgaW5wdXRFdmVudCwgZGF0YXMpIHtcclxuICAgIHZhciBkaXJlY3Rpb247XHJcbiAgICBpZiAocGFyZW50RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gcGFyZW50RGlyZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQaW5jaCkge1xyXG4gICAgICAgIGRpcmVjdGlvbiA9IFswLCAwXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBpbnB1dEV2ZW50LnRhcmdldDtcclxuICAgICAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24odGFyZ2V0LCBkYXRhcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlyZWN0aW9uO1xyXG59XHJcbmZ1bmN0aW9uIGdldERpcmVjdGlvbih0YXJnZXQsIGRhdGFzKSB7XHJcbiAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBkZWcgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yb3RhdGlvblwiKSB8fCBcIlwiO1xyXG4gICAgdmFyIGRpcmVjaXRvbiA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRpcmVjdGlvblwiKTtcclxuICAgIGRhdGFzLmRlZyA9IGRlZztcclxuICAgIGlmICghZGlyZWNpdG9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGRpciA9IFswLCAwXTtcclxuICAgIChkaXJlY2l0b24uaW5kZXhPZihcIndcIikgPiAtMSkgJiYgKGRpclswXSA9IC0xKTtcclxuICAgIChkaXJlY2l0b24uaW5kZXhPZihcImVcIikgPiAtMSkgJiYgKGRpclswXSA9IDEpO1xyXG4gICAgKGRpcmVjaXRvbi5pbmRleE9mKFwiblwiKSA+IC0xKSAmJiAoZGlyWzFdID0gLTEpO1xyXG4gICAgKGRpcmVjaXRvbi5pbmRleE9mKFwic1wiKSA+IC0xKSAmJiAoZGlyWzFdID0gMSk7XHJcbiAgICByZXR1cm4gZGlyO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFic29sdXRlUG9zZXMocG9zZXMsIGRpc3QpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgcGx1cyhkaXN0LCBwb3Nlc1swXSksXHJcbiAgICAgICAgcGx1cyhkaXN0LCBwb3Nlc1sxXSksXHJcbiAgICAgICAgcGx1cyhkaXN0LCBwb3Nlc1syXSksXHJcbiAgICAgICAgcGx1cyhkaXN0LCBwb3Nlc1szXSksXHJcbiAgICBdO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFic29sdXRlUG9zZXNCeVN0YXRlKF9hKSB7XHJcbiAgICB2YXIgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcCwgcG9zMSA9IF9hLnBvczEsIHBvczIgPSBfYS5wb3MyLCBwb3MzID0gX2EucG9zMywgcG9zNCA9IF9hLnBvczQ7XHJcbiAgICByZXR1cm4gZ2V0QWJzb2x1dGVQb3NlcyhbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF0sIFtsZWZ0LCB0b3BdKTtcclxufVxyXG5mdW5jdGlvbiB1bnNldEFibGVzKHNlbGYsIGlzQ29udHJvbCkge1xyXG4gICAgc2VsZltpc0NvbnRyb2wgPyBcImNvbnRyb2xBYmxlc1wiIDogXCJ0YXJnZXRBYmxlc1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgYWJsZS51bnNldCAmJiBhYmxlLnVuc2V0KHNlbGYpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gdW5zZXRHZXN0byhzZWxmLCBpc0NvbnRyb2wpIHtcclxuICAgIHZhciBnZXN0b05hbWUgPSBpc0NvbnRyb2wgPyBcImNvbnRyb2xHZXN0b1wiIDogXCJ0YXJnZXRHZXN0b1wiO1xyXG4gICAgdmFyIGdlc3RvID0gc2VsZltnZXN0b05hbWVdO1xyXG4gICAgaWYgKChnZXN0byA9PT0gbnVsbCB8fCBnZXN0byA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VzdG8uaXNJZGxlKCkpID09PSBmYWxzZSkge1xyXG4gICAgICAgIHVuc2V0QWJsZXMoc2VsZiwgaXNDb250cm9sKTtcclxuICAgIH1cclxuICAgIGdlc3RvID09PSBudWxsIHx8IGdlc3RvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXN0by51bnNldCgpO1xyXG4gICAgc2VsZltnZXN0b05hbWVdID0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBmaWxsQ1NTT2JqZWN0KHN0eWxlLCByZXNvbHZlZEV2ZW50KSB7XHJcbiAgICBpZiAocmVzb2x2ZWRFdmVudCkge1xyXG4gICAgICAgIHZhciBvcmlnaW5hbERhdGFzID0gZ2V0QmVmb3JlUmVuZGVyYWJsZURhdGFzKHJlc29sdmVkRXZlbnQpO1xyXG4gICAgICAgIG9yaWdpbmFsRGF0YXMubmV4dFN0eWxlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9yaWdpbmFsRGF0YXMubmV4dFN0eWxlKSwgc3R5bGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdHlsZTogc3R5bGUsXHJcbiAgICAgICAgY3NzVGV4dDogZ2V0S2V5cyhzdHlsZSkubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBcIlwiLmNvbmNhdChkZWNhbWVsaXplKG5hbWUsIFwiLVwiKSwgXCI6IFwiKS5jb25jYXQoc3R5bGVbbmFtZV0sIFwiO1wiKTsgfSkuam9pbihcIlwiKSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZmlsbEFmdGVyVHJhbnNmb3JtKHByZXZFdmVudCwgbmV4dEV2ZW50LCByZXNvbHZlZEV2ZW50KSB7XHJcbiAgICB2YXIgYWZ0ZXJUcmFuc2Zvcm0gPSBuZXh0RXZlbnQuYWZ0ZXJUcmFuc2Zvcm0gfHwgbmV4dEV2ZW50LnRyYW5zZm9ybTtcclxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZmlsbENTU09iamVjdChfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldkV2ZW50LnN0eWxlKSwgbmV4dEV2ZW50LnN0eWxlKSwgeyB0cmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtIH0pLCByZXNvbHZlZEV2ZW50KSksIHsgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLCB0cmFuc2Zvcm06IHByZXZFdmVudC50cmFuc2Zvcm0gfSk7XHJcbn1cclxuZnVuY3Rpb24gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgcGFyYW1zLCBpc0JlZm9yZUV2ZW50KSB7XHJcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgaWYgKCFkYXRhcy5kYXRhcykge1xyXG4gICAgICAgIGRhdGFzLmRhdGFzID0ge307XHJcbiAgICB9XHJcbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7IHRhcmdldDogbW92ZWFibGUuc3RhdGUudGFyZ2V0LCBjbGllbnRYOiBlLmNsaWVudFgsIGNsaWVudFk6IGUuY2xpZW50WSwgaW5wdXRFdmVudDogZS5pbnB1dEV2ZW50LCBjdXJyZW50VGFyZ2V0OiBtb3ZlYWJsZSwgbW92ZWFibGU6IG1vdmVhYmxlLCBkYXRhczogZGF0YXMuZGF0YXMsIGlzUmVxdWVzdDogZS5pc1JlcXVlc3QsIGlzUmVxdWVzdENoaWxkOiBlLmlzUmVxdWVzdENoaWxkLCBpc0ZpcnN0RHJhZzogISFlLmlzRmlyc3REcmFnLCBpc1RydXN0ZWQ6IGUuaXNUcnVzdGVkICE9PSBmYWxzZSwgc3RvcEFibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZGF0YXMuaXNFdmVudFN0YXJ0ID0gZmFsc2U7XHJcbiAgICAgICAgfSwgc3RvcERyYWc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAoX2EgPSBlLnN0b3ApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGUpO1xyXG4gICAgICAgIH0gfSk7XHJcbiAgICBpZiAoIWRhdGFzLmlzU3RhcnRFdmVudCkge1xyXG4gICAgICAgIGRhdGFzLmlzU3RhcnRFdmVudCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghaXNCZWZvcmVFdmVudCkge1xyXG4gICAgICAgIGRhdGFzLmxhc3RFdmVudCA9IG5leHRQYXJhbXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV4dFBhcmFtcztcclxufVxyXG5mdW5jdGlvbiBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCBwYXJhbXMpIHtcclxuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICB2YXIgaXNEcmFnID0gXCJpc0RyYWdcIiBpbiBwYXJhbXMgPyBwYXJhbXMuaXNEcmFnIDogZS5pc0RyYWc7XHJcbiAgICBpZiAoIWRhdGFzLmRhdGFzKSB7XHJcbiAgICAgICAgZGF0YXMuZGF0YXMgPSB7fTtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7IGlzRHJhZzogaXNEcmFnIH0sIHBhcmFtcyksIHsgbW92ZWFibGU6IG1vdmVhYmxlLCB0YXJnZXQ6IG1vdmVhYmxlLnN0YXRlLnRhcmdldCwgY2xpZW50WDogZS5jbGllbnRYLCBjbGllbnRZOiBlLmNsaWVudFksIGlucHV0RXZlbnQ6IGUuaW5wdXRFdmVudCwgY3VycmVudFRhcmdldDogbW92ZWFibGUsIGxhc3RFdmVudDogZGF0YXMubGFzdEV2ZW50LCBpc0RvdWJsZTogZS5pc0RvdWJsZSwgZGF0YXM6IGRhdGFzLmRhdGFzLCBpc0ZpcnN0RHJhZzogISFlLmlzRmlyc3REcmFnIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNhdGNoRXZlbnQobW92ZWFibGUsIG5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICBtb3ZlYWJsZS5fZW1pdHRlci5vbihuYW1lLCBjYWxsYmFjayk7XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBuYW1lLCBwYXJhbXMsIGlzTWFuYWdlciwgaXNSZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gbW92ZWFibGUudHJpZ2dlckV2ZW50KG5hbWUsIHBhcmFtcywgaXNNYW5hZ2VyLCBpc1JlcXVlc3QpO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWwsIHBzZXVkb0VsdCkge1xyXG4gICAgcmV0dXJuIGdldFdpbmRvdyhlbCkuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgcHNldWRvRWx0KTtcclxufVxyXG5mdW5jdGlvbiBmaWx0ZXJBYmxlcyhhYmxlcywgbWV0aG9kcywgdHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHkpIHtcclxuICAgIHZhciBlbmFibGVkQWJsZXMgPSB7fTtcclxuICAgIHZhciBhYmxlR3JvdXBzID0ge307XHJcbiAgICByZXR1cm4gYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBhYmxlLm5hbWU7XHJcbiAgICAgICAgaWYgKGVuYWJsZWRBYmxlc1tuYW1lXSB8fCAhbWV0aG9kcy5zb21lKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIGFibGVbbWV0aG9kXTsgfSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5ICYmIGFibGUuYWJsZUdyb3VwKSB7XHJcbiAgICAgICAgICAgIGlmIChhYmxlR3JvdXBzW2FibGUuYWJsZUdyb3VwXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFibGVHcm91cHNbYWJsZS5hYmxlR3JvdXBdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5hYmxlZEFibGVzW25hbWVdID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGVxdWFscyhhMSwgYTIpIHtcclxuICAgIHJldHVybiBhMSA9PT0gYTIgfHwgKGExID09IG51bGwgJiYgYTIgPT0gbnVsbCk7XHJcbn1cclxuZnVuY3Rpb24gc2VsZWN0VmFsdWUoKSB7XHJcbiAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhbHVlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGggLSAxO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlc1tsZW5ndGhdO1xyXG59XHJcbmZ1bmN0aW9uIGdyb3VwQnkoYXJyLCBmdW5jKSB7XHJcbiAgICB2YXIgZ3JvdXBzID0gW107XHJcbiAgICB2YXIgZ3JvdXBLZXlzID0gW107XHJcbiAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGdyb3VwS2V5ID0gZnVuYyhlbCwgaW5kZXgsIGFycik7XHJcbiAgICAgICAgdmFyIGtleUluZGV4ID0gZ3JvdXBLZXlzLmluZGV4T2YoZ3JvdXBLZXkpO1xyXG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1trZXlJbmRleF0gfHwgW107XHJcbiAgICAgICAgaWYgKGtleUluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICBncm91cEtleXMucHVzaChncm91cEtleSk7XHJcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JvdXAucHVzaChlbCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBncm91cHM7XHJcbn1cclxuZnVuY3Rpb24gZ3JvdXBCeU1hcChhcnIsIGZ1bmMpIHtcclxuICAgIHZhciBncm91cHMgPSBbXTtcclxuICAgIHZhciBncm91cEtleXMgPSB7fTtcclxuICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgZ3JvdXBLZXkgPSBmdW5jKGVsLCBpbmRleCwgYXJyKTtcclxuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cEtleXNbZ3JvdXBLZXldO1xyXG4gICAgICAgIGlmICghZ3JvdXApIHtcclxuICAgICAgICAgICAgZ3JvdXAgPSBbXTtcclxuICAgICAgICAgICAgZ3JvdXBLZXlzW2dyb3VwS2V5XSA9IGdyb3VwO1xyXG4gICAgICAgICAgICBncm91cHMucHVzaChncm91cCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdyb3VwLnB1c2goZWwpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZ3JvdXBzO1xyXG59XHJcbmZ1bmN0aW9uIGZsYXQoYXJyKSB7XHJcbiAgICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XHJcbiAgICAgICAgcmV0dXJuIHByZXYuY29uY2F0KGN1cik7XHJcbiAgICB9LCBbXSk7XHJcbn1cclxuZnVuY3Rpb24gbWF4T2Zmc2V0KCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgYXJncy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhYnMoYikgLSBhYnMoYSk7IH0pO1xyXG4gICAgcmV0dXJuIGFyZ3NbMF07XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKG1hdHJpeCwgcG9zLCBuKSB7XHJcbiAgICByZXR1cm4gY2FsY3VsYXRlKGludmVydChtYXRyaXgsIG4pLCBjb252ZXJ0UG9zaXRpb25NYXRyaXgocG9zLCBuKSwgbik7XHJcbn1cclxuZnVuY3Rpb24gY29udmVydERyYWdEaXN0KHN0YXRlLCBlKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgaXMzZCA9IHN0YXRlLmlzM2QsIHJvb3RNYXRyaXggPSBzdGF0ZS5yb290TWF0cml4O1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICBfYSA9IF9fcmVhZChjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2UuZGlzdFgsIGUuZGlzdFldLCBuKSwgMiksIGUuZGlzdFggPSBfYVswXSwgZS5kaXN0WSA9IF9hWzFdO1xyXG4gICAgcmV0dXJuIGU7XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlUGFkZGluZyhtYXRyaXgsIHBvcywgYWRkZWQsIG4pIHtcclxuICAgIGlmICghYWRkZWRbMF0gJiYgIWFkZGVkWzFdKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgIH1cclxuICAgIHZhciB4QWRkZWQgPSBjYWxjdWxhdGVQb3NpdGlvbihtYXRyaXgsIFtub3JtYWxpemVkKGFkZGVkWzBdIHx8IDEpLCAwXSwgbik7XHJcbiAgICB2YXIgeUFkZGVkID0gY2FsY3VsYXRlUG9zaXRpb24obWF0cml4LCBbMCwgbm9ybWFsaXplZChhZGRlZFsxXSB8fCAxKV0sIG4pO1xyXG4gICAgdmFyIG5leHRBZGRlZCA9IGNhbGN1bGF0ZVBvc2l0aW9uKG1hdHJpeCwgW1xyXG4gICAgICAgIGFkZGVkWzBdIC8gZ2V0RGlzdFNpemUoeEFkZGVkKSxcclxuICAgICAgICBhZGRlZFsxXSAvIGdldERpc3RTaXplKHlBZGRlZCksXHJcbiAgICBdLCBuKTtcclxuICAgIHJldHVybiBwbHVzKHBvcywgbmV4dEFkZGVkKTtcclxufVxyXG5mdW5jdGlvbiBjb252ZXJ0Q1NTU2l6ZSh2YWx1ZSwgc2l6ZSwgaXNSZWxhdGl2ZSkge1xyXG4gICAgcmV0dXJuIGlzUmVsYXRpdmUgPyBcIlwiLmNvbmNhdCh2YWx1ZSAvIHNpemUgKiAxMDAsIFwiJVwiKSA6IFwiXCIuY29uY2F0KHZhbHVlLCBcInB4XCIpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRpbnlEaXN0KHYpIHtcclxuICAgIHJldHVybiBhYnModikgPD0gVElOWV9OVU0gPyAwIDogdjtcclxufVxyXG5mdW5jdGlvbiBnZXREaXJlY3Rpb25WaWV3Q2xhc3NOYW1lKGFibGVOYW1lKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgaWYgKCFtb3ZlYWJsZS5pc0RyYWdnaW5nKGFibGVOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRHZXN0b0RhdGEobW92ZWFibGUsIGFibGVOYW1lKTtcclxuICAgICAgICB2YXIgZGVnID0gZGF0YS5kZWc7XHJcbiAgICAgICAgaWYgKCFkZWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcmVmaXgoXCJ2aWV3LWNvbnRyb2wtcm90YXRpb25cIi5jb25jYXQoZGVnKSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldERpcmVjdGlvbkNvbmRpdGlvbihhYmxlTmFtZSwgY2hlY2tBYmxlcykge1xyXG4gICAgaWYgKGNoZWNrQWJsZXMgPT09IHZvaWQgMCkgeyBjaGVja0FibGVzID0gW2FibGVOYW1lXTsgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIGlmIChlLmlzUmVxdWVzdCkge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tBYmxlcy5zb21lKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBlLnJlcXVlc3RBYmxlID09PSBuYW1lOyB9KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUucGFyZW50RGlyZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0YXJnZXQgPSBlLmlucHV0RXZlbnQudGFyZ2V0O1xyXG4gICAgICAgIHJldHVybiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcImRpcmVjdGlvblwiKSkgJiYgKCFhYmxlTmFtZSB8fCBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChhYmxlTmFtZSkpKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybUluZm8odHJhbnNmb3Jtcywgc3RhdGUsIGluZGV4KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgbWF0cml4SW5mb3MgPSBwYXJzZSh0cmFuc2Zvcm1zLCB7XHJcbiAgICAgICAgXCJ4JVwiOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAvIDEwMCAqIHN0YXRlLm9mZnNldFdpZHRoOyB9LFxyXG4gICAgICAgIFwieSVcIjogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgLyAxMDAgKiBzdGF0ZS5vZmZzZXRIZWlnaHQ7IH0sXHJcbiAgICB9KTtcclxuICAgIHZhciBiZWZvcmVGdW5jdGlvblRleHRzID0gdHJhbnNmb3Jtcy5zbGljZSgwLCBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBpbmRleCk7XHJcbiAgICB2YXIgYmVmb3JlRnVuY3Rpb25UZXh0czIgPSB0cmFuc2Zvcm1zLnNsaWNlKDAsIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGluZGV4ICsgMSk7XHJcbiAgICB2YXIgdGFyZ2V0RnVuY3Rpb25UZXh0ID0gdHJhbnNmb3Jtc1tpbmRleF0gfHwgXCJcIjtcclxuICAgIHZhciBhZnRlckZ1bmN0aW9uVGV4dHMgPSBpbmRleCA8IDAgPyBbXSA6IHRyYW5zZm9ybXMuc2xpY2UoaW5kZXgpO1xyXG4gICAgdmFyIGFmdGVyRnVuY3Rpb25UZXh0czIgPSBpbmRleCA8IDAgPyBbXSA6IHRyYW5zZm9ybXMuc2xpY2UoaW5kZXggKyAxKTtcclxuICAgIHZhciBiZWZvcmVGdW5jdGlvbnMgPSBtYXRyaXhJbmZvcy5zbGljZSgwLCBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBpbmRleCk7XHJcbiAgICB2YXIgYmVmb3JlRnVuY3Rpb25zMiA9IG1hdHJpeEluZm9zLnNsaWNlKDAsIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGluZGV4ICsgMSk7XHJcbiAgICB2YXIgdGFyZ2V0RnVuY3Rpb24gPSAoX2EgPSBtYXRyaXhJbmZvc1tpbmRleF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBhcnNlKFtcIlwiXSlbMF07XHJcbiAgICB2YXIgYWZ0ZXJGdW5jdGlvbnMgPSBpbmRleCA8IDAgPyBbXSA6IG1hdHJpeEluZm9zLnNsaWNlKGluZGV4KTtcclxuICAgIHZhciBhZnRlckZ1bmN0aW9uczIgPSBpbmRleCA8IDAgPyBbXSA6IG1hdHJpeEluZm9zLnNsaWNlKGluZGV4ICsgMSk7XHJcbiAgICB2YXIgdGFyZ2V0RnVuY3Rpb25zID0gdGFyZ2V0RnVuY3Rpb24gPyBbdGFyZ2V0RnVuY3Rpb25dIDogW107XHJcbiAgICB2YXIgYmVmb3JlRnVuY3Rpb25NYXRyaXggPSB0b01hdChiZWZvcmVGdW5jdGlvbnMpO1xyXG4gICAgdmFyIGJlZm9yZUZ1bmN0aW9uTWF0cml4MiA9IHRvTWF0KGJlZm9yZUZ1bmN0aW9uczIpO1xyXG4gICAgdmFyIGFmdGVyRnVuY3Rpb25NYXRyaXggPSB0b01hdChhZnRlckZ1bmN0aW9ucyk7XHJcbiAgICB2YXIgYWZ0ZXJGdW5jdGlvbk1hdHJpeDIgPSB0b01hdChhZnRlckZ1bmN0aW9uczIpO1xyXG4gICAgdmFyIGFsbEZ1bmN0aW9uTWF0cml4ID0gbXVsdGlwbHkoYmVmb3JlRnVuY3Rpb25NYXRyaXgsIGFmdGVyRnVuY3Rpb25NYXRyaXgsIDQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0cmFuc2Zvcm1zOiB0cmFuc2Zvcm1zLFxyXG4gICAgICAgIGJlZm9yZUZ1bmN0aW9uTWF0cml4OiBiZWZvcmVGdW5jdGlvbk1hdHJpeCxcclxuICAgICAgICBiZWZvcmVGdW5jdGlvbk1hdHJpeDI6IGJlZm9yZUZ1bmN0aW9uTWF0cml4MixcclxuICAgICAgICB0YXJnZXRGdW5jdGlvbk1hdHJpeDogdG9NYXQodGFyZ2V0RnVuY3Rpb25zKSxcclxuICAgICAgICBhZnRlckZ1bmN0aW9uTWF0cml4OiBhZnRlckZ1bmN0aW9uTWF0cml4LFxyXG4gICAgICAgIGFmdGVyRnVuY3Rpb25NYXRyaXgyOiBhZnRlckZ1bmN0aW9uTWF0cml4MixcclxuICAgICAgICBhbGxGdW5jdGlvbk1hdHJpeDogYWxsRnVuY3Rpb25NYXRyaXgsXHJcbiAgICAgICAgYmVmb3JlRnVuY3Rpb25zOiBiZWZvcmVGdW5jdGlvbnMsXHJcbiAgICAgICAgYmVmb3JlRnVuY3Rpb25zMjogYmVmb3JlRnVuY3Rpb25zMixcclxuICAgICAgICB0YXJnZXRGdW5jdGlvbjogdGFyZ2V0RnVuY3Rpb25zWzBdLFxyXG4gICAgICAgIGFmdGVyRnVuY3Rpb25zOiBhZnRlckZ1bmN0aW9ucyxcclxuICAgICAgICBhZnRlckZ1bmN0aW9uczI6IGFmdGVyRnVuY3Rpb25zMixcclxuICAgICAgICBiZWZvcmVGdW5jdGlvblRleHRzOiBiZWZvcmVGdW5jdGlvblRleHRzLFxyXG4gICAgICAgIGJlZm9yZUZ1bmN0aW9uVGV4dHMyOiBiZWZvcmVGdW5jdGlvblRleHRzMixcclxuICAgICAgICB0YXJnZXRGdW5jdGlvblRleHQ6IHRhcmdldEZ1bmN0aW9uVGV4dCxcclxuICAgICAgICBhZnRlckZ1bmN0aW9uVGV4dHM6IGFmdGVyRnVuY3Rpb25UZXh0cyxcclxuICAgICAgICBhZnRlckZ1bmN0aW9uVGV4dHMyOiBhZnRlckZ1bmN0aW9uVGV4dHMyLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc0FycmF5Rm9ybWF0KGFycikge1xyXG4gICAgaWYgKCFhcnIgfHwgIWlzT2JqZWN0KGFycikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOb2RlKGFycikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNBcnJheShhcnIpIHx8IFwibGVuZ3RoXCIgaW4gYXJyO1xyXG59XHJcbmZ1bmN0aW9uIGdldFJlZlRhcmdldCh0YXJnZXQsIGlzU2VsZWN0b3IpIHtcclxuICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOb2RlKHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldCkpIHtcclxuICAgICAgICBpZiAoaXNTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRnVuY3Rpb24odGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQoKTtcclxuICAgIH1cclxuICAgIGlmIChpc1dpbmRvdyh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGlmIChcImN1cnJlbnRcIiBpbiB0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0LmN1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbmZ1bmN0aW9uIGdldFJlZlRhcmdldHModGFyZ2V0cywgaXNTZWxlY3Rvcikge1xyXG4gICAgaWYgKCF0YXJnZXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdmFyIHVzZXJUYXJnZXRzID0gaXNBcnJheUZvcm1hdCh0YXJnZXRzKSA/IFtdLnNsaWNlLmNhbGwodGFyZ2V0cykgOiBbdGFyZ2V0c107XHJcbiAgICByZXR1cm4gdXNlclRhcmdldHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAoaXNTdHJpbmcodGFyZ2V0KSAmJiBpc1NlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwcmV2KSwgZmFsc2UpLCBfX3JlYWQoW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCkpKSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHByZXYucHVzaChnZXRSZWZUYXJnZXRzKHRhcmdldCwgaXNTZWxlY3RvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJldi5wdXNoKGdldFJlZlRhcmdldCh0YXJnZXQsIGlzU2VsZWN0b3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICB9LCBbXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVSb3RhdGlvbihwb3MxLCBwb3MyLCBkaXJlY3Rpb24pIHtcclxuICAgIHZhciBkZWcgPSBnZXRSYWQocG9zMSwgcG9zMikgLyBNYXRoLlBJICogMTgwO1xyXG4gICAgZGVnID0gZGlyZWN0aW9uID49IDAgPyBkZWcgOiAxODAgLSBkZWc7XHJcbiAgICBkZWcgPSBkZWcgPj0gMCA/IGRlZyA6IDM2MCArIGRlZztcclxuICAgIHJldHVybiBkZWc7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RHJhZ0Rpc3RCeVN0YXRlKHN0YXRlLCBkaXN0KSB7XHJcbiAgICB2YXIgcm9vdE1hdHJpeCA9IHN0YXRlLnJvb3RNYXRyaXgsIGlzM2QgPSBzdGF0ZS5pczNkO1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICB2YXIgaW52ZXJzZU1hdHJpeCA9IGludmVydChyb290TWF0cml4LCBuKTtcclxuICAgIGlmICghaXMzZCkge1xyXG4gICAgICAgIGludmVyc2VNYXRyaXggPSBjb252ZXJ0RGltZW5zaW9uKGludmVyc2VNYXRyaXgsIDMsIDQpO1xyXG4gICAgfVxyXG4gICAgaW52ZXJzZU1hdHJpeFsxMl0gPSAwO1xyXG4gICAgaW52ZXJzZU1hdHJpeFsxM10gPSAwO1xyXG4gICAgaW52ZXJzZU1hdHJpeFsxNF0gPSAwO1xyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZU1hdHJpeERpc3QoaW52ZXJzZU1hdHJpeCwgZGlzdCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2l6ZURpc3RCeURpc3Qoc3RhcnRTaXplLCBkaXN0LCByYXRpbywgZGlyZWN0aW9uLCBrZWVwUmF0aW8pIHtcclxuICAgIHZhciBfYSA9IF9fcmVhZChzdGFydFNpemUsIDIpLCBzdGFydE9mZnNldFdpZHRoID0gX2FbMF0sIHN0YXJ0T2Zmc2V0SGVpZ2h0ID0gX2FbMV07XHJcbiAgICB2YXIgZGlzdFdpZHRoID0gMDtcclxuICAgIHZhciBkaXN0SGVpZ2h0ID0gMDtcclxuICAgIGlmIChrZWVwUmF0aW8gJiYgc3RhcnRPZmZzZXRXaWR0aCAmJiBzdGFydE9mZnNldEhlaWdodCkge1xyXG4gICAgICAgIHZhciByYWQgPSBnZXRSYWQoWzAsIDBdLCBkaXN0KTtcclxuICAgICAgICB2YXIgc3RhbmRhcmRSYWQgPSBnZXRSYWQoWzAsIDBdLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgIHZhciBzaXplID0gZ2V0RGlzdFNpemUoZGlzdCk7XHJcbiAgICAgICAgdmFyIHNpZ25TaXplID0gTWF0aC5jb3MocmFkIC0gc3RhbmRhcmRSYWQpICogc2l6ZTtcclxuICAgICAgICBpZiAoIWRpcmVjdGlvblswXSkge1xyXG4gICAgICAgICAgICAvLyB0b3AsIGJvdHRvbVxyXG4gICAgICAgICAgICBkaXN0SGVpZ2h0ID0gc2lnblNpemU7XHJcbiAgICAgICAgICAgIGRpc3RXaWR0aCA9IGRpc3RIZWlnaHQgKiByYXRpbztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWRpcmVjdGlvblsxXSkge1xyXG4gICAgICAgICAgICAvLyBsZWZ0LCByaWdodFxyXG4gICAgICAgICAgICBkaXN0V2lkdGggPSBzaWduU2l6ZTtcclxuICAgICAgICAgICAgZGlzdEhlaWdodCA9IGRpc3RXaWR0aCAvIHJhdGlvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdHdvLXdheVxyXG4gICAgICAgICAgICB2YXIgc3RhcnRXaWR0aFNpemUgPSBkaXJlY3Rpb25bMF0gKiBzdGFydE9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRIZWlnaHRTaXplID0gZGlyZWN0aW9uWzFdICogc3RhcnRPZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBzZWNvbmRSYWQgPSBNYXRoLmF0YW4yKHN0YXJ0V2lkdGhTaXplICsgZGlzdFswXSwgc3RhcnRIZWlnaHRTaXplICsgZGlzdFsxXSk7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFJhZCA9IE1hdGguYXRhbjIoc3RhcnRXaWR0aFNpemUsIHN0YXJ0SGVpZ2h0U2l6ZSk7XHJcbiAgICAgICAgICAgIGlmIChzZWNvbmRSYWQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZWNvbmRSYWQgKz0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpcnN0UmFkIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZmlyc3RSYWQgKz0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJhZF8xID0gMDtcclxuICAgICAgICAgICAgaWYgKGFicyhzZWNvbmRSYWQgLSBmaXJzdFJhZCkgPCBNYXRoLlBJIC8gMiB8fCBhYnMoc2Vjb25kUmFkIC0gZmlyc3RSYWQpID4gTWF0aC5QSSAvIDIgKiAzKSB7XHJcbiAgICAgICAgICAgICAgICByYWRfMSA9IHNlY29uZFJhZCAtIGZpcnN0UmFkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmlyc3RSYWQgKz0gTWF0aC5QSTtcclxuICAgICAgICAgICAgICAgIHJhZF8xID0gc2Vjb25kUmFkIC0gZmlyc3RSYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJhZF8xID4gTWF0aC5QSSAqIDIpIHtcclxuICAgICAgICAgICAgICAgIHJhZF8xIC09IE1hdGguUEkgKiAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJhZF8xID4gTWF0aC5QSSkge1xyXG4gICAgICAgICAgICAgICAgcmFkXzEgPSAyICogTWF0aC5QSSAtIHJhZF8xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJhZF8xIDwgLU1hdGguUEkpIHtcclxuICAgICAgICAgICAgICAgIHJhZF8xID0gLTIgKiBNYXRoLlBJIC0gcmFkXzE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gICAgICAgMTgwXHJcbiAgICAgICAgICAgIC8vIC0xLCAtMSwgIC8vIDEsIC0xXHJcbiAgICAgICAgICAgIC8vIDI3MCAgICAgICAgICAgIDkwXHJcbiAgICAgICAgICAgIC8vIC0xLCAxICAgIC8vIDEsIDFcclxuICAgICAgICAgICAgLy8gICAgICAgMFxyXG4gICAgICAgICAgICB2YXIgZGlzdFNpemUgPSBnZXREaXN0U2l6ZShbc3RhcnRXaWR0aFNpemUgKyBkaXN0WzBdLCBzdGFydEhlaWdodFNpemUgKyBkaXN0WzFdXSkgKiBNYXRoLmNvcyhyYWRfMSk7XHJcbiAgICAgICAgICAgIGRpc3RXaWR0aCA9IGRpc3RTaXplICogTWF0aC5zaW4oZmlyc3RSYWQpIC0gc3RhcnRXaWR0aFNpemU7XHJcbiAgICAgICAgICAgIGRpc3RIZWlnaHQgPSBkaXN0U2l6ZSAqIE1hdGguY29zKGZpcnN0UmFkKSAtIHN0YXJ0SGVpZ2h0U2l6ZTtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGRpc3RXaWR0aCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uWzFdIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZGlzdEhlaWdodCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGRpc3RXaWR0aCA9IGRpcmVjdGlvblswXSAqIGRpc3RbMF07XHJcbiAgICAgICAgZGlzdEhlaWdodCA9IGRpcmVjdGlvblsxXSAqIGRpc3RbMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2Rpc3RXaWR0aCwgZGlzdEhlaWdodF07XHJcbn1cclxuZnVuY3Rpb24gZ2V0T2Zmc2V0U2l6ZURpc3Qoc2l6ZURpcmVjdGlvbiwga2VlcFJhdGlvLCBkYXRhcywgZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgdmFyIHJhdGlvID0gZGF0YXMucmF0aW8sIHN0YXJ0T2Zmc2V0V2lkdGggPSBkYXRhcy5zdGFydE9mZnNldFdpZHRoLCBzdGFydE9mZnNldEhlaWdodCA9IGRhdGFzLnN0YXJ0T2Zmc2V0SGVpZ2h0O1xyXG4gICAgdmFyIGRpc3RXaWR0aCA9IDA7XHJcbiAgICB2YXIgZGlzdEhlaWdodCA9IDA7XHJcbiAgICB2YXIgZGlzdFggPSBlLmRpc3RYLCBkaXN0WSA9IGUuZGlzdFksIHBpbmNoU2NhbGUgPSBlLnBpbmNoU2NhbGUsIHBhcmVudERpc3RhbmNlID0gZS5wYXJlbnREaXN0YW5jZSwgcGFyZW50RGlzdCA9IGUucGFyZW50RGlzdCwgcGFyZW50U2NhbGUgPSBlLnBhcmVudFNjYWxlO1xyXG4gICAgdmFyIHN0YXJ0Rml4ZWREaXJlY3Rpb24gPSBkYXRhcy5maXhlZERpcmVjdGlvbjtcclxuICAgIHZhciBkaXJlY3Rpb25zRGlzdHMgPSBbMCwgMV0ubWFwKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBhYnMoc2l6ZURpcmVjdGlvbltpbmRleF0gLSBzdGFydEZpeGVkRGlyZWN0aW9uW2luZGV4XSk7XHJcbiAgICB9KTtcclxuICAgIHZhciBkaXJlY3Rpb25SYXRpb3MgPSBbMCwgMV0ubWFwKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHZhciBkaXN0ID0gZGlyZWN0aW9uc0Rpc3RzW2luZGV4XTtcclxuICAgICAgICBpZiAoZGlzdCAhPT0gMCkge1xyXG4gICAgICAgICAgICBkaXN0ID0gMiAvIGRpc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaXN0O1xyXG4gICAgfSk7XHJcbiAgICBpZiAocGFyZW50RGlzdCkge1xyXG4gICAgICAgIGRpc3RXaWR0aCA9IHBhcmVudERpc3RbMF07XHJcbiAgICAgICAgZGlzdEhlaWdodCA9IHBhcmVudERpc3RbMV07XHJcbiAgICAgICAgaWYgKGtlZXBSYXRpbykge1xyXG4gICAgICAgICAgICBpZiAoIWRpc3RXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgZGlzdFdpZHRoID0gZGlzdEhlaWdodCAqIHJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFkaXN0SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0SGVpZ2h0ID0gZGlzdFdpZHRoIC8gcmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc051bWJlcihwaW5jaFNjYWxlKSkge1xyXG4gICAgICAgIGRpc3RXaWR0aCA9IChwaW5jaFNjYWxlIC0gMSkgKiBzdGFydE9mZnNldFdpZHRoO1xyXG4gICAgICAgIGRpc3RIZWlnaHQgPSAocGluY2hTY2FsZSAtIDEpICogc3RhcnRPZmZzZXRIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXJlbnRTY2FsZSkge1xyXG4gICAgICAgIGRpc3RXaWR0aCA9IChwYXJlbnRTY2FsZVswXSAtIDEpICogc3RhcnRPZmZzZXRXaWR0aDtcclxuICAgICAgICBkaXN0SGVpZ2h0ID0gKHBhcmVudFNjYWxlWzFdIC0gMSkgKiBzdGFydE9mZnNldEhlaWdodDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhcmVudERpc3RhbmNlKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlWCA9IHN0YXJ0T2Zmc2V0V2lkdGggKiBkaXJlY3Rpb25zRGlzdHNbMF07XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IHN0YXJ0T2Zmc2V0SGVpZ2h0ICogZGlyZWN0aW9uc0Rpc3RzWzFdO1xyXG4gICAgICAgIHZhciByYXRpb0Rpc3RhbmNlID0gZ2V0RGlzdFNpemUoW3NjYWxlWCwgc2NhbGVZXSk7XHJcbiAgICAgICAgZGlzdFdpZHRoID0gcGFyZW50RGlzdGFuY2UgLyByYXRpb0Rpc3RhbmNlICogc2NhbGVYICogZGlyZWN0aW9uUmF0aW9zWzBdO1xyXG4gICAgICAgIGRpc3RIZWlnaHQgPSBwYXJlbnREaXN0YW5jZSAvIHJhdGlvRGlzdGFuY2UgKiBzY2FsZVkgKiBkaXJlY3Rpb25SYXRpb3NbMV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgZGlzdF8xID0gZ2V0RHJhZ0Rpc3QoeyBkYXRhczogZGF0YXMsIGRpc3RYOiBkaXN0WCwgZGlzdFk6IGRpc3RZIH0pO1xyXG4gICAgICAgIGRpc3RfMSA9IGRpcmVjdGlvblJhdGlvcy5tYXAoZnVuY3Rpb24gKHJhdGlvLCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXN0XzFbaV0gKiByYXRpbztcclxuICAgICAgICB9KTtcclxuICAgICAgICBfYSA9IF9fcmVhZChnZXRTaXplRGlzdEJ5RGlzdChbc3RhcnRPZmZzZXRXaWR0aCwgc3RhcnRPZmZzZXRIZWlnaHRdLCBkaXN0XzEsIHJhdGlvLCBzaXplRGlyZWN0aW9uLCBrZWVwUmF0aW8pLCAyKSwgZGlzdFdpZHRoID0gX2FbMF0sIGRpc3RIZWlnaHQgPSBfYVsxXTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLy8gZGlyZWN0aW9uLFxyXG4gICAgICAgIC8vIHNpemVEaXJlY3Rpb24sXHJcbiAgICAgICAgZGlzdFdpZHRoOiBkaXN0V2lkdGgsXHJcbiAgICAgICAgZGlzdEhlaWdodDogZGlzdEhlaWdodCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybVVuaXQob3JpZ2luLCB4eSkge1xyXG4gICAgaWYgKHh5KSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gXCJsZWZ0XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgeDogXCIwJVwiLCB5OiBcIjUwJVwiIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9yaWdpbiA9PT0gXCJ0b3BcIikge1xyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBcIjUwJVwiLCB5OiBcIjUwJVwiIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9yaWdpbiA9PT0gXCJjZW50ZXJcIikge1xyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBcIjUwJVwiLCB5OiBcIjUwJVwiIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9yaWdpbiA9PT0gXCJyaWdodFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IFwiMTAwJVwiLCB5OiBcIjUwJVwiIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9yaWdpbiA9PT0gXCJib3R0b21cIikge1xyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBcIjUwJVwiLCB5OiBcIjEwMCVcIiB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2EgPSBfX3JlYWQob3JpZ2luLnNwbGl0KFwiIFwiKSwgMiksIGxlZnQgPSBfYVswXSwgcmlnaHQgPSBfYVsxXTtcclxuICAgICAgICB2YXIgbGVmdE9yaWdpbiA9IGNvbnZlcnRUcmFuc2Zvcm1Vbml0KGxlZnQgfHwgXCJcIik7XHJcbiAgICAgICAgdmFyIHJpZ2h0T3JpZ2luID0gY29udmVydFRyYW5zZm9ybVVuaXQocmlnaHQgfHwgXCJcIik7XHJcbiAgICAgICAgdmFyIG9yaWdpbk9iamVjdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBsZWZ0T3JpZ2luKSwgcmlnaHRPcmlnaW4pO1xyXG4gICAgICAgIHZhciBuZXh0T3JpZ2luT2JqZWN0ID0ge1xyXG4gICAgICAgICAgICB4OiBcIjUwJVwiLFxyXG4gICAgICAgICAgICB5OiBcIjUwJVwiLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9yaWdpbk9iamVjdC54KSB7XHJcbiAgICAgICAgICAgIG5leHRPcmlnaW5PYmplY3QueCA9IG9yaWdpbk9iamVjdC54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3JpZ2luT2JqZWN0LnkpIHtcclxuICAgICAgICAgICAgbmV4dE9yaWdpbk9iamVjdC55ID0gb3JpZ2luT2JqZWN0Lnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmlnaW5PYmplY3QudmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKG9yaWdpbk9iamVjdC54ICYmICFvcmlnaW5PYmplY3QueSkge1xyXG4gICAgICAgICAgICAgICAgbmV4dE9yaWdpbk9iamVjdC55ID0gb3JpZ2luT2JqZWN0LnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghb3JpZ2luT2JqZWN0LnggJiYgb3JpZ2luT2JqZWN0LnkpIHtcclxuICAgICAgICAgICAgICAgIG5leHRPcmlnaW5PYmplY3QueCA9IG9yaWdpbk9iamVjdC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dE9yaWdpbk9iamVjdDtcclxuICAgIH1cclxuICAgIGlmIChvcmlnaW4gPT09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogXCIwJVwiIH07XHJcbiAgICB9XHJcbiAgICBpZiAob3JpZ2luID09PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICByZXR1cm4geyB4OiBcIjEwMCVcIiB9O1xyXG4gICAgfVxyXG4gICAgaWYgKG9yaWdpbiA9PT0gXCJ0b3BcIikge1xyXG4gICAgICAgIHJldHVybiB7IHk6IFwiMCVcIiB9O1xyXG4gICAgfVxyXG4gICAgaWYgKG9yaWdpbiA9PT0gXCJib3R0b21cIikge1xyXG4gICAgICAgIHJldHVybiB7IHk6IFwiMTAwJVwiIH07XHJcbiAgICB9XHJcbiAgICBpZiAoIW9yaWdpbikge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIGlmIChvcmlnaW4gPT09IFwiY2VudGVyXCIpIHtcclxuICAgICAgICByZXR1cm4geyB2YWx1ZTogXCI1MCVcIiB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdmFsdWU6IG9yaWdpbiB9O1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1PcmlnaW5BcnJheSh0cmFuc2Zvcm1PcmlnaW4sIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHZhciBfYSA9IGNvbnZlcnRUcmFuc2Zvcm1Vbml0KHRyYW5zZm9ybU9yaWdpbiwgdHJ1ZSksIHggPSBfYS54LCB5ID0gX2EueTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgY29udmVydFVuaXRTaXplKHgsIHdpZHRoKSB8fCAwLFxyXG4gICAgICAgIGNvbnZlcnRVbml0U2l6ZSh5LCBoZWlnaHQpIHx8IDAsXHJcbiAgICBdO1xyXG59XHJcbmZ1bmN0aW9uIHJvdGF0ZVBvc2VzSW5mbyhwb3Nlcywgb3JpZ2luLCByYWQpIHtcclxuICAgIHZhciBwcmV2UG9zZXMgPSBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gbWludXMocG9zLCBvcmlnaW4pOyB9KTtcclxuICAgIHZhciBuZXh0UG9zZXMgPSBwcmV2UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHJvdGF0ZShwb3MsIHJhZCk7IH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcmV2OiBwcmV2UG9zZXMsXHJcbiAgICAgICAgbmV4dDogbmV4dFBvc2VzLFxyXG4gICAgICAgIHJlc3VsdDogbmV4dFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwbHVzKHBvcywgb3JpZ2luKTsgfSksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzRGVlcEFycmF5RXF1YWxzKGFycjEsIGFycjIpIHtcclxuICAgIHJldHVybiBhcnIxLmxlbmd0aCA9PT0gYXJyMi5sZW5ndGggJiYgYXJyMS5ldmVyeShmdW5jdGlvbiAodmFsdWUxLCBpKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlMiA9IGFycjJbaV07XHJcbiAgICAgICAgdmFyIGlzQXJyYXkxID0gaXNBcnJheSh2YWx1ZTEpO1xyXG4gICAgICAgIHZhciBpc0FycmF5MiA9IGlzQXJyYXkodmFsdWUyKTtcclxuICAgICAgICBpZiAoaXNBcnJheTEgJiYgaXNBcnJheTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzRGVlcEFycmF5RXF1YWxzKHZhbHVlMSwgdmFsdWUyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXkxICYmICFpc0FycmF5Mikge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoVmFsdWUobW92ZWFibGUsIHByb3BlcnR5LCBuZXh0VmFsdWUsIHZhbHVlS2V5LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIHZhciBzdG9yZSA9IG1vdmVhYmxlLl9zdG9yZTtcclxuICAgIHZhciBwcmV2VmFsdWUgPSBzdG9yZVtwcm9wZXJ0eV07XHJcbiAgICBpZiAoIShwcm9wZXJ0eSBpbiBzdG9yZSkpIHtcclxuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc3RvcmVbcHJvcGVydHldID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICBwcmV2VmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdG9yZVtwcm9wZXJ0eV0gPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByZXZWYWx1ZSA9PT0gbmV4dFZhbHVlIHx8IHZhbHVlS2V5KHByZXZWYWx1ZSkgPT09IHZhbHVlS2V5KG5leHRWYWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcHJldlZhbHVlO1xyXG4gICAgfVxyXG4gICAgc3RvcmVbcHJvcGVydHldID0gbmV4dFZhbHVlO1xyXG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcclxufVxyXG5mdW5jdGlvbiBzaWduKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPj0gMCA/IDEgOiAtMTtcclxufVxyXG5mdW5jdGlvbiBhYnModmFsdWUpIHtcclxuICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY291bnRFYWNoKGNvdW50LCBjYWxsYmFjaykge1xyXG4gICAgcmV0dXJuIGNvdW50ZXIoY291bnQpLm1hcChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGNhbGxiYWNrKGluZGV4KTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGFkZGluZ0JveChwYWRkaW5nKSB7XHJcbiAgICBpZiAoaXNOdW1iZXIocGFkZGluZykpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b3A6IHBhZGRpbmcsXHJcbiAgICAgICAgICAgIGxlZnQ6IHBhZGRpbmcsXHJcbiAgICAgICAgICAgIHJpZ2h0OiBwYWRkaW5nLFxyXG4gICAgICAgICAgICBib3R0b206IHBhZGRpbmcsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogcGFkZGluZy5sZWZ0IHx8IDAsXHJcbiAgICAgICAgdG9wOiBwYWRkaW5nLnRvcCB8fCAwLFxyXG4gICAgICAgIHJpZ2h0OiBwYWRkaW5nLnJpZ2h0IHx8IDAsXHJcbiAgICAgICAgYm90dG9tOiBwYWRkaW5nLmJvdHRvbSB8fCAwLFxyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5QaW5jaGFibGVcclxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgcGluY2hlZCB3aXRoIGRyYWdnYWJsZSwgcmVzaXphYmxlLCBzY2FsYWJsZSwgcm90YXRhYmxlIChkZWZhdWx0OiBmYWxzZSlcclxuICovXHJcbnZhciBQaW5jaGFibGUgPSBtYWtlQWJsZShcInBpbmNoYWJsZVwiLCB7XHJcbiAgICBwcm9wczogW1xyXG4gICAgICAgIFwicGluY2hhYmxlXCIsXHJcbiAgICBdLFxyXG4gICAgZXZlbnRzOiBbXHJcbiAgICAgICAgXCJwaW5jaFN0YXJ0XCIsXHJcbiAgICAgICAgXCJwaW5jaFwiLFxyXG4gICAgICAgIFwicGluY2hFbmRcIixcclxuICAgICAgICBcInBpbmNoR3JvdXBTdGFydFwiLFxyXG4gICAgICAgIFwicGluY2hHcm91cFwiLFxyXG4gICAgICAgIFwicGluY2hHcm91cEVuZFwiLFxyXG4gICAgXSxcclxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIHBpbmNoU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsIHRhcmdldHMgPSBlLnRhcmdldHMsIGFuZ2xlID0gZS5hbmdsZSwgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcztcclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgcGluY2hhYmxlID0gX2EucGluY2hhYmxlLCBhYmxlcyA9IF9hLmFibGVzO1xyXG4gICAgICAgIGlmICghcGluY2hhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IFwib25QaW5jaFwiLmNvbmNhdCh0YXJnZXRzID8gXCJHcm91cFwiIDogXCJcIiwgXCJTdGFydFwiKTtcclxuICAgICAgICB2YXIgY29udHJvbEV2ZW50TmFtZSA9IFwiZHJhZ1wiLmNvbmNhdCh0YXJnZXRzID8gXCJHcm91cFwiIDogXCJcIiwgXCJDb250cm9sU3RhcnRcIik7XHJcbiAgICAgICAgdmFyIHBpbmNoQWJsZXMgPSAocGluY2hhYmxlID09PSB0cnVlID8gbW92ZWFibGUuY29udHJvbEFibGVzIDogYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwaW5jaGFibGUuaW5kZXhPZihhYmxlLm5hbWUpID4gLTE7XHJcbiAgICAgICAgfSkpLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkgeyByZXR1cm4gYWJsZS5jYW5QaW5jaCAmJiBhYmxlW2NvbnRyb2xFdmVudE5hbWVdOyB9KTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xyXG4gICAgICAgIGlmICh0YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy50YXJnZXRzID0gdGFyZ2V0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgZXZlbnROYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgIGRhdGFzLmlzUGluY2ggPSByZXN1bHQgIT09IGZhbHNlO1xyXG4gICAgICAgIGRhdGFzLmFibGVzID0gcGluY2hBYmxlcztcclxuICAgICAgICB2YXIgaXNQaW5jaCA9IGRhdGFzLmlzUGluY2g7XHJcbiAgICAgICAgaWYgKCFpc1BpbmNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGluY2hBYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRGF0YXNbYWJsZS5uYW1lXSA9IG9yaWdpbmFsRGF0YXNbYWJsZS5uYW1lXSB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKCFhYmxlW2NvbnRyb2xFdmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFibGVFdmVudCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBkYXRhczogb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdLCBwYXJlbnRSb3RhdGU6IGFuZ2xlLCBpc1BpbmNoOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBhYmxlW2NvbnRyb2xFdmVudE5hbWVdKG1vdmVhYmxlLCBhYmxlRXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xyXG4gICAgICAgICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdCxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiBbMCwgMF0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gaXNQaW5jaDtcclxuICAgIH0sXHJcbiAgICBwaW5jaDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgcGluY2hTY2FsZSA9IGUuc2NhbGUsIGRpc3RhbmNlID0gZS5kaXN0YW5jZSwgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcywgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudCwgdGFyZ2V0cyA9IGUudGFyZ2V0cywgYW5nbGUgPSBlLmFuZ2xlO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNQaW5jaCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJlbnREaXN0YW5jZSA9IGRpc3RhbmNlICogKDEgLSAxIC8gcGluY2hTY2FsZSk7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHt9KTtcclxuICAgICAgICBpZiAodGFyZ2V0cykge1xyXG4gICAgICAgICAgICBwYXJhbXMudGFyZ2V0cyA9IHRhcmdldHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBldmVudE5hbWUgPSBcIm9uUGluY2hcIi5jb25jYXQodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgZXZlbnROYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgIHZhciBhYmxlcyA9IGRhdGFzLmFibGVzO1xyXG4gICAgICAgIHZhciBjb250cm9sRXZlbnROYW1lID0gXCJkcmFnXCIuY29uY2F0KHRhcmdldHMgPyBcIkdyb3VwXCIgOiBcIlwiLCBcIkNvbnRyb2xcIik7XHJcbiAgICAgICAgYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoIWFibGVbY29udHJvbEV2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhYmxlW2NvbnRyb2xFdmVudE5hbWVdKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgZGF0YXM6IG9yaWdpbmFsRGF0YXNbYWJsZS5uYW1lXSwgaW5wdXRFdmVudDogaW5wdXRFdmVudCwgcmVzb2x2ZU1hdHJpeDogdHJ1ZSwgcGluY2hTY2FsZTogcGluY2hTY2FsZSwgcGFyZW50RGlzdGFuY2U6IHBhcmVudERpc3RhbmNlLCBwYXJlbnRSb3RhdGU6IGFuZ2xlLCBpc1BpbmNoOiB0cnVlIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfSxcclxuICAgIHBpbmNoRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBpc1BpbmNoID0gZS5pc1BpbmNoLCBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LCB0YXJnZXRzID0gZS50YXJnZXRzLCBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNQaW5jaCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBldmVudE5hbWUgPSBcIm9uUGluY2hcIi5jb25jYXQodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIsIFwiRW5kXCIpO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7IGlzRHJhZzogaXNQaW5jaCB9KTtcclxuICAgICAgICBpZiAodGFyZ2V0cykge1xyXG4gICAgICAgICAgICBwYXJhbXMudGFyZ2V0cyA9IHRhcmdldHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgZXZlbnROYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgIHZhciBhYmxlcyA9IGRhdGFzLmFibGVzO1xyXG4gICAgICAgIHZhciBjb250cm9sRXZlbnROYW1lID0gXCJkcmFnXCIuY29uY2F0KHRhcmdldHMgPyBcIkdyb3VwXCIgOiBcIlwiLCBcIkNvbnRyb2xFbmRcIik7XHJcbiAgICAgICAgYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoIWFibGVbY29udHJvbEV2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhYmxlW2NvbnRyb2xFdmVudE5hbWVdKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgaXNEcmFnOiBpc1BpbmNoLCBkYXRhczogb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdLCBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50LCBpc1BpbmNoOiB0cnVlIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXNQaW5jaDtcclxuICAgIH0sXHJcbiAgICBwaW5jaEdyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpbmNoU3RhcnQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzIH0pKTtcclxuICAgIH0sXHJcbiAgICBwaW5jaEdyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5waW5jaChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMgfSkpO1xyXG4gICAgfSxcclxuICAgIHBpbmNoR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpbmNoRW5kKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyB9KSk7XHJcbiAgICB9LFxyXG59KTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgcGluY2hlZCB3aXRoIGRyYWdnYWJsZSwgcmVzaXphYmxlLCBzY2FsYWJsZSwgcm90YXRhYmxlIChkZWZhdWx0OiBmYWxzZSlcclxuICogQG5hbWUgTW92ZWFibGUuUGluY2hhYmxlI3BpbmNoYWJsZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5waW5jaGFibGUgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gdGhlIHBpbmNoIHN0YXJ0cywgdGhlIHBpbmNoU3RhcnQgZXZlbnQgaXMgY2FsbGVkIHdpdGggcGFydCBvZiBzY2FsZVN0YXJ0LCByb3RhdGVTdGFydCwgcmVzaXplU3RhcnRcclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxyXG4gKiBAZXZlbnQgcGluY2hTdGFydFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNoU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHBpbmNoU3RhcnQgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3RhdGFibGU6IHRydWUsXHJcbiAqICAgICBzY2FsYWJsZTogdHJ1ZSxcclxuICogICAgIHBpbmNoYWJsZTogdHJ1ZSwgLy8gW1wicm90YXRhYmxlXCIsIFwic2NhbGFibGVcIl1cclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gcGluY2hpbmcsIHRoZSBwaW5jaCBldmVudCBpcyBjYWxsZWQgd2l0aCBwYXJ0IG9mIHNjYWxlLCByb3RhdGUsIHJlc2l6ZVxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUGluY2hhYmxlXHJcbiAqIEBldmVudCBwaW5jaFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNofSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBwaW5jaCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHJvdGF0YWJsZTogdHJ1ZSxcclxuICogICAgIHNjYWxhYmxlOiB0cnVlLFxyXG4gKiAgICAgcGluY2hhYmxlOiB0cnVlLCAvLyBbXCJyb3RhdGFibGVcIiwgXCJzY2FsYWJsZVwiXVxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJwaW5jaFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlXCIsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJzY2FsZVwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgcGluY2ggZmluaXNoZXMsIHRoZSBwaW5jaEVuZCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5QaW5jaGFibGVcclxuICogQGV2ZW50IHBpbmNoRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2hFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHBpbmNoRW5kIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgcm90YXRhYmxlOiB0cnVlLFxyXG4gKiAgICAgc2NhbGFibGU6IHRydWUsXHJcbiAqICAgICBwaW5jaGFibGU6IHRydWUsIC8vIFtcInJvdGF0YWJsZVwiLCBcInNjYWxhYmxlXCJdXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInBpbmNoRW5kXCIsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyb3RhdGVFbmRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlRW5kXCIsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBncm91cCBwaW5jaCBzdGFydHMsIHRoZSBgcGluY2hHcm91cFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5QaW5jaGFibGVcclxuICogQGV2ZW50IHBpbmNoR3JvdXBTdGFydFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNoR3JvdXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHBpbmNoR3JvdXBTdGFydGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4gKiAgICAgcGluY2hhYmxlOiB0cnVlXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInBpbmNoR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25QaW5jaEdyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gdGhlIGdyb3VwIHBpbmNoLCB0aGUgYHBpbmNoR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxyXG4gKiBAZXZlbnQgcGluY2hHcm91cFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNoR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBwaW5jaEdyb3VwYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiAqICAgICBwaW5jaGFibGU6IHRydWVcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hHcm91cFwiLCAoeyB0YXJnZXRzLCBldmVudHMgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJvblBpbmNoR3JvdXBcIiwgdGFyZ2V0cyk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gdGhlIGdyb3VwIHBpbmNoIGZpbmlzaGVzLCB0aGUgYHBpbmNoR3JvdXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxyXG4gKiBAZXZlbnQgcGluY2hHcm91cEVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNoR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBwaW5jaEdyb3VwRW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiAqICAgICBwaW5jaGFibGU6IHRydWVcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hHcm91cEVuZFwiLCAoeyB0YXJnZXRzLCBpc0RyYWcgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJvblBpbmNoR3JvdXBFbmRcIiwgdGFyZ2V0cywgaXNEcmFnKTtcclxuICogfSk7XHJcbiAqL1xuXG52YXIgZGlyZWN0aW9uQ29uZGl0aW9uID0gZ2V0RGlyZWN0aW9uQ29uZGl0aW9uKFwic2NhbGFibGVcIik7XHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIFNjYWxhYmxlXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxyXG4gKiBAZGVzY3JpcHRpb24gU2NhbGFibGUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRhcmdldCdzIHggYW5kIHkgY2FuIGJlIHNjYWxlIG9mIHRyYW5zZm9ybS5cclxuICovXHJcbnZhciBTY2FsYWJsZSA9IHtcclxuICAgIG5hbWU6IFwic2NhbGFibGVcIixcclxuICAgIGFibGVHcm91cDogXCJzaXplXCIsXHJcbiAgICBjYW5QaW5jaDogdHJ1ZSxcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJzY2FsYWJsZVwiLFxyXG4gICAgICAgIFwidGhyb3R0bGVTY2FsZVwiLFxyXG4gICAgICAgIFwicmVuZGVyRGlyZWN0aW9uc1wiLFxyXG4gICAgICAgIFwia2VlcFJhdGlvXCIsXHJcbiAgICAgICAgXCJlZGdlXCIsXHJcbiAgICAgICAgXCJkaXNwbGF5QXJvdW5kQ29udHJvbHNcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcInNjYWxlU3RhcnRcIixcclxuICAgICAgICBcImJlZm9yZVNjYWxlXCIsXHJcbiAgICAgICAgXCJzY2FsZVwiLFxyXG4gICAgICAgIFwic2NhbGVFbmRcIixcclxuICAgICAgICBcInNjYWxlR3JvdXBTdGFydFwiLFxyXG4gICAgICAgIFwiYmVmb3JlU2NhbGVHcm91cFwiLFxyXG4gICAgICAgIFwic2NhbGVHcm91cFwiLFxyXG4gICAgICAgIFwic2NhbGVHcm91cEVuZFwiLFxyXG4gICAgXSxcclxuICAgIHJlbmRlcjogZ2V0UmVuZGVyRGlyZWN0aW9ucyhcInNjYWxhYmxlXCIpLFxyXG4gICAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGRpcmVjdGlvbkNvbmRpdGlvbixcclxuICAgIHZpZXdDbGFzc05hbWU6IGdldERpcmVjdGlvblZpZXdDbGFzc05hbWUoXCJzY2FsYWJsZVwiKSxcclxuICAgIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsIGlzUGluY2ggPSBlLmlzUGluY2gsIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsIHBhcmVudERpcmVjdGlvbiA9IGUucGFyZW50RGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBnZXRUb3RhbERpcmVjdGlvbihwYXJlbnREaXJlY3Rpb24sIGlzUGluY2gsIGlucHV0RXZlbnQsIGRhdGFzKTtcclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCB0YXJnZXRUcmFuc2Zvcm0gPSBfYS50YXJnZXRUcmFuc2Zvcm0sIHRhcmdldCA9IF9hLnRhcmdldCwgcG9zMSA9IF9hLnBvczEsIHBvczIgPSBfYS5wb3MyLCBwb3M0ID0gX2EucG9zNDtcclxuICAgICAgICBpZiAoIWRpcmVjdGlvbiB8fCAhdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1BpbmNoKSB7XHJcbiAgICAgICAgICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFzLmRhdGFzID0ge307XHJcbiAgICAgICAgZGF0YXMudHJhbnNmb3JtID0gdGFyZ2V0VHJhbnNmb3JtO1xyXG4gICAgICAgIGRhdGFzLnByZXZEaXN0ID0gWzEsIDFdO1xyXG4gICAgICAgIGRhdGFzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgICAgICBkYXRhcy5zdGFydE9mZnNldFdpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgZGF0YXMuc3RhcnRWYWx1ZSA9IFsxLCAxXTtcclxuICAgICAgICAvLyBjb25zdCBzY2FsZVdpZHRoID0gZ2V0RGlzdChwb3MxLCBwb3MyKTtcclxuICAgICAgICAvLyBjb25zdCBzY2FsZUhlaWdodCA9IGdldERpc3QocG9zMiwgcG9zNCk7XHJcbiAgICAgICAgdmFyIGlzV2lkdGggPSAoIWRpcmVjdGlvblswXSAmJiAhZGlyZWN0aW9uWzFdKSB8fCBkaXJlY3Rpb25bMF0gfHwgIWRpcmVjdGlvblsxXTtcclxuICAgICAgICAvLyBkYXRhcy5zY2FsZVdpZHRoID0gc2NhbGVXaWR0aDtcclxuICAgICAgICAvLyBkYXRhcy5zY2FsZUhlaWdodCA9IHNjYWxlSGVpZ2h0O1xyXG4gICAgICAgIC8vIGRhdGFzLnNjYWxlWFJhdGlvID0gc2NhbGVXaWR0aCAvIHdpZHRoO1xyXG4gICAgICAgIC8vIGRhdGFzLnNjYWxlWVJhdGlvID0gc2NhbGVIZWlnaHQgLyBoZWlnaHQ7XHJcbiAgICAgICAgc2V0RGVmYXVsdFRyYW5zZm9ybUluZGV4KG1vdmVhYmxlLCBlLCBcInNjYWxlXCIpO1xyXG4gICAgICAgIGRhdGFzLmlzV2lkdGggPSBpc1dpZHRoO1xyXG4gICAgICAgIGZ1bmN0aW9uIHNldFJhdGlvKHJhdGlvKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLnJhdGlvID0gcmF0aW8gJiYgaXNGaW5pdGUocmF0aW8pID8gcmF0aW8gOiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhcy5zdGFydFBvc2l0aW9ucyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKTtcclxuICAgICAgICBmdW5jdGlvbiBzZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0Rml4ZWREaXJlY3Rpb25JbmZvKGRhdGFzLnN0YXJ0UG9zaXRpb25zLCBmaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkRGlyZWN0aW9uID0gcmVzdWx0LmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBkYXRhcy5maXhlZFBvc2l0aW9uID0gcmVzdWx0LmZpeGVkUG9zaXRpb247XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkT2Zmc2V0ID0gcmVzdWx0LmZpeGVkT2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhcy5zZXRGaXhlZERpcmVjdGlvbiA9IHNldEZpeGVkRGlyZWN0aW9uO1xyXG4gICAgICAgIHNldFJhdGlvKGdldERpc3QkMShwb3MxLCBwb3MyKSAvIGdldERpc3QkMShwb3MyLCBwb3M0KSk7XHJcbiAgICAgICAgc2V0Rml4ZWREaXJlY3Rpb24oWy1kaXJlY3Rpb25bMF0sIC1kaXJlY3Rpb25bMV1dKTtcclxuICAgICAgICB2YXIgc2V0TWluU2NhbGVTaXplID0gZnVuY3Rpb24gKG1pbikge1xyXG4gICAgICAgICAgICBkYXRhcy5taW5TY2FsZVNpemUgPSBtaW47XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc2V0TWF4U2NhbGVTaXplID0gZnVuY3Rpb24gKG1heCkge1xyXG4gICAgICAgICAgICBkYXRhcy5tYXhTY2FsZVNpemUgPSBtYXg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjb25zdCBzZXRNaW5TY2FsZSA9IChtaW46IG51bWJlcltdKSA9PiB7XHJcbiAgICAgICAgLy8gfTtcclxuICAgICAgICAvLyBjb25zdCBzZXRNYXhTY2FsZSA9IChtYXg6IG51bWJlcltdKSA9PiB7XHJcbiAgICAgICAgLy8gfTtcclxuICAgICAgICBzZXRNaW5TY2FsZVNpemUoWy1JbmZpbml0eSwgLUluZmluaXR5XSk7XHJcbiAgICAgICAgc2V0TWF4U2NhbGVTaXplKFtJbmZpbml0eSwgSW5maW5pdHldKTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oX19hc3NpZ24oeyBkaXJlY3Rpb246IGRpcmVjdGlvbiwgc2V0OiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSBzY2FsZTtcclxuICAgICAgICAgICAgfSwgc2V0UmF0aW86IHNldFJhdGlvLCBzZXRGaXhlZERpcmVjdGlvbjogc2V0Rml4ZWREaXJlY3Rpb24sIHNldE1pblNjYWxlU2l6ZTogc2V0TWluU2NhbGVTaXplLCBzZXRNYXhTY2FsZVNpemU6IHNldE1heFNjYWxlU2l6ZSB9LCBmaWxsVHJhbnNmb3JtU3RhcnRFdmVudChtb3ZlYWJsZSwgZSkpLCB7IGRyYWdTdGFydDogRHJhZ2dhYmxlLmRyYWdTdGFydChtb3ZlYWJsZSwgbmV3IEN1c3RvbUdlc3RvKCkuZHJhZ1N0YXJ0KFswLCAwXSwgZSkpIH0pKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uU2NhbGVTdGFydFwiLCBwYXJhbXMpO1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0Rml4ZWREaXJlY3Rpb24gPSBkYXRhcy5maXhlZERpcmVjdGlvbjtcclxuICAgICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBkYXRhcy5pc1NjYWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YXMuaXNTY2FsZSA/IHBhcmFtcyA6IGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXNvbHZlVHJhbnNmb3JtRXZlbnQobW92ZWFibGUsIGUsIFwic2NhbGVcIik7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgcGFyZW50S2VlcFJhdGlvID0gZS5wYXJlbnRLZWVwUmF0aW8sIHBhcmVudEZsYWcgPSBlLnBhcmVudEZsYWcsIGlzUGluY2ggPSBlLmlzUGluY2gsIGRyYWdDbGllbnQgPSBlLmRyYWdDbGllbnQsIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0LCB1c2VTbmFwID0gZS51c2VTbmFwLCByZXNvbHZlTWF0cml4ID0gZS5yZXNvbHZlTWF0cml4O1xyXG4gICAgICAgIHZhciBwcmV2RGlzdCA9IGRhdGFzLnByZXZEaXN0LCBkaXJlY3Rpb24gPSBkYXRhcy5kaXJlY3Rpb24sIHN0YXJ0T2Zmc2V0V2lkdGggPSBkYXRhcy5zdGFydE9mZnNldFdpZHRoLCBzdGFydE9mZnNldEhlaWdodCA9IGRhdGFzLnN0YXJ0T2Zmc2V0SGVpZ2h0LCBpc1NjYWxlID0gZGF0YXMuaXNTY2FsZSwgc3RhcnRWYWx1ZSA9IGRhdGFzLnN0YXJ0VmFsdWUsIGlzV2lkdGggPSBkYXRhcy5pc1dpZHRoLCByYXRpbyA9IGRhdGFzLnJhdGlvO1xyXG4gICAgICAgIGlmICghaXNTY2FsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xyXG4gICAgICAgIHZhciB0aHJvdHRsZVNjYWxlID0gcHJvcHMudGhyb3R0bGVTY2FsZSwgcGFyZW50TW92ZWFibGUgPSBwcm9wcy5wYXJlbnRNb3ZlYWJsZTtcclxuICAgICAgICB2YXIgc2l6ZURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgICAgICBpZiAoIWRpcmVjdGlvblswXSAmJiAhZGlyZWN0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgIHNpemVEaXJlY3Rpb24gPSBbMSwgMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrZWVwUmF0aW8gPSAocmF0aW8gJiYgKHBhcmVudEtlZXBSYXRpbyAhPSBudWxsID8gcGFyZW50S2VlcFJhdGlvIDogcHJvcHMua2VlcFJhdGlvKSkgfHwgZmFsc2U7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgdmFyIHRlbXBTY2FsZVZhbHVlID0gW1xyXG4gICAgICAgICAgICBzdGFydFZhbHVlWzBdLFxyXG4gICAgICAgICAgICBzdGFydFZhbHVlWzFdLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0TmV4dFNjYWxlKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRPZmZzZXRTaXplRGlzdChzaXplRGlyZWN0aW9uLCBrZWVwUmF0aW8sIGRhdGFzLCBlKSwgZGlzdFdpZHRoID0gX2EuZGlzdFdpZHRoLCBkaXN0SGVpZ2h0ID0gX2EuZGlzdEhlaWdodDtcclxuICAgICAgICAgICAgdmFyIGRpc3RYID0gc3RhcnRPZmZzZXRXaWR0aCA/IChzdGFydE9mZnNldFdpZHRoICsgZGlzdFdpZHRoKSAvIHN0YXJ0T2Zmc2V0V2lkdGggOiAxO1xyXG4gICAgICAgICAgICB2YXIgZGlzdFkgPSBzdGFydE9mZnNldEhlaWdodCA/IChzdGFydE9mZnNldEhlaWdodCArIGRpc3RIZWlnaHQpIC8gc3RhcnRPZmZzZXRIZWlnaHQgOiAxO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0VmFsdWVbMF0pIHtcclxuICAgICAgICAgICAgICAgIHRlbXBTY2FsZVZhbHVlWzBdID0gZGlzdFdpZHRoIC8gc3RhcnRPZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0VmFsdWVbMV0pIHtcclxuICAgICAgICAgICAgICAgIHRlbXBTY2FsZVZhbHVlWzFdID0gZGlzdEhlaWdodCAvIHN0YXJ0T2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVggPSAoc2l6ZURpcmVjdGlvblswXSB8fCBrZWVwUmF0aW8gPyBkaXN0WCA6IDEpICogdGVtcFNjYWxlVmFsdWVbMF07XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVkgPSAoc2l6ZURpcmVjdGlvblsxXSB8fCBrZWVwUmF0aW8gPyBkaXN0WSA6IDEpICogdGVtcFNjYWxlVmFsdWVbMV07XHJcbiAgICAgICAgICAgIGlmIChzY2FsZVggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlWCA9IHNpZ24ocHJldkRpc3RbMF0pICogTUlOX1NDQUxFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzY2FsZVkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlWSA9IHNpZ24ocHJldkRpc3RbMV0pICogTUlOX1NDQUxFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbc2NhbGVYLCBzY2FsZVldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2NhbGUgPSBnZXROZXh0U2NhbGUoKTtcclxuICAgICAgICBpZiAoIWlzUGluY2ggJiYgbW92ZWFibGUucHJvcHMuZ3JvdXBhYmxlKSB7XHJcbiAgICAgICAgICAgIHZhciBzbmFwUmVuZGVySW5mbyA9IHN0YXRlLnNuYXBSZW5kZXJJbmZvIHx8IHt9O1xyXG4gICAgICAgICAgICB2YXIgc3RhdGVEaXJlY3Rpb24gPSBzbmFwUmVuZGVySW5mby5kaXJlY3Rpb247XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHN0YXRlRGlyZWN0aW9uKSAmJiAoc3RhdGVEaXJlY3Rpb25bMF0gfHwgc3RhdGVEaXJlY3Rpb25bMV0pKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHsgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlU2NhbGVcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgICAgICAgIHNldEZpeGVkRGlyZWN0aW9uOiBmdW5jdGlvbiAobmV4dEZpeGVkRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhcy5zZXRGaXhlZERpcmVjdGlvbihuZXh0Rml4ZWREaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgc2NhbGUgPSBnZXROZXh0U2NhbGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3RhcnRGaXhlZERpcmVjdGlvbjogZGF0YXMuc3RhcnRGaXhlZERpcmVjdGlvbixcclxuICAgICAgICAgICAgc2V0U2NhbGU6IGZ1bmN0aW9uIChuZXh0U2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlID0gbmV4dFNjYWxlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sIHRydWUpKTtcclxuICAgICAgICB2YXIgZGlzdCA9IFtcclxuICAgICAgICAgICAgc2NhbGVbMF0gLyB0ZW1wU2NhbGVWYWx1ZVswXSxcclxuICAgICAgICAgICAgc2NhbGVbMV0gLyB0ZW1wU2NhbGVWYWx1ZVsxXSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBmaXhlZFBvc2l0aW9uID0gZHJhZ0NsaWVudDtcclxuICAgICAgICB2YXIgc25hcERpc3QgPSBbMCwgMF07XHJcbiAgICAgICAgdmFyIGRpc3RTaWduID0gc2lnbihkaXN0WzBdICogZGlzdFsxXSk7XHJcbiAgICAgICAgdmFyIGlzU2VsZlBpbmNoID0gIWRyYWdDbGllbnQgJiYgIXBhcmVudEZsYWcgJiYgaXNQaW5jaDtcclxuICAgICAgICBpZiAoaXNTZWxmUGluY2ggfHwgcmVzb2x2ZU1hdHJpeCkge1xyXG4gICAgICAgICAgICBmaXhlZFBvc2l0aW9uID0gZ2V0VHJhbnNsYXRlRml4ZWRQb3NpdGlvbihtb3ZlYWJsZSwgZGF0YXMudGFyZ2V0QWxsVHJhbnNmb3JtLCBbMCwgMF0sIFswLCAwXSwgZGF0YXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghZHJhZ0NsaWVudCkge1xyXG4gICAgICAgICAgICBmaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1BpbmNoKSB7XHJcbiAgICAgICAgICAgIHNuYXBEaXN0ID0gY2hlY2tTbmFwU2NhbGUobW92ZWFibGUsIGRpc3QsIGRpcmVjdGlvbiwgIXVzZVNuYXAgJiYgaXNSZXF1ZXN0LCBkYXRhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZWVwUmF0aW8pIHtcclxuICAgICAgICAgICAgaWYgKHNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSAmJiBzbmFwRGlzdFswXSAmJiBzbmFwRGlzdFsxXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNuYXBEaXN0WzBdICogc3RhcnRPZmZzZXRXaWR0aCkgPiBNYXRoLmFicyhzbmFwRGlzdFsxXSAqIHN0YXJ0T2Zmc2V0SGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNuYXBEaXN0WzFdID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNuYXBEaXN0WzBdID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNOb1NuYXAgPSAhc25hcERpc3RbMF0gJiYgIXNuYXBEaXN0WzFdO1xyXG4gICAgICAgICAgICBpZiAoaXNOb1NuYXApIHtcclxuICAgICAgICAgICAgICAgIC8vIHRocm90dGxlIHNjYWxlIHZhbHVlIChub3QgYWJzb2x1dGUgc2NhbGUgc2l6ZSlcclxuICAgICAgICAgICAgICAgIGlmIChpc1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFswXSA9IHRocm90dGxlKGRpc3RbMF0gKiB0ZW1wU2NhbGVWYWx1ZVswXSwgdGhyb3R0bGVTY2FsZSkgLyB0ZW1wU2NhbGVWYWx1ZVswXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RbMV0gPSB0aHJvdHRsZShkaXN0WzFdICogdGVtcFNjYWxlVmFsdWVbMV0sIHRocm90dGxlU2NhbGUpIC8gdGVtcFNjYWxlVmFsdWVbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChzaXplRGlyZWN0aW9uWzBdICYmICFzaXplRGlyZWN0aW9uWzFdKVxyXG4gICAgICAgICAgICAgICAgfHwgKHNuYXBEaXN0WzBdICYmICFzbmFwRGlzdFsxXSlcclxuICAgICAgICAgICAgICAgIHx8IChpc05vU25hcCAmJiBpc1dpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgZGlzdFswXSArPSBzbmFwRGlzdFswXTtcclxuICAgICAgICAgICAgICAgIHZhciBzbmFwSGVpZ2h0ID0gc3RhcnRPZmZzZXRXaWR0aCAqIGRpc3RbMF0gKiB0ZW1wU2NhbGVWYWx1ZVswXSAvIHJhdGlvO1xyXG4gICAgICAgICAgICAgICAgZGlzdFsxXSA9IHNpZ24oZGlzdFNpZ24gKiBkaXN0WzBdKSAqIGFicyhzbmFwSGVpZ2h0IC8gc3RhcnRPZmZzZXRIZWlnaHQgLyB0ZW1wU2NhbGVWYWx1ZVsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKCFzaXplRGlyZWN0aW9uWzBdICYmIHNpemVEaXJlY3Rpb25bMV0pXHJcbiAgICAgICAgICAgICAgICB8fCAoIXNuYXBEaXN0WzBdICYmIHNuYXBEaXN0WzFdKVxyXG4gICAgICAgICAgICAgICAgfHwgKGlzTm9TbmFwICYmICFpc1dpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgZGlzdFsxXSArPSBzbmFwRGlzdFsxXTtcclxuICAgICAgICAgICAgICAgIHZhciBzbmFwV2lkdGggPSBzdGFydE9mZnNldEhlaWdodCAqIGRpc3RbMV0gKiB0ZW1wU2NhbGVWYWx1ZVsxXSAqIHJhdGlvO1xyXG4gICAgICAgICAgICAgICAgZGlzdFswXSA9IHNpZ24oZGlzdFNpZ24gKiBkaXN0WzFdKSAqIGFicyhzbmFwV2lkdGggLyBzdGFydE9mZnNldFdpZHRoIC8gdGVtcFNjYWxlVmFsdWVbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkaXN0WzBdICs9IHNuYXBEaXN0WzBdO1xyXG4gICAgICAgICAgICBkaXN0WzFdICs9IHNuYXBEaXN0WzFdO1xyXG4gICAgICAgICAgICBpZiAoIXNuYXBEaXN0WzBdKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0WzBdID0gdGhyb3R0bGUoZGlzdFswXSAqIHRlbXBTY2FsZVZhbHVlWzBdLCB0aHJvdHRsZVNjYWxlKSAvIHRlbXBTY2FsZVZhbHVlWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc25hcERpc3RbMV0pIHtcclxuICAgICAgICAgICAgICAgIGRpc3RbMV0gPSB0aHJvdHRsZShkaXN0WzFdICogdGVtcFNjYWxlVmFsdWVbMV0sIHRocm90dGxlU2NhbGUpIC8gdGVtcFNjYWxlVmFsdWVbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpc3RbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgZGlzdFswXSA9IHNpZ24ocHJldkRpc3RbMF0pICogTUlOX1NDQUxFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzdFsxXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaXN0WzFdID0gc2lnbihwcmV2RGlzdFsxXSkgKiBNSU5fU0NBTEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjYWxlID0gbXVsdGlwbHkyKGRpc3QsIFt0ZW1wU2NhbGVWYWx1ZVswXSwgdGVtcFNjYWxlVmFsdWVbMV1dKTtcclxuICAgICAgICB2YXIgc3RhcnRPZmZzZXRTaXplID0gW1xyXG4gICAgICAgICAgICBzdGFydE9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICBzdGFydE9mZnNldEhlaWdodCxcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBzY2FsZVNpemUgPSBbXHJcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0V2lkdGggKiBzY2FsZVswXSxcclxuICAgICAgICAgICAgc3RhcnRPZmZzZXRIZWlnaHQgKiBzY2FsZVsxXSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIHNjYWxlU2l6ZSA9IGNhbGN1bGF0ZUJvdW5kU2l6ZShzY2FsZVNpemUsIGRhdGFzLm1pblNjYWxlU2l6ZSwgZGF0YXMubWF4U2NhbGVTaXplLCBrZWVwUmF0aW8gPyByYXRpbyA6IGZhbHNlKTtcclxuICAgICAgICAvLyBpZiAoa2VlcFJhdGlvICYmIChpc0dyb3VwIHx8IGtlZXBSYXRpb0ZpbmFsbHkpKSB7XHJcbiAgICAgICAgLy8gICAgIGlmIChpc1dpZHRoKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBib3VuZGluZ0hlaWdodCA9IGJvdW5kaW5nV2lkdGggLyByYXRpbztcclxuICAgICAgICAvLyAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgICAgIGJvdW5kaW5nV2lkdGggPSBib3VuZGluZ0hlaWdodCAqIHJhdGlvO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIHNjYWxlID0gY291bnRFYWNoKDIsIGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydE9mZnNldFNpemVbaV0gPyBzY2FsZVNpemVbaV0gLyBzdGFydE9mZnNldFNpemVbaV0gOiBzY2FsZVNpemVbaV07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGlzdCA9IGNvdW50RWFjaCgyLCBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2NhbGVbaV0gLyB0ZW1wU2NhbGVWYWx1ZVtpXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgZGVsdGEgPSBjb3VudEVhY2goMiwgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHByZXZEaXN0W2ldID8gZGlzdFtpXSAvIHByZXZEaXN0W2ldIDogZGlzdFtpXTsgfSk7XHJcbiAgICAgICAgdmFyIGRpc3RUZXh0ID0gXCJzY2FsZShcIi5jb25jYXQoZGlzdC5qb2luKFwiLCBcIiksIFwiKVwiKTtcclxuICAgICAgICB2YXIgc2NhbGVUZXh0ID0gXCJzY2FsZShcIi5jb25jYXQoc2NhbGUuam9pbihcIiwgXCIpLCBcIilcIik7XHJcbiAgICAgICAgdmFyIG5leHRUcmFuc2Zvcm0gPSBjb252ZXJ0VHJhbnNmb3JtRm9ybWF0KGRhdGFzLCBzY2FsZVRleHQsIGRpc3RUZXh0KTtcclxuICAgICAgICB2YXIgaXNaZXJvU2NhbGUgPSAhc3RhcnRWYWx1ZVswXSB8fCAhc3RhcnRWYWx1ZVsxXTtcclxuICAgICAgICB2YXIgaW52ZXJzZURpc3QgPSBnZXRTY2FsZURpc3QobW92ZWFibGUsIGlzWmVyb1NjYWxlID8gc2NhbGVUZXh0IDogZGlzdFRleHQsIGRhdGFzLmZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBkYXRhcy5maXhlZE9mZnNldCwgZGF0YXMsIGlzWmVyb1NjYWxlKTtcclxuICAgICAgICB2YXIgaW52ZXJzZURlbHRhID0gaXNTZWxmUGluY2ggPyBpbnZlcnNlRGlzdCA6IG1pbnVzKGludmVyc2VEaXN0LCBkYXRhcy5wcmV2SW52ZXJzZURpc3QgfHwgWzAsIDBdKTtcclxuICAgICAgICBkYXRhcy5wcmV2RGlzdCA9IGRpc3Q7XHJcbiAgICAgICAgZGF0YXMucHJldkludmVyc2VEaXN0ID0gaW52ZXJzZURpc3Q7XHJcbiAgICAgICAgaWYgKHNjYWxlWzBdID09PSBwcmV2RGlzdFswXSAmJiBzY2FsZVsxXSA9PT0gcHJldkRpc3RbMV1cclxuICAgICAgICAgICAgJiYgaW52ZXJzZURlbHRhLmV2ZXJ5KGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuICFudW07IH0pXHJcbiAgICAgICAgICAgICYmICFwYXJlbnRNb3ZlYWJsZVxyXG4gICAgICAgICAgICAmJiAhaXNTZWxmUGluY2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oeyBvZmZzZXRXaWR0aDogc3RhcnRPZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0OiBzdGFydE9mZnNldEhlaWdodCwgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIHNjYWxlOiBzY2FsZSwgZGlzdDogZGlzdCwgZGVsdGE6IGRlbHRhLCBpc1BpbmNoOiAhIWlzUGluY2ggfSwgZmlsbFRyYW5zZm9ybUV2ZW50KG1vdmVhYmxlLCBuZXh0VHJhbnNmb3JtLCBpbnZlcnNlRGVsdGEsIGlzUGluY2gsIGUpKSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uU2NhbGVcIiwgcGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNTY2FsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFzLmlzU2NhbGUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgc2NhbGVFbmRQYXJhbSA9IGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZUVuZFwiLCBzY2FsZUVuZFBhcmFtKTtcclxuICAgICAgICByZXR1cm4gc2NhbGVFbmRQYXJhbTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sQ29uZGl0aW9uOiBkaXJlY3Rpb25Db25kaXRpb24sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2xTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxFdmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwicmVzaXphYmxlXCIsIGUpO1xyXG4gICAgICAgIGRhdGFzLm1vdmVhYmxlU2NhbGUgPSBtb3ZlYWJsZS5zY2FsZTtcclxuICAgICAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xTdGFydFwiLCBlLCBmdW5jdGlvbiAoY2hpbGQsIGV2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydENoaWxkRGlzdChtb3ZlYWJsZSwgY2hpbGQsIGRhdGFzLCBldik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHNldEZpeGVkRGlyZWN0aW9uID0gZnVuY3Rpb24gKGZpeGVkRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5zZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldiwgaSkge1xyXG4gICAgICAgICAgICAgICAgZXYuc2V0Rml4ZWREaXJlY3Rpb24oZml4ZWREaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRDaGlsZERpc3QobW92ZWFibGUsIGV2Lm1vdmVhYmxlLCBkYXRhcywgb3JpZ2luYWxFdmVudHNbaV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGRhdGFzLnNldEZpeGVkRGlyZWN0aW9uID0gc2V0Rml4ZWREaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1zKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50cywgc2V0Rml4ZWREaXJlY3Rpb246IHNldEZpeGVkRGlyZWN0aW9uIH0pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZUdyb3VwU3RhcnRcIiwgbmV4dFBhcmFtcyk7XHJcbiAgICAgICAgZGF0YXMuaXNTY2FsZSA9IHJlc3VsdCAhPT0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGRhdGFzLmlzU2NhbGUgPyBuZXh0UGFyYW1zIDogZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICBpZiAoIWRhdGFzLmlzU2NhbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaEV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlU2NhbGVcIiwgZnVuY3Rpb24gKHBhcmVudEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVNjYWxlR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmVudEV2ZW50KSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzIH0pLCB0cnVlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpc3QgPSBwYXJhbXMuZGlzdDtcclxuICAgICAgICB2YXIgbW92ZWFibGVTY2FsZSA9IGRhdGFzLm1vdmVhYmxlU2NhbGU7XHJcbiAgICAgICAgbW92ZWFibGUuc2NhbGUgPSBbXHJcbiAgICAgICAgICAgIGRpc3RbMF0gKiBtb3ZlYWJsZVNjYWxlWzBdLFxyXG4gICAgICAgICAgICBkaXN0WzFdICogbW92ZWFibGVTY2FsZVsxXSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBrZWVwUmF0aW8gPSBtb3ZlYWJsZS5wcm9wcy5rZWVwUmF0aW87XHJcbiAgICAgICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbFwiLCBlLCBmdW5jdGlvbiAoXywgZXYpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKGNhbGN1bGF0ZShjcmVhdGVSb3RhdGVNYXRyaXgobW92ZWFibGUucm90YXRpb24gLyAxODAgKiBNYXRoLlBJLCAzKSwgW1xyXG4gICAgICAgICAgICAgICAgZXYuZGF0YXMub3JpZ2luYWxYICogZGlzdFswXSxcclxuICAgICAgICAgICAgICAgIGV2LmRhdGFzLm9yaWdpbmFsWSAqIGRpc3RbMV0sXHJcbiAgICAgICAgICAgICAgICAxLFxyXG4gICAgICAgICAgICBdLCAzKSwgMiksIGNsaWVudFggPSBfYVswXSwgY2xpZW50WSA9IF9hWzFdO1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV2KSwgeyBwYXJlbnREaXN0OiBudWxsLCBwYXJlbnRTY2FsZTogZGlzdCwgcGFyZW50S2VlcFJhdGlvOiBrZWVwUmF0aW8sIFxyXG4gICAgICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgY2hpbGQgZml4ZWQgcG9zaXRpb24gZm9yIHBhcmVudCBncm91cCdzIGRyYWdnaW5nLlxyXG4gICAgICAgICAgICAgICAgZHJhZ0NsaWVudDogcGx1cyhmaXhlZFBvc2l0aW9uLCBbY2xpZW50WCwgY2xpZW50WV0pIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50cyB9LCBwYXJhbXMpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlR3JvdXBcIiwgbmV4dFBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5leHRQYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLCBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1NjYWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sRW5kXCIsIGUpO1xyXG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxyXG4gICAgICAgICAgICBldmVudHM6IGV2ZW50cyxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZUdyb3VwRW5kXCIsIG5leHRQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBpc0RyYWc7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlLlNjYWxhYmxlI3JlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuU2NhbGFibGVSZXF1ZXN0UGFyYW19IGUgLSB0aGUgU2NhbGFibGUncyByZXF1ZXN0IHBhcmFtZXRlclxyXG4gICAgICogQHJldHVybiB7TW92ZWFibGUuUmVxdWVzdGVyfSBNb3ZlYWJsZSBSZXF1ZXN0ZXJcclxuICAgICAqIEBleGFtcGxlXHJcblxuICAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcclxuICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJzY2FsYWJsZVwiLCB7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSwgdHJ1ZSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVxdWVzdFN0YXJ0XHJcbiAgICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwic2NhbGFibGVcIik7XHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVxdWVzdFxyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIHJlcXVlc3RFbmRcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0RW5kKCk7XHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSB7fTtcclxuICAgICAgICB2YXIgZGlzdFdpZHRoID0gMDtcclxuICAgICAgICB2YXIgZGlzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgdmFyIHVzZVNuYXAgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc0NvbnRyb2w6IHRydWUsXHJcbiAgICAgICAgICAgIHJlcXVlc3RTdGFydDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHVzZVNuYXAgPSBlLnVzZVNuYXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzOiBkYXRhcyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnREaXJlY3Rpb246IGUuZGlyZWN0aW9uIHx8IFsxLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICB1c2VTbmFwOiB1c2VTbmFwLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGRpc3RXaWR0aCArPSBlLmRlbHRhV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBkaXN0SGVpZ2h0ICs9IGUuZGVsdGFIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzOiBkYXRhcyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnREaXN0OiBbZGlzdFdpZHRoLCBkaXN0SGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRLZWVwUmF0aW86IGUua2VlcFJhdGlvLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZVNuYXA6IHVzZVNuYXAsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhczogZGF0YXMsIGlzRHJhZzogdHJ1ZSwgdXNlU25hcDogdXNlU25hcCB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBzY2FsZWQuXHJcbiAqXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNjYWxhYmxlI3NjYWxhYmxlXHJcbiAqIEBkZWZhdWx0IGZhbHNlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnNjYWxhYmxlID0gdHJ1ZTtcclxuICovXHJcbi8qKlxyXG4gKiB0aHJvdHRsZSBvZiBzY2FsZVgsIHNjYWxlWSB3aGVuIHNjYWxlLlxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY2FsYWJsZSN0aHJvdHRsZVNjYWxlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnRocm90dGxlU2NhbGUgPSAwLjE7XHJcbiAqL1xyXG4vKipcclxuICogU2V0IGRpcmVjdGlvbnMgdG8gc2hvdyB0aGUgY29udHJvbCBib3guIChkZWZhdWx0OiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0pXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNjYWxhYmxlI3JlbmRlckRpcmVjdGlvbnNcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICBzY2FsYWJsZTogdHJ1ZSxcclxuICogICByZW5kZXJEaXJlY3Rpb25zOiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0sXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5yZW5kZXJEaXJlY3Rpb25zID0gW1wibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl07XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiByZXNpemUgb3Igc2NhbGUsIGtlZXBzIGEgcmF0aW8gb2YgdGhlIHdpZHRoLCBoZWlnaHQuIChkZWZhdWx0OiBmYWxzZSlcclxuICogQG5hbWUgTW92ZWFibGUuU2NhbGFibGUja2VlcFJhdGlvXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgc2NhbGFibGU6IHRydWUsXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5rZWVwUmF0aW8gPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gdGhlIHNjYWxlIHN0YXJ0cywgdGhlIHNjYWxlU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2NhbGFibGVcclxuICogQGV2ZW50IHNjYWxlU3RhcnRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5TY2FsYWJsZS5PblNjYWxlU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHNjYWxlU3RhcnQgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHNjYWxhYmxlOiB0cnVlIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gc2NhbGluZywgYGJlZm9yZVNjYWxlYCBpcyBjYWxsZWQgYmVmb3JlIGBzY2FsZWAgb2NjdXJzLiBJbiBgYmVmb3JlU2NhbGVgLCB5b3UgY2FuIGdldCBhbmQgc2V0IHRoZSBwcmUtdmFsdWUgYmVmb3JlIHNjYWxpbmcuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxyXG4gKiBAZXZlbnQgYmVmb3JlU2NhbGVcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5TY2FsYWJsZS5PbkJlZm9yZVNjYWxlfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgYmVmb3JlU2NhbGVgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBzY2FsYWJsZTogdHJ1ZSB9KTtcclxuICogbW92ZWFibGUub24oXCJiZWZvcmVTY2FsZVwiLCAoeyBzZXRGaXhlZERpcmVjdGlvbiB9KSA9PiB7XHJcbiAqICAgICBpZiAoc2hpZnRLZXkpIHtcclxuICogICAgICAgIHNldEZpeGVkRGlyZWN0aW9uKFswLCAwXSk7XHJcbiAqICAgICB9XHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlXCIsICh7IHRhcmdldCwgdHJhbnNmb3JtLCBkaXN0IH0pID0+IHtcclxuICogICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gc2NhbGluZywgdGhlIGBzY2FsZWAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2NhbGFibGVcclxuICogQGV2ZW50IHNjYWxlXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZX0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjYWxlYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgc2NhbGFibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVcIiwgKHsgdGFyZ2V0LCB0cmFuc2Zvcm0sIGRpc3QgfSkgPT4ge1xyXG4gKiAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgc2NhbGUgZmluaXNoZXMsIHRoZSBgc2NhbGVFbmRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXHJcbiAqIEBldmVudCBzY2FsZUVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGVFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBzY2FsZUVuZGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHNjYWxhYmxlOiB0cnVlIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlRW5kXCIsICh7IHRhcmdldCwgaXNEcmFnIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCwgaXNEcmFnKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuKiBXaGVuIHRoZSBncm91cCBzY2FsZSBzdGFydHMsIHRoZSBgc2NhbGVHcm91cFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXHJcbiogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXHJcbiogQGV2ZW50IHNjYWxlR3JvdXBTdGFydFxyXG4qIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZUdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBzY2FsZUdyb3VwU3RhcnRgIGV2ZW50XHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiogICAgIHNjYWxhYmxlOiB0cnVlXHJcbiogfSk7XHJcbiogbW92ZWFibGUub24oXCJzY2FsZUdyb3VwU3RhcnRcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKFwib25TY2FsZUdyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4qIFdoZW4gdGhlIGdyb3VwIHNjYWxlLCB0aGUgYHNjYWxlR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuU2NhbGFibGVcclxuKiBAZXZlbnQgc2NhbGVHcm91cFxyXG4qIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZUdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc2NhbGVHcm91cGAgZXZlbnRcclxuKiBAZXhhbXBsZVxyXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuKlxyXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuKiAgICAgc2NhbGFibGU6IHRydWVcclxuKiB9KTtcclxuKiBtb3ZlYWJsZS5vbihcInNjYWxlR3JvdXBcIiwgKHsgdGFyZ2V0cywgZXZlbnRzIH0pID0+IHtcclxuKiAgICAgY29uc29sZS5sb2coXCJvblNjYWxlR3JvdXBcIiwgdGFyZ2V0cyk7XHJcbiogICAgIGV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcclxuKiAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuKiAgICAgICAgIC8vIGV2LmRyYWcgaXMgYSBkcmFnIGV2ZW50IHRoYXQgb2NjdXJzIHdoZW4gdGhlIGdyb3VwIHNjYWxlLlxyXG4qICAgICAgICAgY29uc3QgbGVmdCA9IGV2LmRyYWcuYmVmb3JlRGlzdFswXTtcclxuKiAgICAgICAgIGNvbnN0IHRvcCA9IGV2LmRyYWcuYmVmb3JlRGlzdFsxXTtcclxuKiAgICAgICAgIGNvbnN0IHNjYWxlWCA9IGV2LnNjYWxlWzBdO1xyXG4qICAgICAgICAgY29uc3Qgc2NhbGVZID0gZXYuc2NhbGVbMV07XHJcbiogICAgIH0pO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuICogV2hlbiB0aGUgZ3JvdXAgc2NhbGUgZmluaXNoZXMsIHRoZSBgc2NhbGVHcm91cEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2NhbGFibGVcclxuICogQGV2ZW50IHNjYWxlR3JvdXBFbmRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5TY2FsYWJsZS5PblNjYWxlR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBzY2FsZUdyb3VwRW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiAqICAgICBzY2FsYWJsZTogdHJ1ZVxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJzY2FsZUdyb3VwRW5kXCIsICh7IHRhcmdldHMsIGlzRHJhZyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uU2NhbGVHcm91cEVuZFwiLCB0YXJnZXRzLCBpc0RyYWcpO1xyXG4gKiB9KTtcclxuICovXG5cbmZ1bmN0aW9uIGdldE1pZGRsZUxpbmVQb3MocG9zMSwgcG9zMikge1xyXG4gICAgcmV0dXJuIHBvczEubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHsgcmV0dXJuIGRvdChwb3MsIHBvczJbaV0sIDEsIDIpOyB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmlhbmdsZVJhZChwb3MxLCBwb3MyLCBwb3MzKSB7XHJcbiAgICAvLyBwb3MxIFJhZFxyXG4gICAgdmFyIHJhZDEgPSBnZXRSYWQocG9zMSwgcG9zMik7XHJcbiAgICB2YXIgcmFkMiA9IGdldFJhZChwb3MxLCBwb3MzKTtcclxuICAgIHZhciByYWQgPSByYWQyIC0gcmFkMTtcclxuICAgIHJldHVybiByYWQgPj0gMCA/IHJhZCA6IHJhZCArIDIgKiBNYXRoLlBJO1xyXG59XHJcbmZ1bmN0aW9uIGlzVmFsaWRQb3MocG9zZXMxLCBwb3NlczIpIHtcclxuICAgIHZhciByYWQxID0gZ2V0VHJpYW5nbGVSYWQocG9zZXMxWzBdLCBwb3NlczFbMV0sIHBvc2VzMVsyXSk7XHJcbiAgICB2YXIgcmFkMiA9IGdldFRyaWFuZ2xlUmFkKHBvc2VzMlswXSwgcG9zZXMyWzFdLCBwb3NlczJbMl0pO1xyXG4gICAgdmFyIHBpID0gTWF0aC5QSTtcclxuICAgIGlmICgocmFkMSA+PSBwaSAmJiByYWQyIDw9IHBpKSB8fCAocmFkMSA8PSBwaSAmJiByYWQyID49IHBpKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLldhcnBhYmxlXHJcbiAqIEBkZXNjcmlwdGlvbiBXYXJwYWJsZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0IGNhbiBiZSB3YXJwZWQoZGlzdG9ydGVkLCBiZW50ZWQpLlxyXG4gKi9cclxudmFyIFdhcnBhYmxlID0ge1xyXG4gICAgbmFtZTogXCJ3YXJwYWJsZVwiLFxyXG4gICAgYWJsZUdyb3VwOiBcInNpemVcIixcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJ3YXJwYWJsZVwiLFxyXG4gICAgICAgIFwicmVuZGVyRGlyZWN0aW9uc1wiLFxyXG4gICAgICAgIFwiZWRnZVwiLFxyXG4gICAgICAgIFwiZGlzcGxheUFyb3VuZENvbnRyb2xzXCIsXHJcbiAgICBdLFxyXG4gICAgZXZlbnRzOiBbXHJcbiAgICAgICAgXCJ3YXJwU3RhcnRcIixcclxuICAgICAgICBcIndhcnBcIixcclxuICAgICAgICBcIndhcnBFbmRcIixcclxuICAgIF0sXHJcbiAgICB2aWV3Q2xhc3NOYW1lOiBnZXREaXJlY3Rpb25WaWV3Q2xhc3NOYW1lKFwid2FycGFibGVcIiksXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgcmVzaXphYmxlID0gX2EucmVzaXphYmxlLCBzY2FsYWJsZSA9IF9hLnNjYWxhYmxlLCB3YXJwYWJsZSA9IF9hLndhcnBhYmxlLCB6b29tID0gX2Euem9vbTtcclxuICAgICAgICBpZiAocmVzaXphYmxlIHx8IHNjYWxhYmxlIHx8ICF3YXJwYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLCBwb3MxID0gX2IucG9zMSwgcG9zMiA9IF9iLnBvczIsIHBvczMgPSBfYi5wb3MzLCBwb3M0ID0gX2IucG9zNDtcclxuICAgICAgICB2YXIgbGluZVBvc0Zyb20xID0gZ2V0TWlkZGxlTGluZVBvcyhwb3MxLCBwb3MyKTtcclxuICAgICAgICB2YXIgbGluZVBvc0Zyb20yID0gZ2V0TWlkZGxlTGluZVBvcyhwb3MyLCBwb3MxKTtcclxuICAgICAgICB2YXIgbGluZVBvc0Zyb20zID0gZ2V0TWlkZGxlTGluZVBvcyhwb3MxLCBwb3MzKTtcclxuICAgICAgICB2YXIgbGluZVBvc0Zyb200ID0gZ2V0TWlkZGxlTGluZVBvcyhwb3MzLCBwb3MxKTtcclxuICAgICAgICB2YXIgbGluZVBvc1RvMSA9IGdldE1pZGRsZUxpbmVQb3MocG9zMywgcG9zNCk7XHJcbiAgICAgICAgdmFyIGxpbmVQb3NUbzIgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczQsIHBvczMpO1xyXG4gICAgICAgIHZhciBsaW5lUG9zVG8zID0gZ2V0TWlkZGxlTGluZVBvcyhwb3MyLCBwb3M0KTtcclxuICAgICAgICB2YXIgbGluZVBvc1RvNCA9IGdldE1pZGRsZUxpbmVQb3MocG9zNCwgcG9zMik7XHJcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoW1xyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lXCIpLCBrZXk6IFwibWlkZGVMaW5lMVwiLCBzdHlsZTogZ2V0TGluZVN0eWxlKGxpbmVQb3NGcm9tMSwgbGluZVBvc1RvMSwgem9vbSkgfSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHByZWZpeChcImxpbmVcIiksIGtleTogXCJtaWRkZUxpbmUyXCIsIHN0eWxlOiBnZXRMaW5lU3R5bGUobGluZVBvc0Zyb20yLCBsaW5lUG9zVG8yLCB6b29tKSB9KSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiKSwga2V5OiBcIm1pZGRlTGluZTNcIiwgc3R5bGU6IGdldExpbmVTdHlsZShsaW5lUG9zRnJvbTMsIGxpbmVQb3NUbzMsIHpvb20pIH0pLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lXCIpLCBrZXk6IFwibWlkZGVMaW5lNFwiLCBzdHlsZTogZ2V0TGluZVN0eWxlKGxpbmVQb3NGcm9tNCwgbGluZVBvc1RvNCwgem9vbSkgfSlcclxuICAgICAgICBdLCBfX3JlYWQocmVuZGVyQWxsRGlyZWN0aW9ucyhtb3ZlYWJsZSwgXCJ3YXJwYWJsZVwiLCBSZWFjdCkpLCBmYWxzZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIGlmIChlLmlzUmVxdWVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0YXJnZXQgPSBlLmlucHV0RXZlbnQudGFyZ2V0O1xyXG4gICAgICAgIHJldHVybiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcImRpcmVjdGlvblwiKSkgJiYgaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJ3YXJwYWJsZVwiKSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gbW92ZWFibGUucHJvcHMudGFyZ2V0O1xyXG4gICAgICAgIHZhciBpbnB1dFRhcmdldCA9IGlucHV0RXZlbnQudGFyZ2V0O1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXRUYXJnZXQsIGRhdGFzKTtcclxuICAgICAgICBpZiAoIWRpcmVjdGlvbiB8fCAhdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHN0YXRlLnRyYW5zZm9ybU9yaWdpbiwgaXMzZCA9IHN0YXRlLmlzM2QsIHRhcmdldFRyYW5zZm9ybSA9IHN0YXRlLnRhcmdldFRyYW5zZm9ybSwgdGFyZ2V0TWF0cml4ID0gc3RhdGUudGFyZ2V0TWF0cml4LCB3aWR0aCA9IHN0YXRlLndpZHRoLCBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQsIGxlZnQgPSBzdGF0ZS5sZWZ0LCB0b3AgPSBzdGF0ZS50b3A7XHJcbiAgICAgICAgZGF0YXMuZGF0YXMgPSB7fTtcclxuICAgICAgICBkYXRhcy50YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXRUcmFuc2Zvcm07XHJcbiAgICAgICAgZGF0YXMud2FycFRhcmdldE1hdHJpeCA9IGlzM2QgPyB0YXJnZXRNYXRyaXggOiBjb252ZXJ0RGltZW5zaW9uKHRhcmdldE1hdHJpeCwgMywgNCk7XHJcbiAgICAgICAgZGF0YXMudGFyZ2V0SW52ZXJzZU1hdHJpeCA9IGlnbm9yZURpbWVuc2lvbihpbnZlcnQoZGF0YXMud2FycFRhcmdldE1hdHJpeCwgNCksIDMsIDQpO1xyXG4gICAgICAgIGRhdGFzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgICAgICBkYXRhcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICBkYXRhcy50b3AgPSB0b3A7XHJcbiAgICAgICAgZGF0YXMucG9zZXMgPSBbXHJcbiAgICAgICAgICAgIFswLCAwXSxcclxuICAgICAgICAgICAgW3dpZHRoLCAwXSxcclxuICAgICAgICAgICAgWzAsIGhlaWdodF0sXHJcbiAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcclxuICAgICAgICBdLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gbWludXMocCwgdHJhbnNmb3JtT3JpZ2luKTsgfSk7XHJcbiAgICAgICAgZGF0YXMubmV4dFBvc2VzID0gZGF0YXMucG9zZXMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCB4ID0gX2JbMF0sIHkgPSBfYlsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZShkYXRhcy53YXJwVGFyZ2V0TWF0cml4LCBbeCwgeSwgMCwgMV0sIDQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSBjcmVhdGVJZGVudGl0eU1hdHJpeCg0KTtcclxuICAgICAgICBkYXRhcy5wcmV2TWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgoNCk7XHJcbiAgICAgICAgZGF0YXMuYWJzb2x1dGVQb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKHN0YXRlKTtcclxuICAgICAgICBkYXRhcy5wb3NJbmRleGVzID0gZ2V0UG9zSW5kZXhlc0J5RGlyZWN0aW9uKGRpcmVjdGlvbik7XHJcbiAgICAgICAgc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcclxuICAgICAgICBzZXREZWZhdWx0VHJhbnNmb3JtSW5kZXgobW92ZWFibGUsIGUsIFwibWF0cml4M2RcIik7XHJcbiAgICAgICAgc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7IHNldDogZnVuY3Rpb24gKG1hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YXMuc3RhcnRWYWx1ZSA9IG1hdHJpeDtcclxuICAgICAgICAgICAgfSB9LCBmaWxsVHJhbnNmb3JtU3RhcnRFdmVudChtb3ZlYWJsZSwgZSkpKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uV2FycFN0YXJ0XCIsIHBhcmFtcyk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZGF0YXMuaXNXYXJwID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGFzLmlzV2FycDtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XHJcbiAgICAgICAgdmFyIGRpc3RYID0gZS5kaXN0WCwgZGlzdFkgPSBlLmRpc3RZO1xyXG4gICAgICAgIHZhciB0YXJnZXRJbnZlcnNlTWF0cml4ID0gZGF0YXMudGFyZ2V0SW52ZXJzZU1hdHJpeCwgcHJldk1hdHJpeCA9IGRhdGFzLnByZXZNYXRyaXgsIGlzV2FycCA9IGRhdGFzLmlzV2FycCwgc3RhcnRWYWx1ZSA9IGRhdGFzLnN0YXJ0VmFsdWUsIHBvc2VzID0gZGF0YXMucG9zZXMsIHBvc0luZGV4ZXMgPSBkYXRhcy5wb3NJbmRleGVzLCBhYnNvbHV0ZVBvc2VzID0gZGF0YXMuYWJzb2x1dGVQb3NlcztcclxuICAgICAgICBpZiAoIWlzV2FycCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc29sdmVUcmFuc2Zvcm1FdmVudChtb3ZlYWJsZSwgZSwgXCJtYXRyaXgzZFwiKTtcclxuICAgICAgICBpZiAoaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJ3YXJwYWJsZVwiKSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRQb3NlcyA9IHBvc0luZGV4ZXMubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gYWJzb2x1dGVQb3Nlc1tpbmRleF07IH0pO1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRQb3Nlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFBvc2VzLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3RlZFBvc2VzWzBdWzBdICsgc2VsZWN0ZWRQb3Nlc1sxXVswXSkgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3RlZFBvc2VzWzBdWzFdICsgc2VsZWN0ZWRQb3Nlc1sxXVsxXSkgLyAyLFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIF9hID0gY2hlY2tNb3ZlYWJsZVNuYXBCb3VuZHMobW92ZWFibGUsIGlzUmVxdWVzdCwge1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbDogc2VsZWN0ZWRQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzFdICsgZGlzdFk7IH0pLFxyXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IHNlbGVjdGVkUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1swXSArIGRpc3RYOyB9KSxcclxuICAgICAgICAgICAgfSksIGhvcml6b250YWxTbmFwSW5mbyA9IF9hLmhvcml6b250YWwsIHZlcnRpY2FsU25hcEluZm8gPSBfYS52ZXJ0aWNhbDtcclxuICAgICAgICAgICAgZGlzdFkgLT0gaG9yaXpvbnRhbFNuYXBJbmZvLm9mZnNldDtcclxuICAgICAgICAgICAgZGlzdFggLT0gdmVydGljYWxTbmFwSW5mby5vZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaXN0ID0gZ2V0RHJhZ0Rpc3QoeyBkYXRhczogZGF0YXMsIGRpc3RYOiBkaXN0WCwgZGlzdFk6IGRpc3RZIH0sIHRydWUpO1xyXG4gICAgICAgIHZhciBuZXh0UG9zZXMgPSBkYXRhcy5uZXh0UG9zZXMuc2xpY2UoKTtcclxuICAgICAgICBwb3NJbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIG5leHRQb3Nlc1tpbmRleF0gPSBwbHVzKG5leHRQb3Nlc1tpbmRleF0sIGRpc3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghTkVBUkJZX1BPUy5ldmVyeShmdW5jdGlvbiAobmVhckJ5UG9zZXMpIHsgcmV0dXJuIGlzVmFsaWRQb3MobmVhckJ5UG9zZXMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBwb3Nlc1tpXTsgfSksIG5lYXJCeVBvc2VzLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gbmV4dFBvc2VzW2ldOyB9KSk7IH0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGggPSBjcmVhdGVXYXJwTWF0cml4KHBvc2VzWzBdLCBwb3Nlc1syXSwgcG9zZXNbMV0sIHBvc2VzWzNdLCBuZXh0UG9zZXNbMF0sIG5leHRQb3Nlc1syXSwgbmV4dFBvc2VzWzFdLCBuZXh0UG9zZXNbM10pO1xyXG4gICAgICAgIGlmICghaC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCICogQSAqIE1cclxuICAgICAgICB2YXIgYWZ0ZXJNYXRyaXggPSBtdWx0aXBseSh0YXJnZXRJbnZlcnNlTWF0cml4LCBoLCA0KTtcclxuICAgICAgICAvLyBCICogTSAqIEFcclxuICAgICAgICB2YXIgbWF0cml4ID0gZ2V0VHJhbnNmcm9tTWF0cml4KGRhdGFzLCBhZnRlck1hdHJpeCwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGRlbHRhID0gbXVsdGlwbHkoaW52ZXJ0KHByZXZNYXRyaXgsIDQpLCBtYXRyaXgsIDQpO1xyXG4gICAgICAgIGRhdGFzLnByZXZNYXRyaXggPSBtYXRyaXg7XHJcbiAgICAgICAgdmFyIHRvdGFsTWF0cml4ID0gbXVsdGlwbHkoc3RhcnRWYWx1ZSwgbWF0cml4LCA0KTtcclxuICAgICAgICB2YXIgbmV4dFRyYW5zZm9ybSA9IGNvbnZlcnRUcmFuc2Zvcm1Gb3JtYXQoZGF0YXMsIFwibWF0cml4M2QoXCIuY29uY2F0KHRvdGFsTWF0cml4LmpvaW4oXCIsIFwiKSwgXCIpXCIpLCBcIm1hdHJpeDNkKFwiLmNvbmNhdChtYXRyaXguam9pbihcIiwgXCIpLCBcIilcIikpO1xyXG4gICAgICAgIGZpbGxPcmlnaW5hbFRyYW5zZm9ybShlLCBuZXh0VHJhbnNmb3JtKTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25XYXJwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHsgZGVsdGE6IGRlbHRhLCBtYXRyaXg6IHRvdGFsTWF0cml4LCBkaXN0OiBtYXRyaXgsIG11bHRpcGx5OiBtdWx0aXBseSwgdHJhbnNmb3JtOiBuZXh0VHJhbnNmb3JtIH0sIGZpbGxDU1NPYmplY3Qoe1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IG5leHRUcmFuc2Zvcm0sXHJcbiAgICAgICAgfSwgZSkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsIGlzRHJhZyA9IGUuaXNEcmFnO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNXYXJwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMuaXNXYXJwID0gZmFsc2U7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uV2FycEVuZFwiLCBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSkpO1xyXG4gICAgICAgIHJldHVybiBpc0RyYWc7XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSB3YXJwZWQuIChkZWZhdWx0OiBmYWxzZSlcclxuICogQG5hbWUgTW92ZWFibGUuV2FycGFibGUjd2FycGFibGVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUud2FycGFibGUgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiogU2V0IGRpcmVjdGlvbnMgdG8gc2hvdyB0aGUgY29udHJvbCBib3guIChkZWZhdWx0OiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0pXHJcbiogQG5hbWUgTW92ZWFibGUuV2FycGFibGUjcmVuZGVyRGlyZWN0aW9uc1xyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICB3YXJwYWJsZTogdHJ1ZSxcclxuKiAgICAgcmVuZGVyRGlyZWN0aW9uczogW1wiblwiLCBcIm53XCIsIFwibmVcIiwgXCJzXCIsIFwic2VcIiwgXCJzd1wiLCBcImVcIiwgXCJ3XCJdLFxyXG4qIH0pO1xyXG4qXHJcbiogbW92ZWFibGUucmVuZGVyRGlyZWN0aW9ucyA9IFtcIm53XCIsIFwibmVcIiwgXCJzd1wiLCBcInNlXCJdO1xyXG4qL1xyXG4vKipcclxuKiBXaGVuIHRoZSB3YXJwIHN0YXJ0cywgdGhlIHdhcnBTdGFydCBldmVudCBpcyBjYWxsZWQuXHJcbiogQG1lbWJlcm9mIE1vdmVhYmxlLldhcnBhYmxlXHJcbiogQGV2ZW50IHdhcnBTdGFydFxyXG4qIEBwYXJhbSB7TW92ZWFibGUuV2FycGFibGUuT25XYXJwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHdhcnBTdGFydCBldmVudFxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyB3YXJwYWJsZTogdHJ1ZSB9KTtcclxuKiBtb3ZlYWJsZS5vbihcIndhcnBTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4qICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuICogV2hlbiB3YXJwaW5nLCB0aGUgd2FycCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5XYXJwYWJsZVxyXG4gKiBAZXZlbnQgd2FycFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLldhcnBhYmxlLk9uV2FycH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgd2FycCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqIGxldCBtYXRyaXggPSBbXHJcbiAqICAxLCAwLCAwLCAwLFxyXG4gKiAgMCwgMSwgMCwgMCxcclxuICogIDAsIDAsIDEsIDAsXHJcbiAqICAwLCAwLCAwLCAxLFxyXG4gKiBdO1xyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHdhcnBhYmxlOiB0cnVlIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcIndhcnBcIiwgKHsgdGFyZ2V0LCB0cmFuc2Zvcm0sIGRlbHRhLCBtdWx0aXBseSB9KSA9PiB7XHJcbiAqICAgIC8vIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAqICAgIG1hdHJpeCA9IG11bHRpcGx5KG1hdHJpeCwgZGVsdGEpO1xyXG4gKiAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gYG1hdHJpeDNkKCR7bWF0cml4LmpvaW4oXCIsXCIpfSlgO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSB3YXJwIGZpbmlzaGVzLCB0aGUgd2FycEVuZCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5XYXJwYWJsZVxyXG4gKiBAZXZlbnQgd2FycEVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLldhcnBhYmxlLk9uV2FycEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgd2FycEVuZCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgd2FycGFibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwid2FycEVuZFwiLCAoeyB0YXJnZXQsIGlzRHJhZyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQsIGlzRHJhZyk7XHJcbiAqIH0pO1xyXG4gKi9cblxudmFyIEFSRUFfUElFQ0VTID0gLyojX19QVVJFX18qLyBwcmVmaXgoXCJhcmVhLXBpZWNlc1wiKTtcclxudmFyIEFSRUFfUElFQ0UgPSAvKiNfX1BVUkVfXyovIHByZWZpeChcImFyZWEtcGllY2VcIik7XHJcbnZhciBBVk9JRCA9IC8qI19fUFVSRV9fKi8gcHJlZml4KFwiYXZvaWRcIik7XHJcbnZhciBWSUVXX0RSQUdHSU5HID0gcHJlZml4KFwidmlldy1kcmFnZ2luZ1wiKTtcblxuZnVuY3Rpb24gcmVzdG9yZVN0eWxlKG1vdmVhYmxlKSB7XHJcbiAgICB2YXIgZWwgPSBtb3ZlYWJsZS5hcmVhRWxlbWVudDtcclxuICAgIGlmICghZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgcmVtb3ZlQ2xhc3MoZWwsIEFWT0lEKTtcclxuICAgIGVsLnN0eWxlLmNzc1RleHQgKz0gXCJsZWZ0OiAwcHg7IHRvcDogMHB4OyB3aWR0aDogXCIuY29uY2F0KHdpZHRoLCBcInB4OyBoZWlnaHQ6IFwiKS5jb25jYXQoaGVpZ2h0LCBcInB4XCIpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlclBpZWNlcyhSZWFjdCkge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcImFyZWFfcGllY2VzXCIsIGNsYXNzTmFtZTogQVJFQV9QSUVDRVMgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBBUkVBX1BJRUNFIH0pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IEFSRUFfUElFQ0UgfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogQVJFQV9QSUVDRSB9KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBBUkVBX1BJRUNFIH0pKSk7XHJcbn1cclxudmFyIERyYWdBcmVhID0ge1xyXG4gICAgbmFtZTogXCJkcmFnQXJlYVwiLFxyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcImRyYWdBcmVhXCIsXHJcbiAgICAgICAgXCJwYXNzRHJhZ0FyZWFcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcImNsaWNrXCIsXHJcbiAgICAgICAgXCJjbGlja0dyb3VwXCIsXHJcbiAgICBdLFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XHJcbiAgICAgICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsIHRhcmdldCA9IF9hLnRhcmdldCwgZHJhZ0FyZWEgPSBfYS5kcmFnQXJlYSwgZ3JvdXBhYmxlID0gX2EuZ3JvdXBhYmxlLCBwYXNzRHJhZ0FyZWEgPSBfYS5wYXNzRHJhZ0FyZWE7XHJcbiAgICAgICAgdmFyIF9iID0gbW92ZWFibGUuZ2V0U3RhdGUoKSwgd2lkdGggPSBfYi53aWR0aCwgaGVpZ2h0ID0gX2IuaGVpZ2h0LCByZW5kZXJQb3NlcyA9IF9iLnJlbmRlclBvc2VzO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBwYXNzRHJhZ0FyZWEgPyBwcmVmaXgoXCJhcmVhXCIsIFwicGFzc1wiKSA6IHByZWZpeChcImFyZWFcIik7XHJcbiAgICAgICAgaWYgKGdyb3VwYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogXCJhcmVhXCIsIHJlZjogcmVmKG1vdmVhYmxlLCBcImFyZWFFbGVtZW50XCIpLCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9KSxcclxuICAgICAgICAgICAgICAgIHJlbmRlclBpZWNlcyhSZWFjdCksXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICFkcmFnQXJlYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoID0gY3JlYXRlV2FycE1hdHJpeChbMCwgMF0sIFt3aWR0aCwgMF0sIFswLCBoZWlnaHRdLCBbd2lkdGgsIGhlaWdodF0sIHJlbmRlclBvc2VzWzBdLCByZW5kZXJQb3Nlc1sxXSwgcmVuZGVyUG9zZXNbMl0sIHJlbmRlclBvc2VzWzNdKTtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gaC5sZW5ndGggPyBtYWtlTWF0cml4Q1NTKGgsIHRydWUpIDogXCJub25lXCI7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogXCJhcmVhXCIsIHJlZjogcmVmKG1vdmVhYmxlLCBcImFyZWFFbGVtZW50XCIpLCBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IFwiMHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIwcHhcIixcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjAgMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxyXG4gICAgICAgICAgICAgICAgfSB9KSxcclxuICAgICAgICAgICAgcmVuZGVyUGllY2VzKFJlYWN0KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBfYSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IF9hLmRhdGFzLCBjbGllbnRYID0gX2EuY2xpZW50WCwgY2xpZW50WSA9IF9hLmNsaWVudFksIGlucHV0RXZlbnQgPSBfYS5pbnB1dEV2ZW50O1xyXG4gICAgICAgIGlmICghaW5wdXRFdmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFzLmlzRHJhZ0FyZWEgPSBmYWxzZTtcclxuICAgICAgICB2YXIgYXJlYUVsZW1lbnQgPSBtb3ZlYWJsZS5hcmVhRWxlbWVudDtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICB2YXIgbW92ZWFibGVDbGllbnRSZWN0ID0gc3RhdGUubW92ZWFibGVDbGllbnRSZWN0LCByZW5kZXJQb3NlcyA9IHN0YXRlLnJlbmRlclBvc2VzLCByb290TWF0cml4ID0gc3RhdGUucm9vdE1hdHJpeCwgaXMzZCA9IHN0YXRlLmlzM2Q7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBtb3ZlYWJsZUNsaWVudFJlY3QubGVmdCwgdG9wID0gbW92ZWFibGVDbGllbnRSZWN0LnRvcDtcclxuICAgICAgICB2YXIgX2IgPSBnZXRSZWN0KHJlbmRlclBvc2VzKSwgcmVsYXRpdmVMZWZ0ID0gX2IubGVmdCwgcmVsYXRpdmVUb3AgPSBfYi50b3AsIHdpZHRoID0gX2Iud2lkdGgsIGhlaWdodCA9IF9iLmhlaWdodDtcclxuICAgICAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgICAgICB2YXIgX2MgPSBfX3JlYWQoY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKHJvb3RNYXRyaXgsIFtjbGllbnRYIC0gbGVmdCwgY2xpZW50WSAtIHRvcF0sIG4pLCAyKSwgcG9zWCA9IF9jWzBdLCBwb3NZID0gX2NbMV07XHJcbiAgICAgICAgcG9zWCAtPSByZWxhdGl2ZUxlZnQ7XHJcbiAgICAgICAgcG9zWSAtPSByZWxhdGl2ZVRvcDtcclxuICAgICAgICB2YXIgcmVjdHMgPSBbXHJcbiAgICAgICAgICAgIHsgbGVmdDogcmVsYXRpdmVMZWZ0LCB0b3A6IHJlbGF0aXZlVG9wLCB3aWR0aDogd2lkdGgsIGhlaWdodDogcG9zWSAtIDEwIH0sXHJcbiAgICAgICAgICAgIHsgbGVmdDogcmVsYXRpdmVMZWZ0LCB0b3A6IHJlbGF0aXZlVG9wLCB3aWR0aDogcG9zWCAtIDEwLCBoZWlnaHQ6IGhlaWdodCB9LFxyXG4gICAgICAgICAgICB7IGxlZnQ6IHJlbGF0aXZlTGVmdCwgdG9wOiByZWxhdGl2ZVRvcCArIHBvc1kgKyAxMCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCAtIHBvc1kgLSAxMCB9LFxyXG4gICAgICAgICAgICB7IGxlZnQ6IHJlbGF0aXZlTGVmdCArIHBvc1ggKyAxMCwgdG9wOiByZWxhdGl2ZVRvcCwgd2lkdGg6IHdpZHRoIC0gcG9zWCAtIDEwLCBoZWlnaHQ6IGhlaWdodCB9LFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW10uc2xpY2UuY2FsbChhcmVhRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcuY2hpbGRyZW4pO1xyXG4gICAgICAgIHJlY3RzLmZvckVhY2goZnVuY3Rpb24gKHJlY3QsIGkpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuY3NzVGV4dFxyXG4gICAgICAgICAgICAgICAgPSBcImxlZnQ6IFwiLmNvbmNhdChyZWN0LmxlZnQsIFwicHg7dG9wOiBcIikuY29uY2F0KHJlY3QudG9wLCBcInB4OyB3aWR0aDogXCIpLmNvbmNhdChyZWN0LndpZHRoLCBcInB4OyBoZWlnaHQ6IFwiKS5jb25jYXQocmVjdC5oZWlnaHQsIFwicHg7XCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZENsYXNzKGFyZWFFbGVtZW50LCBBVk9JRCk7XHJcbiAgICAgICAgc3RhdGUuZGlzYWJsZU5hdGl2ZUV2ZW50ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9LFxyXG4gICAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBfYSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IF9hLmRhdGFzLCBpbnB1dEV2ZW50ID0gX2EuaW5wdXRFdmVudDtcclxuICAgICAgICB0aGlzLmVuYWJsZU5hdGl2ZUV2ZW50KG1vdmVhYmxlKTtcclxuICAgICAgICBpZiAoIWlucHV0RXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRhdGFzLmlzRHJhZ0FyZWEpIHtcclxuICAgICAgICAgICAgZGF0YXMuaXNEcmFnQXJlYSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc3RvcmVTdHlsZShtb3ZlYWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlTmF0aXZlRXZlbnQobW92ZWFibGUpO1xyXG4gICAgICAgIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LCBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgaWYgKCFpbnB1dEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc0RyYWdBcmVhKSB7XHJcbiAgICAgICAgICAgIHJlc3RvcmVTdHlsZShtb3ZlYWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgcmVzdG9yZVN0eWxlKG1vdmVhYmxlKTtcclxuICAgICAgICBtb3ZlYWJsZS5zdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBlbmFibGVOYXRpdmVFdmVudDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgaWYgKHN0YXRlLmRpc2FibGVOYXRpdmVFdmVudCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZU5hdGl2ZUV2ZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBBZGQgYW4gZXZlbnQgdG8gdGhlIG1vdmVhYmxlIGFyZWEgaW5zdGVhZCBvZiB0aGUgdGFyZ2V0IGZvciBzdG9wUHJvcGFnYXRpb24uIChkZWZhdWx0OiBmYWxzZSwgdHJ1ZSBpbiBncm91cClcclxuICogQG5hbWUgTW92ZWFibGUjZHJhZ0FyZWFcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICBkcmFnQXJlYTogZmFsc2UsXHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFNldCBgcG9pbnRlckV2ZW50czogbm9uZTtgIGNzcyB0byBwYXNzIGV2ZW50cyBpbiBkcmFnQXJlYS4gKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZSNwYXNzRHJhZ0FyZWFcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICBkcmFnQXJlYTogZmFsc2UsXHJcbiAqIH0pO1xyXG4gKi9cblxudmFyIE9yaWdpbiA9IG1ha2VBYmxlKFwib3JpZ2luXCIsIHtcclxuICAgIHByb3BzOiBbXCJvcmlnaW5cIiwgXCJzdmdPcmlnaW5cIl0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgem9vbSA9IF9hLnpvb20sIHN2Z09yaWdpbiA9IF9hLnN2Z09yaWdpbiwgZ3JvdXBhYmxlID0gX2EuZ3JvdXBhYmxlO1xyXG4gICAgICAgIHZhciBfYiA9IG1vdmVhYmxlLmdldFN0YXRlKCksIGJlZm9yZU9yaWdpbiA9IF9iLmJlZm9yZU9yaWdpbiwgcm90YXRpb24gPSBfYi5yb3RhdGlvbiwgc3ZnID0gX2Iuc3ZnLCBhbGxNYXRyaXggPSBfYi5hbGxNYXRyaXgsIGlzM2QgPSBfYi5pczNkLCBsZWZ0ID0gX2IubGVmdCwgdG9wID0gX2IudG9wLCBvZmZzZXRXaWR0aCA9IF9iLm9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgPSBfYi5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgdmFyIG9yaWdpblN0eWxlO1xyXG4gICAgICAgIGlmICghZ3JvdXBhYmxlICYmIHN2ZyAmJiBzdmdPcmlnaW4pIHtcclxuICAgICAgICAgICAgdmFyIF9jID0gX19yZWFkKGNvbnZlcnRUcmFuc2Zvcm1PcmlnaW5BcnJheShzdmdPcmlnaW4sIG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQpLCAyKSwgb3JpZ2luWCA9IF9jWzBdLCBvcmlnaW5ZID0gX2NbMV07XHJcbiAgICAgICAgICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBbb3JpZ2luWCwgb3JpZ2luWV0sIG4pO1xyXG4gICAgICAgICAgICBvcmlnaW5TdHlsZSA9IGdldENvbnRyb2xUcmFuc2Zvcm0ocm90YXRpb24sIHpvb20sIG1pbnVzKHJlc3VsdCwgW2xlZnQsIHRvcF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9yaWdpblN0eWxlID0gZ2V0Q29udHJvbFRyYW5zZm9ybShyb3RhdGlvbiwgem9vbSwgYmVmb3JlT3JpZ2luKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbFwiLCBcIm9yaWdpblwiKSwgc3R5bGU6IG9yaWdpblN0eWxlLCBrZXk6IFwiYmVmb3JlT3JpZ2luXCIgfSksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbn0pO1xyXG4vKipcclxuICogV2hldGhlciBvciBub3QgdGhlIG9yaWdpbiBjb250cm9sYm94IHdpbGwgYmUgdmlzaWJsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXHJcbiAqIEBuYW1lIE1vdmVhYmxlI29yaWdpblxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5vcmlnaW4gPSB0cnVlO1xyXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjcm9sbFBvc2l0aW9uKGUpIHtcclxuICAgIHZhciBzY3JvbGxDb250YWluZXIgPSBlLnNjcm9sbENvbnRhaW5lcjtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQsXHJcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCxcclxuICAgIF07XHJcbn1cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuU2Nyb2xsYWJsZVxyXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBzY3JvbGxlZCB0byB0aGUgc2Nyb2xsIGNvbnRhaW5lciAoZGVmYXVsdDogZmFsc2UpXHJcbiAqL1xyXG52YXIgU2Nyb2xsYWJsZSA9IHtcclxuICAgIG5hbWU6IFwic2Nyb2xsYWJsZVwiLFxyXG4gICAgY2FuUGluY2g6IHRydWUsXHJcbiAgICBwcm9wczogW1xyXG4gICAgICAgIFwic2Nyb2xsYWJsZVwiLFxyXG4gICAgICAgIFwic2Nyb2xsQ29udGFpbmVyXCIsXHJcbiAgICAgICAgXCJzY3JvbGxUaHJlc2hvbGRcIixcclxuICAgICAgICBcInNjcm9sbFRocm90dGxlVGltZVwiLFxyXG4gICAgICAgIFwiZ2V0U2Nyb2xsUG9zaXRpb25cIixcclxuICAgICAgICBcInNjcm9sbE9wdGlvbnNcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcInNjcm9sbFwiLFxyXG4gICAgICAgIFwic2Nyb2xsR3JvdXBcIixcclxuICAgIF0sXHJcbiAgICBkcmFnUmVsYXRpb246IFwic3Ryb25nXCIsXHJcbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xyXG4gICAgICAgIHZhciBfYSA9IHByb3BzLnNjcm9sbENvbnRhaW5lciwgc2Nyb2xsQ29udGFpbmVyID0gX2EgPT09IHZvaWQgMCA/IG1vdmVhYmxlLmdldENvbnRhaW5lcigpIDogX2EsIHNjcm9sbE9wdGlvbnMgPSBwcm9wcy5zY3JvbGxPcHRpb25zO1xyXG4gICAgICAgIHZhciBkcmFnU2Nyb2xsID0gbmV3IERyYWdTY3JvbGwoKTtcclxuICAgICAgICB2YXIgc2Nyb2xsQ29udGFpbmVyRWxlbWVudCA9IGdldFJlZlRhcmdldChzY3JvbGxDb250YWluZXIsIHRydWUpO1xyXG4gICAgICAgIGUuZGF0YXMuZHJhZ1Njcm9sbCA9IGRyYWdTY3JvbGw7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuZHJhZ1Njcm9sbCA9IGRyYWdTY3JvbGw7XHJcbiAgICAgICAgdmFyIGdlc3RvTmFtZSA9IGUuaXNDb250cm9sID8gXCJjb250cm9sR2VzdG9cIiA6IFwidGFyZ2V0R2VzdG9cIjtcclxuICAgICAgICB2YXIgdGFyZ2V0cyA9IGUudGFyZ2V0cztcclxuICAgICAgICBkcmFnU2Nyb2xsLm9uKFwic2Nyb2xsXCIsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX2EuY29udGFpbmVyLCBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb247XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxDb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHRhcmdldHMgPyBcIm9uU2Nyb2xsR3JvdXBcIiA6IFwib25TY3JvbGxcIjtcclxuICAgICAgICAgICAgaWYgKHRhcmdldHMpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXRzID0gdGFyZ2V0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIGV2ZW50TmFtZSwgcGFyYW1zKTtcclxuICAgICAgICB9KS5vbihcIm1vdmVcIiwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRYID0gX2Eub2Zmc2V0WCwgb2Zmc2V0WSA9IF9hLm9mZnNldFksIGlucHV0RXZlbnQgPSBfYS5pbnB1dEV2ZW50O1xyXG4gICAgICAgICAgICBtb3ZlYWJsZVtnZXN0b05hbWVdLnNjcm9sbEJ5KG9mZnNldFgsIG9mZnNldFksIGlucHV0RXZlbnQuaW5wdXRFdmVudCwgZmFsc2UpO1xyXG4gICAgICAgIH0pLm9uKFwic2Nyb2xsRHJhZ1wiLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIG5leHQgPSBfYS5uZXh0O1xyXG4gICAgICAgICAgICBuZXh0KG1vdmVhYmxlW2dlc3RvTmFtZV0uZ2V0Q3VycmVudEV2ZW50KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRyYWdTY3JvbGwuZHJhZ1N0YXJ0KGUsIF9fYXNzaWduKHsgY29udGFpbmVyOiBzY3JvbGxDb250YWluZXJFbGVtZW50IH0sIHNjcm9sbE9wdGlvbnMpKTtcclxuICAgIH0sXHJcbiAgICBjaGVja1Njcm9sbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRyYWdTY3JvbGwgPSBlLmRhdGFzLmRyYWdTY3JvbGw7XHJcbiAgICAgICAgaWYgKCFkcmFnU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsIF9iID0gX2Euc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxDb250YWluZXIgPSBfYiA9PT0gdm9pZCAwID8gbW92ZWFibGUuZ2V0Q29udGFpbmVyKCkgOiBfYiwgX2MgPSBfYS5zY3JvbGxUaHJlc2hvbGQsIHNjcm9sbFRocmVzaG9sZCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIF9kID0gX2Euc2Nyb2xsVGhyb3R0bGVUaW1lLCBzY3JvbGxUaHJvdHRsZVRpbWUgPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kLCBfZSA9IF9hLmdldFNjcm9sbFBvc2l0aW9uLCBnZXRTY3JvbGxQb3NpdGlvbiA9IF9lID09PSB2b2lkIDAgPyBnZXREZWZhdWx0U2Nyb2xsUG9zaXRpb24gOiBfZSwgc2Nyb2xsT3B0aW9ucyA9IF9hLnNjcm9sbE9wdGlvbnM7XHJcbiAgICAgICAgZHJhZ1Njcm9sbC5kcmFnKGUsIF9fYXNzaWduKHsgY29udGFpbmVyOiBzY3JvbGxDb250YWluZXIsIHRocmVzaG9sZDogc2Nyb2xsVGhyZXNob2xkLCB0aHJvdHRsZVRpbWU6IHNjcm9sbFRocm90dGxlVGltZSwgZ2V0U2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNjcm9sbFBvc2l0aW9uKHsgc2Nyb2xsQ29udGFpbmVyOiBldi5jb250YWluZXIsIGRpcmVjdGlvbjogZXYuZGlyZWN0aW9uIH0pO1xyXG4gICAgICAgICAgICB9IH0sIHNjcm9sbE9wdGlvbnMpKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGVja1Njcm9sbChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgZS5kYXRhcy5kcmFnU2Nyb2xsLmRyYWdFbmQoKTtcclxuICAgICAgICBlLmRhdGFzLmRyYWdTY3JvbGwgPSBudWxsO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGlzQ29udHJvbDogdHJ1ZSB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBpc0NvbnRyb2w6IHRydWUgfSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9FbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzIH0pKTtcclxuICAgIH0sXHJcbiAgICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgICAgIChfYSA9IHN0YXRlLmRyYWdTY3JvbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmFnRW5kKCk7XHJcbiAgICAgICAgc3RhdGUuZHJhZ1Njcm9sbCA9IG51bGw7XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogV2hlbiB0aGUgZHJhZyBjdXJzb3IgbGVhdmVzIHRoZSBzY3JvbGxDb250YWluZXIsIHRoZSBgc2Nyb2xsYCBldmVudCBvY2N1ciB0byBzY3JvbGwuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY3JvbGxhYmxlXHJcbiAqIEBldmVudCBzY3JvbGxcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5TY3JvbGxhYmxlLk9uU2Nyb2xsfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc2Nyb2xsYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInNjcm9sbFwiLCAoeyBzY3JvbGxDb250YWluZXIsIGRpcmVjdGlvbiB9KSA9PiB7XHJcbiAqICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgKz0gZGlyZWN0aW9uWzBdICogMTA7XHJcbiAqICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArPSBkaXJlY3Rpb25bMV0gKiAxMDtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgZHJhZyBjdXJzb3IgbGVhdmVzIHRoZSBzY3JvbGxDb250YWluZXIsIHRoZSBgc2Nyb2xsR3JvdXBgIGV2ZW50IG9jY3VyIHRvIHNjcm9sbCBpbiBncm91cC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjcm9sbGFibGVcclxuICogQGV2ZW50IHNjcm9sbEdyb3VwXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2Nyb2xsYWJsZS5PblNjcm9sbEdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc2Nyb2xsR3JvdXBgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwic2Nyb2xsXCIsICh7IHNjcm9sbENvbnRhaW5lciwgZGlyZWN0aW9uIH0pID0+IHtcclxuICogICBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCArPSBkaXJlY3Rpb25bMF0gKiAxMDtcclxuICogICBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wICs9IGRpcmVjdGlvblsxXSAqIDEwO1xyXG4gKiB9KTtcclxuICovXG5cbnZhciBEZWZhdWx0ID0ge1xyXG4gICAgbmFtZTogXCJcIixcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJ0YXJnZXRcIixcclxuICAgICAgICBcImRyYWdUYXJnZXRTZWxmXCIsXHJcbiAgICAgICAgXCJkcmFnVGFyZ2V0XCIsXHJcbiAgICAgICAgXCJkcmFnQ29udGFpbmVyXCIsXHJcbiAgICAgICAgXCJjb250YWluZXJcIixcclxuICAgICAgICBcIndhcnBTZWxmXCIsXHJcbiAgICAgICAgXCJyb290Q29udGFpbmVyXCIsXHJcbiAgICAgICAgXCJ1c2VSZXNpemVPYnNlcnZlclwiLFxyXG4gICAgICAgIFwidXNlTXV0YXRpb25PYnNlcnZlclwiLFxyXG4gICAgICAgIFwiem9vbVwiLFxyXG4gICAgICAgIFwiZHJhZ0ZvY3VzZWRJbnB1dFwiLFxyXG4gICAgICAgIFwidHJhbnNmb3JtT3JpZ2luXCIsXHJcbiAgICAgICAgXCJhYmxlc1wiLFxyXG4gICAgICAgIFwiY2xhc3NOYW1lXCIsXHJcbiAgICAgICAgXCJwaW5jaFRocmVzaG9sZFwiLFxyXG4gICAgICAgIFwicGluY2hPdXRzaWRlXCIsXHJcbiAgICAgICAgXCJ0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseVwiLFxyXG4gICAgICAgIFwiY2hlY2tJbnB1dFwiLFxyXG4gICAgICAgIFwiY3NwTm9uY2VcIixcclxuICAgICAgICBcInRyYW5zbGF0ZVpcIixcclxuICAgICAgICBcImhpZGVEZWZhdWx0TGluZXNcIixcclxuICAgICAgICBcInByb3BzXCIsXHJcbiAgICAgICAgXCJmbHVzaFN5bmNcIixcclxuICAgICAgICBcInN0b3BQcm9wYWdhdGlvblwiLFxyXG4gICAgICAgIFwicHJldmVudENsaWNrRXZlbnRPbkRyYWdcIixcclxuICAgICAgICBcInByZXZlbnRDbGlja0RlZmF1bHRcIixcclxuICAgICAgICBcInZpZXdDb250YWluZXJcIixcclxuICAgICAgICBcInBlcnNpc3REYXRhXCIsXHJcbiAgICAgICAgXCJ1c2VBY2N1cmF0ZVBvc2l0aW9uXCIsXHJcbiAgICAgICAgXCJmaXJzdFJlbmRlclN0YXRlXCIsXHJcbiAgICAgICAgXCJsaW5lUGFkZGluZ1wiLFxyXG4gICAgICAgIFwiY29udHJvbFBhZGRpbmdcIixcclxuICAgICAgICBcInByZXZlbnREZWZhdWx0XCIsXHJcbiAgICAgICAgXCJwcmV2ZW50UmlnaHRDbGlja1wiLFxyXG4gICAgICAgIFwicHJldmVudFdoZWVsQ2xpY2tcIixcclxuICAgICAgICBcInJlcXVlc3RTdHlsZXNcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcImNoYW5nZVRhcmdldHNcIixcclxuICAgIF0sXHJcbn07XG5cbnZhciBQYWRkaW5nID0gbWFrZUFibGUoXCJwYWRkaW5nXCIsIHtcclxuICAgIHByb3BzOiBbXCJwYWRkaW5nXCJdLFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICAgICAgaWYgKHByb3BzLmRyYWdBcmVhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9hID0gZ2V0UGFkZGluZ0JveChwcm9wcy5wYWRkaW5nIHx8IHt9KSwgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcCwgcmlnaHQgPSBfYS5yaWdodCwgYm90dG9tID0gX2EuYm90dG9tO1xyXG4gICAgICAgIHZhciBfYiA9IG1vdmVhYmxlLmdldFN0YXRlKCksIHJlbmRlclBvc2VzID0gX2IucmVuZGVyUG9zZXMsIHBvczEgPSBfYi5wb3MxLCBwb3MyID0gX2IucG9zMiwgcG9zMyA9IF9iLnBvczMsIHBvczQgPSBfYi5wb3M0O1xyXG4gICAgICAgIHZhciBwb3NlcyA9IFtwb3MxLCBwb3MyLCBwb3MzLCBwb3M0XTtcclxuICAgICAgICB2YXIgcGFkZGluZ0RpcmVjdGlvbnMgPSBbXTtcclxuICAgICAgICBpZiAobGVmdCA+IDApIHtcclxuICAgICAgICAgICAgcGFkZGluZ0RpcmVjdGlvbnMucHVzaChbMCwgMl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9wID4gMCkge1xyXG4gICAgICAgICAgICBwYWRkaW5nRGlyZWN0aW9ucy5wdXNoKFswLCAxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyaWdodCA+IDApIHtcclxuICAgICAgICAgICAgcGFkZGluZ0RpcmVjdGlvbnMucHVzaChbMSwgM10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYm90dG9tID4gMCkge1xyXG4gICAgICAgICAgICBwYWRkaW5nRGlyZWN0aW9ucy5wdXNoKFsyLCAzXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYWRkaW5nRGlyZWN0aW9ucy5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGRpcjEgPSBfYlswXSwgZGlyMiA9IF9iWzFdO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1BvczEgPSBwb3Nlc1tkaXIxXTtcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmdQb3MyID0gcG9zZXNbZGlyMl07XHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nUG9zMyA9IHJlbmRlclBvc2VzW2RpcjFdO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1BvczQgPSByZW5kZXJQb3Nlc1tkaXIyXTtcclxuICAgICAgICAgICAgdmFyIGggPSBjcmVhdGVXYXJwTWF0cml4KFswLCAwXSwgWzEwMCwgMF0sIFswLCAxMDBdLCBbMTAwLCAxMDBdLCBwYWRkaW5nUG9zMSwgcGFkZGluZ1BvczIsIHBhZGRpbmdQb3MzLCBwYWRkaW5nUG9zNCk7XHJcbiAgICAgICAgICAgIGlmICghaC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcInBhZGRpbmdcIi5jb25jYXQoaSksIGNsYXNzTmFtZTogcHJlZml4KFwicGFkZGluZ1wiKSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IG1ha2VNYXRyaXhDU1MoaCwgdHJ1ZSksXHJcbiAgICAgICAgICAgICAgICB9IH0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbn0pO1xyXG4vKipcclxuICogQWRkIHBhZGRpbmcgYXJvdW5kIHRoZSB0YXJnZXQgdG8gaW5jcmVhc2UgdGhlIGRyYWcgYXJlYS5cclxuICogQG5hbWUgTW92ZWFibGUjcGFkZGluZ1xyXG4gKiBAZGVmYXVsdCBudWxsXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgdGFyZ2V0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKSxcclxuICogIHBhZGRpbmc6IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwIH0sXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5wYWRkaW5nID0geyBsZWZ0OiAxMCwgdG9wOiAxMCwgcmlnaHQ6IDEwLCBib3R0b206IDEwIH0sXHJcbiAqIG1vdmVhYmxlLnVwZGF0ZVJlY3QoKTtcclxuICovXG5cbnZhciBSQURJVVNfRElSRUNUSU9OUyA9IFtcIm53XCIsIFwibmVcIiwgXCJzZVwiLCBcInN3XCJdO1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVSYXRpbyh2YWx1ZXMsIHNpemUpIHtcclxuICAgIHZhciBzdW1TaXplID0gdmFsdWVzWzBdICsgdmFsdWVzWzFdO1xyXG4gICAgdmFyIHN1bVJhdGlvID0gc3VtU2l6ZSA+IHNpemUgPyBzaXplIC8gc3VtU2l6ZSA6IDE7XHJcbiAgICB2YWx1ZXNbMF0gKj0gc3VtUmF0aW87XHJcbiAgICB2YWx1ZXNbMV0gPSBzaXplIC0gdmFsdWVzWzFdICogc3VtUmF0aW87XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG59XHJcbnZhciBIT1JJWk9OVEFMX1JBRElVU19PUkRFUiA9IFsxLCAyLCA1LCA2XTtcclxudmFyIFZFUlRJQ0FMX1JBRElVU19PUkRFUiA9IFswLCAzLCA0LCA3XTtcclxudmFyIEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlMgPSBbMSwgLTEsIC0xLCAxXTtcclxudmFyIFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TID0gWzEsIDEsIC0xLCAtMV07XHJcbmZ1bmN0aW9uIGdldFJhZGl1c1N0eWxlcyhuZXh0UG9zZXMsIGlzUmVsYXRpdmUsIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xyXG4gICAgaWYgKGxlZnQgPT09IHZvaWQgMCkgeyBsZWZ0ID0gMDsgfVxyXG4gICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7IHRvcCA9IDA7IH1cclxuICAgIGlmIChyaWdodCA9PT0gdm9pZCAwKSB7IHJpZ2h0ID0gd2lkdGg7IH1cclxuICAgIGlmIChib3R0b20gPT09IHZvaWQgMCkgeyBib3R0b20gPSBoZWlnaHQ7IH1cclxuICAgIHZhciBjbGlwU3R5bGVzID0gW107XHJcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgdmFyIHJhZGl1c1Bvc2VzID0gbmV4dFBvc2VzLmZpbHRlcihmdW5jdGlvbiAocG9zKSB7IHJldHVybiAhcG9zLnZpcnR1YWw7IH0pO1xyXG4gICAgdmFyIHJhd3MgPSByYWRpdXNQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvc0luZm8pIHtcclxuICAgICAgICB2YXIgaG9yaXpvbnRhbCA9IHBvc0luZm8uaG9yaXpvbnRhbCwgdmVydGljYWwgPSBwb3NJbmZvLnZlcnRpY2FsLCBwb3MgPSBwb3NJbmZvLnBvcztcclxuICAgICAgICBpZiAodmVydGljYWwgJiYgIWlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgaXNWZXJ0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNsaXBTdHlsZXMucHVzaChcIi9cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIHZhciByYXdQb3MgPSBNYXRoLm1heCgwLCB2ZXJ0aWNhbCA9PT0gMSA/IHBvc1sxXSAtIHRvcCA6IGJvdHRvbSAtIHBvc1sxXSk7XHJcbiAgICAgICAgICAgIGNsaXBTdHlsZXMucHVzaChjb252ZXJ0Q1NTU2l6ZShyYXdQb3MsIGhlaWdodCwgaXNSZWxhdGl2ZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmF3UG9zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJhd1BvcyA9IE1hdGgubWF4KDAsIGhvcml6b250YWwgPT09IDEgPyBwb3NbMF0gLSBsZWZ0IDogcmlnaHQgLSBwb3NbMF0pO1xyXG4gICAgICAgICAgICBjbGlwU3R5bGVzLnB1c2goY29udmVydENTU1NpemUocmF3UG9zLCB3aWR0aCwgaXNSZWxhdGl2ZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmF3UG9zO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByYWRpdXNQb3NlczogcmFkaXVzUG9zZXMsXHJcbiAgICAgICAgc3R5bGVzOiBjbGlwU3R5bGVzLFxyXG4gICAgICAgIHJhd3M6IHJhd3MsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFJhZGl1c1JhbmdlKGNvbnRyb2xQb3Nlcykge1xyXG4gICAgLy8gW3N0YXJ0LCBsZW5ndGhdXHJcbiAgICB2YXIgaG9yaXpvbnRhbFJhbmdlID0gWzAsIDBdO1xyXG4gICAgdmFyIHZlcnRpY2FsUmFuZ2UgPSBbMCwgMF07XHJcbiAgICB2YXIgbGVuZ3RoID0gY29udHJvbFBvc2VzLmxlbmd0aDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgY2xpcFBvc2UgPSBjb250cm9sUG9zZXNbaV07XHJcbiAgICAgICAgaWYgKCFjbGlwUG9zZS5zdWIpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGlwUG9zZS5ob3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsUmFuZ2VbMV0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWxSYW5nZVswXSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaG9yaXpvbnRhbFJhbmdlWzFdID0gaSAtIGhvcml6b250YWxSYW5nZVswXSArIDE7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsUmFuZ2VbMF0gPSBpICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsaXBQb3NlLnZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbFJhbmdlWzFdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFJhbmdlWzBdID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2ZXJ0aWNhbFJhbmdlWzFdID0gaSAtIHZlcnRpY2FsUmFuZ2VbMF0gKyAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaG9yaXpvbnRhbFJhbmdlOiBob3Jpem9udGFsUmFuZ2UsXHJcbiAgICAgICAgdmVydGljYWxSYW5nZTogdmVydGljYWxSYW5nZSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmFkaXVzVmFsdWVzKHZhbHVlcywgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCBtaW5Db3VudHMsIGZ1bGwpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgIGlmIChtaW5Db3VudHMgPT09IHZvaWQgMCkgeyBtaW5Db3VudHMgPSBbMCwgMF07IH1cclxuICAgIGlmIChmdWxsID09PSB2b2lkIDApIHsgZnVsbCA9IGZhbHNlOyB9XHJcbiAgICB2YXIgc3BsaXRJbmRleCA9IHZhbHVlcy5pbmRleE9mKFwiL1wiKTtcclxuICAgIHZhciBzcGxpdExlbmd0aCA9IChzcGxpdEluZGV4ID4gLTEgPyB2YWx1ZXMuc2xpY2UoMCwgc3BsaXRJbmRleCkgOiB2YWx1ZXMpLmxlbmd0aDtcclxuICAgIHZhciBob3Jpem9udGFsVmFsdWVzID0gdmFsdWVzLnNsaWNlKDAsIHNwbGl0TGVuZ3RoKTtcclxuICAgIHZhciB2ZXJ0aWNhbFZhbHVlcyA9IHZhbHVlcy5zbGljZShzcGxpdExlbmd0aCArIDEpO1xyXG4gICAgdmFyIGhvcml6b250YWxWYWx1ZXNMZW5ndGggPSBob3Jpem9udGFsVmFsdWVzLmxlbmd0aDtcclxuICAgIHZhciB2ZXJ0aWNhbFZhbHVlc0xlbmd0aCA9IHZlcnRpY2FsVmFsdWVzLmxlbmd0aDtcclxuICAgIHZhciBoYXNWZXJ0aWNhbFZhbHVlcyA9IHZlcnRpY2FsVmFsdWVzTGVuZ3RoID4gMDtcclxuICAgIHZhciBfZSA9IF9fcmVhZChob3Jpem9udGFsVmFsdWVzLCA0KSwgX2YgPSBfZVswXSwgbndWYWx1ZSA9IF9mID09PSB2b2lkIDAgPyBcIjBweFwiIDogX2YsIF9nID0gX2VbMV0sIG5lVmFsdWUgPSBfZyA9PT0gdm9pZCAwID8gbndWYWx1ZSA6IF9nLCBfaCA9IF9lWzJdLCBzZVZhbHVlID0gX2ggPT09IHZvaWQgMCA/IG53VmFsdWUgOiBfaCwgX2ogPSBfZVszXSwgc3dWYWx1ZSA9IF9qID09PSB2b2lkIDAgPyBuZVZhbHVlIDogX2o7XHJcbiAgICB2YXIgX2sgPSBfX3JlYWQodmVydGljYWxWYWx1ZXMsIDQpLCBfbCA9IF9rWzBdLCB3blZhbHVlID0gX2wgPT09IHZvaWQgMCA/IG53VmFsdWUgOiBfbCwgX20gPSBfa1sxXSwgZW5WYWx1ZSA9IF9tID09PSB2b2lkIDAgPyBoYXNWZXJ0aWNhbFZhbHVlcyA/IHduVmFsdWUgOiBuZVZhbHVlIDogX20sIF9vID0gX2tbMl0sIGVzVmFsdWUgPSBfbyA9PT0gdm9pZCAwID8gaGFzVmVydGljYWxWYWx1ZXMgPyB3blZhbHVlIDogc2VWYWx1ZSA6IF9vLCBfcCA9IF9rWzNdLCB3c1ZhbHVlID0gX3AgPT09IHZvaWQgMCA/IGhhc1ZlcnRpY2FsVmFsdWVzID8gZW5WYWx1ZSA6IHN3VmFsdWUgOiBfcDtcclxuICAgIHZhciBob3Jpem9udGFsUmF3UG9zZXMgPSBbbndWYWx1ZSwgbmVWYWx1ZSwgc2VWYWx1ZSwgc3dWYWx1ZV0ubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIGNvbnZlcnRVbml0U2l6ZShwb3MsIHdpZHRoKTsgfSk7XHJcbiAgICB2YXIgdmVydGljYWxSYXdQb3NlcyA9IFt3blZhbHVlLCBlblZhbHVlLCBlc1ZhbHVlLCB3c1ZhbHVlXS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gY29udmVydFVuaXRTaXplKHBvcywgaGVpZ2h0KTsgfSk7XHJcbiAgICB2YXIgaG9yaXpvbnRhbFBvc2VzID0gaG9yaXpvbnRhbFJhd1Bvc2VzLnNsaWNlKCk7XHJcbiAgICB2YXIgdmVydGljYWxQb3NlcyA9IHZlcnRpY2FsUmF3UG9zZXMuc2xpY2UoKTtcclxuICAgIF9hID0gX19yZWFkKGNhbGN1bGF0ZVJhdGlvKFtob3Jpem9udGFsUG9zZXNbMF0sIGhvcml6b250YWxQb3Nlc1sxXV0sIHdpZHRoKSwgMiksIGhvcml6b250YWxQb3Nlc1swXSA9IF9hWzBdLCBob3Jpem9udGFsUG9zZXNbMV0gPSBfYVsxXTtcclxuICAgIF9iID0gX19yZWFkKGNhbGN1bGF0ZVJhdGlvKFtob3Jpem9udGFsUG9zZXNbM10sIGhvcml6b250YWxQb3Nlc1syXV0sIHdpZHRoKSwgMiksIGhvcml6b250YWxQb3Nlc1szXSA9IF9iWzBdLCBob3Jpem9udGFsUG9zZXNbMl0gPSBfYlsxXTtcclxuICAgIF9jID0gX19yZWFkKGNhbGN1bGF0ZVJhdGlvKFt2ZXJ0aWNhbFBvc2VzWzBdLCB2ZXJ0aWNhbFBvc2VzWzNdXSwgaGVpZ2h0KSwgMiksIHZlcnRpY2FsUG9zZXNbMF0gPSBfY1swXSwgdmVydGljYWxQb3Nlc1szXSA9IF9jWzFdO1xyXG4gICAgX2QgPSBfX3JlYWQoY2FsY3VsYXRlUmF0aW8oW3ZlcnRpY2FsUG9zZXNbMV0sIHZlcnRpY2FsUG9zZXNbMl1dLCBoZWlnaHQpLCAyKSwgdmVydGljYWxQb3Nlc1sxXSA9IF9kWzBdLCB2ZXJ0aWNhbFBvc2VzWzJdID0gX2RbMV07XHJcbiAgICB2YXIgbmV4dEhvcml6b250YWxQb3NlcyA9IGZ1bGxcclxuICAgICAgICA/IGhvcml6b250YWxQb3Nlc1xyXG4gICAgICAgIDogaG9yaXpvbnRhbFBvc2VzLnNsaWNlKDAsIE1hdGgubWF4KG1pbkNvdW50c1swXSwgaG9yaXpvbnRhbFZhbHVlc0xlbmd0aCkpO1xyXG4gICAgdmFyIG5leHRWZXJ0aWNhbFBvc2VzID0gZnVsbFxyXG4gICAgICAgID8gdmVydGljYWxQb3Nlc1xyXG4gICAgICAgIDogdmVydGljYWxQb3Nlcy5zbGljZSgwLCBNYXRoLm1heChtaW5Db3VudHNbMV0sIHZlcnRpY2FsVmFsdWVzTGVuZ3RoKSk7XHJcbiAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobmV4dEhvcml6b250YWxQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBSQURJVVNfRElSRUNUSU9OU1tpXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2aXJ0dWFsOiBpID49IGhvcml6b250YWxWYWx1ZXNMZW5ndGgsXHJcbiAgICAgICAgICAgIGhvcml6b250YWw6IEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0sXHJcbiAgICAgICAgICAgIHZlcnRpY2FsOiAwLFxyXG4gICAgICAgICAgICBwb3M6IFtsZWZ0ICsgcG9zLCB0b3AgKyAoVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xID8gaGVpZ2h0IDogMCldLFxyXG4gICAgICAgICAgICBzdWI6IHRydWUsXHJcbiAgICAgICAgICAgIHJhdzogaG9yaXpvbnRhbFJhd1Bvc2VzW2ldLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcclxuICAgICAgICB9O1xyXG4gICAgfSkpLCBmYWxzZSksIF9fcmVhZChuZXh0VmVydGljYWxQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBSQURJVVNfRElSRUNUSU9OU1tpXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2aXJ0dWFsOiBpID49IHZlcnRpY2FsVmFsdWVzTGVuZ3RoLFxyXG4gICAgICAgICAgICBob3Jpem9udGFsOiAwLFxyXG4gICAgICAgICAgICB2ZXJ0aWNhbDogVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0sXHJcbiAgICAgICAgICAgIHBvczogW2xlZnQgKyAoSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1tpXSA9PT0gLTEgPyB3aWR0aCA6IDApLCB0b3AgKyBwb3NdLFxyXG4gICAgICAgICAgICBzdWI6IHRydWUsXHJcbiAgICAgICAgICAgIHJhdzogdmVydGljYWxSYXdQb3Nlc1tpXSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXHJcbiAgICAgICAgfTtcclxuICAgIH0pKSwgZmFsc2UpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZVJhZGl1c1Bvcyhjb250cm9sUG9zZXMsIHBvc2VzLCBpbmRleCwgc3RhcnRJbmRleCwgbGVuZ3RoKSB7XHJcbiAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsgbGVuZ3RoID0gcG9zZXMubGVuZ3RoOyB9XHJcbiAgICB2YXIgX2EgPSBnZXRSYWRpdXNSYW5nZShjb250cm9sUG9zZXMuc2xpY2Uoc3RhcnRJbmRleCkpLCBob3Jpem9udGFsUmFuZ2UgPSBfYS5ob3Jpem9udGFsUmFuZ2UsIHZlcnRpY2FsUmFuZ2UgPSBfYS52ZXJ0aWNhbFJhbmdlO1xyXG4gICAgdmFyIHJhZGl1c2xJbmRleCA9IGluZGV4IC0gc3RhcnRJbmRleDtcclxuICAgIHZhciBkZWxldGVDb3VudCA9IDA7XHJcbiAgICBpZiAocmFkaXVzbEluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgZGVsZXRlQ291bnQgPSBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyYWRpdXNsSW5kZXggPiAwICYmIHJhZGl1c2xJbmRleCA8IGhvcml6b250YWxSYW5nZVsxXSkge1xyXG4gICAgICAgIGRlbGV0ZUNvdW50ID0gaG9yaXpvbnRhbFJhbmdlWzFdIC0gcmFkaXVzbEluZGV4O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmFkaXVzbEluZGV4ID49IHZlcnRpY2FsUmFuZ2VbMF0pIHtcclxuICAgICAgICBkZWxldGVDb3VudCA9IHZlcnRpY2FsUmFuZ2VbMF0gKyB2ZXJ0aWNhbFJhbmdlWzFdIC0gcmFkaXVzbEluZGV4O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29udHJvbFBvc2VzLnNwbGljZShpbmRleCwgZGVsZXRlQ291bnQpO1xyXG4gICAgcG9zZXMuc3BsaWNlKGluZGV4LCBkZWxldGVDb3VudCk7XHJcbn1cclxuZnVuY3Rpb24gYWRkUmFkaXVzUG9zKGNvbnRyb2xQb3NlcywgcG9zZXMsIHN0YXJ0SW5kZXgsIGhvcml6b250YWxJbmRleCwgdmVydGljYWxJbmRleCwgZGlzdFgsIGRpc3RZLCByaWdodCwgYm90dG9tLCBsZWZ0LCB0b3ApIHtcclxuICAgIGlmIChsZWZ0ID09PSB2b2lkIDApIHsgbGVmdCA9IDA7IH1cclxuICAgIGlmICh0b3AgPT09IHZvaWQgMCkgeyB0b3AgPSAwOyB9XHJcbiAgICB2YXIgX2EgPSBnZXRSYWRpdXNSYW5nZShjb250cm9sUG9zZXMuc2xpY2Uoc3RhcnRJbmRleCkpLCBob3Jpem9udGFsUmFuZ2UgPSBfYS5ob3Jpem9udGFsUmFuZ2UsIHZlcnRpY2FsUmFuZ2UgPSBfYS52ZXJ0aWNhbFJhbmdlO1xyXG4gICAgaWYgKGhvcml6b250YWxJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgdmFyIHJhZGl1c1ggPSBIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TW2hvcml6b250YWxJbmRleF0gPT09IDFcclxuICAgICAgICAgICAgPyBkaXN0WCAtIGxlZnRcclxuICAgICAgICAgICAgOiByaWdodCAtIGRpc3RYO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBob3Jpem9udGFsUmFuZ2VbMV07IGkgPD0gaG9yaXpvbnRhbEluZGV4OyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHkgPSBWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OU1tpXSA9PT0gMSA/IHRvcCA6IGJvdHRvbTtcclxuICAgICAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbEluZGV4ID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gZGlzdFg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgeCA9IGxlZnQgKyByYWRpdXNYO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gcmlnaHQgLSAocG9zZXNbc3RhcnRJbmRleF1bMF0gLSBsZWZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250cm9sUG9zZXMuc3BsaWNlKHN0YXJ0SW5kZXggKyBpLCAwLCB7XHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsOiBIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TW2ldLFxyXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IDAsXHJcbiAgICAgICAgICAgICAgICBwb3M6IFt4LCB5XSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHBvc2VzLnNwbGljZShzdGFydEluZGV4ICsgaSwgMCwgW3gsIHldKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmVydGljYWxJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgdmFyIHJhZGl1c1kgPSBWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OU1t2ZXJ0aWNhbEluZGV4XSA9PT0gMVxyXG4gICAgICAgICAgICA/IGRpc3RZIC0gdG9wXHJcbiAgICAgICAgICAgIDogYm90dG9tIC0gZGlzdFk7XHJcbiAgICAgICAgaWYgKGhvcml6b250YWxSYW5nZVsxXSA9PT0gMCAmJiB2ZXJ0aWNhbFJhbmdlWzFdID09PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBbXHJcbiAgICAgICAgICAgICAgICBsZWZ0ICsgcmFkaXVzWSxcclxuICAgICAgICAgICAgICAgIHRvcCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgY29udHJvbFBvc2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbDogSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1swXSxcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsOiAwLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBwb3MsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwb3Nlcy5wdXNoKHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydFZlcnRpY2FsSW5kZXggPSB2ZXJ0aWNhbFJhbmdlWzBdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB2ZXJ0aWNhbFJhbmdlWzFdOyBpIDw9IHZlcnRpY2FsSW5kZXg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IDEgPyBsZWZ0IDogcmlnaHQ7XHJcbiAgICAgICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsSW5kZXggPT09IGkpIHtcclxuICAgICAgICAgICAgICAgIHkgPSBkaXN0WTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gdG9wICsgcmFkaXVzWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OU1tpXSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHBvc2VzW3N0YXJ0SW5kZXggKyBzdGFydFZlcnRpY2FsSW5kZXhdWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgeSA9IGJvdHRvbSAtIChwb3Nlc1tzdGFydEluZGV4ICsgc3RhcnRWZXJ0aWNhbEluZGV4XVsxXSAtIHRvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udHJvbFBvc2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbDogMCxcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsOiBWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OU1tpXSxcclxuICAgICAgICAgICAgICAgIHBvczogW3gsIHldLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcG9zZXMucHVzaChbeCwgeV0pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3BsaXRSYWRpdXNQb3Nlcyhjb250cm9sUG9zZXMsIHJhd3MpIHtcclxuICAgIGlmIChyYXdzID09PSB2b2lkIDApIHsgcmF3cyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zLnJhdzsgfSk7IH1cclxuICAgIHZhciBob3Jpem9udGFscyA9IGNvbnRyb2xQb3Nlc1xyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBvcywgaSkgeyByZXR1cm4gcG9zLmhvcml6b250YWwgPyByYXdzW2ldIDogbnVsbDsgfSkuZmlsdGVyKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvcyAhPSBudWxsOyB9KTtcclxuICAgIHZhciB2ZXJ0aWNhbHMgPSBjb250cm9sUG9zZXNcclxuICAgICAgICAubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHsgcmV0dXJuIHBvcy52ZXJ0aWNhbCA/IHJhd3NbaV0gOiBudWxsOyB9KS5maWx0ZXIoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zICE9IG51bGw7IH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBob3Jpem9udGFsczogaG9yaXpvbnRhbHMsXHJcbiAgICAgICAgdmVydGljYWxzOiB2ZXJ0aWNhbHMsXHJcbiAgICB9O1xyXG59XG5cbnZhciBDTElQX0RJUkVDVElPTlMgPSBbXHJcbiAgICBbMCwgLTEsIFwiblwiXSxcclxuICAgIFsxLCAwLCBcImVcIl0sXHJcbl07XHJcbnZhciBDTElQX1JFQ1RfRElSRUNUSU9OUyA9IFtcclxuICAgIFstMSwgLTEsIFwibndcIl0sXHJcbiAgICBbMCwgLTEsIFwiblwiXSxcclxuICAgIFsxLCAtMSwgXCJuZVwiXSxcclxuICAgIFsxLCAwLCBcImVcIl0sXHJcbiAgICBbMSwgMSwgXCJzZVwiXSxcclxuICAgIFswLCAxLCBcInNcIl0sXHJcbiAgICBbLTEsIDEsIFwic3dcIl0sXHJcbiAgICBbLTEsIDAsIFwid1wiXSxcclxuXTtcclxuLy8gMSAyIDUgNiAwIDMgNCA3XHJcbi8vIDAgMSAyIDMgNCA1IDYgN1xyXG5mdW5jdGlvbiBnZXRDbGlwU3R5bGVzKG1vdmVhYmxlLCBjbGlwUGF0aCwgcG9zZXMpIHtcclxuICAgIHZhciBjbGlwUmVsYXRpdmUgPSBtb3ZlYWJsZS5wcm9wcy5jbGlwUmVsYXRpdmU7XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgdmFyIF9iID0gY2xpcFBhdGgsIGNsaXBUeXBlID0gX2IudHlwZSwgY2xpcFBvc2VzID0gX2IucG9zZXM7XHJcbiAgICB2YXIgaXNSZWN0ID0gY2xpcFR5cGUgPT09IFwicmVjdFwiO1xyXG4gICAgdmFyIGlzQ2lyY2xlID0gY2xpcFR5cGUgPT09IFwiY2lyY2xlXCI7XHJcbiAgICBpZiAoY2xpcFR5cGUgPT09IFwicG9seWdvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBcIlwiLmNvbmNhdChjb252ZXJ0Q1NTU2l6ZShwb3NbMF0sIHdpZHRoLCBjbGlwUmVsYXRpdmUpLCBcIiBcIikuY29uY2F0KGNvbnZlcnRDU1NTaXplKHBvc1sxXSwgaGVpZ2h0LCBjbGlwUmVsYXRpdmUpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlY3QgfHwgY2xpcFR5cGUgPT09IFwiaW5zZXRcIikge1xyXG4gICAgICAgIHZhciB0b3BfMSA9IHBvc2VzWzFdWzFdO1xyXG4gICAgICAgIHZhciByaWdodCA9IHBvc2VzWzNdWzBdO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gcG9zZXNbN11bMF07XHJcbiAgICAgICAgdmFyIGJvdHRvbSA9IHBvc2VzWzVdWzFdO1xyXG4gICAgICAgIGlmIChpc1JlY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIHRvcF8xLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQsXHJcbiAgICAgICAgICAgICAgICBib3R0b20sXHJcbiAgICAgICAgICAgICAgICBsZWZ0LFxyXG4gICAgICAgICAgICBdLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBcIlwiLmNvbmNhdChwb3MsIFwicHhcIik7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2xpcFN0eWxlcyA9IFt0b3BfMSwgd2lkdGggLSByaWdodCwgaGVpZ2h0IC0gYm90dG9tLCBsZWZ0XVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHsgcmV0dXJuIGNvbnZlcnRDU1NTaXplKHBvcywgaSAlIDIgPyB3aWR0aCA6IGhlaWdodCwgY2xpcFJlbGF0aXZlKTsgfSk7XHJcbiAgICAgICAgaWYgKHBvc2VzLmxlbmd0aCA+IDgpIHtcclxuICAgICAgICAgICAgdmFyIF9jID0gX19yZWFkKG1pbnVzKHBvc2VzWzRdLCBwb3Nlc1swXSksIDIpLCBzdWJXaWR0aCA9IF9jWzBdLCBzdWJIZWlnaHQgPSBfY1sxXTtcclxuICAgICAgICAgICAgY2xpcFN0eWxlcy5wdXNoLmFwcGx5KGNsaXBTdHlsZXMsIF9fc3ByZWFkQXJyYXkoW1wicm91bmRcIl0sIF9fcmVhZChnZXRSYWRpdXNTdHlsZXMoY2xpcFBvc2VzLnNsaWNlKDgpLm1hcChmdW5jdGlvbiAoaW5mbywgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbmZvKSwgeyBwb3M6IHBvc2VzW2ldIH0pO1xyXG4gICAgICAgICAgICB9KSwgY2xpcFJlbGF0aXZlLCBzdWJXaWR0aCwgc3ViSGVpZ2h0LCBsZWZ0LCB0b3BfMSwgcmlnaHQsIGJvdHRvbSkuc3R5bGVzKSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsaXBTdHlsZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0NpcmNsZSB8fCBjbGlwVHlwZSA9PT0gXCJlbGxpcHNlXCIpIHtcclxuICAgICAgICB2YXIgY2VudGVyID0gcG9zZXNbMF07XHJcbiAgICAgICAgdmFyIHJ5ID0gY29udmVydENTU1NpemUoYWJzKHBvc2VzWzFdWzFdIC0gY2VudGVyWzFdKSwgaXNDaXJjbGUgPyBNYXRoLnNxcnQoKHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpIC8gMikgOiBoZWlnaHQsIGNsaXBSZWxhdGl2ZSk7XHJcbiAgICAgICAgdmFyIGNsaXBTdHlsZXMgPSBpc0NpcmNsZSA/IFtyeV1cclxuICAgICAgICAgICAgOiBbY29udmVydENTU1NpemUoYWJzKHBvc2VzWzJdWzBdIC0gY2VudGVyWzBdKSwgd2lkdGgsIGNsaXBSZWxhdGl2ZSksIHJ5XTtcclxuICAgICAgICBjbGlwU3R5bGVzLnB1c2goXCJhdFwiLCBjb252ZXJ0Q1NTU2l6ZShjZW50ZXJbMF0sIHdpZHRoLCBjbGlwUmVsYXRpdmUpLCBjb252ZXJ0Q1NTU2l6ZShjZW50ZXJbMV0sIGhlaWdodCwgY2xpcFJlbGF0aXZlKSk7XHJcbiAgICAgICAgcmV0dXJuIGNsaXBTdHlsZXM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVjdFBvc2VzKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCkge1xyXG4gICAgdmFyIHhzID0gW2xlZnQsIChsZWZ0ICsgcmlnaHQpIC8gMiwgcmlnaHRdO1xyXG4gICAgdmFyIHlzID0gW3RvcCwgKHRvcCArIGJvdHRvbSkgLyAyLCBib3R0b21dO1xyXG4gICAgcmV0dXJuIENMSVBfUkVDVF9ESVJFQ1RJT05TLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDMpLCBkaXJ4ID0gX2JbMF0sIGRpcnkgPSBfYlsxXSwgZGlyID0gX2JbMl07XHJcbiAgICAgICAgdmFyIHggPSB4c1tkaXJ4ICsgMV07XHJcbiAgICAgICAgdmFyIHkgPSB5c1tkaXJ5ICsgMV07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVydGljYWw6IGFicyhkaXJ5KSxcclxuICAgICAgICAgICAgaG9yaXpvbnRhbDogYWJzKGRpcngpLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcixcclxuICAgICAgICAgICAgcG9zOiBbeCwgeV0sXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbnRyb2xTaXplKGNvbnRyb2xQb3Nlcykge1xyXG4gICAgdmFyIHhSYW5nZSA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcclxuICAgIHZhciB5UmFuZ2UgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XHJcbiAgICBjb250cm9sUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgcG9zID0gX2EucG9zO1xyXG4gICAgICAgIHhSYW5nZVswXSA9IE1hdGgubWluKHhSYW5nZVswXSwgcG9zWzBdKTtcclxuICAgICAgICB4UmFuZ2VbMV0gPSBNYXRoLm1heCh4UmFuZ2VbMV0sIHBvc1swXSk7XHJcbiAgICAgICAgeVJhbmdlWzBdID0gTWF0aC5taW4oeVJhbmdlWzBdLCBwb3NbMV0pO1xyXG4gICAgICAgIHlSYW5nZVsxXSA9IE1hdGgubWF4KHlSYW5nZVsxXSwgcG9zWzFdKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBhYnMoeFJhbmdlWzFdIC0geFJhbmdlWzBdKSxcclxuICAgICAgICBhYnMoeVJhbmdlWzFdIC0geVJhbmdlWzBdKSxcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2xpcFBhdGgodGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBkZWZhdWx0Q2xpcCwgY3VzdG9tQ2xpcCkge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XHJcbiAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBjbGlwVGV4dCA9IGN1c3RvbUNsaXA7XHJcbiAgICBpZiAoIWNsaXBUZXh0KSB7XHJcbiAgICAgICAgdmFyIGdldFN0eWxlID0gZ2V0Q2FjaGVkU3R5bGUodGFyZ2V0KTtcclxuICAgICAgICB2YXIgY2xpcFBhdGggPSBnZXRTdHlsZShcImNsaXBQYXRoXCIpO1xyXG4gICAgICAgIGNsaXBUZXh0ID0gY2xpcFBhdGggIT09IFwibm9uZVwiID8gY2xpcFBhdGggOiBnZXRTdHlsZShcImNsaXBcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNsaXBUZXh0IHx8IGNsaXBUZXh0ID09PSBcIm5vbmVcIiB8fCBjbGlwVGV4dCA9PT0gXCJhdXRvXCIpIHtcclxuICAgICAgICBjbGlwVGV4dCA9IGRlZmF1bHRDbGlwO1xyXG4gICAgICAgIGlmICghY2xpcFRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBfayA9IHNwbGl0QnJhY2tldChjbGlwVGV4dCksIF9sID0gX2sucHJlZml4LCBjbGlwUHJlZml4ID0gX2wgPT09IHZvaWQgMCA/IGNsaXBUZXh0IDogX2wsIF9tID0gX2sudmFsdWUsIHZhbHVlID0gX20gPT09IHZvaWQgMCA/IFwiXCIgOiBfbTtcclxuICAgIHZhciBpc0NpcmNsZSA9IGNsaXBQcmVmaXggPT09IFwiY2lyY2xlXCI7XHJcbiAgICB2YXIgc3BsaXR0ZXIgPSBcIiBcIjtcclxuICAgIGlmIChjbGlwUHJlZml4ID09PSBcInBvbHlnb25cIikge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBzcGxpdENvbW1hKHZhbHVlIHx8IFwiMCUgMCUsIDEwMCUgMCUsIDEwMCUgMTAwJSwgMCUgMTAwJVwiKTtcclxuICAgICAgICBzcGxpdHRlciA9IFwiLFwiO1xyXG4gICAgICAgIHZhciBwb3NlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQocG9zLnNwbGl0KFwiIFwiKSwgMiksIHhQb3MgPSBfYVswXSwgeVBvcyA9IF9hWzFdO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IDEsXHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsOiAxLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgY29udmVydFVuaXRTaXplKHhQb3MsIHdpZHRoKSxcclxuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0VW5pdFNpemUoeVBvcywgaGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG1pbk1heHMgPSBnZXRNaW5NYXhzKHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3MucG9zOyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogY2xpcFByZWZpeCxcclxuICAgICAgICAgICAgY2xpcFRleHQ6IGNsaXBUZXh0LFxyXG4gICAgICAgICAgICBwb3NlczogcG9zZXMsXHJcbiAgICAgICAgICAgIHNwbGl0dGVyOiBzcGxpdHRlcixcclxuICAgICAgICAgICAgbGVmdDogbWluTWF4cy5taW5YLFxyXG4gICAgICAgICAgICByaWdodDogbWluTWF4cy5tYXhYLFxyXG4gICAgICAgICAgICB0b3A6IG1pbk1heHMubWluWSxcclxuICAgICAgICAgICAgYm90dG9tOiBtaW5NYXhzLm1heFksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQ2lyY2xlIHx8IGNsaXBQcmVmaXggPT09IFwiZWxsaXBzZVwiKSB7XHJcbiAgICAgICAgdmFyIHhQb3MgPSBcIlwiO1xyXG4gICAgICAgIHZhciB5UG9zID0gXCJcIjtcclxuICAgICAgICB2YXIgcmFkaXVzWF8xID0gMDtcclxuICAgICAgICB2YXIgcmFkaXVzWV8xID0gMDtcclxuICAgICAgICB2YXIgdmFsdWVzID0gc3BsaXRTcGFjZSh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKGlzQ2lyY2xlKSB7XHJcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBcIlwiO1xyXG4gICAgICAgICAgICBfYSA9IF9fcmVhZCh2YWx1ZXMsIDQpLCBfYiA9IF9hWzBdLCByYWRpdXMgPSBfYiA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9iLCBfYyA9IF9hWzJdLCB4UG9zID0gX2MgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfYywgX2QgPSBfYVszXSwgeVBvcyA9IF9kID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2Q7XHJcbiAgICAgICAgICAgIHJhZGl1c1hfMSA9IGNvbnZlcnRVbml0U2l6ZShyYWRpdXMsIE1hdGguc3FydCgod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyKSk7XHJcbiAgICAgICAgICAgIHJhZGl1c1lfMSA9IHJhZGl1c1hfMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB4UmFkaXVzID0gXCJcIjtcclxuICAgICAgICAgICAgdmFyIHlSYWRpdXMgPSBcIlwiO1xyXG4gICAgICAgICAgICBfZSA9IF9fcmVhZCh2YWx1ZXMsIDUpLCBfZiA9IF9lWzBdLCB4UmFkaXVzID0gX2YgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfZiwgX2cgPSBfZVsxXSwgeVJhZGl1cyA9IF9nID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2csIF9oID0gX2VbM10sIHhQb3MgPSBfaCA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9oLCBfaiA9IF9lWzRdLCB5UG9zID0gX2ogPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfajtcclxuICAgICAgICAgICAgcmFkaXVzWF8xID0gY29udmVydFVuaXRTaXplKHhSYWRpdXMsIHdpZHRoKTtcclxuICAgICAgICAgICAgcmFkaXVzWV8xID0gY29udmVydFVuaXRTaXplKHlSYWRpdXMsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjZW50ZXJQb3NfMSA9IFtcclxuICAgICAgICAgICAgY29udmVydFVuaXRTaXplKHhQb3MsIHdpZHRoKSxcclxuICAgICAgICAgICAgY29udmVydFVuaXRTaXplKHlQb3MsIGhlaWdodCksXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgcG9zZXMgPSBfX3NwcmVhZEFycmF5KFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IDEsXHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsOiAxLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBjZW50ZXJQb3NfMSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJuZXN3XCIsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLCBfX3JlYWQoQ0xJUF9ESVJFQ1RJT05TLnNsaWNlKDAsIGlzQ2lyY2xlID8gMSA6IDIpLm1hcChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbDogYWJzKGRpclsxXSksXHJcbiAgICAgICAgICAgIGhvcml6b250YWw6IGRpclswXSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJbMl0sXHJcbiAgICAgICAgICAgIHN1YjogdHJ1ZSxcclxuICAgICAgICAgICAgcG9zOiBbXHJcbiAgICAgICAgICAgICAgICBjZW50ZXJQb3NfMVswXSArIGRpclswXSAqIHJhZGl1c1hfMSxcclxuICAgICAgICAgICAgICAgIGNlbnRlclBvc18xWzFdICsgZGlyWzFdICogcmFkaXVzWV8xLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH0pOyB9KSksIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBjbGlwUHJlZml4LFxyXG4gICAgICAgICAgICBjbGlwVGV4dDogY2xpcFRleHQsXHJcbiAgICAgICAgICAgIHJhZGl1c1g6IHJhZGl1c1hfMSxcclxuICAgICAgICAgICAgcmFkaXVzWTogcmFkaXVzWV8xLFxyXG4gICAgICAgICAgICBsZWZ0OiBjZW50ZXJQb3NfMVswXSAtIHJhZGl1c1hfMSxcclxuICAgICAgICAgICAgdG9wOiBjZW50ZXJQb3NfMVsxXSAtIHJhZGl1c1lfMSxcclxuICAgICAgICAgICAgcmlnaHQ6IGNlbnRlclBvc18xWzBdICsgcmFkaXVzWF8xLFxyXG4gICAgICAgICAgICBib3R0b206IGNlbnRlclBvc18xWzFdICsgcmFkaXVzWV8xLFxyXG4gICAgICAgICAgICBwb3NlczogcG9zZXMsXHJcbiAgICAgICAgICAgIHNwbGl0dGVyOiBzcGxpdHRlcixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2xpcFByZWZpeCA9PT0gXCJpbnNldFwiKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHNwbGl0U3BhY2UodmFsdWUgfHwgXCIwIDAgMCAwXCIpO1xyXG4gICAgICAgIHZhciByb3VuZEluZGV4ID0gdmFsdWVzLmluZGV4T2YoXCJyb3VuZFwiKTtcclxuICAgICAgICB2YXIgcmVjdExlbmd0aCA9IChyb3VuZEluZGV4ID4gLTEgPyB2YWx1ZXMuc2xpY2UoMCwgcm91bmRJbmRleCkgOiB2YWx1ZXMpLmxlbmd0aDtcclxuICAgICAgICB2YXIgcmFkaXVzVmFsdWVzID0gdmFsdWVzLnNsaWNlKHJlY3RMZW5ndGggKyAxKTtcclxuICAgICAgICB2YXIgX28gPSBfX3JlYWQodmFsdWVzLnNsaWNlKDAsIHJlY3RMZW5ndGgpLCA0KSwgdG9wVmFsdWUgPSBfb1swXSwgX3AgPSBfb1sxXSwgcmlnaHRWYWx1ZSA9IF9wID09PSB2b2lkIDAgPyB0b3BWYWx1ZSA6IF9wLCBfcSA9IF9vWzJdLCBib3R0b21WYWx1ZSA9IF9xID09PSB2b2lkIDAgPyB0b3BWYWx1ZSA6IF9xLCBfciA9IF9vWzNdLCBsZWZ0VmFsdWUgPSBfciA9PT0gdm9pZCAwID8gcmlnaHRWYWx1ZSA6IF9yO1xyXG4gICAgICAgIHZhciBfcyA9IF9fcmVhZChbdG9wVmFsdWUsIGJvdHRvbVZhbHVlXS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gY29udmVydFVuaXRTaXplKHBvcywgaGVpZ2h0KTsgfSksIDIpLCB0b3BfMiA9IF9zWzBdLCBib3R0b20gPSBfc1sxXTtcclxuICAgICAgICB2YXIgX3QgPSBfX3JlYWQoW2xlZnRWYWx1ZSwgcmlnaHRWYWx1ZV0ubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIGNvbnZlcnRVbml0U2l6ZShwb3MsIHdpZHRoKTsgfSksIDIpLCBsZWZ0ID0gX3RbMF0sIHJpZ2h0ID0gX3RbMV07XHJcbiAgICAgICAgdmFyIG5leHRSaWdodCA9IHdpZHRoIC0gcmlnaHQ7XHJcbiAgICAgICAgdmFyIG5leHRCb3R0b20gPSBoZWlnaHQgLSBib3R0b207XHJcbiAgICAgICAgdmFyIHJhZGl1c1Bvc2VzID0gZ2V0UmFkaXVzVmFsdWVzKHJhZGl1c1ZhbHVlcywgbmV4dFJpZ2h0IC0gbGVmdCwgbmV4dEJvdHRvbSAtIHRvcF8yLCBsZWZ0LCB0b3BfMik7XHJcbiAgICAgICAgdmFyIHBvc2VzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZ2V0UmVjdFBvc2VzKHRvcF8yLCBuZXh0UmlnaHQsIG5leHRCb3R0b20sIGxlZnQpKSwgZmFsc2UpLCBfX3JlYWQocmFkaXVzUG9zZXMpLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogXCJpbnNldFwiLFxyXG4gICAgICAgICAgICBjbGlwVGV4dDogY2xpcFRleHQsXHJcbiAgICAgICAgICAgIHBvc2VzOiBwb3NlcyxcclxuICAgICAgICAgICAgdG9wOiB0b3BfMixcclxuICAgICAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICAgICAgcmlnaHQ6IG5leHRSaWdodCxcclxuICAgICAgICAgICAgYm90dG9tOiBuZXh0Qm90dG9tLFxyXG4gICAgICAgICAgICByYWRpdXM6IHJhZGl1c1ZhbHVlcyxcclxuICAgICAgICAgICAgc3BsaXR0ZXI6IHNwbGl0dGVyLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjbGlwUHJlZml4ID09PSBcInJlY3RcIikge1xyXG4gICAgICAgIC8vIHRvcCByaWdodCBib3R0b20gbGVmdFxyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBzcGxpdENvbW1hKHZhbHVlIHx8IFwiMHB4LCBcIi5jb25jYXQod2lkdGgsIFwicHgsIFwiKS5jb25jYXQoaGVpZ2h0LCBcInB4LCAwcHhcIikpO1xyXG4gICAgICAgIHNwbGl0dGVyID0gXCIsXCI7XHJcbiAgICAgICAgdmFyIF91ID0gX19yZWFkKHZhbHVlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgICAgICB2YXIgcG9zVmFsdWUgPSBzcGxpdFVuaXQocG9zKS52YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc1ZhbHVlO1xyXG4gICAgICAgIH0pLCA0KSwgdG9wXzMgPSBfdVswXSwgcmlnaHQgPSBfdVsxXSwgYm90dG9tID0gX3VbMl0sIGxlZnQgPSBfdVszXTtcclxuICAgICAgICB2YXIgcG9zZXMgPSBnZXRSZWN0UG9zZXModG9wXzMsIHJpZ2h0LCBib3R0b20sIGxlZnQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwicmVjdFwiLFxyXG4gICAgICAgICAgICBjbGlwVGV4dDogY2xpcFRleHQsXHJcbiAgICAgICAgICAgIHBvc2VzOiBwb3NlcyxcclxuICAgICAgICAgICAgdG9wOiB0b3BfMyxcclxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxyXG4gICAgICAgICAgICBib3R0b206IGJvdHRvbSxcclxuICAgICAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXHJcbiAgICAgICAgICAgIHNwbGl0dGVyOiBzcGxpdHRlcixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG59XG5cbmZ1bmN0aW9uIG1vdmVDb250cm9sUG9zKGNvbnRyb2xQb3NlcywgaW5kZXgsIGRpc3QsIGlzUmVjdCwga2VlcFJhdGlvKSB7XHJcbiAgICB2YXIgX2EgPSBjb250cm9sUG9zZXNbaW5kZXhdLCBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb24sIHN1YiA9IF9hLnN1YjtcclxuICAgIHZhciBkaXN0cyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gWzAsIDBdOyB9KTtcclxuICAgIHZhciBkaXJlY3Rpb25zID0gZGlyZWN0aW9uID8gZGlyZWN0aW9uLnNwbGl0KFwiXCIpIDogW107XHJcbiAgICBpZiAoaXNSZWN0ICYmIGluZGV4IDwgOCkge1xyXG4gICAgICAgIHZhciB2ZXJ0aWNhbERpcmVjdGlvbnMgPSBkaXJlY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBkaXIgPT09IFwid1wiIHx8IGRpciA9PT0gXCJlXCI7IH0pO1xyXG4gICAgICAgIHZhciBob3Jpem9udGFsRGlyZWN0aW9ucyA9IGRpcmVjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpciA9PT0gXCJuXCIgfHwgZGlyID09PSBcInNcIjsgfSk7XHJcbiAgICAgICAgdmFyIHZlcnRpY2FsRGlyZWN0aW9uXzEgPSB2ZXJ0aWNhbERpcmVjdGlvbnNbMF07XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxEaXJlY3Rpb25fMSA9IGhvcml6b250YWxEaXJlY3Rpb25zWzBdO1xyXG4gICAgICAgIGRpc3RzW2luZGV4XSA9IGRpc3Q7XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKGdldENvbnRyb2xTaXplKGNvbnRyb2xQb3NlcyksIDIpLCB3aWR0aCA9IF9iWzBdLCBoZWlnaHQgPSBfYlsxXTtcclxuICAgICAgICB2YXIgcmF0aW8gPSB3aWR0aCAmJiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IDA7XHJcbiAgICAgICAgaWYgKHJhdGlvICYmIGtlZXBSYXRpbykge1xyXG4gICAgICAgICAgICAvLyAwIDEgMlxyXG4gICAgICAgICAgICAvLyA3ICAgM1xyXG4gICAgICAgICAgICAvLyA2IDUgNFxyXG4gICAgICAgICAgICB2YXIgZml4ZWRJbmRleCA9IChpbmRleCArIDQpICUgODtcclxuICAgICAgICAgICAgdmFyIGZpeGVkUG9zaXRpb24gPSBjb250cm9sUG9zZXNbZml4ZWRJbmRleF0ucG9zO1xyXG4gICAgICAgICAgICB2YXIgc2l6ZURpcmVjdGlvbiA9IFswLCAwXTtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKFwid1wiKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplRGlyZWN0aW9uWzBdID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoXCJlXCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHNpemVEaXJlY3Rpb25bMF0gPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24uaW5kZXhPZihcIm5cIikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZURpcmVjdGlvblsxXSA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbi5pbmRleE9mKFwic1wiKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplRGlyZWN0aW9uWzFdID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV4dERpc3QgPSBnZXRTaXplRGlzdEJ5RGlzdChbd2lkdGgsIGhlaWdodF0sIGRpc3QsIHJhdGlvLCBzaXplRGlyZWN0aW9uLCB0cnVlKTtcclxuICAgICAgICAgICAgdmFyIG5leHRXaWR0aCA9IHdpZHRoICsgbmV4dERpc3RbMF07XHJcbiAgICAgICAgICAgIHZhciBuZXh0SGVpZ2h0ID0gaGVpZ2h0ICsgbmV4dERpc3RbMV07XHJcbiAgICAgICAgICAgIHZhciB0b3BfMSA9IGZpeGVkUG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgIHZhciBib3R0b20gPSBmaXhlZFBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IGZpeGVkUG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IGZpeGVkUG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIGlmIChzaXplRGlyZWN0aW9uWzBdID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IHJpZ2h0IC0gbmV4dFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemVEaXJlY3Rpb25bMF0gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIG5leHRXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0IC0gbmV4dFdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQgKyBuZXh0V2lkdGggLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaXplRGlyZWN0aW9uWzFdID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdG9wXzEgPSBib3R0b20gLSBuZXh0SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemVEaXJlY3Rpb25bMV0gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHRvcF8xICsgbmV4dEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRvcF8xID0gYm90dG9tIC0gbmV4dEhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICBib3R0b20gPSB0b3BfMSArIG5leHRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5leHRDb250cm9sUG9zZXNfMSA9IGdldFJlY3RQb3Nlcyh0b3BfMSwgcmlnaHQsIGJvdHRvbSwgbGVmdCk7XHJcbiAgICAgICAgICAgIGNvbnRyb2xQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sUG9zZSwgaSkge1xyXG4gICAgICAgICAgICAgICAgZGlzdHNbaV1bMF0gPSBuZXh0Q29udHJvbFBvc2VzXzFbaV0ucG9zWzBdIC0gY29udHJvbFBvc2UucG9zWzBdO1xyXG4gICAgICAgICAgICAgICAgZGlzdHNbaV1bMV0gPSBuZXh0Q29udHJvbFBvc2VzXzFbaV0ucG9zWzFdIC0gY29udHJvbFBvc2UucG9zWzFdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sUG9zZSwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xEaXIgPSBjb250cm9sUG9zZS5kaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2xEaXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbERpci5pbmRleE9mKHZlcnRpY2FsRGlyZWN0aW9uXzEpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0c1tpXVswXSA9IGRpc3RbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbERpci5pbmRleE9mKGhvcml6b250YWxEaXJlY3Rpb25fMSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RzW2ldWzFdID0gZGlzdFsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbERpcmVjdGlvbl8xKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0c1sxXVswXSA9IGRpc3RbMF0gLyAyO1xyXG4gICAgICAgICAgICAgICAgZGlzdHNbNV1bMF0gPSBkaXN0WzBdIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbERpcmVjdGlvbl8xKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0c1szXVsxXSA9IGRpc3RbMV0gLyAyO1xyXG4gICAgICAgICAgICAgICAgZGlzdHNbN11bMV0gPSBkaXN0WzFdIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRpcmVjdGlvbiAmJiAhc3ViKSB7XHJcbiAgICAgICAgZGlyZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICAgICAgdmFyIGlzVmVydGljYWwgPSBkaXIgPT09IFwiblwiIHx8IGRpciA9PT0gXCJzXCI7XHJcbiAgICAgICAgICAgIGNvbnRyb2xQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sUG9zZSwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpckRpciA9IGNvbnRyb2xQb3NlLmRpcmVjdGlvbiwgZGlySG9yaXpvbnRhbCA9IGNvbnRyb2xQb3NlLmhvcml6b250YWwsIGRpclZlcnRpY2FsID0gY29udHJvbFBvc2UudmVydGljYWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpckRpciB8fCBkaXJEaXIuaW5kZXhPZihkaXIpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRpc3RzW2ldID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIGlzVmVydGljYWwgfHwgIWRpckhvcml6b250YWwgPyAwIDogZGlzdFswXSxcclxuICAgICAgICAgICAgICAgICAgICAhaXNWZXJ0aWNhbCB8fCAhZGlyVmVydGljYWwgPyAwIDogZGlzdFsxXSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGlzdHNbaW5kZXhdID0gZGlzdDtcclxuICAgIH1cclxuICAgIHJldHVybiBkaXN0cztcclxufVxyXG5mdW5jdGlvbiBhZGRDbGlwUGF0aChtb3ZlYWJsZSwgZSkge1xyXG4gICAgdmFyIF9hID0gX19yZWFkKGNhbGN1bGF0ZVBvaW50ZXJEaXN0KG1vdmVhYmxlLCBlKSwgMiksIGRpc3RYID0gX2FbMF0sIGRpc3RZID0gX2FbMV07XHJcbiAgICB2YXIgX2IgPSBlLmRhdGFzLCBjbGlwUGF0aCA9IF9iLmNsaXBQYXRoLCBjbGlwSW5kZXggPSBfYi5jbGlwSW5kZXg7XHJcbiAgICB2YXIgX2MgPSBjbGlwUGF0aCwgY2xpcFR5cGUgPSBfYy50eXBlLCBjbGlwUG9zZXMgPSBfYy5wb3Nlcywgc3BsaXR0ZXIgPSBfYy5zcGxpdHRlcjtcclxuICAgIHZhciBwb3NlcyA9IGNsaXBQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zLnBvczsgfSk7XHJcbiAgICBpZiAoY2xpcFR5cGUgPT09IFwicG9seWdvblwiKSB7XHJcbiAgICAgICAgcG9zZXMuc3BsaWNlKGNsaXBJbmRleCwgMCwgW2Rpc3RYLCBkaXN0WV0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2xpcFR5cGUgPT09IFwiaW5zZXRcIikge1xyXG4gICAgICAgIHZhciBob3Jpem9udGFsSW5kZXggPSBIT1JJWk9OVEFMX1JBRElVU19PUkRFUi5pbmRleE9mKGNsaXBJbmRleCk7XHJcbiAgICAgICAgdmFyIHZlcnRpY2FsSW5kZXggPSBWRVJUSUNBTF9SQURJVVNfT1JERVIuaW5kZXhPZihjbGlwSW5kZXgpO1xyXG4gICAgICAgIHZhciBsZW5ndGhfMSA9IGNsaXBQb3Nlcy5sZW5ndGg7XHJcbiAgICAgICAgYWRkUmFkaXVzUG9zKGNsaXBQb3NlcywgcG9zZXMsIDgsIGhvcml6b250YWxJbmRleCwgdmVydGljYWxJbmRleCwgZGlzdFgsIGRpc3RZLCBwb3Nlc1s0XVswXSwgcG9zZXNbNF1bMV0sIHBvc2VzWzBdWzBdLCBwb3Nlc1swXVsxXSk7XHJcbiAgICAgICAgaWYgKGxlbmd0aF8xID09PSBjbGlwUG9zZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY2xpcFN0eWxlcyA9IGdldENsaXBTdHlsZXMobW92ZWFibGUsIGNsaXBQYXRoLCBwb3Nlcyk7XHJcbiAgICB2YXIgY2xpcFN0eWxlID0gXCJcIi5jb25jYXQoY2xpcFR5cGUsIFwiKFwiKS5jb25jYXQoY2xpcFN0eWxlcy5qb2luKHNwbGl0dGVyKSwgXCIpXCIpO1xyXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpcFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7IGNsaXBFdmVudFR5cGU6IFwiYWRkZWRcIiwgY2xpcFR5cGU6IGNsaXBUeXBlLCBwb3NlczogcG9zZXMsIGNsaXBTdHlsZXM6IGNsaXBTdHlsZXMsIGNsaXBTdHlsZTogY2xpcFN0eWxlLCBkaXN0WDogMCwgZGlzdFk6IDAgfSwgZmlsbENTU09iamVjdCh7XHJcbiAgICAgICAgY2xpcFBhdGg6IGNsaXBTdHlsZSxcclxuICAgIH0sIGUpKSkpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUNsaXBQYXRoKG1vdmVhYmxlLCBlKSB7XHJcbiAgICB2YXIgX2EgPSBlLmRhdGFzLCBjbGlwUGF0aCA9IF9hLmNsaXBQYXRoLCBjbGlwSW5kZXggPSBfYS5jbGlwSW5kZXg7XHJcbiAgICB2YXIgX2IgPSBjbGlwUGF0aCwgY2xpcFR5cGUgPSBfYi50eXBlLCBjbGlwUG9zZXMgPSBfYi5wb3Nlcywgc3BsaXR0ZXIgPSBfYi5zcGxpdHRlcjtcclxuICAgIHZhciBwb3NlcyA9IGNsaXBQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zLnBvczsgfSk7XHJcbiAgICB2YXIgbGVuZ3RoID0gcG9zZXMubGVuZ3RoO1xyXG4gICAgaWYgKGNsaXBUeXBlID09PSBcInBvbHlnb25cIikge1xyXG4gICAgICAgIGNsaXBQb3Nlcy5zcGxpY2UoY2xpcEluZGV4LCAxKTtcclxuICAgICAgICBwb3Nlcy5zcGxpY2UoY2xpcEluZGV4LCAxKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNsaXBUeXBlID09PSBcImluc2V0XCIpIHtcclxuICAgICAgICBpZiAoY2xpcEluZGV4IDwgOCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZVJhZGl1c1BvcyhjbGlwUG9zZXMsIHBvc2VzLCBjbGlwSW5kZXgsIDgsIGxlbmd0aCk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gY2xpcFBvc2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGNsaXBTdHlsZXMgPSBnZXRDbGlwU3R5bGVzKG1vdmVhYmxlLCBjbGlwUGF0aCwgcG9zZXMpO1xyXG4gICAgdmFyIGNsaXBTdHlsZSA9IFwiXCIuY29uY2F0KGNsaXBUeXBlLCBcIihcIikuY29uY2F0KGNsaXBTdHlsZXMuam9pbihzcGxpdHRlciksIFwiKVwiKTtcclxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oeyBjbGlwRXZlbnRUeXBlOiBcInJlbW92ZWRcIiwgY2xpcFR5cGU6IGNsaXBUeXBlLCBwb3NlczogcG9zZXMsIGNsaXBTdHlsZXM6IGNsaXBTdHlsZXMsIGNsaXBTdHlsZTogY2xpcFN0eWxlLCBkaXN0WDogMCwgZGlzdFk6IDAgfSwgZmlsbENTU09iamVjdCh7XHJcbiAgICAgICAgY2xpcFBhdGg6IGNsaXBTdHlsZSxcclxuICAgIH0sIGUpKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLkNsaXBwYWJsZVxyXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciB0byBjbGlwIHRoZSB0YXJnZXQuXHJcbiAqL1xyXG52YXIgQ2xpcHBhYmxlID0ge1xyXG4gICAgbmFtZTogXCJjbGlwcGFibGVcIixcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJjbGlwcGFibGVcIixcclxuICAgICAgICBcImRlZmF1bHRDbGlwUGF0aFwiLFxyXG4gICAgICAgIFwiY3VzdG9tQ2xpcFBhdGhcIixcclxuICAgICAgICBcImtlZXBSYXRpb1wiLFxyXG4gICAgICAgIFwiY2xpcFJlbGF0aXZlXCIsXHJcbiAgICAgICAgXCJjbGlwQXJlYVwiLFxyXG4gICAgICAgIFwiZHJhZ1dpdGhDbGlwXCIsXHJcbiAgICAgICAgXCJjbGlwVGFyZ2V0Qm91bmRzXCIsXHJcbiAgICAgICAgXCJjbGlwVmVydGljYWxHdWlkZWxpbmVzXCIsXHJcbiAgICAgICAgXCJjbGlwSG9yaXpvbnRhbEd1aWRlbGluZXNcIixcclxuICAgICAgICBcImNsaXBTbmFwVGhyZXNob2xkXCIsXHJcbiAgICBdLFxyXG4gICAgZXZlbnRzOiBbXHJcbiAgICAgICAgXCJjbGlwU3RhcnRcIixcclxuICAgICAgICBcImNsaXBcIixcclxuICAgICAgICBcImNsaXBFbmRcIixcclxuICAgIF0sXHJcbiAgICBjc3M6IFtcclxuICAgICAgICBcIi5jb250cm9sLmNsaXAtY29udHJvbCB7XFxuYmFja2dyb3VuZDogIzZkNjtcXG5jdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5jb250cm9sLmNsaXAtY29udHJvbC5jbGlwLXJhZGl1cyB7XFxuYmFja2dyb3VuZDogI2Q2NjtcXG59XFxuLmxpbmUuY2xpcC1saW5lIHtcXG5iYWNrZ3JvdW5kOiAjNmU2O1xcbmN1cnNvcjogbW92ZTtcXG56LWluZGV4OiAxO1xcbn1cXG4uY2xpcC1hcmVhIHtcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxudG9wOiAwO1xcbmxlZnQ6IDA7XFxufVxcbi5jbGlwLWVsbGlwc2Uge1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5jdXJzb3I6IG1vdmU7XFxuYm9yZGVyOiAxcHggc29saWQgIzZkNjtcXG5ib3JkZXI6IHZhcigtLXpvb21weCkgc29saWQgIzZkNjtcXG5ib3JkZXItcmFkaXVzOiA1MCU7XFxudHJhbnNmb3JtLW9yaWdpbjogMHB4IDBweDtcXG59XCIsXHJcbiAgICAgICAgXCI6aG9zdCB7XFxuLS1ib3VuZHMtY29sb3I6ICNkNjY7XFxufVwiLFxyXG4gICAgICAgIFwiLmd1aWRlbGluZSB7XFxucG9pbnRlci1ldmVudHM6IG5vbmU7XFxuei1pbmRleDogMjtcXG59XCIsXHJcbiAgICAgICAgXCIubGluZS5ndWlkZWxpbmUuYm91bmRzIHtcXG5iYWNrZ3JvdW5kOiAjZDY2O1xcbmJhY2tncm91bmQ6IHZhcigtLWJvdW5kcy1jb2xvcik7XFxufVwiLFxyXG4gICAgXSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLCBjdXN0b21DbGlwUGF0aCA9IF9hLmN1c3RvbUNsaXBQYXRoLCBkZWZhdWx0Q2xpcFBhdGggPSBfYS5kZWZhdWx0Q2xpcFBhdGgsIGNsaXBBcmVhID0gX2EuY2xpcEFyZWEsIHpvb20gPSBfYS56b29tLCBncm91cGFibGUgPSBfYS5ncm91cGFibGU7XHJcbiAgICAgICAgdmFyIF9iID0gbW92ZWFibGUuZ2V0U3RhdGUoKSwgdGFyZ2V0ID0gX2IudGFyZ2V0LCB3aWR0aCA9IF9iLndpZHRoLCBoZWlnaHQgPSBfYi5oZWlnaHQsIGFsbE1hdHJpeCA9IF9iLmFsbE1hdHJpeCwgaXMzZCA9IF9iLmlzM2QsIGxlZnQgPSBfYi5sZWZ0LCB0b3AgPSBfYi50b3AsIHBvczEgPSBfYi5wb3MxLCBwb3MyID0gX2IucG9zMiwgcG9zMyA9IF9iLnBvczMsIHBvczQgPSBfYi5wb3M0LCBjbGlwUGF0aFN0YXRlID0gX2IuY2xpcFBhdGhTdGF0ZSwgc25hcEJvdW5kSW5mb3MgPSBfYi5zbmFwQm91bmRJbmZvcywgcm90YXRpb25SYWQgPSBfYi5yb3RhdGlvbjtcclxuICAgICAgICBpZiAoIXRhcmdldCB8fCBncm91cGFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2xpcFBhdGggPSBnZXRDbGlwUGF0aCh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIGRlZmF1bHRDbGlwUGF0aCB8fCBcImluc2V0XCIsIGNsaXBQYXRoU3RhdGUgfHwgY3VzdG9tQ2xpcFBhdGgpO1xyXG4gICAgICAgIGlmICghY2xpcFBhdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgICAgICB2YXIgdHlwZSA9IGNsaXBQYXRoLnR5cGU7XHJcbiAgICAgICAgdmFyIGNsaXBQb3NlcyA9IGNsaXBQYXRoLnBvc2VzO1xyXG4gICAgICAgIHZhciBwb3NlcyA9IGNsaXBQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZFBvcyA9IGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgcG9zLnBvcywgbik7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkUG9zWzBdIC0gbGVmdCxcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRQb3NbMV0gLSB0b3AsXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGNvbnRyb2xzID0gW107XHJcbiAgICAgICAgdmFyIGxpbmVzID0gW107XHJcbiAgICAgICAgdmFyIGlzUmVjdCA9IHR5cGUgPT09IFwicmVjdFwiO1xyXG4gICAgICAgIHZhciBpc0luc2V0ID0gdHlwZSA9PT0gXCJpbnNldFwiO1xyXG4gICAgICAgIHZhciBpc1BvbHlnb24gPSB0eXBlID09PSBcInBvbHlnb25cIjtcclxuICAgICAgICBpZiAoaXNSZWN0IHx8IGlzSW5zZXQgfHwgaXNQb2x5Z29uKSB7XHJcbiAgICAgICAgICAgIHZhciBsaW5lUG9zZXNfMSA9IGlzSW5zZXQgPyBwb3Nlcy5zbGljZSgwLCA4KSA6IHBvc2VzO1xyXG4gICAgICAgICAgICBsaW5lcyA9IGxpbmVQb3Nlc18xLm1hcChmdW5jdGlvbiAodG8sIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gaSA9PT0gMCA/IGxpbmVQb3Nlc18xW2xpbmVQb3Nlc18xLmxlbmd0aCAtIDFdIDogbGluZVBvc2VzXzFbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhZCA9IGdldFJhZChmcm9tLCB0byk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGdldERpYWdvbmFsU2l6ZShmcm9tLCB0byk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogXCJjbGlwTGluZVwiLmNvbmNhdChpKSwgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lXCIsIFwiY2xpcC1saW5lXCIsIFwic25hcC1jb250cm9sXCIpLCBcImRhdGEtY2xpcC1pbmRleFwiOiBpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQoZGlzdCwgXCJweFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoZnJvbVswXSwgXCJweCwgXCIpLmNvbmNhdChmcm9tWzFdLCBcInB4KSByb3RhdGUoXCIpLmNvbmNhdChyYWQsIFwicmFkKSBzY2FsZVkoXCIpLmNvbmNhdCh6b29tLCBcIilcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRyb2xzID0gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IFwiY2xpcENvbnRyb2xcIi5jb25jYXQoaSksIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbFwiLCBcImNsaXAtY29udHJvbFwiLCBcInNuYXAtY29udHJvbFwiKSwgXCJkYXRhLWNsaXAtaW5kZXhcIjogaSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChwb3NbMF0sIFwicHgsIFwiKS5jb25jYXQocG9zWzFdLCBcInB4KSByb3RhdGUoXCIpLmNvbmNhdChyb3RhdGlvblJhZCwgXCJyYWQpIHNjYWxlKFwiKS5jb25jYXQoem9vbSwgXCIpXCIpLFxyXG4gICAgICAgICAgICAgICAgfSB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNJbnNldCkge1xyXG4gICAgICAgICAgICBjb250cm9scy5wdXNoLmFwcGx5KGNvbnRyb2xzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocG9zZXMuc2xpY2UoOCkubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcImNsaXBSYWRpdXNDb250cm9sXCIuY29uY2F0KGkpLCBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2xcIiwgXCJjbGlwLWNvbnRyb2xcIiwgXCJjbGlwLXJhZGl1c1wiLCBcInNuYXAtY29udHJvbFwiKSwgXCJkYXRhLWNsaXAtaW5kZXhcIjogOCArIGksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHBvc1swXSwgXCJweCwgXCIpLmNvbmNhdChwb3NbMV0sIFwicHgpIHJvdGF0ZShcIikuY29uY2F0KHJvdGF0aW9uUmFkLCBcInJhZCkgc2NhbGUoXCIpLmNvbmNhdCh6b29tLCBcIilcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KTtcclxuICAgICAgICAgICAgfSkpLCBmYWxzZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gXCJjaXJjbGVcIiB8fCB0eXBlID09PSBcImVsbGlwc2VcIikge1xyXG4gICAgICAgICAgICB2YXIgY2xpcExlZnQgPSBjbGlwUGF0aC5sZWZ0LCBjbGlwVG9wID0gY2xpcFBhdGgudG9wLCByYWRpdXNYID0gY2xpcFBhdGgucmFkaXVzWCwgcmFkaXVzWSA9IGNsaXBQYXRoLnJhZGl1c1k7XHJcbiAgICAgICAgICAgIHZhciBfYyA9IF9fcmVhZChtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIFtjbGlwTGVmdCwgY2xpcFRvcF0sIG4pLCBjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIFswLCAwXSwgbikpLCAyKSwgZGlzdExlZnQgPSBfY1swXSwgZGlzdFRvcCA9IF9jWzFdO1xyXG4gICAgICAgICAgICB2YXIgZWxsaXBzZUNsaXBQYXRoID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgIGlmICghY2xpcEFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwaWVjZSA9IE1hdGgubWF4KDEwLCByYWRpdXNYIC8gNSwgcmFkaXVzWSAvIDUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZWFQb3NlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGllY2U7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByYWQgPSBNYXRoLlBJICogMiAvIHBpZWNlICogaTtcclxuICAgICAgICAgICAgICAgICAgICBhcmVhUG9zZXMucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c1ggKyAocmFkaXVzWCAtIHpvb20pICogTWF0aC5jb3MocmFkKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzWSArIChyYWRpdXNZIC0gem9vbSkgKiBNYXRoLnNpbihyYWQpLFxyXG4gICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXJlYVBvc2VzLnB1c2goW3JhZGl1c1gsIC0yXSk7XHJcbiAgICAgICAgICAgICAgICBhcmVhUG9zZXMucHVzaChbLTIsIC0yXSk7XHJcbiAgICAgICAgICAgICAgICBhcmVhUG9zZXMucHVzaChbLTIsIHJhZGl1c1kgKiAyICsgMl0pO1xyXG4gICAgICAgICAgICAgICAgYXJlYVBvc2VzLnB1c2goW3JhZGl1c1ggKiAyICsgMiwgcmFkaXVzWSAqIDIgKyAyXSk7XHJcbiAgICAgICAgICAgICAgICBhcmVhUG9zZXMucHVzaChbcmFkaXVzWCAqIDIgKyAyLCAtMl0pO1xyXG4gICAgICAgICAgICAgICAgYXJlYVBvc2VzLnB1c2goW3JhZGl1c1gsIC0yXSk7XHJcbiAgICAgICAgICAgICAgICBlbGxpcHNlQ2xpcFBhdGggPSBcInBvbHlnb24oXCIuY29uY2F0KGFyZWFQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gXCJcIi5jb25jYXQocG9zWzBdLCBcInB4IFwiKS5jb25jYXQocG9zWzFdLCBcInB4XCIpOyB9KS5qb2luKFwiLCBcIiksIFwiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250cm9scy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IFwiY2xpcEVsbGlwc2VcIiwgY2xhc3NOYW1lOiBwcmVmaXgoXCJjbGlwLWVsbGlwc2VcIiwgXCJzbmFwLWNvbnRyb2xcIiksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHJhZGl1c1ggKiAyLCBcInB4XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQocmFkaXVzWSAqIDIsIFwicHhcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGg6IGVsbGlwc2VDbGlwUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdCgtbGVmdCArIGRpc3RMZWZ0LCBcInB4LCBcIikuY29uY2F0KC10b3AgKyBkaXN0VG9wLCBcInB4KSBcIikuY29uY2F0KG1ha2VNYXRyaXhDU1MoYWxsTWF0cml4KSksXHJcbiAgICAgICAgICAgICAgICB9IH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsaXBBcmVhKSB7XHJcbiAgICAgICAgICAgIHZhciBfZCA9IGdldFJlY3QoX19zcHJlYWRBcnJheShbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF0sIF9fcmVhZChwb3NlcyksIGZhbHNlKSksIGFsbFdpZHRoID0gX2Qud2lkdGgsIGFsbEhlaWdodCA9IF9kLmhlaWdodCwgYWxsTGVmdF8xID0gX2QubGVmdCwgYWxsVG9wXzEgPSBfZC50b3A7XHJcbiAgICAgICAgICAgIGlmIChpc1BvbHlnb24gfHwgaXNSZWN0IHx8IGlzSW5zZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmVhUG9zZXMgPSBpc0luc2V0ID8gcG9zZXMuc2xpY2UoMCwgOCkgOiBwb3NlcztcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogXCJjbGlwQXJlYVwiLCBjbGFzc05hbWU6IHByZWZpeChcImNsaXAtYXJlYVwiLCBcInNuYXAtY29udHJvbFwiKSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KGFsbFdpZHRoLCBcInB4XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGFsbEhlaWdodCwgXCJweFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoYWxsTGVmdF8xLCBcInB4LCBcIikuY29uY2F0KGFsbFRvcF8xLCBcInB4KVwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGg6IFwicG9seWdvbihcIi5jb25jYXQoYXJlYVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBcIlwiLmNvbmNhdChwb3NbMF0gLSBhbGxMZWZ0XzEsIFwicHggXCIpLmNvbmNhdChwb3NbMV0gLSBhbGxUb3BfMSwgXCJweFwiKTsgfSkuam9pbihcIiwgXCIpLCBcIilcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNuYXBCb3VuZEluZm9zKSB7XHJcbiAgICAgICAgICAgIFtcInZlcnRpY2FsXCIsIFwiaG9yaXpvbnRhbFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3Rpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHNuYXBCb3VuZEluZm9zW2RpcmVjdGlvblR5cGVdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvblR5cGUgPT09IFwiaG9yaXpvbnRhbFwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZm8uaXNTbmFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGluZm8uc25hcC5wb3NJbmZvcy5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBfYS5wb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbmFwUG9zMSA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgaXNIb3Jpem9udGFsID8gWzAsIHBvc10gOiBbcG9zLCAwXSwgbiksIFtsZWZ0LCB0b3BdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXBQb3MyID0gbWludXMoY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBpc0hvcml6b250YWwgPyBbd2lkdGgsIHBvc10gOiBbcG9zLCBoZWlnaHRdLCBuKSwgW2xlZnQsIHRvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyTGluZShSZWFjdCwgXCJcIiwgc25hcFBvczEsIHNuYXBQb3MyLCB6b29tLCBcImNsaXBcIi5jb25jYXQoZGlyZWN0aW9uVHlwZSwgXCJzbmFwXCIpLmNvbmNhdChpKSwgXCJndWlkZWxpbmVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGluZm8uaXNCb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2guYXBwbHkobGluZXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChpbmZvLmJvdW5kcy5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBfYS5wb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbmFwUG9zMSA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgaXNIb3Jpem9udGFsID8gWzAsIHBvc10gOiBbcG9zLCAwXSwgbiksIFtsZWZ0LCB0b3BdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXBQb3MyID0gbWludXMoY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBpc0hvcml6b250YWwgPyBbd2lkdGgsIHBvc10gOiBbcG9zLCBoZWlnaHRdLCBuKSwgW2xlZnQsIHRvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyTGluZShSZWFjdCwgXCJcIiwgc25hcFBvczEsIHNuYXBQb3MyLCB6b29tLCBcImNsaXBcIi5jb25jYXQoZGlyZWN0aW9uVHlwZSwgXCJib3VuZHNcIikuY29uY2F0KGkpLCBcImd1aWRlbGluZVwiLCBcImJvdW5kc1wiLCBcImJvbGRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGNvbnRyb2xzKSwgZmFsc2UpLCBfX3JlYWQobGluZXMpLCBmYWxzZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiBlLmlucHV0RXZlbnQgJiYgKGUuaW5wdXRFdmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIikuaW5kZXhPZihcImNsaXBcIikgPiAtMTtcclxuICAgIH0sXHJcbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xyXG4gICAgICAgIHZhciBfYSA9IHByb3BzLmRyYWdXaXRoQ2xpcCwgZHJhZ1dpdGhDbGlwID0gX2EgPT09IHZvaWQgMCA/IHRydWUgOiBfYTtcclxuICAgICAgICBpZiAoZHJhZ1dpdGhDbGlwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2xTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBpc0RyYWdUYXJnZXQ6IHRydWUgfSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdDb250cm9sRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgZGVmYXVsdENsaXBQYXRoID0gX2EuZGVmYXVsdENsaXBQYXRoLCBjdXN0b21DbGlwUGF0aCA9IF9hLmN1c3RvbUNsaXBQYXRoO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQsIHdpZHRoID0gc3RhdGUud2lkdGgsIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcclxuICAgICAgICB2YXIgaW5wdXRUYXJnZXQgPSBlLmlucHV0RXZlbnQgPyBlLmlucHV0RXZlbnQudGFyZ2V0IDogbnVsbDtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gKGlucHV0VGFyZ2V0ICYmIGlucHV0VGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKSB8fCBcIlwiO1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgdmFyIGNsaXBQYXRoID0gZ2V0Q2xpcFBhdGgodGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBkZWZhdWx0Q2xpcFBhdGggfHwgXCJpbnNldFwiLCBjdXN0b21DbGlwUGF0aCk7XHJcbiAgICAgICAgaWYgKCFjbGlwUGF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjbGlwVGV4dCA9IGNsaXBQYXRoLmNsaXBUZXh0LCB0eXBlID0gY2xpcFBhdGgudHlwZSwgcG9zZXMgPSBjbGlwUGF0aC5wb3NlcztcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpcFN0YXJ0XCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgY2xpcFR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIGNsaXBTdHlsZTogY2xpcFRleHQsXHJcbiAgICAgICAgICAgIHBvc2VzOiBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zLnBvczsgfSksXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLmlzQ2xpcFN0YXJ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMuaXNDb250cm9sID0gY2xhc3NOYW1lICYmIGNsYXNzTmFtZS5pbmRleE9mKFwiY2xpcC1jb250cm9sXCIpID4gLTE7XHJcbiAgICAgICAgZGF0YXMuaXNMaW5lID0gY2xhc3NOYW1lLmluZGV4T2YoXCJjbGlwLWxpbmVcIikgPiAtMTtcclxuICAgICAgICBkYXRhcy5pc0FyZWEgPSBjbGFzc05hbWUuaW5kZXhPZihcImNsaXAtYXJlYVwiKSA+IC0xIHx8IGNsYXNzTmFtZS5pbmRleE9mKFwiY2xpcC1lbGxpcHNlXCIpID4gLTE7XHJcbiAgICAgICAgZGF0YXMuY2xpcEluZGV4ID0gaW5wdXRUYXJnZXQgPyBwYXJzZUludChpbnB1dFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNsaXAtaW5kZXhcIiksIDEwKSA6IC0xO1xyXG4gICAgICAgIGRhdGFzLmNsaXBQYXRoID0gY2xpcFBhdGg7XHJcbiAgICAgICAgZGF0YXMuaXNDbGlwU3RhcnQgPSB0cnVlO1xyXG4gICAgICAgIHN0YXRlLmNsaXBQYXRoU3RhdGUgPSBjbGlwVGV4dDtcclxuICAgICAgICBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzLCBpc0RyYWdUYXJnZXQgPSBlLmlzRHJhZ1RhcmdldDtcclxuICAgICAgICBpZiAoIWRhdGFzLmlzQ2xpcFN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9kID0gZGF0YXMsIGlzQ29udHJvbCA9IF9kLmlzQ29udHJvbCwgaXNMaW5lID0gX2QuaXNMaW5lLCBpc0FyZWEgPSBfZC5pc0FyZWEsIGNsaXBJbmRleCA9IF9kLmNsaXBJbmRleCwgY2xpcFBhdGggPSBfZC5jbGlwUGF0aDtcclxuICAgICAgICBpZiAoIWNsaXBQYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByb3BzID0gZ2V0UHJvcHMobW92ZWFibGUucHJvcHMsIFwiY2xpcHBhYmxlXCIpO1xyXG4gICAgICAgIHZhciBrZWVwUmF0aW8gPSBwcm9wcy5rZWVwUmF0aW87XHJcbiAgICAgICAgdmFyIGRpc3RYID0gMDtcclxuICAgICAgICB2YXIgZGlzdFkgPSAwO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbERyYWdnYWJsZSA9IG9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbERpc3QgPSBnZXREcmFnRGlzdChlKTtcclxuICAgICAgICBpZiAoaXNEcmFnVGFyZ2V0ICYmIG9yaWdpbmFsRHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgIF9hID0gX19yZWFkKG9yaWdpbmFsRHJhZ2dhYmxlLnByZXZCZWZvcmVEaXN0LCAyKSwgZGlzdFggPSBfYVswXSwgZGlzdFkgPSBfYVsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9iID0gX19yZWFkKG9yaWdpbmFsRGlzdCwgMiksIGRpc3RYID0gX2JbMF0sIGRpc3RZID0gX2JbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXJzdERpc3QgPSBbZGlzdFgsIGRpc3RZXTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICB2YXIgd2lkdGggPSBzdGF0ZS53aWR0aCwgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBpc0RyYWdXaXRoVGFyZ2V0ID0gIWlzQXJlYSAmJiAhaXNDb250cm9sICYmICFpc0xpbmU7XHJcbiAgICAgICAgdmFyIGNsaXBUeXBlID0gY2xpcFBhdGgudHlwZSwgY2xpcFBvc2VzID0gY2xpcFBhdGgucG9zZXMsIHNwbGl0dGVyID0gY2xpcFBhdGguc3BsaXR0ZXI7XHJcbiAgICAgICAgdmFyIHBvc2VzID0gY2xpcFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3MucG9zOyB9KTtcclxuICAgICAgICBpZiAoaXNEcmFnV2l0aFRhcmdldCkge1xyXG4gICAgICAgICAgICBkaXN0WCA9IC1kaXN0WDtcclxuICAgICAgICAgICAgZGlzdFkgPSAtZGlzdFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpc0FsbCA9ICFpc0NvbnRyb2wgfHwgY2xpcFBvc2VzW2NsaXBJbmRleF0uZGlyZWN0aW9uID09PSBcIm5lc3dcIjtcclxuICAgICAgICB2YXIgaXNSZWN0ID0gY2xpcFR5cGUgPT09IFwiaW5zZXRcIiB8fCBjbGlwVHlwZSA9PT0gXCJyZWN0XCI7XHJcbiAgICAgICAgdmFyIGRpc3RzID0gY2xpcFBvc2VzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBbMCwgMF07IH0pO1xyXG4gICAgICAgIGlmIChpc0NvbnRyb2wgJiYgIWlzQWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBfZSA9IGNsaXBQb3Nlc1tjbGlwSW5kZXhdLCBob3Jpem9udGFsID0gX2UuaG9yaXpvbnRhbCwgdmVydGljYWwgPSBfZS52ZXJ0aWNhbDtcclxuICAgICAgICAgICAgdmFyIGRpc3QgPSBbXHJcbiAgICAgICAgICAgICAgICBkaXN0WCAqIGFicyhob3Jpem9udGFsKSxcclxuICAgICAgICAgICAgICAgIGRpc3RZICogYWJzKHZlcnRpY2FsKSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgZGlzdHMgPSBtb3ZlQ29udHJvbFBvcyhjbGlwUG9zZXMsIGNsaXBJbmRleCwgZGlzdCwgaXNSZWN0LCBrZWVwUmF0aW8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0FsbCkge1xyXG4gICAgICAgICAgICBkaXN0cyA9IHBvc2VzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBbZGlzdFgsIGRpc3RZXTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXh0UG9zZXMgPSBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkgeyByZXR1cm4gcGx1cyhwb3MsIGRpc3RzW2ldKTsgfSk7XHJcbiAgICAgICAgdmFyIGd1aWRlUG9zZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobmV4dFBvc2VzKSwgZmFsc2UpO1xyXG4gICAgICAgIHN0YXRlLnNuYXBCb3VuZEluZm9zID0gbnVsbDtcclxuICAgICAgICB2YXIgaXNDaXJjbGUgPSBjbGlwUGF0aC50eXBlID09PSBcImNpcmNsZVwiO1xyXG4gICAgICAgIHZhciBpc0VsbGlwc2UgPSBjbGlwUGF0aC50eXBlID09PSBcImVsbGlwc2VcIjtcclxuICAgICAgICBpZiAoaXNDaXJjbGUgfHwgaXNFbGxpcHNlKSB7XHJcbiAgICAgICAgICAgIHZhciBndWlkZVJlY3QgPSBnZXRSZWN0KG5leHRQb3Nlcyk7XHJcbiAgICAgICAgICAgIHZhciByeSA9IGFicyhndWlkZVJlY3QuYm90dG9tIC0gZ3VpZGVSZWN0LnRvcCk7XHJcbiAgICAgICAgICAgIHZhciByeCA9IGFicyhpc0VsbGlwc2UgPyBndWlkZVJlY3QucmlnaHQgLSBndWlkZVJlY3QubGVmdCA6IHJ5KTtcclxuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IG5leHRQb3Nlc1swXVsxXSArIHJ5O1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IG5leHRQb3Nlc1swXVswXSAtIHJ4O1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBuZXh0UG9zZXNbMF1bMF0gKyByeDtcclxuICAgICAgICAgICAgLy8gcmlnaHRcclxuICAgICAgICAgICAgaWYgKGlzQ2lyY2xlKSB7XHJcbiAgICAgICAgICAgICAgICBndWlkZVBvc2VzLnB1c2goW3JpZ2h0LCBndWlkZVJlY3QuYm90dG9tXSk7XHJcbiAgICAgICAgICAgICAgICBkaXN0cy5wdXNoKFsxLCAwXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYm90dG9tXHJcbiAgICAgICAgICAgIGd1aWRlUG9zZXMucHVzaChbZ3VpZGVSZWN0LmxlZnQsIGJvdHRvbV0pO1xyXG4gICAgICAgICAgICBkaXN0cy5wdXNoKFswLCAxXSk7XHJcbiAgICAgICAgICAgIC8vIGxlZnRcclxuICAgICAgICAgICAgZ3VpZGVQb3Nlcy5wdXNoKFtsZWZ0LCBndWlkZVJlY3QuYm90dG9tXSk7XHJcbiAgICAgICAgICAgIGRpc3RzLnB1c2goWzEsIDBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGd1aWRlbGluZXMgPSBnZXREZWZhdWx0R3VpZGVsaW5lcygocHJvcHMuY2xpcEhvcml6b250YWxHdWlkZWxpbmVzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGNvbnZlcnRVbml0U2l6ZShcIlwiLmNvbmNhdCh2KSwgaGVpZ2h0KTsgfSksIChwcm9wcy5jbGlwVmVydGljYWxHdWlkZWxpbmVzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGNvbnZlcnRVbml0U2l6ZShcIlwiLmNvbmNhdCh2KSwgd2lkdGgpOyB9KSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdmFyIGd1aWRlWFBvc2VzID0gW107XHJcbiAgICAgICAgdmFyIGd1aWRlWVBvc2VzID0gW107XHJcbiAgICAgICAgaWYgKGlzQ2lyY2xlIHx8IGlzRWxsaXBzZSkge1xyXG4gICAgICAgICAgICBndWlkZVhQb3NlcyA9IFtndWlkZVBvc2VzWzRdWzBdLCBndWlkZVBvc2VzWzJdWzBdXTtcclxuICAgICAgICAgICAgZ3VpZGVZUG9zZXMgPSBbZ3VpZGVQb3Nlc1sxXVsxXSwgZ3VpZGVQb3Nlc1szXVsxXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdFBvc2VzID0gW2d1aWRlUG9zZXNbMF0sIGd1aWRlUG9zZXNbMl0sIGd1aWRlUG9zZXNbNF0sIGd1aWRlUG9zZXNbNl1dO1xyXG4gICAgICAgICAgICB2YXIgcmVjdERpc3RzXzEgPSBbZGlzdHNbMF0sIGRpc3RzWzJdLCBkaXN0c1s0XSwgZGlzdHNbNl1dO1xyXG4gICAgICAgICAgICBndWlkZVhQb3NlcyA9IHJlY3RQb3Nlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIHJlY3REaXN0c18xW2ldWzBdOyB9KS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzBdOyB9KTtcclxuICAgICAgICAgICAgZ3VpZGVZUG9zZXMgPSByZWN0UG9zZXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiByZWN0RGlzdHNfMVtpXVsxXTsgfSkubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1sxXTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBndWlkZVhQb3NlcyA9IGd1aWRlUG9zZXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBkaXN0c1tpXVswXTsgfSkubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1swXTsgfSk7XHJcbiAgICAgICAgICAgIGd1aWRlWVBvc2VzID0gZ3VpZGVQb3Nlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIGRpc3RzW2ldWzFdOyB9KS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzFdOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJvdW5kRGVsdGEgPSBbMCwgMF07XHJcbiAgICAgICAgdmFyIF9mID0gY2hlY2tTbmFwQm91bmRzKGd1aWRlbGluZXMsIHByb3BzLmNsaXBUYXJnZXRCb3VuZHMgJiYgeyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiB3aWR0aCwgYm90dG9tOiBoZWlnaHQgfSwgZ3VpZGVYUG9zZXMsIGd1aWRlWVBvc2VzLCA1LCA1KSwgaG9yaXpvbnRhbFNuYXBJbmZvID0gX2YuaG9yaXpvbnRhbCwgdmVydGljYWxTbmFwSW5mbyA9IF9mLnZlcnRpY2FsO1xyXG4gICAgICAgIHZhciBzbmFwT2Zmc2V0WSA9IGhvcml6b250YWxTbmFwSW5mby5vZmZzZXQ7XHJcbiAgICAgICAgdmFyIHNuYXBPZmZzZXRYID0gdmVydGljYWxTbmFwSW5mby5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKGhvcml6b250YWxTbmFwSW5mby5pc0JvdW5kKSB7XHJcbiAgICAgICAgICAgIGJvdW5kRGVsdGFbMV0gKz0gc25hcE9mZnNldFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJ0aWNhbFNuYXBJbmZvLmlzQm91bmQpIHtcclxuICAgICAgICAgICAgYm91bmREZWx0YVswXSArPSBzbmFwT2Zmc2V0WDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChpc0VsbGlwc2UgfHwgaXNDaXJjbGUpICYmIGRpc3RzWzBdWzBdID09PSAwICYmIGRpc3RzWzBdWzFdID09PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBndWlkZVJlY3QgPSBnZXRSZWN0KG5leHRQb3Nlcyk7XHJcbiAgICAgICAgICAgIHZhciBjeSA9IGd1aWRlUmVjdC5ib3R0b20gLSBndWlkZVJlY3QudG9wO1xyXG4gICAgICAgICAgICB2YXIgY3ggPSBpc0VsbGlwc2UgPyBndWlkZVJlY3QucmlnaHQgLSBndWlkZVJlY3QubGVmdCA6IGN5O1xyXG4gICAgICAgICAgICB2YXIgZGlzdFNuYXBYID0gdmVydGljYWxTbmFwSW5mby5pc0JvdW5kXHJcbiAgICAgICAgICAgICAgICA/IGFicyhzbmFwT2Zmc2V0WClcclxuICAgICAgICAgICAgICAgIDogKHZlcnRpY2FsU25hcEluZm8uc25hcEluZGV4ID09PSAwID8gLXNuYXBPZmZzZXRYIDogc25hcE9mZnNldFgpO1xyXG4gICAgICAgICAgICB2YXIgZGlzdFNuYXBZID0gaG9yaXpvbnRhbFNuYXBJbmZvLmlzQm91bmRcclxuICAgICAgICAgICAgICAgID8gYWJzKHNuYXBPZmZzZXRZKVxyXG4gICAgICAgICAgICAgICAgOiAoaG9yaXpvbnRhbFNuYXBJbmZvLnNuYXBJbmRleCA9PT0gMCA/IC1zbmFwT2Zmc2V0WSA6IHNuYXBPZmZzZXRZKTtcclxuICAgICAgICAgICAgY3ggLT0gZGlzdFNuYXBYO1xyXG4gICAgICAgICAgICBjeSAtPSBkaXN0U25hcFk7XHJcbiAgICAgICAgICAgIGlmIChpc0NpcmNsZSkge1xyXG4gICAgICAgICAgICAgICAgY3kgPSBjaGVja1NuYXBCb3VuZFByaW9yaXR5KHZlcnRpY2FsU25hcEluZm8sIGhvcml6b250YWxTbmFwSW5mbykgPiAwID8gY3kgOiBjeDtcclxuICAgICAgICAgICAgICAgIGN4ID0gY3k7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IGd1aWRlUG9zZXNbMF07XHJcbiAgICAgICAgICAgIGd1aWRlUG9zZXNbMV1bMV0gPSBjZW50ZXJbMV0gLSBjeTtcclxuICAgICAgICAgICAgZ3VpZGVQb3Nlc1syXVswXSA9IGNlbnRlclswXSArIGN4O1xyXG4gICAgICAgICAgICBndWlkZVBvc2VzWzNdWzFdID0gY2VudGVyWzFdICsgY3k7XHJcbiAgICAgICAgICAgIGd1aWRlUG9zZXNbNF1bMF0gPSBjZW50ZXJbMF0gLSBjeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNSZWN0ICYmIGtlZXBSYXRpbyAmJiBpc0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgdmFyIF9nID0gX19yZWFkKGdldENvbnRyb2xTaXplKGNsaXBQb3NlcyksIDIpLCB3aWR0aF8xID0gX2dbMF0sIGhlaWdodF8xID0gX2dbMV07XHJcbiAgICAgICAgICAgIHZhciByYXRpbyA9IHdpZHRoXzEgJiYgaGVpZ2h0XzEgPyB3aWR0aF8xIC8gaGVpZ2h0XzEgOiAwO1xyXG4gICAgICAgICAgICB2YXIgY2xpcFBvc2UgPSBjbGlwUG9zZXNbY2xpcEluZGV4XTtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGNsaXBQb3NlLmRpcmVjdGlvbiB8fCBcIlwiO1xyXG4gICAgICAgICAgICB2YXIgdG9wXzIgPSBndWlkZVBvc2VzWzFdWzFdO1xyXG4gICAgICAgICAgICB2YXIgYm90dG9tID0gZ3VpZGVQb3Nlc1s1XVsxXTtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBndWlkZVBvc2VzWzddWzBdO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBndWlkZVBvc2VzWzNdWzBdO1xyXG4gICAgICAgICAgICBpZiAoYWJzKHNuYXBPZmZzZXRZKSA8PSBhYnMoc25hcE9mZnNldFgpKSB7XHJcbiAgICAgICAgICAgICAgICBzbmFwT2Zmc2V0WSA9IHNpZ24oc25hcE9mZnNldFkpICogYWJzKHNuYXBPZmZzZXRYKSAvIHJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc25hcE9mZnNldFggPSBzaWduKHNuYXBPZmZzZXRYKSAqIGFicyhzbmFwT2Zmc2V0WSkgKiByYXRpbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uLmluZGV4T2YoXCJ3XCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgLT0gc25hcE9mZnNldFg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoXCJlXCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0IC09IHNuYXBPZmZzZXRYO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGVmdCArPSBzbmFwT2Zmc2V0WCAvIDI7XHJcbiAgICAgICAgICAgICAgICByaWdodCAtPSBzbmFwT2Zmc2V0WCAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKFwiblwiKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BfMiAtPSBzbmFwT2Zmc2V0WTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24uaW5kZXhPZihcInNcIikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgYm90dG9tIC09IHNuYXBPZmZzZXRZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9wXzIgKz0gc25hcE9mZnNldFkgLyAyO1xyXG4gICAgICAgICAgICAgICAgYm90dG9tIC09IHNuYXBPZmZzZXRZIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV4dENvbnRyb2xQb3Nlc18yID0gZ2V0UmVjdFBvc2VzKHRvcF8yLCByaWdodCwgYm90dG9tLCBsZWZ0KTtcclxuICAgICAgICAgICAgZ3VpZGVQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIF9hID0gX19yZWFkKG5leHRDb250cm9sUG9zZXNfMltpXS5wb3MsIDIpLCBwb3NbMF0gPSBfYVswXSwgcG9zWzFdID0gX2FbMV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ3VpZGVQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MsIGopIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gZGlzdHNbal07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc1swXSAtPSBzbmFwT2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkaXN0WzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zWzFdIC09IHNuYXBPZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5leHRDbGlwU3R5bGVzID0gZ2V0Q2xpcFN0eWxlcyhtb3ZlYWJsZSwgY2xpcFBhdGgsIG5leHRQb3Nlcyk7XHJcbiAgICAgICAgdmFyIGNsaXBTdHlsZSA9IFwiXCIuY29uY2F0KGNsaXBUeXBlLCBcIihcIikuY29uY2F0KG5leHRDbGlwU3R5bGVzLmpvaW4oc3BsaXR0ZXIpLCBcIilcIik7XHJcbiAgICAgICAgc3RhdGUuY2xpcFBhdGhTdGF0ZSA9IGNsaXBTdHlsZTtcclxuICAgICAgICBpZiAoaXNDaXJjbGUgfHwgaXNFbGxpcHNlKSB7XHJcbiAgICAgICAgICAgIGd1aWRlWFBvc2VzID0gW2d1aWRlUG9zZXNbNF1bMF0sIGd1aWRlUG9zZXNbMl1bMF1dO1xyXG4gICAgICAgICAgICBndWlkZVlQb3NlcyA9IFtndWlkZVBvc2VzWzFdWzFdLCBndWlkZVBvc2VzWzNdWzFdXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNSZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0UG9zZXMgPSBbZ3VpZGVQb3Nlc1swXSwgZ3VpZGVQb3Nlc1syXSwgZ3VpZGVQb3Nlc1s0XSwgZ3VpZGVQb3Nlc1s2XV07XHJcbiAgICAgICAgICAgIGd1aWRlWFBvc2VzID0gcmVjdFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3NbMF07IH0pO1xyXG4gICAgICAgICAgICBndWlkZVlQb3NlcyA9IHJlY3RQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzFdOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGd1aWRlWFBvc2VzID0gZ3VpZGVQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzBdOyB9KTtcclxuICAgICAgICAgICAgZ3VpZGVZUG9zZXMgPSBndWlkZVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3NbMV07IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5zbmFwQm91bmRJbmZvcyA9IGNoZWNrU25hcEJvdW5kcyhndWlkZWxpbmVzLCBwcm9wcy5jbGlwVGFyZ2V0Qm91bmRzICYmIHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogd2lkdGgsIGJvdHRvbTogaGVpZ2h0IH0sIGd1aWRlWFBvc2VzLCBndWlkZVlQb3NlcywgMSwgMSk7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsRHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgIHZhciBpczNkID0gc3RhdGUuaXMzZCwgYWxsTWF0cml4ID0gc3RhdGUuYWxsTWF0cml4O1xyXG4gICAgICAgICAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgICAgICAgICAgdmFyIGRyYWdEaXN0ID0gYm91bmREZWx0YTtcclxuICAgICAgICAgICAgaWYgKGlzRHJhZ1RhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgZHJhZ0Rpc3QgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REaXN0WzBdICsgYm91bmREZWx0YVswXSAtIG9yaWdpbmFsRGlzdFswXSxcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdERpc3RbMV0gKyBib3VuZERlbHRhWzFdIC0gb3JpZ2luYWxEaXN0WzFdLFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcmlnaW5hbERyYWdnYWJsZS5kZWx0YU9mZnNldCA9IG11bHRpcGx5KGFsbE1hdHJpeCwgW2RyYWdEaXN0WzBdLCBkcmFnRGlzdFsxXSwgMCwgMF0sIG4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHsgY2xpcEV2ZW50VHlwZTogXCJjaGFuZ2VkXCIsIGNsaXBUeXBlOiBjbGlwVHlwZSwgcG9zZXM6IG5leHRQb3NlcywgY2xpcFN0eWxlOiBjbGlwU3R5bGUsIGNsaXBTdHlsZXM6IG5leHRDbGlwU3R5bGVzLCBkaXN0WDogZGlzdFgsIGRpc3RZOiBkaXN0WSB9LCBmaWxsQ1NTT2JqZWN0KChfYyA9IHt9LFxyXG4gICAgICAgICAgICBfY1tjbGlwVHlwZSA9PT0gXCJyZWN0XCIgPyBcImNsaXBcIiA6IFwiY2xpcFBhdGhcIl0gPSBjbGlwU3R5bGUsXHJcbiAgICAgICAgICAgIF9jKSwgZSkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xyXG4gICAgICAgIHZhciBpc0RyYWcgPSBlLmlzRHJhZywgZGF0YXMgPSBlLmRhdGFzLCBpc0RvdWJsZSA9IGUuaXNEb3VibGU7XHJcbiAgICAgICAgdmFyIGlzTGluZSA9IGRhdGFzLmlzTGluZSwgaXNDbGlwU3RhcnQgPSBkYXRhcy5pc0NsaXBTdGFydCwgaXNDb250cm9sID0gZGF0YXMuaXNDb250cm9sO1xyXG4gICAgICAgIGlmICghaXNDbGlwU3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlwRW5kXCIsIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KSk7XHJcbiAgICAgICAgaWYgKGlzRG91YmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsaXBQYXRoKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0xpbmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFkZFxyXG4gICAgICAgICAgICAgICAgYWRkQ2xpcFBhdGgobW92ZWFibGUsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0RvdWJsZSB8fCBpc0RyYWc7XHJcbiAgICB9LFxyXG4gICAgdW5zZXQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIG1vdmVhYmxlLnN0YXRlLmNsaXBQYXRoU3RhdGUgPSBcIlwiO1xyXG4gICAgICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBCb3VuZEluZm9zID0gbnVsbDtcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRvIGNsaXAgdGhlIHRhcmdldC4gKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5DbGlwcGFibGUjY2xpcHBhYmxlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXHJcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXHJcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XHJcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9XHJcbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiAgSWYgY2xpcHBhdGggaXMgbm90IHNldCwgdGhlIGRlZmF1bHQgdmFsdWUgY2FuIGJlIHNldC4gKGRlZmF1bHRDbGlwUGF0aCA8IHN0eWxlIDwgY3VzdG9tQ2xpcFBhdGggPCBkcmFnZ2luZyBjbGlwUGF0aClcclxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2RlZmF1bHRDbGlwUGF0aFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcclxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXHJcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxyXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xyXG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XHJcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfSBlbHNlIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfVxyXG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogJSBDYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhYnNvbHV0ZSBweCAoYHJlY3RgIG5vdCBwb3NzaWJsZSkgKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5DbGlwcGFibGUjY2xpcFJlbGF0aXZlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXHJcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXHJcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XHJcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9XHJcbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBZb3UgY2FuIGZvcmNlIHRoZSBjdXN0b20gY2xpcFBhdGguIChkZWZhdWx0Q2xpcFBhdGggPCBzdHlsZSA8IGN1c3RvbUNsaXBQYXRoIDwgZHJhZ2dpbmcgY2xpcFBhdGgpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjdXN0b21DbGlwUGF0aFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcclxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXHJcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxyXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xyXG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XHJcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfSBlbHNlIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfVxyXG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBkcmFnZ2luZyB0aGUgdGFyZ2V0LCB0aGUgY2xpcCBhbHNvIG1vdmVzLiAoZGVmYXVsdDogdHJ1ZSlcclxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2RyYWdXaXRoQ2xpcFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcclxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXHJcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxyXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xyXG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XHJcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfSBlbHNlIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfVxyXG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogWW91IGNhbiBkcmFnIHRoZSBjbGlwIGJ5IHNldHRpbmcgY2xpcEFyZWEuXHJcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwQXJlYVxyXG4gKiBAZGVmYXVsdCBmYWxzZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcclxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXHJcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxyXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xyXG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XHJcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfSBlbHNlIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfVxyXG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuKiBXaGV0aGVyIHRoZSBjbGlwIGlzIGJvdW5kIHRvIHRoZSB0YXJnZXQuXHJcbiogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBUYXJnZXRCb3VuZHNcclxuKiBAZGVmYXVsdCBmYWxzZVxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICBjbGlwcGFibGU6IHRydWUsXHJcbiogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4qICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcclxuKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4qICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiogICAgIGNsaXBUYXJnZXRCb3VuZHM6IHRydWUsXHJcbiogfSk7XHJcbiogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4qIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcclxuKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XHJcbiogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XHJcbiogICAgIH0gZWxzZSB7XHJcbiogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xyXG4qICAgICB9XHJcbiogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xyXG4qICAgICBjb25zb2xlLmxvZyhlKTtcclxuKiB9KTtcclxuKi9cclxuLyoqXHJcbiAqIEFkZCBjbGlwIGd1aWRlbGluZXMgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi5cclxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBWZXJ0aWNhbEd1aWRlbGluZXNcclxuICogQGRlZmF1bHQgMFxyXG4gKiBAZXhhbXBsZVxyXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuKlxyXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4qICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcclxuKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXHJcbiogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiogICAgIGNsaXBBcmVhOiBmYWxzZSxcclxuKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxyXG4qICAgICBjbGlwVmVydGljYWxHdWlkZWxpbmVzOiBbMCwgMTAwLCAyMDBdLFxyXG4qICAgICBjbGlwSG9yaXpvbnRhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXHJcbiogICAgIGNsaXBTbmFwVGhyZXNob2xkOiA1LFxyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuKiBBZGQgY2xpcCBndWlkZWxpbmVzIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbi5cclxuKiBAbmFtZSBNb3ZlYWJsZS5DbGlwcGFibGUjY2xpcEhvcml6b250YWxHdWlkZWxpbmVzXHJcbiogQGRlZmF1bHQgW11cclxuKiBAZXhhbXBsZVxyXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuKlxyXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4qICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcclxuKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXHJcbiogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiogICAgIGNsaXBBcmVhOiBmYWxzZSxcclxuKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxyXG4qICAgICBjbGlwVmVydGljYWxHdWlkZWxpbmVzOiBbMCwgMTAwLCAyMDBdLFxyXG4qICAgICBjbGlwSG9yaXpvbnRhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXHJcbiogICAgIGNsaXBTbmFwVGhyZXNob2xkOiA1LFxyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuKiBpc3RhbmNlIHZhbHVlIHRoYXQgY2FuIHNuYXAgdG8gY2xpcCBndWlkZWxpbmVzLlxyXG4qIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwU25hcFRocmVzaG9sZFxyXG4qIEBkZWZhdWx0IDVcclxuKiBAZXhhbXBsZVxyXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuKlxyXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4qICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcclxuKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXHJcbiogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiogICAgIGNsaXBBcmVhOiBmYWxzZSxcclxuKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxyXG4qICAgICBjbGlwVmVydGljYWxHdWlkZWxpbmVzOiBbMCwgMTAwLCAyMDBdLFxyXG4qICAgICBjbGlwSG9yaXpvbnRhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXHJcbiogICAgIGNsaXBTbmFwVGhyZXNob2xkOiA1LFxyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuICogV2hlbiBkcmFnIHN0YXJ0IHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgY2xpcFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5DbGlwcGFibGVcclxuICogQGV2ZW50IGNsaXBTdGFydFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLkNsaXBwYWJsZS5PbkNsaXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaXBTdGFydGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICBjbGlwcGFibGU6IHRydWUsXHJcbiAqICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcclxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxyXG4gKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcclxuICogICAgIGNsaXBBcmVhOiBmYWxzZSxcclxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwiY2xpcFN0YXJ0XCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcclxuICogICAgIGlmIChlLmNsaXBUeXBlID09PSBcInJlY3RcIikge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcclxuICogICAgIH0gZWxzZSB7XHJcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcFBhdGggPSBlLmNsaXBTdHlsZTtcclxuICogICAgIH1cclxuICogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gZHJhZyB0aGUgY2xpcCBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYGNsaXBgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkNsaXBwYWJsZVxyXG4gKiBAZXZlbnQgY2xpcFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLkNsaXBwYWJsZS5PbkNsaXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBjbGlwYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcclxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXHJcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxyXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xyXG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XHJcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfSBlbHNlIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfVxyXG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBkcmFnIGVuZCB0aGUgY2xpcCBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYGNsaXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkNsaXBwYWJsZVxyXG4gKiBAZXZlbnQgY2xpcEVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLkNsaXBwYWJsZS5PbkNsaXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBjbGlwRW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcclxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXHJcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxyXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xyXG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XHJcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfSBlbHNlIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfVxyXG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xuXG4vKipcclxuICogQG5hbWVzcGFjZSBPcmlnaW5EcmFnZ2FibGVcclxuICogQG1lbWJlcm9mIE1vdmVhYmxlXHJcbiAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIHRvIGRyYWcgb3JpZ2luIChkZWZhdWx0OiBmYWxzZSlcclxuICovXHJcbnZhciBPcmlnaW5EcmFnZ2FibGUgPSB7XHJcbiAgICBuYW1lOiBcIm9yaWdpbkRyYWdnYWJsZVwiLFxyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcIm9yaWdpbkRyYWdnYWJsZVwiLFxyXG4gICAgICAgIFwib3JpZ2luUmVsYXRpdmVcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcImRyYWdPcmlnaW5TdGFydFwiLFxyXG4gICAgICAgIFwiZHJhZ09yaWdpblwiLFxyXG4gICAgICAgIFwiZHJhZ09yaWdpbkVuZFwiLFxyXG4gICAgXSxcclxuICAgIGNzczogW1xyXG4gICAgICAgIFwiOmhvc3RbZGF0YS1hYmxlLW9yaWdpbmRyYWdnYWJsZV0gLmNvbnRyb2wub3JpZ2luIHtcXG5wb2ludGVyLWV2ZW50czogYXV0bztcXG59XCIsXHJcbiAgICBdLFxyXG4gICAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChfLCBlKSB7XHJcbiAgICAgICAgaWYgKGUuaXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlLnJlcXVlc3RBYmxlID09PSBcIm9yaWdpbkRyYWdnYWJsZVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzQ2xhc3MoZS5pbnB1dEV2ZW50LnRhcmdldCwgcHJlZml4KFwib3JpZ2luXCIpKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgZHJhZ1N0YXJ0OiBEcmFnZ2FibGUuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBuZXcgQ3VzdG9tR2VzdG8oKS5kcmFnU3RhcnQoWzAsIDBdLCBlKSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdPcmlnaW5TdGFydFwiLCBwYXJhbXMpO1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0T3JpZ2luID0gbW92ZWFibGUuc3RhdGUudHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0VGFyZ2V0T3JpZ2luID0gbW92ZWFibGUuc3RhdGUudGFyZ2V0T3JpZ2luO1xyXG4gICAgICAgIGRhdGFzLnByZXZPcmlnaW4gPSBbMCwgMF07XHJcbiAgICAgICAgZGF0YXMuaXNEcmFnT3JpZ2luID0gdHJ1ZTtcclxuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBkYXRhcy5pc0RyYWdPcmlnaW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBpc1BpbmNoID0gZS5pc1BpbmNoLCBpc1JlcXVlc3QgPSBlLmlzUmVxdWVzdDtcclxuICAgICAgICBpZiAoIWRhdGFzLmlzRHJhZ09yaWdpbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChnZXREcmFnRGlzdChlKSwgMiksIGRpc3RYID0gX2FbMF0sIGRpc3RZID0gX2FbMV07XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gc3RhdGUud2lkdGgsIGhlaWdodCA9IHN0YXRlLmhlaWdodCwgb2Zmc2V0TWF0cml4ID0gc3RhdGUub2Zmc2V0TWF0cml4LCB0YXJnZXRNYXRyaXggPSBzdGF0ZS50YXJnZXRNYXRyaXgsIGlzM2QgPSBzdGF0ZS5pczNkO1xyXG4gICAgICAgIHZhciBfYiA9IG1vdmVhYmxlLnByb3BzLm9yaWdpblJlbGF0aXZlLCBvcmlnaW5SZWxhdGl2ZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XHJcbiAgICAgICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICAgICAgdmFyIGRpc3QgPSBbZGlzdFgsIGRpc3RZXTtcclxuICAgICAgICBpZiAoaXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHZhciBkaXN0T3JpZ2luID0gZS5kaXN0T3JpZ2luO1xyXG4gICAgICAgICAgICBpZiAoZGlzdE9yaWdpblswXSB8fCBkaXN0T3JpZ2luWzFdKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0ID0gZGlzdE9yaWdpbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luID0gcGx1cyhkYXRhcy5zdGFydE9yaWdpbiwgZGlzdCk7XHJcbiAgICAgICAgdmFyIHRhcmdldE9yaWdpbiA9IHBsdXMoZGF0YXMuc3RhcnRUYXJnZXRPcmlnaW4sIGRpc3QpO1xyXG4gICAgICAgIHZhciBkZWx0YSA9IG1pbnVzKGRpc3QsIGRhdGFzLnByZXZPcmlnaW4pO1xyXG4gICAgICAgIHZhciBuZXh0TWF0cml4ID0gZ2V0TmV4dE1hdHJpeChvZmZzZXRNYXRyaXgsIHRhcmdldE1hdHJpeCwgb3JpZ2luLCBuKTtcclxuICAgICAgICB2YXIgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcclxuICAgICAgICB2YXIgbmV4dFJlY3QgPSBnZXRSZWN0KGNhbGN1bGF0ZVBvc2VzKG5leHRNYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pKTtcclxuICAgICAgICB2YXIgZHJhZ0RlbHRhID0gW1xyXG4gICAgICAgICAgICByZWN0LmxlZnQgLSBuZXh0UmVjdC5sZWZ0LFxyXG4gICAgICAgICAgICByZWN0LnRvcCAtIG5leHRSZWN0LnRvcCxcclxuICAgICAgICBdO1xyXG4gICAgICAgIGRhdGFzLnByZXZPcmlnaW4gPSBkaXN0O1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBbXHJcbiAgICAgICAgICAgIGNvbnZlcnRDU1NTaXplKHRhcmdldE9yaWdpblswXSwgd2lkdGgsIG9yaWdpblJlbGF0aXZlKSxcclxuICAgICAgICAgICAgY29udmVydENTU1NpemUodGFyZ2V0T3JpZ2luWzFdLCBoZWlnaHQsIG9yaWdpblJlbGF0aXZlKSxcclxuICAgICAgICBdLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBEcmFnZ2FibGUuZHJhZyhtb3ZlYWJsZSwgc2V0Q3VzdG9tRHJhZyhlLCBtb3ZlYWJsZS5zdGF0ZSwgZHJhZ0RlbHRhLCAhIWlzUGluY2gsIGZhbHNlKSk7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKF9fYXNzaWduKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgb3JpZ2luOiBvcmlnaW4sIGRpc3Q6IGRpc3QsIGRlbHRhOiBkZWx0YSwgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sIGRyYWc6IHJlc3VsdCB9LCBmaWxsQ1NTT2JqZWN0KHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcmVzdWx0LnRyYW5zZm9ybSxcclxuICAgICAgICB9LCBlKSksIHsgYWZ0ZXJUcmFuc2Zvcm06IHJlc3VsdC50cmFuc2Zvcm0gfSkpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdPcmlnaW5cIiwgcGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNEcmFnT3JpZ2luKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ09yaWdpbkVuZFwiLCBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSkpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdDb250cm9sQ29uZGl0aW9uKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW92ZWFibGUudHJhbnNmb3JtT3JpZ2luID0gcGFyYW1zLnRyYW5zZm9ybU9yaWdpbjtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogQG1ldGhvZCBNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGUjcmVxdWVzdFxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gZSAtIHRoZSBPcmlnaW5EcmFnZ2FibGUncyByZXF1ZXN0IHBhcmFtZXRlclxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW2UueF0gLSB4IHBvc2l0aW9uXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS55XSAtIHkgcG9zaXRpb25cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhWF0gLSB4IG51bWJlciB0byBtb3ZlXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVldIC0geSBudW1iZXIgdG8gbW92ZVxyXG4gICAgKiBAcGFyYW0ge2FycmF5fSBbZS5kZWx0YU9yaWdpbl0gLSBsZWZ0LCB0b3AgbnVtYmVyIHRvIG1vdmUgdHJhbnNmb3JtLW9yaWdpblxyXG4gICAgKiBAcGFyYW0ge2FycmF5fSBbZS5vcmlnaW5dIC0gdHJhbnNmb3JtLW9yaWdpbiBwb3NpdGlvblxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW2UuaXNJbnN0YW50XSAtIFdoZXRoZXIgdG8gZXhlY3V0ZSB0aGUgcmVxdWVzdCBpbnN0YW50bHlcclxuICAgICogQHJldHVybiB7TW92ZWFibGUuUmVxdWVzdGVyfSBNb3ZlYWJsZSBSZXF1ZXN0ZXJcclxuICAgICogQGV4YW1wbGVcclxuXG4gICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXHJcbiAgICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxyXG4gICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9LCB0cnVlKTtcclxuICAgICogLy8gVXNlIEFic29sdXRlIFZhbHVlXHJcbiAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9LCB0cnVlKTtcclxuICAgICogLy8gVXNlIFRyYW5zZm9ybSBWYWx1ZVxyXG4gICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgZGVsdGFPcmlnaW46IFsxMCwgMF0gfSwgdHJ1ZSk7XHJcbiAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyBvcmlnaW46IFsxMDAsIDBdIH0sIHRydWUpO1xyXG4gICAgKiAvLyByZXF1ZXN0U3RhcnRcclxuICAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiKTtcclxuICAgICpcclxuICAgICogLy8gcmVxdWVzdFxyXG4gICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcclxuICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xyXG4gICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XHJcbiAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcclxuICAgICogLy8gVXNlIEFic29sdXRlIFZhbHVlXHJcbiAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9KTtcclxuICAgICogbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiLCB7IHg6IDIyMCwgeTogMTAwIH0pO1xyXG4gICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgeDogMjQwLCB5OiAxMDAgfSk7XHJcbiAgICAqXHJcbiAgICAqIC8vIHJlcXVlc3RFbmRcclxuICAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcclxuICAgICovXHJcbiAgICByZXF1ZXN0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSB7fTtcclxuICAgICAgICB2YXIgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcclxuICAgICAgICB2YXIgZGlzdFggPSAwO1xyXG4gICAgICAgIHZhciBkaXN0WSA9IDA7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHJlY3QudHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgICAgIHZhciBkaXN0T3JpZ2luID0gWzAsIDBdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzQ29udHJvbDogdHJ1ZSxcclxuICAgICAgICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhczogZGF0YXMgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcImRlbHRhT3JpZ2luXCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RPcmlnaW5bMF0gKz0gZS5kZWx0YU9yaWdpblswXTtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0T3JpZ2luWzFdICs9IGUuZGVsdGFPcmlnaW5bMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcIm9yaWdpblwiIGluIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0T3JpZ2luWzBdID0gZS5vcmlnaW5bMF0gLSB0cmFuc2Zvcm1PcmlnaW5bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdE9yaWdpblsxXSA9IGUub3JpZ2luWzFdIC0gdHJhbnNmb3JtT3JpZ2luWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwieFwiIGluIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdFggPSBlLnggLSByZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZGVsdGFYXCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0WCArPSBlLmRlbHRhWDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwieVwiIGluIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdFkgPSBlLnkgLSByZWN0LnRvcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJkZWx0YVlcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RZICs9IGUuZGVsdGFZO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGFzOiBkYXRhcywgZGlzdFg6IGRpc3RYLCBkaXN0WTogZGlzdFksIGRpc3RPcmlnaW46IGRpc3RPcmlnaW4gfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YXM6IGRhdGFzLCBpc0RyYWc6IHRydWUgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgdG8gZHJhZyBvcmlnaW4gKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGUjb3JpZ2luRHJhZ2dhYmxlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgb3JpZ2luRHJhZ2dhYmxlOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbGV0IHRyYW5zbGF0ZSA9IFswLCAwXTtcclxuICogbW92ZWFibGUub24oXCJkcmFnT3JpZ2luU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBlLmRyYWdTdGFydCAmJiBlLmRyYWdTdGFydC5zZXQodHJhbnNsYXRlKTtcclxuICogfSkub24oXCJkcmFnT3JpZ2luXCIsIGUgPT4ge1xyXG4gKiAgICAgdHJhbnNsYXRlID0gZS5kcmFnLmJlZm9yZVRyYW5zbGF0ZTtcclxuICogICAgIGUudGFyZ2V0LnN0eWxlLmNzc1RleHRcclxuICogICAgICAgICA9IGB0cmFuc2Zvcm0tb3JpZ2luOiAke2UudHJhbnNmb3JtT3JpZ2lufTtgXHJcbiAqICAgICAgICAgKyBgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt0cmFuc2xhdGVbMF19cHgsICR7dHJhbnNsYXRlWzFdfXB4KWA7XHJcbiAqIH0pLm9uKFwiZHJhZ09yaWdpbkVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiAlIENhbiBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGFic29sdXRlIHB4IChkZWZhdWx0OiB0cnVlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGUjb3JpZ2luUmVsYXRpdmVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICBvcmlnaW5EcmFnZ2FibGU6IHRydWUsXHJcbiAqICAgICBvcmlnaW5SZWxhdGl2ZTogZmFsc2UsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vcmlnaW5SZWxhdGl2ZSA9IHRydWU7XHJcbiAqL1xyXG4vKipcclxuKiBXaGVuIGRyYWcgc3RhcnQgdGhlIG9yaWdpbiwgdGhlIGBkcmFnT3JpZ2luU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlXHJcbiogQGV2ZW50IGRyYWdPcmlnaW5TdGFydFxyXG4qIEBwYXJhbSB7TW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlLk9uRHJhZ09yaWdpblN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgZHJhZ09yaWdpblN0YXJ0YCBldmVudFxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICBvcmlnaW5EcmFnZ2FibGU6IHRydWUsXHJcbiogfSk7XHJcbiogbGV0IHRyYW5zbGF0ZSA9IFswLCAwXTtcclxuKiBtb3ZlYWJsZS5vbihcImRyYWdPcmlnaW5TdGFydFwiLCBlID0+IHtcclxuKiAgICAgZS5kcmFnU3RhcnQgJiYgZS5kcmFnU3RhcnQuc2V0KHRyYW5zbGF0ZSk7XHJcbiogfSkub24oXCJkcmFnT3JpZ2luXCIsIGUgPT4ge1xyXG4qICAgICB0cmFuc2xhdGUgPSBlLmRyYWcuYmVmb3JlVHJhbnNsYXRlO1xyXG4qICAgICBlLnRhcmdldC5zdHlsZS5jc3NUZXh0XHJcbiogICAgICAgICA9IGB0cmFuc2Zvcm0tb3JpZ2luOiAke2UudHJhbnNmb3JtT3JpZ2lufTtgXHJcbiogICAgICAgICArIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVswXX1weCwgJHt0cmFuc2xhdGVbMV19cHgpYDtcclxuKiB9KS5vbihcImRyYWdPcmlnaW5FbmRcIiwgZSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuKiBXaGVuIGRyYWcgdGhlIG9yaWdpbiwgdGhlIGBkcmFnT3JpZ2luYCBldmVudCBpcyBjYWxsZWQuXHJcbiogQG1lbWJlcm9mIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZVxyXG4qIEBldmVudCBkcmFnT3JpZ2luXHJcbiogQHBhcmFtIHtNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGUuT25EcmFnT3JpZ2lufSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgZHJhZ09yaWdpbmAgZXZlbnRcclxuKiBAZXhhbXBsZVxyXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuKlxyXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuKiAgICAgb3JpZ2luRHJhZ2dhYmxlOiB0cnVlLFxyXG4qIH0pO1xyXG4qIGxldCB0cmFuc2xhdGUgPSBbMCwgMF07XHJcbiogbW92ZWFibGUub24oXCJkcmFnT3JpZ2luU3RhcnRcIiwgZSA9PiB7XHJcbiogICAgIGUuZHJhZ1N0YXJ0ICYmIGUuZHJhZ1N0YXJ0LnNldCh0cmFuc2xhdGUpO1xyXG4qIH0pLm9uKFwiZHJhZ09yaWdpblwiLCBlID0+IHtcclxuKiAgICAgdHJhbnNsYXRlID0gZS5kcmFnLmJlZm9yZVRyYW5zbGF0ZTtcclxuKiAgICAgZS50YXJnZXQuc3R5bGUuY3NzVGV4dFxyXG4qICAgICAgICAgPSBgdHJhbnNmb3JtLW9yaWdpbjogJHtlLnRyYW5zZm9ybU9yaWdpbn07YFxyXG4qICAgICAgICAgKyBgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt0cmFuc2xhdGVbMF19cHgsICR7dHJhbnNsYXRlWzFdfXB4KWA7XHJcbiogfSkub24oXCJkcmFnT3JpZ2luRW5kXCIsIGUgPT4ge1xyXG4qICAgICBjb25zb2xlLmxvZyhlKTtcclxuKiB9KTtcclxuKi9cclxuLyoqXHJcbiogV2hlbiBkcmFnIGVuZCB0aGUgb3JpZ2luLCB0aGUgYGRyYWdPcmlnaW5FbmRgIGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlXHJcbiogQGV2ZW50IGRyYWdPcmlnaW5FbmRcclxuKiBAcGFyYW0ge01vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZS5PbkRyYWdPcmlnaW5FbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnT3JpZ2luRW5kYCBldmVudFxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICBvcmlnaW5EcmFnZ2FibGU6IHRydWUsXHJcbiogfSk7XHJcbiogbGV0IHRyYW5zbGF0ZSA9IFswLCAwXTtcclxuKiBtb3ZlYWJsZS5vbihcImRyYWdPcmlnaW5TdGFydFwiLCBlID0+IHtcclxuKiAgICAgZS5kcmFnU3RhcnQgJiYgZS5kcmFnU3RhcnQuc2V0KHRyYW5zbGF0ZSk7XHJcbiogfSkub24oXCJkcmFnT3JpZ2luXCIsIGUgPT4ge1xyXG4qICAgICB0cmFuc2xhdGUgPSBlLmRyYWcuYmVmb3JlVHJhbnNsYXRlO1xyXG4qICAgICBlLnRhcmdldC5zdHlsZS5jc3NUZXh0XHJcbiogICAgICAgICA9IGB0cmFuc2Zvcm0tb3JpZ2luOiAke2UudHJhbnNmb3JtT3JpZ2lufTtgXHJcbiogICAgICAgICArIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVswXX1weCwgJHt0cmFuc2xhdGVbMV19cHgpYDtcclxuKiB9KS5vbihcImRyYWdPcmlnaW5FbmRcIiwgZSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4qIH0pO1xyXG4qL1xuXG5mdW5jdGlvbiBhZGRCb3JkZXJSYWRpdXNCeUxpbmUoY29udHJvbFBvc2VzLCBsaW5lSW5kZXgsIGRpc3RYLCBkaXN0WSkge1xyXG4gICAgLy8gbGluZUluZGV4XHJcbiAgICAvLyAwIHRvcFxyXG4gICAgLy8gMSByaWdodFxyXG4gICAgLy8gMiBib3R0b21cclxuICAgIC8vIDMgbGVmdFxyXG4gICAgdmFyIGhvcml6b250YWxzTGVuZ3RoID0gY29udHJvbFBvc2VzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgdmlydHVhbCA9IF9hLnZpcnR1YWwsIGhvcml6b250YWwgPSBfYS5ob3Jpem9udGFsO1xyXG4gICAgICAgIHJldHVybiBob3Jpem9udGFsICYmICF2aXJ0dWFsO1xyXG4gICAgfSkubGVuZ3RoO1xyXG4gICAgdmFyIHZlcnRpY2Fsc0xlbmd0aCA9IGNvbnRyb2xQb3Nlcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHZpcnR1YWwgPSBfYS52aXJ0dWFsLCB2ZXJ0aWNhbCA9IF9hLnZlcnRpY2FsO1xyXG4gICAgICAgIHJldHVybiB2ZXJ0aWNhbCAmJiAhdmlydHVhbDtcclxuICAgIH0pLmxlbmd0aDtcclxuICAgIHZhciBjb250cm9sSW5kZXggPSAtMTtcclxuICAgIC8vdG9wXHJcbiAgICBpZiAobGluZUluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgaWYgKGhvcml6b250YWxzTGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xJbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvcml6b250YWxzTGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xJbmRleCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gYm90dG9tXHJcbiAgICBpZiAobGluZUluZGV4ID09PSAyKSB7XHJcbiAgICAgICAgaWYgKGhvcml6b250YWxzTGVuZ3RoIDw9IDIpIHtcclxuICAgICAgICAgICAgY29udHJvbEluZGV4ID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaG9yaXpvbnRhbHNMZW5ndGggPD0gMykge1xyXG4gICAgICAgICAgICBjb250cm9sSW5kZXggPSAzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGxlZnRcclxuICAgIGlmIChsaW5lSW5kZXggPT09IDMpIHtcclxuICAgICAgICBpZiAodmVydGljYWxzTGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xJbmRleCA9IDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZlcnRpY2Fsc0xlbmd0aCA8IDQpIHtcclxuICAgICAgICAgICAgY29udHJvbEluZGV4ID0gNztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyByaWdodFxyXG4gICAgaWYgKGxpbmVJbmRleCA9PT0gMSkge1xyXG4gICAgICAgIGlmICh2ZXJ0aWNhbHNMZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICBjb250cm9sSW5kZXggPSA1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2ZXJ0aWNhbHNMZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICBjb250cm9sSW5kZXggPSA2O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjb250cm9sSW5kZXggPT09IC0xIHx8ICFjb250cm9sUG9zZXNbY29udHJvbEluZGV4XS52aXJ0dWFsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbnRyb2xQb3NlSW5mbyA9IGNvbnRyb2xQb3Nlc1tjb250cm9sSW5kZXhdO1xyXG4gICAgYWRkQm9yZGVyUmFkaXVzKGNvbnRyb2xQb3NlcywgY29udHJvbEluZGV4KTtcclxuICAgIGlmIChjb250cm9sSW5kZXggPCA0KSB7XHJcbiAgICAgICAgY29udHJvbFBvc2VJbmZvLnBvc1swXSA9IGRpc3RYO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29udHJvbFBvc2VJbmZvLnBvc1sxXSA9IGRpc3RZO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZEJvcmRlclJhZGl1cyhjb250cm9sUG9zZXMsIGluZGV4KSB7XHJcbiAgICBpZiAoaW5kZXggPCA0KSB7XHJcbiAgICAgICAgY29udHJvbFBvc2VzLnNsaWNlKDAsIGluZGV4ICsgMSkuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICBpbmZvLnZpcnR1YWwgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChjb250cm9sUG9zZXNbMF0udmlydHVhbCkge1xyXG4gICAgICAgICAgICBjb250cm9sUG9zZXNbMF0udmlydHVhbCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250cm9sUG9zZXMuc2xpY2UoNCwgaW5kZXggKyAxKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgIGluZm8udmlydHVhbCA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUJvcmRlclJhZGl1cyhjb250cm9sUG9zZXMsIGluZGV4KSB7XHJcbiAgICBpZiAoaW5kZXggPCA0KSB7XHJcbiAgICAgICAgY29udHJvbFBvc2VzLnNsaWNlKGluZGV4LCA0KS5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgIGluZm8udmlydHVhbCA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250cm9sUG9zZXMuc2xpY2UoaW5kZXgpLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgaW5mby52aXJ0dWFsID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRCb3JkZXJSYWRpdXMoYm9yZGVyUmFkaXVzLCB3aWR0aCwgaGVpZ2h0LCBtaW5Db3VudHMsIGZ1bGwpIHtcclxuICAgIGlmIChtaW5Db3VudHMgPT09IHZvaWQgMCkgeyBtaW5Db3VudHMgPSBbMCwgMF07IH1cclxuICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgIGlmICghYm9yZGVyUmFkaXVzIHx8IGJvcmRlclJhZGl1cyA9PT0gXCIwcHhcIikge1xyXG4gICAgICAgIHZhbHVlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsdWVzID0gc3BsaXRTcGFjZShib3JkZXJSYWRpdXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldFJhZGl1c1ZhbHVlcyh2YWx1ZXMsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIG1pbkNvdW50cywgZnVsbCk7XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlclJvdW5kRXZlbnQobW92ZWFibGUsIGUsIGRpc3QsIGRlbHRhLCBuZXh0UG9zZXMpIHtcclxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgdmFyIHdpZHRoID0gc3RhdGUud2lkdGgsIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcclxuICAgIHZhciBfYSA9IGdldFJhZGl1c1N0eWxlcyhuZXh0UG9zZXMsIG1vdmVhYmxlLnByb3BzLnJvdW5kUmVsYXRpdmUsIHdpZHRoLCBoZWlnaHQpLCByYXdzID0gX2EucmF3cywgc3R5bGVzID0gX2Euc3R5bGVzLCByYWRpdXNQb3NlcyA9IF9hLnJhZGl1c1Bvc2VzO1xyXG4gICAgdmFyIF9iID0gc3BsaXRSYWRpdXNQb3NlcyhyYWRpdXNQb3NlcywgcmF3cyksIGhvcml6b250YWxzID0gX2IuaG9yaXpvbnRhbHMsIHZlcnRpY2FscyA9IF9iLnZlcnRpY2FscztcclxuICAgIHZhciBib3JkZXJSYWRpdXMgPSBzdHlsZXMuam9pbihcIiBcIik7XHJcbiAgICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IGJvcmRlclJhZGl1cztcclxuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7IGhvcml6b250YWxzOiBob3Jpem9udGFscywgdmVydGljYWxzOiB2ZXJ0aWNhbHMsIGJvcmRlclJhZGl1czogYm9yZGVyUmFkaXVzLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBkZWx0YTogZGVsdGEsIGRpc3Q6IGRpc3QgfSwgZmlsbENTU09iamVjdCh7XHJcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXMsXHJcbiAgICB9LCBlKSkpO1xyXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRcIiwgcGFyYW1zKTtcclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3R5bGVCb3JkZXJSYWRpdXMobW92ZWFibGUpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICB2YXIgc3R5bGUgPSBtb3ZlYWJsZS5nZXRTdGF0ZSgpLnN0eWxlO1xyXG4gICAgdmFyIGJvcmRlclJhZGl1cyA9IHN0eWxlLmJvcmRlclJhZGl1cyB8fCBcIlwiO1xyXG4gICAgaWYgKCFib3JkZXJSYWRpdXMgJiYgbW92ZWFibGUucHJvcHMuZ3JvdXBhYmxlKSB7XHJcbiAgICAgICAgdmFyIGZpcnN0TW92ZWFibGUgPSBtb3ZlYWJsZS5tb3ZlYWJsZXNbMF07XHJcbiAgICAgICAgdmFyIGZpcnN0VGFyZ2V0ID0gbW92ZWFibGUuZ2V0VGFyZ2V0cygpWzBdO1xyXG4gICAgICAgIGlmIChmaXJzdFRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAoKGZpcnN0TW92ZWFibGUgPT09IG51bGwgfHwgZmlyc3RNb3ZlYWJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3RNb3ZlYWJsZS5wcm9wcy50YXJnZXQpID09PSBmaXJzdFRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzID0gKF9iID0gKF9hID0gbW92ZWFibGUubW92ZWFibGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGUuc3R5bGUuYm9yZGVyUmFkaXVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuYm9yZGVyUmFkaXVzID0gYm9yZGVyUmFkaXVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzID0gZ2V0Q29tcHV0ZWRTdHlsZShmaXJzdFRhcmdldCkuYm9yZGVyUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuYm9yZGVyUmFkaXVzID0gYm9yZGVyUmFkaXVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJvcmRlclJhZGl1cztcclxufVxyXG4vKipcclxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5Sb3VuZGFibGVcclxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgdG8gc2hvdyBhbmQgZHJhZyBvciBkb3VibGUgY2xpY2sgYm9yZGVyLXJhZGl1c1xyXG4gKi9cclxudmFyIFJvdW5kYWJsZSA9IHtcclxuICAgIG5hbWU6IFwicm91bmRhYmxlXCIsXHJcbiAgICBwcm9wczogW1xyXG4gICAgICAgIFwicm91bmRhYmxlXCIsXHJcbiAgICAgICAgXCJyb3VuZFJlbGF0aXZlXCIsXHJcbiAgICAgICAgXCJtaW5Sb3VuZENvbnRyb2xzXCIsXHJcbiAgICAgICAgXCJtYXhSb3VuZENvbnRyb2xzXCIsXHJcbiAgICAgICAgXCJyb3VuZENsaWNrYWJsZVwiLFxyXG4gICAgICAgIFwicm91bmRQYWRkaW5nXCIsXHJcbiAgICAgICAgXCJpc0Rpc3BsYXlTaGFkb3dSb3VuZENvbnRyb2xzXCIsXHJcbiAgICBdLFxyXG4gICAgZXZlbnRzOiBbXHJcbiAgICAgICAgXCJyb3VuZFN0YXJ0XCIsXHJcbiAgICAgICAgXCJyb3VuZFwiLFxyXG4gICAgICAgIFwicm91bmRFbmRcIixcclxuICAgICAgICBcInJvdW5kR3JvdXBTdGFydFwiLFxyXG4gICAgICAgIFwicm91bmRHcm91cFwiLFxyXG4gICAgICAgIFwicm91bmRHcm91cEVuZFwiLFxyXG4gICAgXSxcclxuICAgIGNzczogW1xyXG4gICAgICAgIFwiLmNvbnRyb2wuYm9yZGVyLXJhZGl1cyB7XFxuYmFja2dyb3VuZDogI2Q2NjtcXG5jdXJzb3I6IHBvaW50ZXI7XFxuei1pbmRleDogMztcXG59XCIsXHJcbiAgICAgICAgXCIuY29udHJvbC5ib3JkZXItcmFkaXVzLnZlcnRpY2FsIHtcXG5iYWNrZ3JvdW5kOiAjZDZkO1xcbnotaW5kZXg6IDI7XFxufVwiLFxyXG4gICAgICAgIFwiLmNvbnRyb2wuYm9yZGVyLXJhZGl1cy52aXJ0dWFsIHtcXG5vcGFjaXR5OiAwLjU7XFxuei1pbmRleDogMTtcXG59XCIsXHJcbiAgICAgICAgXCI6aG9zdC5yb3VuZC1saW5lLWNsaWNrYWJsZSAubGluZS5kaXJlY3Rpb24ge1xcbmN1cnNvcjogcG9pbnRlcjtcXG59XCIsXHJcbiAgICBdLFxyXG4gICAgY2xhc3NOYW1lOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB2YXIgcm91bmRDbGlja2FibGUgPSBtb3ZlYWJsZS5wcm9wcy5yb3VuZENsaWNrYWJsZTtcclxuICAgICAgICByZXR1cm4gcm91bmRDbGlja2FibGUgPT09IHRydWUgfHwgcm91bmRDbGlja2FibGUgPT09IFwibGluZVwiID8gcHJlZml4KFwicm91bmQtbGluZS1jbGlja2FibGVcIikgOiBcIlwiO1xyXG4gICAgfSxcclxuICAgIHJlcXVlc3RTdHlsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbXCJib3JkZXJSYWRpdXNcIl07XHJcbiAgICB9LFxyXG4gICAgcmVxdWVzdENoaWxkU3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW1wiYm9yZGVyUmFkaXVzXCJdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLmdldFN0YXRlKCksIHRhcmdldCA9IF9hLnRhcmdldCwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCBhbGxNYXRyaXggPSBfYS5hbGxNYXRyaXgsIGlzM2QgPSBfYS5pczNkLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCBib3JkZXJSYWRpdXNTdGF0ZSA9IF9hLmJvcmRlclJhZGl1c1N0YXRlO1xyXG4gICAgICAgIHZhciBfYiA9IG1vdmVhYmxlLnByb3BzLCBfYyA9IF9iLm1pblJvdW5kQ29udHJvbHMsIG1pblJvdW5kQ29udHJvbHMgPSBfYyA9PT0gdm9pZCAwID8gWzAsIDBdIDogX2MsIF9kID0gX2IubWF4Um91bmRDb250cm9scywgbWF4Um91bmRDb250cm9scyA9IF9kID09PSB2b2lkIDAgPyBbNCwgNF0gOiBfZCwgem9vbSA9IF9iLnpvb20sIF9lID0gX2Iucm91bmRQYWRkaW5nLCByb3VuZFBhZGRpbmcgPSBfZSA9PT0gdm9pZCAwID8gMCA6IF9lLCBpc0Rpc3BsYXlTaGFkb3dSb3VuZENvbnRyb2xzID0gX2IuaXNEaXNwbGF5U2hhZG93Um91bmRDb250cm9scywgZ3JvdXBhYmxlID0gX2IuZ3JvdXBhYmxlO1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYm9yZGVyUmFkaXVzID0gYm9yZGVyUmFkaXVzU3RhdGUgfHwgZ2V0U3R5bGVCb3JkZXJSYWRpdXMobW92ZWFibGUpO1xyXG4gICAgICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgICAgIHZhciByYWRpdXNWYWx1ZXMgPSBnZXRCb3JkZXJSYWRpdXMoYm9yZGVyUmFkaXVzLCB3aWR0aCwgaGVpZ2h0LCBtaW5Sb3VuZENvbnRyb2xzLCB0cnVlKTtcclxuICAgICAgICBpZiAoIXJhZGl1c1ZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZlcnRpY2FsQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBob3Jpem9udGFsQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBiYXNlUG9zID0gZ3JvdXBhYmxlID8gWzAsIDBdIDogW2xlZnQsIHRvcF07XHJcbiAgICAgICAgcmV0dXJuIHJhZGl1c1ZhbHVlcy5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWwgPSB2Lmhvcml6b250YWw7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbCA9IHYudmVydGljYWw7XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSB2LmRpcmVjdGlvbiB8fCBcIlwiO1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxQb3MgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodi5wb3MpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGhvcml6b250YWxDb3VudCArPSBNYXRoLmFicyhob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgdmVydGljYWxDb3VudCArPSBNYXRoLmFicyh2ZXJ0aWNhbCk7XHJcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsICYmIGRpcmVjdGlvbi5pbmRleE9mKFwiblwiKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFBvc1sxXSAtPSByb3VuZFBhZGRpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsICYmIGRpcmVjdGlvbi5pbmRleE9mKFwid1wiKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFBvc1swXSAtPSByb3VuZFBhZGRpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhvcml6b250YWwgJiYgZGlyZWN0aW9uLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUG9zWzFdICs9IHJvdW5kUGFkZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmVydGljYWwgJiYgZGlyZWN0aW9uLmluZGV4T2YoXCJlXCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUG9zWzBdICs9IHJvdW5kUGFkZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcG9zID0gbWludXMoY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBvcmlnaW5hbFBvcywgbiksIGJhc2VQb3MpO1xyXG4gICAgICAgICAgICB2YXIgaXNEaXNwbGF5VmVydGljYWxTaGFkb3cgPSBpc0Rpc3BsYXlTaGFkb3dSb3VuZENvbnRyb2xzXHJcbiAgICAgICAgICAgICAgICAmJiBpc0Rpc3BsYXlTaGFkb3dSb3VuZENvbnRyb2xzICE9PSBcImhvcml6b250YWxcIjtcclxuICAgICAgICAgICAgdmFyIGlzRGlzcGxheSA9IHYudmVydGljYWxcclxuICAgICAgICAgICAgICAgID8gdmVydGljYWxDb3VudCA8PSBtYXhSb3VuZENvbnRyb2xzWzFdICYmIChpc0Rpc3BsYXlWZXJ0aWNhbFNoYWRvdyB8fCAhdi52aXJ0dWFsKVxyXG4gICAgICAgICAgICAgICAgOiBob3Jpem9udGFsQ291bnQgPD0gbWF4Um91bmRDb250cm9sc1swXSAmJiAoaXNEaXNwbGF5U2hhZG93Um91bmRDb250cm9scyB8fCAhdi52aXJ0dWFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IFwiYm9yZGVyUmFkaXVzQ29udHJvbFwiLmNvbmNhdChpKSwgY2xhc3NOYW1lOiBwcmVmaXgoXCJjb250cm9sXCIsIFwiYm9yZGVyLXJhZGl1c1wiLCB2LnZlcnRpY2FsID8gXCJ2ZXJ0aWNhbFwiIDogXCJcIiwgdi52aXJ0dWFsID8gXCJ2aXJ0dWFsXCIgOiBcIlwiKSwgXCJkYXRhLXJhZGl1cy1pbmRleFwiOiBpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlzRGlzcGxheSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHBvc1swXSwgXCJweCwgXCIpLmNvbmNhdChwb3NbMV0sIFwicHgpIHNjYWxlKFwiKS5jb25jYXQoem9vbSwgXCIpXCIpLFxyXG4gICAgICAgICAgICAgICAgfSB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgaWYgKCFlLmlucHV0RXZlbnQgfHwgZS5pc1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gKGUuaW5wdXRFdmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKFwiYm9yZGVyLXJhZGl1c1wiKSA+IC0xXHJcbiAgICAgICAgICAgIHx8IChjbGFzc05hbWUuaW5kZXhPZihcIm1vdmVhYmxlLWxpbmVcIikgPiAtMSAmJiBjbGFzc05hbWUuaW5kZXhPZihcIm1vdmVhYmxlLWRpcmVjdGlvblwiKSA+IC0xKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbENvbmRpdGlvbihtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICB2YXIgaW5wdXRUYXJnZXQgPSBpbnB1dEV2ZW50LnRhcmdldDtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gKGlucHV0VGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xyXG4gICAgICAgIHZhciBpc0NvbnRyb2wgPSBjbGFzc05hbWUuaW5kZXhPZihcImJvcmRlci1yYWRpdXNcIikgPiAtMTtcclxuICAgICAgICB2YXIgaXNMaW5lID0gY2xhc3NOYW1lLmluZGV4T2YoXCJtb3ZlYWJsZS1saW5lXCIpID4gLTEgJiYgY2xhc3NOYW1lLmluZGV4T2YoXCJtb3ZlYWJsZS1kaXJlY3Rpb25cIikgPiAtMTtcclxuICAgICAgICB2YXIgY29udHJvbEluZGV4ID0gaXNDb250cm9sID8gcGFyc2VJbnQoaW5wdXRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yYWRpdXMtaW5kZXhcIiksIDEwKSA6IC0xO1xyXG4gICAgICAgIHZhciBsaW5lSW5kZXggPSAtMTtcclxuICAgICAgICBpZiAoaXNMaW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleEF0dHIgPSBpbnB1dFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWxpbmUta2V5XCIpIHx8IFwiXCI7XHJcbiAgICAgICAgICAgIGlmIChpbmRleEF0dHIpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVJbmRleCA9IHBhcnNlSW50KGluZGV4QXR0ci5yZXBsYWNlKC9yZW5kZXItbGluZS0vZywgXCJcIiksIDEwKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihsaW5lSW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZUluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0NvbnRyb2wgJiYgIWlzTGluZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdW5kU3RhcnRcIiwgcGFyYW1zKTtcclxuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFzLmxpbmVJbmRleCA9IGxpbmVJbmRleDtcclxuICAgICAgICBkYXRhcy5jb250cm9sSW5kZXggPSBjb250cm9sSW5kZXg7XHJcbiAgICAgICAgZGF0YXMuaXNDb250cm9sID0gaXNDb250cm9sO1xyXG4gICAgICAgIGRhdGFzLmlzTGluZSA9IGlzTGluZTtcclxuICAgICAgICBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLCByb3VuZFJlbGF0aXZlID0gX2Eucm91bmRSZWxhdGl2ZSwgX2IgPSBfYS5taW5Sb3VuZENvbnRyb2xzLCBtaW5Sb3VuZENvbnRyb2xzID0gX2IgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9iO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHN0YXRlLndpZHRoLCBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XHJcbiAgICAgICAgZGF0YXMuaXNSb3VuZCA9IHRydWU7XHJcbiAgICAgICAgZGF0YXMucHJldkRpc3QgPSBbMCwgMF07XHJcbiAgICAgICAgdmFyIGJvcmRlclJhZGl1cyA9IGdldFN0eWxlQm9yZGVyUmFkaXVzKG1vdmVhYmxlKTtcclxuICAgICAgICB2YXIgY29udHJvbFBvc2VzID0gZ2V0Qm9yZGVyUmFkaXVzKGJvcmRlclJhZGl1cyB8fCBcIlwiLCB3aWR0aCwgaGVpZ2h0LCBtaW5Sb3VuZENvbnRyb2xzLCB0cnVlKSB8fCBbXTtcclxuICAgICAgICBkYXRhcy5jb250cm9sUG9zZXMgPSBjb250cm9sUG9zZXM7XHJcbiAgICAgICAgc3RhdGUuYm9yZGVyUmFkaXVzU3RhdGUgPSBnZXRSYWRpdXNTdHlsZXMoY29udHJvbFBvc2VzLCByb3VuZFJlbGF0aXZlLCB3aWR0aCwgaGVpZ2h0KS5zdHlsZXMuam9pbihcIiBcIik7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICB2YXIgY29udHJvbFBvc2VzID0gZGF0YXMuY29udHJvbFBvc2VzO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNSb3VuZCB8fCAhZGF0YXMuaXNDb250cm9sIHx8ICFjb250cm9sUG9zZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4ID0gZGF0YXMuY29udHJvbEluZGV4O1xyXG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChnZXREcmFnRGlzdChlKSwgMiksIGRpc3RYID0gX2FbMF0sIGRpc3RZID0gX2FbMV07XHJcbiAgICAgICAgdmFyIGRpc3QgPSBbZGlzdFgsIGRpc3RZXTtcclxuICAgICAgICB2YXIgZGVsdGEgPSBtaW51cyhkaXN0LCBkYXRhcy5wcmV2RGlzdCk7XHJcbiAgICAgICAgdmFyIF9iID0gbW92ZWFibGUucHJvcHMubWF4Um91bmRDb250cm9scywgbWF4Um91bmRDb250cm9scyA9IF9iID09PSB2b2lkIDAgPyBbNCwgNF0gOiBfYjtcclxuICAgICAgICB2YXIgX2MgPSBtb3ZlYWJsZS5zdGF0ZSwgd2lkdGggPSBfYy53aWR0aCwgaGVpZ2h0ID0gX2MuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBzZWxlY3RlZENvbnRyb2xQb3NlID0gY29udHJvbFBvc2VzW2luZGV4XTtcclxuICAgICAgICB2YXIgc2VsZWN0ZWRWZXJ0aWNhbCA9IHNlbGVjdGVkQ29udHJvbFBvc2UudmVydGljYWw7XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkSG9yaXpvbnRhbCA9IHNlbGVjdGVkQ29udHJvbFBvc2UuaG9yaXpvbnRhbDtcclxuICAgICAgICAvLyAwOiBbMCwgMSwgMiwgM10gbWF4Q291bnQgPT09IDFcclxuICAgICAgICAvLyAwOiBbMCwgMl0gbWF4Q291bnQgPT09IDJcclxuICAgICAgICAvLyAxOiBbMSwgM10gbWF4Q291bnQgPT09IDJcclxuICAgICAgICAvLyAwOiBbMF0gbWF4Q291bnQgPT09IDNcclxuICAgICAgICAvLyAxOiBbMSwgM10gbWF4Q291bnQgPT09IDNcclxuICAgICAgICB2YXIgZGlzdHMgPSBjb250cm9sUG9zZXMubWFwKGZ1bmN0aW9uIChwb3NlKSB7XHJcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsID0gcG9zZS5ob3Jpem9udGFsLCB2ZXJ0aWNhbCA9IHBvc2UudmVydGljYWw7XHJcbiAgICAgICAgICAgIHZhciBwb3NlRGlzdCA9IFtcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWwgKiBzZWxlY3RlZEhvcml6b250YWwgKiBkaXN0WzBdLFxyXG4gICAgICAgICAgICAgICAgdmVydGljYWwgKiBzZWxlY3RlZFZlcnRpY2FsICogZGlzdFsxXSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXhSb3VuZENvbnRyb2xzWzBdID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc2VEaXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF4Um91bmRDb250cm9sc1swXSA8IDQgJiYgaG9yaXpvbnRhbCAhPT0gc2VsZWN0ZWRIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc2VEaXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1heFJvdW5kQ29udHJvbHNbMV0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHBvc2VEaXN0WzFdID0gdmVydGljYWwgKiBzZWxlY3RlZEhvcml6b250YWwgKiBkaXN0WzBdIC8gd2lkdGggKiBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zZURpc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWRWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heFJvdW5kQ29udHJvbHNbMV0gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zZURpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXhSb3VuZENvbnRyb2xzWzFdIDwgNCAmJiB2ZXJ0aWNhbCAhPT0gc2VsZWN0ZWRWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NlRGlzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gWzAsIDBdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRpc3RzW2luZGV4XSA9IGRpc3Q7XHJcbiAgICAgICAgdmFyIG5leHRQb3NlcyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKGluZm8sIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbmZvKSwgeyBwb3M6IHBsdXMoaW5mby5wb3MsIGRpc3RzW2ldKSB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaW5kZXggPCA0KSB7XHJcbiAgICAgICAgICAgIG5leHRQb3Nlcy5zbGljZSgwLCBpbmRleCArIDEpLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIGluZm8udmlydHVhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5leHRQb3Nlcy5zbGljZSg0LCBpbmRleCArIDEpLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIGluZm8udmlydHVhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMucHJldkRpc3QgPSBbZGlzdFgsIGRpc3RZXTtcclxuICAgICAgICByZXR1cm4gdHJpZ2dlclJvdW5kRXZlbnQobW92ZWFibGUsIGUsIGRpc3QsIGRlbHRhLCBuZXh0UG9zZXMpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IFwiXCI7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgaXNEb3VibGUgPSBlLmlzRG91YmxlO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNSb3VuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpc0NvbnRyb2wgPSBkYXRhcy5pc0NvbnRyb2wsIGNvbnRyb2xJbmRleCA9IGRhdGFzLmNvbnRyb2xJbmRleCwgaXNMaW5lID0gZGF0YXMuaXNMaW5lLCBsaW5lSW5kZXggPSBkYXRhcy5saW5lSW5kZXg7XHJcbiAgICAgICAgdmFyIGNvbnRyb2xQb3NlcyA9IGRhdGFzLmNvbnRyb2xQb3NlcztcclxuICAgICAgICB2YXIgbGVuZ3RoID0gY29udHJvbFBvc2VzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHZpcnR1YWwgPSBfYS52aXJ0dWFsO1xyXG4gICAgICAgICAgICByZXR1cm4gdmlydHVhbDtcclxuICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMucm91bmRDbGlja2FibGUsIHJvdW5kQ2xpY2thYmxlID0gX2EgPT09IHZvaWQgMCA/IHRydWUgOiBfYTtcclxuICAgICAgICBpZiAoaXNEb3VibGUgJiYgcm91bmRDbGlja2FibGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzQ29udHJvbCAmJiAocm91bmRDbGlja2FibGUgPT09IHRydWUgfHwgcm91bmRDbGlja2FibGUgPT09IFwiY29udHJvbFwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQm9yZGVyUmFkaXVzKGNvbnRyb2xQb3NlcywgY29udHJvbEluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0xpbmUgJiYgKHJvdW5kQ2xpY2thYmxlID09PSB0cnVlIHx8IHJvdW5kQ2xpY2thYmxlID09PSBcImxpbmVcIikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChjYWxjdWxhdGVQb2ludGVyRGlzdChtb3ZlYWJsZSwgZSksIDIpLCBkaXN0WCA9IF9iWzBdLCBkaXN0WSA9IF9iWzFdO1xyXG4gICAgICAgICAgICAgICAgYWRkQm9yZGVyUmFkaXVzQnlMaW5lKGNvbnRyb2xQb3NlcywgbGluZUluZGV4LCBkaXN0WCwgZGlzdFkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT09IGNvbnRyb2xQb3Nlcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlydHVhbCA9IF9hLnZpcnR1YWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlydHVhbDtcclxuICAgICAgICAgICAgfSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyUm91bmRFdmVudChtb3ZlYWJsZSwgZSwgWzAsIDBdLCBbMCwgMF0sIGNvbnRyb2xQb3Nlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3VuZEVuZFwiLCBwYXJhbXMpO1xyXG4gICAgICAgIHN0YXRlLmJvcmRlclJhZGl1c1N0YXRlID0gXCJcIjtcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZHJhZ0NvbnRyb2xTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xyXG4gICAgICAgIHZhciB0YXJnZXRzID0gbW92ZWFibGUucHJvcHMudGFyZ2V0cztcclxuICAgICAgICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBcInJvdW5kYWJsZVwiLCBlKTtcclxuICAgICAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cywgZXZlbnRzOiBldmVudHMubWFwKGZ1bmN0aW9uIChldiwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHsgdGFyZ2V0OiB0YXJnZXRzW2ldLCBtb3ZlYWJsZTogbW92ZWFibGVzW2ldLCBjdXJyZW50VGFyZ2V0OiBtb3ZlYWJsZXNbaV0gfSk7XHJcbiAgICAgICAgICAgIH0pIH0sIHJlc3VsdCk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRHcm91cFN0YXJ0XCIsIG5leHRQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcclxuICAgICAgICB2YXIgdGFyZ2V0cyA9IG1vdmVhYmxlLnByb3BzLnRhcmdldHM7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJyb3VuZGFibGVcIiwgZSk7XHJcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbih7IHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsIGV2ZW50czogZXZlbnRzLm1hcChmdW5jdGlvbiAoZXYsIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7IHRhcmdldDogdGFyZ2V0c1tpXSwgbW92ZWFibGU6IG1vdmVhYmxlc1tpXSwgY3VycmVudFRhcmdldDogbW92ZWFibGVzW2ldIH0pLCBmaWxsQ1NTT2JqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJlc3VsdC5ib3JkZXJSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICB9LCBldikpO1xyXG4gICAgICAgICAgICB9KSB9LCByZXN1bHQpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdW5kR3JvdXBcIiwgbmV4dFBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5leHRQYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcclxuICAgICAgICB2YXIgdGFyZ2V0cyA9IG1vdmVhYmxlLnByb3BzLnRhcmdldHM7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJyb3VuZGFibGVcIiwgZSk7XHJcbiAgICAgICAgY2F0Y2hFdmVudChtb3ZlYWJsZSwgXCJvblJvdW5kXCIsIGZ1bmN0aW9uIChwYXJlbnRFdmVudCkge1xyXG4gICAgICAgICAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cywgZXZlbnRzOiBldmVudHMubWFwKGZ1bmN0aW9uIChldiwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7IHRhcmdldDogdGFyZ2V0c1tpXSwgbW92ZWFibGU6IG1vdmVhYmxlc1tpXSwgY3VycmVudFRhcmdldDogbW92ZWFibGVzW2ldIH0pLCBmaWxsQ1NTT2JqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBwYXJlbnRFdmVudC5ib3JkZXJSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZXYpKTtcclxuICAgICAgICAgICAgICAgIH0pIH0sIHBhcmVudEV2ZW50KTtcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRHcm91cFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cywgZXZlbnRzOiBldmVudHMubWFwKGZ1bmN0aW9uIChldiwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHsgdGFyZ2V0OiB0YXJnZXRzW2ldLCBtb3ZlYWJsZTogbW92ZWFibGVzW2ldLCBjdXJyZW50VGFyZ2V0OiBtb3ZlYWJsZXNbaV0sIGxhc3RFdmVudDogKF9hID0gZXYuZGF0YXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0RXZlbnQgfSk7XHJcbiAgICAgICAgICAgIH0pIH0sIHJlc3VsdCk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRHcm91cEVuZFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV4dFBhcmFtcztcclxuICAgIH0sXHJcbiAgICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuYm9yZGVyUmFkaXVzU3RhdGUgPSBcIlwiO1xyXG4gICAgfSxcclxufTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgdG8gc2hvdyBhbmQgZHJhZyBvciBkb3VibGUgY2xpY2sgYm9yZGVyLXJhZGl1cywgKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3VuZGFibGUjcm91bmRhYmxlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxyXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJyb3VuZFwiLCBlID0+IHtcclxuICogICAgIGUudGFyZ2V0LnN0eWxlLmJvcmRlclJhZGl1cyA9IGUuYm9yZGVyUmFkaXVzO1xyXG4gKiB9KS5vbihcInJvdW5kRW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqICUgQ2FuIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgYWJzb2x1dGUgcHhcclxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI3JvdW5kUmVsYXRpdmVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcInJvdW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgZS50YXJnZXQuc3R5bGUuYm9yZGVyUmFkaXVzID0gZS5ib3JkZXJSYWRpdXM7XHJcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogTWluaW11bSBudW1iZXIgb2Ygcm91bmQgY29udHJvbHMuIEl0IG1vdmVzIGluIHByb3BvcnRpb24gYnkgY29udHJvbC4gW2hvcml6b250YWwsIHZlcnRpY2FsXSAoZGVmYXVsdDogWzAsIDBdKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3VuZGFibGUjbWluUm91bmRDb250cm9sc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcclxuICogICAgIHJvdW5kUmVsYXRpdmU6IGZhbHNlLFxyXG4gKiAgICAgbWluUm91bmRDb250cm9sczogWzAsIDBdLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUubWluUm91bmRDb250cm9scyA9IFsxLCAwXTtcclxuICovXHJcbi8qKlxyXG4gKiBNYXhpbXVtIG51bWJlciBvZiByb3VuZCBjb250cm9scy4gSXQgbW92ZXMgaW4gcHJvcG9ydGlvbiBieSBjb250cm9sLiBbaG9yaXpvbnRhbCwgdmVydGljYWxdIChkZWZhdWx0OiBbNCwgNF0pXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdW5kYWJsZSNtYXhSb3VuZENvbnRyb2xzXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxyXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXHJcbiAqICAgICBtYXhSb3VuZENvbnRyb2xzOiBbNCwgNF0sXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5tYXhSb3VuZENvbnRyb2xzID0gWzEsIDBdO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZXRoZXIgeW91IGNhbiBhZGQvZGVsZXRlIHJvdW5kIGNvbnRyb2xzIGJ5IGRvdWJsZS1jbGlja2luZyBhIGxpbmUgb3IgY29udHJvbC5cclxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI3JvdW5kQ2xpY2thYmxlXHJcbiAqIEBkZWZhdWx0IHRydWVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcclxuICogICAgIHJvdW5kQ2xpY2thYmxlOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUucm91bmRDbGlja2FibGUgPSBmYWxzZTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRvIHNob3cgYSByb3VuZCBjb250cm9sIHRoYXQgZG9lcyBub3QgYWN0dWFsbHkgZXhpc3QgYXMgYSBzaGFkb3dcclxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI2lzRGlzcGxheVNoYWRvd1JvdW5kQ29udHJvbHNcclxuICogQGRlZmF1bHQgZmFsc2VcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqICAgICBpc0Rpc3BsYXlTaGFkb3dSb3VuZENvbnRyb2xzOiBmYWxzZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLmlzRGlzcGxheVNoYWRvd1JvdW5kQ29udHJvbHMgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBwYWRkaW5nIHZhbHVlIG9mIHRoZSBwb3NpdGlvbiBvZiB0aGUgcm91bmQgY29udHJvbFxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3VuZGFibGUjcm91bmRQYWRkaW5nXHJcbiAqIEBkZWZhdWx0IGZhbHNlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxyXG4gKiAgICAgcm91bmRQYWRkaW5nOiAwLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUucm91bmRQYWRkaW5nID0gMTU7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBkcmFnIHN0YXJ0IHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgcm91bmRTdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm91bmRhYmxlXHJcbiAqIEBldmVudCByb3VuZFN0YXJ0XHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm91bmRhYmxlLk9uUm91bmRTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdW5kU3RhcnRgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxyXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJyb3VuZFwiLCBlID0+IHtcclxuICogICAgIGUudGFyZ2V0LnN0eWxlLmJvcmRlclJhZGl1cyA9IGUuYm9yZGVyUmFkaXVzO1xyXG4gKiB9KS5vbihcInJvdW5kRW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gZHJhZyBvciBkb3VibGUgY2xpY2sgdGhlIGJvcmRlciBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYHJvdW5kYCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3VuZGFibGVcclxuICogQGV2ZW50IHJvdW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm91bmRhYmxlLk9uUm91bmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3VuZGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxyXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJyb3VuZFwiLCBlID0+IHtcclxuICogICAgIGUudGFyZ2V0LnN0eWxlLmJvcmRlclJhZGl1cyA9IGUuYm9yZGVyUmFkaXVzO1xyXG4gKiB9KS5vbihcInJvdW5kRW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gZHJhZyBlbmQgdGhlIGJvcmRlciBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYHJvdW5kRW5kYCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3VuZGFibGVcclxuICogQGV2ZW50IHJvdW5kRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm91bmRhYmxlLm9uUm91bmRFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3VuZEVuZGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxyXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJyb3VuZFwiLCBlID0+IHtcclxuICogICAgIGUudGFyZ2V0LnN0eWxlLmJvcmRlclJhZGl1cyA9IGUuYm9yZGVyUmFkaXVzO1xyXG4gKiB9KS5vbihcInJvdW5kRW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gZHJhZyBzdGFydCB0aGUgY2xpcCBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYHJvdW5kR3JvdXBTdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm91bmRhYmxlXHJcbiAqIEBldmVudCByb3VuZEdyb3VwU3RhcnRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3VuZGFibGUuT25Sb3VuZEdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3VuZEdyb3VwU3RhcnRgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0czogW3RhcmdldDEsIHRhcmdldDIsIHRhcmdldDNdLFxyXG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyb3VuZEdyb3VwU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlLnRhcmdldHMpO1xyXG4gKiB9KS5vbihcInJvdW5kR3JvdXBcIiwgZSA9PiB7XHJcbiAqICAgZS5ldmVudHMuZm9yRWFjaChldiA9PiB7XHJcbiAqICAgICAgIGV2LnRhcmdldC5zdHlsZS5jc3NUZXh0ICs9IGV2LmNzc1RleHQ7XHJcbiAqICAgfSk7XHJcbiAqIH0pLm9uKFwicm91bmRHcm91cEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIGRyYWcgb3IgZG91YmxlIGNsaWNrIHRoZSBib3JkZXIgYXJlYSBvciBjb250cm9scywgdGhlIGByb3VuZEdyb3VwYCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3VuZGFibGVcclxuICogQGV2ZW50IHJvdW5kR3JvdXBcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3VuZGFibGUuT25Sb3VuZEdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm91bmRHcm91cGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXRzOiBbdGFyZ2V0MSwgdGFyZ2V0MiwgdGFyZ2V0M10sXHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kR3JvdXBTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0cyk7XHJcbiAqIH0pLm9uKFwicm91bmRHcm91cFwiLCBlID0+IHtcclxuICogICBlLmV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcclxuICogICAgICAgZXYudGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gZXYuY3NzVGV4dDtcclxuICogICB9KTtcclxuICogfSkub24oXCJyb3VuZEdyb3VwRW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gZHJhZyBlbmQgdGhlIGJvcmRlciBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYHJvdW5kR3JvdXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdW5kYWJsZVxyXG4gKiBAZXZlbnQgcm91bmRHcm91cEVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdW5kYWJsZS5vblJvdW5kR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3VuZEdyb3VwRW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldHM6IFt0YXJnZXQxLCB0YXJnZXQyLCB0YXJnZXQzXSxcclxuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRHcm91cFN0YXJ0XCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZS50YXJnZXRzKTtcclxuICogfSkub24oXCJyb3VuZEdyb3VwXCIsIGUgPT4ge1xyXG4gKiAgICAgZS5ldmVudHMuZm9yRWFjaChldiA9PiB7XHJcbiAqICAgICAgICAgZXYudGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gZXYuY3NzVGV4dDtcclxuICogICAgIH0pO1xyXG4gKiB9KS5vbihcInJvdW5kR3JvdXBFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xuXG5mdW5jdGlvbiBpc0lkZW50aXR5TWF0cml4KG1hdHJpeCwgaXMzZCkge1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICB2YXIgaWRlbnRpdHlNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcclxuICAgIHZhciB2YWx1ZSA9IFwibWF0cml4XCIuY29uY2F0KGlzM2QgPyBcIjNkXCIgOiBcIlwiLCBcIihcIikuY29uY2F0KGlkZW50aXR5TWF0cml4LmpvaW4oXCIsXCIpLCBcIilcIik7XHJcbiAgICByZXR1cm4gbWF0cml4ID09PSB2YWx1ZSB8fCBtYXRyaXggPT09IFwibWF0cml4KDEsMCwwLDEsMCwwKVwiO1xyXG59XHJcbnZhciBCZWZvcmVSZW5kZXJhYmxlID0ge1xyXG4gICAgaXNQaW5jaDogdHJ1ZSxcclxuICAgIG5hbWU6IFwiYmVmb3JlUmVuZGVyYWJsZVwiLFxyXG4gICAgcHJvcHM6IFtdLFxyXG4gICAgZXZlbnRzOiBbXHJcbiAgICAgICAgXCJiZWZvcmVSZW5kZXJTdGFydFwiLFxyXG4gICAgICAgIFwiYmVmb3JlUmVuZGVyXCIsXHJcbiAgICAgICAgXCJiZWZvcmVSZW5kZXJFbmRcIixcclxuICAgICAgICBcImJlZm9yZVJlbmRlckdyb3VwU3RhcnRcIixcclxuICAgICAgICBcImJlZm9yZVJlbmRlckdyb3VwXCIsXHJcbiAgICAgICAgXCJiZWZvcmVSZW5kZXJHcm91cEVuZFwiLFxyXG4gICAgXSxcclxuICAgIGRyYWdSZWxhdGlvbjogXCJ3ZWFrXCIsXHJcbiAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCBpczNkID0gX2EuaXMzZCwgdGFyZ2V0TWF0cml4ID0gX2EudGFyZ2V0TWF0cml4LCBpbmxpbmVUcmFuc2Zvcm0gPSBfYS5pbmxpbmVUcmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIGNzc01hdHJpeCA9IGlzM2RcclxuICAgICAgICAgICAgPyBcIm1hdHJpeDNkKFwiLmNvbmNhdCh0YXJnZXRNYXRyaXguam9pbihcIixcIiksIFwiKVwiKVxyXG4gICAgICAgICAgICA6IFwibWF0cml4KFwiLmNvbmNhdChjb252ZXJ0TWF0cml4dG9DU1ModGFyZ2V0TWF0cml4LCB0cnVlKSwgXCIpXCIpO1xyXG4gICAgICAgIHZhciBzdGFydFRyYW5zZm9ybSA9ICFpbmxpbmVUcmFuc2Zvcm0gfHwgaW5saW5lVHJhbnNmb3JtID09PSBcIm5vbmVcIiA/IGNzc01hdHJpeCA6IGlubGluZVRyYW5zZm9ybTtcclxuICAgICAgICBlLmRhdGFzLnN0YXJ0VHJhbnNmb3JtcyA9IGlzSWRlbnRpdHlNYXRyaXgoc3RhcnRUcmFuc2Zvcm0sIGlzM2QpID8gW10gOiBzcGxpdFNwYWNlKHN0YXJ0VHJhbnNmb3JtKTtcclxuICAgIH0sXHJcbiAgICByZXNldFN0eWxlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgZGF0YXMubmV4dFN0eWxlID0ge307XHJcbiAgICAgICAgZGF0YXMubmV4dFRyYW5zZm9ybXMgPSBlLmRhdGFzLnN0YXJ0VHJhbnNmb3JtcztcclxuICAgICAgICBkYXRhcy5uZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzID0gW107XHJcbiAgICB9LFxyXG4gICAgZmlsbERyYWdTdGFydFBhcmFtczogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICBlLmRhdGFzLnN0YXJ0VHJhbnNmb3JtcyA9IGlzQXJyYXkodHJhbnNmb3JtKSA/IHRyYW5zZm9ybSA6IHNwbGl0U3BhY2UodHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZmlsbERyYWdQYXJhbXM6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0obW92ZWFibGUsIGUpO1xyXG4gICAgICAgIHRoaXMucmVzZXRTdHlsZShlKTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZW5kZXJTdGFydFwiLCB0aGlzLmZpbGxEcmFnU3RhcnRQYXJhbXMobW92ZWFibGUsIGUpKTtcclxuICAgIH0sXHJcbiAgICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICBpZiAoIWUuZGF0YXMuc3RhcnRUcmFuc2Zvcm1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldFN0eWxlKGUpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlclwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICBpZiAoIWUuZGF0YXMuc3RhcnRUcmFuc2Zvcm1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNldFN0eWxlKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZW5kZXJFbmRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcclxuICAgICAgICAgICAgaXNEcmFnOiBlLmlzRHJhZyxcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKTtcclxuICAgICAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChjaGlsZEV2ZW50LCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZE1vdmVhYmxlID0gbW92ZWFibGVzW2ldO1xyXG4gICAgICAgICAgICBfdGhpcy5zZXRUcmFuc2Zvcm0oY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlc2V0U3R5bGUoY2hpbGRFdmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5maWxsRHJhZ1N0YXJ0UGFyYW1zKGNoaWxkTW92ZWFibGUsIGNoaWxkRXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlckdyb3VwU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcclxuICAgICAgICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcclxuICAgICAgICAgICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7IH0sXHJcbiAgICAgICAgICAgIGV2ZW50czogcGFyYW1zLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5kcmFnKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBcImJlZm9yZVJlbmRlcmFibGVcIiwgZSk7XHJcbiAgICAgICAgdmFyIG1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcztcclxuICAgICAgICB2YXIgcGFyYW1zID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoY2hpbGRFdmVudCwgaSkge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcclxuICAgICAgICAgICAgX3RoaXMucmVzZXRTdHlsZShjaGlsZEV2ZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZpbGxEcmFnUGFyYW1zKGNoaWxkTW92ZWFibGUsIGNoaWxkRXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlckdyb3VwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXHJcbiAgICAgICAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXHJcbiAgICAgICAgICAgIGV2ZW50czogcGFyYW1zLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVuZGVyR3JvdXBFbmRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcclxuICAgICAgICAgICAgaXNEcmFnOiBlLmlzRHJhZyxcclxuICAgICAgICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdHcm91cChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbn07XG5cbnZhciBSZW5kZXJhYmxlID0ge1xyXG4gICAgbmFtZTogXCJyZW5kZXJhYmxlXCIsXHJcbiAgICBwcm9wczogW10sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcInJlbmRlclN0YXJ0XCIsXHJcbiAgICAgICAgXCJyZW5kZXJcIixcclxuICAgICAgICBcInJlbmRlckVuZFwiLFxyXG4gICAgICAgIFwicmVuZGVyR3JvdXBTdGFydFwiLFxyXG4gICAgICAgIFwicmVuZGVyR3JvdXBcIixcclxuICAgICAgICBcInJlbmRlckdyb3VwRW5kXCIsXHJcbiAgICBdLFxyXG4gICAgZHJhZ1JlbGF0aW9uOiBcIndlYWtcIixcclxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyXCIsIHRoaXMuZmlsbERyYWdQYXJhbXMobW92ZWFibGUsIGUpKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQWZ0ZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlbmRlckVuZFwiLCB0aGlzLmZpbGxEcmFnRW5kUGFyYW1zKG1vdmVhYmxlLCBlKSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlbmRlckdyb3VwU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcclxuICAgICAgICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKTtcclxuICAgICAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChjaGlsZEV2ZW50LCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZE1vdmVhYmxlID0gbW92ZWFibGVzW2ldO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZmlsbERyYWdQYXJhbXMoY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oX19hc3NpZ24oeyBpc1BpbmNoOiAhIWUuaXNQaW5jaCwgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cywgdHJhbnNmb3JtOiBnZXROZXh0VHJhbnNmb3JtVGV4dChlKSwgdHJhbnNmb3JtT2JqZWN0OiB7fSB9LCBmaWxsQ1NTT2JqZWN0KGdldE5leHRTdHlsZShlKSkpLCB7IGV2ZW50czogcGFyYW1zIH0pKSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKTtcclxuICAgICAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChjaGlsZEV2ZW50LCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZE1vdmVhYmxlID0gbW92ZWFibGVzW2ldO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZmlsbERyYWdFbmRQYXJhbXMoY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyR3JvdXBFbmRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oeyBpc1BpbmNoOiAhIWUuaXNQaW5jaCwgaXNEcmFnOiBlLmlzRHJhZywgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cywgZXZlbnRzOiBwYXJhbXMsIHRyYW5zZm9ybU9iamVjdDoge30sIHRyYW5zZm9ybTogZ2V0TmV4dFRyYW5zZm9ybVRleHQoZSkgfSwgZmlsbENTU09iamVjdChnZXROZXh0U3R5bGUoZSkpKSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sQWZ0ZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdBZnRlcihtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdHcm91cChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBmaWxsRHJhZ1BhcmFtczogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybU9iamVjdCA9IHt9O1xyXG4gICAgICAgIHBhcnNlKGdldE5leHRUcmFuc2Zvcm1zKGUpIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChtYXRyaXhJbmZvKSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybU9iamVjdFttYXRyaXhJbmZvLm5hbWVdID0gbWF0cml4SW5mby5mdW5jdGlvblZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7IGlzUGluY2g6ICEhZS5pc1BpbmNoLCB0cmFuc2Zvcm1PYmplY3Q6IHRyYW5zZm9ybU9iamVjdCwgdHJhbnNmb3JtOiBnZXROZXh0VHJhbnNmb3JtVGV4dChlKSB9LCBmaWxsQ1NTT2JqZWN0KGdldE5leHRTdHlsZShlKSkpKTtcclxuICAgIH0sXHJcbiAgICBmaWxsRHJhZ0VuZFBhcmFtczogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybU9iamVjdCA9IHt9O1xyXG4gICAgICAgIHBhcnNlKGdldE5leHRUcmFuc2Zvcm1zKGUpIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChtYXRyaXhJbmZvKSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybU9iamVjdFttYXRyaXhJbmZvLm5hbWVdID0gbWF0cml4SW5mby5mdW5jdGlvblZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7IGlzUGluY2g6ICEhZS5pc1BpbmNoLCBpc0RyYWc6IGUuaXNEcmFnLCB0cmFuc2Zvcm1PYmplY3Q6IHRyYW5zZm9ybU9iamVjdCwgdHJhbnNmb3JtOiBnZXROZXh0VHJhbnNmb3JtVGV4dChlKSB9LCBmaWxsQ1NTT2JqZWN0KGdldE5leHRTdHlsZShlKSkpKTtcclxuICAgIH0sXHJcbn07XG5cbmZ1bmN0aW9uIHRyaWdnZXJBYmxlKG1vdmVhYmxlLCBtb3ZlYWJsZUFibGVzLCBldmVudE9wZXJhdGlvbnMsIGV2ZW50QWZmaXgsIGV2ZW50VHlwZSwgZSwgcmVxdWVzdEluc3RhbnQpIHtcclxuICAgIC8vIHByZSBzZXR0aW5nXHJcbiAgICBlLmNsaWVudERpc3RYID0gZS5kaXN0WDtcclxuICAgIGUuY2xpZW50RGlzdFkgPSBlLmRpc3RZO1xyXG4gICAgdmFyIGlzU3RhcnQgPSBldmVudFR5cGUgPT09IFwiU3RhcnRcIjtcclxuICAgIHZhciBpc0VuZCA9IGV2ZW50VHlwZSA9PT0gXCJFbmRcIjtcclxuICAgIHZhciBpc0FmdGVyID0gZXZlbnRUeXBlID09PSBcIkFmdGVyXCI7XHJcbiAgICB2YXIgdGFyZ2V0ID0gbW92ZWFibGUuc3RhdGUudGFyZ2V0O1xyXG4gICAgdmFyIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0O1xyXG4gICAgdmFyIGlzQ29udHJvbCA9IGV2ZW50QWZmaXguaW5kZXhPZihcIkNvbnRyb2xcIikgPiAtMTtcclxuICAgIGlmICghdGFyZ2V0XHJcbiAgICAgICAgfHwgKGlzU3RhcnQgJiYgaXNDb250cm9sICYmICFpc1JlcXVlc3QgJiYgbW92ZWFibGUuYXJlYUVsZW1lbnQgPT09IGUuaW5wdXRFdmVudC50YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIGFibGVzID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG1vdmVhYmxlQWJsZXMpLCBmYWxzZSk7XHJcbiAgICBpZiAoaXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgdmFyIHJlcXVlc3RBYmxlXzEgPSBlLnJlcXVlc3RBYmxlO1xyXG4gICAgICAgIGlmICghYWJsZXMuc29tZShmdW5jdGlvbiAoYWJsZSkgeyByZXR1cm4gYWJsZS5uYW1lID09PSByZXF1ZXN0QWJsZV8xOyB9KSkge1xyXG4gICAgICAgICAgICBhYmxlcy5wdXNoLmFwcGx5KGFibGVzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobW92ZWFibGUucHJvcHMuYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7IHJldHVybiBhYmxlLm5hbWUgPT09IHJlcXVlc3RBYmxlXzE7IH0pKSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWFibGVzLmxlbmd0aCB8fCBhYmxlcy5ldmVyeShmdW5jdGlvbiAoYWJsZSkgeyByZXR1cm4gYWJsZS5kcmFnUmVsYXRpb247IH0pKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gXCJkcmFnXCIgXCJDb250cm9sXCIgXCJBZnRlclwiXHJcbiAgICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcclxuICAgIHZhciBpbnB1dFRhcmdldDtcclxuICAgIGlmIChpc0VuZCAmJiBpbnB1dEV2ZW50KSB7XHJcbiAgICAgICAgaW5wdXRUYXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKSB8fCBpbnB1dEV2ZW50LnRhcmdldDtcclxuICAgIH1cclxuICAgIHZhciBpc0RyYWdTdG9wID0gZmFsc2U7XHJcbiAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaXNEcmFnU3RvcCA9IHRydWU7XHJcbiAgICAgICAgKF9hID0gZS5zdG9wKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChlKTtcclxuICAgIH07XHJcbiAgICB2YXIgaXNGaXJzdFN0YXJ0ID0gaXNTdGFydCAmJiAoIW1vdmVhYmxlLnRhcmdldEdlc3RvIHx8ICFtb3ZlYWJsZS5jb250cm9sR2VzdG9cclxuICAgICAgICB8fCAoIW1vdmVhYmxlLnRhcmdldEdlc3RvLmlzRmxhZygpIHx8ICFtb3ZlYWJsZS5jb250cm9sR2VzdG8uaXNGbGFnKCkpKTtcclxuICAgIGlmIChpc0ZpcnN0U3RhcnQpIHtcclxuICAgICAgICBtb3ZlYWJsZS51cGRhdGVSZWN0KGV2ZW50VHlwZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLy8gdHJpZ2dlciBhYmxlc1xyXG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgIHZhciBnZXN0b1R5cGUgPSBpc0NvbnRyb2wgPyBcImNvbnRyb2xHZXN0b1wiIDogXCJ0YXJnZXRHZXN0b1wiO1xyXG4gICAgdmFyIHByZXZHZXN0byA9IG1vdmVhYmxlW2dlc3RvVHlwZV07XHJcbiAgICB2YXIgdHJpZ2dlciA9IGZ1bmN0aW9uIChhYmxlLCBldmVudE5hbWUsIGNvbmRpdGlvbk5hbWUpIHtcclxuICAgICAgICBpZiAoIShldmVudE5hbWUgaW4gYWJsZSkgfHwgcHJldkdlc3RvICE9PSBtb3ZlYWJsZVtnZXN0b1R5cGVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFibGVOYW1lID0gYWJsZS5uYW1lO1xyXG4gICAgICAgIHZhciBuZXh0RGF0YXMgPSBkYXRhc1thYmxlTmFtZV0gfHwgKGRhdGFzW2FibGVOYW1lXSA9IHt9KTtcclxuICAgICAgICBpZiAoaXNTdGFydCkge1xyXG4gICAgICAgICAgICBuZXh0RGF0YXMuaXNFdmVudFN0YXJ0ID0gIWNvbmRpdGlvbk5hbWVcclxuICAgICAgICAgICAgICAgIHx8ICFhYmxlW2NvbmRpdGlvbk5hbWVdIHx8IGFibGVbY29uZGl0aW9uTmFtZV0obW92ZWFibGUsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5leHREYXRhcy5pc0V2ZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gYWJsZVtldmVudE5hbWVdKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgc3RvcDogc3RvcCwgZGF0YXM6IG5leHREYXRhcywgb3JpZ2luYWxEYXRhczogZGF0YXMsIGlucHV0VGFyZ2V0OiBpbnB1dFRhcmdldCB9KSk7XHJcbiAgICAgICAgbW92ZWFibGUuX2VtaXR0ZXIub2ZmKCk7XHJcbiAgICAgICAgaWYgKGlzU3RhcnQgJiYgcmVzdWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBuZXh0RGF0YXMuaXNFdmVudFN0YXJ0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLy8gdW5zZXQgYWJsZXMgZm9yIGZpcnN0IGRyYWcgc3RhcnRcclxuICAgIGlmIChpc0ZpcnN0U3RhcnQpIHtcclxuICAgICAgICBhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgIGFibGUudW5zZXQgJiYgYWJsZS51bnNldChtb3ZlYWJsZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBCZWZvcmVSZW5kZXJhYmxlXHJcbiAgICB0cmlnZ2VyKEJlZm9yZVJlbmRlcmFibGUsIFwiZHJhZ1wiLmNvbmNhdChldmVudEFmZml4KS5jb25jYXQoZXZlbnRUeXBlKSk7XHJcbiAgICB2YXIgZm9yY2VFbmRlZENvdW50ID0gMDtcclxuICAgIHZhciB1cGRhdGVkQ291bnQgPSAwO1xyXG4gICAgZXZlbnRPcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50T3BlcmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKGlzRHJhZ1N0b3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXZlbnROYW1lID0gXCJcIi5jb25jYXQoZXZlbnRPcGVyYXRpb24pLmNvbmNhdChldmVudEFmZml4KS5jb25jYXQoZXZlbnRUeXBlKTtcclxuICAgICAgICB2YXIgY29uZGl0aW9uTmFtZSA9IFwiXCIuY29uY2F0KGV2ZW50T3BlcmF0aW9uKS5jb25jYXQoZXZlbnRBZmZpeCwgXCJDb25kaXRpb25cIik7XHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gXCJcIiAmJiAhaXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZGlzdFgsIGRpc3RZXHJcbiAgICAgICAgICAgIGNvbnZlcnREcmFnRGlzdChtb3ZlYWJsZS5zdGF0ZSwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnN0IGlzR3JvdXAgPSBldmVudEFmZml4LmluZGV4T2YoXCJHcm91cFwiKSA+IC0xO1xyXG4gICAgICAgIHZhciBldmVudEFibGVzID0gYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7IHJldHVybiBhYmxlW2V2ZW50TmFtZV07IH0pO1xyXG4gICAgICAgIGV2ZW50QWJsZXMgPSBldmVudEFibGVzLmZpbHRlcihmdW5jdGlvbiAoYWJsZSwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWJsZS5uYW1lICYmIGV2ZW50QWJsZXMuaW5kZXhPZihhYmxlKSA9PT0gaTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IGV2ZW50QWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7IHJldHVybiB0cmlnZ2VyKGFibGUsIGV2ZW50TmFtZSwgY29uZGl0aW9uTmFtZSk7IH0pO1xyXG4gICAgICAgIHZhciBpc1VwZGF0ZSA9IHJlc3VsdHMubGVuZ3RoO1xyXG4gICAgICAgIC8vIGVuZCBhYmxlc1xyXG4gICAgICAgIGlmIChpc0RyYWdTdG9wKSB7XHJcbiAgICAgICAgICAgICsrZm9yY2VFbmRlZENvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVcGRhdGUpIHtcclxuICAgICAgICAgICAgKyt1cGRhdGVkQ291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNEcmFnU3RvcCAmJiBpc1N0YXJ0ICYmIGV2ZW50QWJsZXMubGVuZ3RoICYmICFpc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICBmb3JjZUVuZGVkQ291bnQgKz0gZXZlbnRBYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhYmxlTmFtZSA9IGFibGUubmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0RGF0YXMgPSBkYXRhc1thYmxlTmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dERhdGFzLmlzRXZlbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhYmxlLmRyYWdSZWxhdGlvbiA9PT0gXCJzdHJvbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgZHJhZ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcHJlIHN0b3AgZHJhZ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KS5sZW5ndGggPyAxIDogMDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmICghaXNBZnRlciB8fCB1cGRhdGVkQ291bnQpIHtcclxuICAgICAgICB0cmlnZ2VyKFJlbmRlcmFibGUsIFwiZHJhZ1wiLmNvbmNhdChldmVudEFmZml4KS5jb25jYXQoZXZlbnRUeXBlKSk7XHJcbiAgICB9XHJcbiAgICAvLyBzdG9wIGdlc3RvIGNvbmRpdGlvblxyXG4gICAgdmFyIGlzRm9yY2VFbmQgPSBwcmV2R2VzdG8gIT09IG1vdmVhYmxlW2dlc3RvVHlwZV0gfHwgZm9yY2VFbmRlZENvdW50ID09PSBldmVudE9wZXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgaWYgKGlzRW5kIHx8IGlzRHJhZ1N0b3AgfHwgaXNGb3JjZUVuZCkge1xyXG4gICAgICAgIG1vdmVhYmxlLnN0YXRlLmdlc3RvcyA9IHt9O1xyXG4gICAgICAgIGlmIChtb3ZlYWJsZS5tb3ZlYWJsZXMpIHtcclxuICAgICAgICAgICAgbW92ZWFibGUubW92ZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTW92ZWFibGUpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkTW92ZWFibGUuc3RhdGUuZ2VzdG9zID0ge307XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgIGFibGUudW5zZXQgJiYgYWJsZS51bnNldChtb3ZlYWJsZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdGFydCAmJiAhaXNGb3JjZUVuZCAmJiAhaXNSZXF1ZXN0ICYmIHVwZGF0ZWRDb3VudCAmJiBtb3ZlYWJsZS5wcm9wcy5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vdmVhYmxlLmlzVW5tb3VudGVkIHx8IGlzRm9yY2VFbmQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoKCFpc1N0YXJ0ICYmIHVwZGF0ZWRDb3VudCAmJiAhcmVxdWVzdEluc3RhbnQpIHx8IGlzRW5kKSB7XHJcbiAgICAgICAgdmFyIGZsdXNoU3luYyA9IG1vdmVhYmxlLnByb3BzLmZsdXNoU3luYyB8fCBkZWZhdWx0U3luYztcclxuICAgICAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBtb3ZlYWJsZS51cGRhdGVSZWN0KGlzRW5kID8gZXZlbnRUeXBlIDogXCJcIiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBtb3ZlYWJsZS5mb3JjZVVwZGF0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1N0YXJ0ICYmICFpc0VuZCAmJiAhaXNBZnRlciAmJiB1cGRhdGVkQ291bnQgJiYgIXJlcXVlc3RJbnN0YW50KSB7XHJcbiAgICAgICAgdHJpZ2dlckFibGUobW92ZWFibGUsIG1vdmVhYmxlQWJsZXMsIGV2ZW50T3BlcmF0aW9ucywgZXZlbnRBZmZpeCwgZXZlbnRUeXBlICsgXCJBZnRlclwiLCBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrTW92ZWFibGVUYXJnZXQobW92ZWFibGUsIGlzQ29udHJvbCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7IHRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7IH1cclxuICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdmFyIGFyZWFFbGVtZW50ID0gbW92ZWFibGUuYXJlYUVsZW1lbnQ7XHJcbiAgICAgICAgdmFyIGRyYWdUYXJnZXRFbGVtZW50ID0gbW92ZWFibGUuX2RyYWdUYXJnZXQ7XHJcbiAgICAgICAgaWYgKCFkcmFnVGFyZ2V0RWxlbWVudCB8fCAoIWlzQ29udHJvbCAmJiAoKF9hID0gbW92ZWFibGUuY29udHJvbEdlc3RvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNGbGFnKCkpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudFRhcmdldCA9PT0gZHJhZ1RhcmdldEVsZW1lbnRcclxuICAgICAgICAgICAgfHwgZHJhZ1RhcmdldEVsZW1lbnQuY29udGFpbnMoZXZlbnRUYXJnZXQpXHJcbiAgICAgICAgICAgIHx8IGV2ZW50VGFyZ2V0ID09PSBhcmVhRWxlbWVudFxyXG4gICAgICAgICAgICB8fCAoIW1vdmVhYmxlLmlzTW92ZWFibGVFbGVtZW50KGV2ZW50VGFyZ2V0KSAmJiAhbW92ZWFibGUuY29udHJvbEJveC5jb250YWlucyhldmVudFRhcmdldCkpXHJcbiAgICAgICAgICAgIHx8IGhhc0NsYXNzKGV2ZW50VGFyZ2V0LCBcIm1vdmVhYmxlLWFyZWFcIilcclxuICAgICAgICAgICAgfHwgaGFzQ2xhc3MoZXZlbnRUYXJnZXQsIFwibW92ZWFibGUtcGFkZGluZ1wiKVxyXG4gICAgICAgICAgICB8fCBoYXNDbGFzcyhldmVudFRhcmdldCwgXCJtb3ZlYWJsZS1lZGdlRHJhZ2dhYmxlXCIpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUYXJnZXRBYmxlR2VzdG8obW92ZWFibGUsIG1vdmVhYmxlVGFyZ2V0LCBldmVudEFmZml4KSB7XHJcbiAgICB2YXIgY29udHJvbEJveCA9IG1vdmVhYmxlLmNvbnRyb2xCb3g7XHJcbiAgICB2YXIgdGFyZ2V0cyA9IFtdO1xyXG4gICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICB2YXIgZHJhZ0FyZWEgPSBwcm9wcy5kcmFnQXJlYTtcclxuICAgIHZhciB0YXJnZXQgPSBtb3ZlYWJsZS5zdGF0ZS50YXJnZXQ7XHJcbiAgICB2YXIgZHJhZ1RhcmdldCA9IHByb3BzLmRyYWdUYXJnZXQ7XHJcbiAgICB0YXJnZXRzLnB1c2goY29udHJvbEJveCk7XHJcbiAgICBpZiAoIWRyYWdBcmVhIHx8IGRyYWdUYXJnZXQpIHtcclxuICAgICAgICB0YXJnZXRzLnB1c2gobW92ZWFibGVUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkcmFnQXJlYSAmJiBkcmFnVGFyZ2V0ICYmIHRhcmdldCAmJiBtb3ZlYWJsZVRhcmdldCAhPT0gdGFyZ2V0ICYmIHByb3BzLmRyYWdUYXJnZXRTZWxmKSB7XHJcbiAgICAgICAgdGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICB2YXIgY2hlY2tUYXJnZXQgPSBjaGVja01vdmVhYmxlVGFyZ2V0KG1vdmVhYmxlKTtcclxuICAgIHJldHVybiBnZXRBYmxlR2VzdG8obW92ZWFibGUsIHRhcmdldHMsIFwidGFyZ2V0QWJsZXNcIiwgZXZlbnRBZmZpeCwge1xyXG4gICAgICAgIGRyYWdTdGFydDogY2hlY2tUYXJnZXQsXHJcbiAgICAgICAgcGluY2hTdGFydDogY2hlY2tUYXJnZXQsXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb250cm9sQWJsZUdlc3RvKG1vdmVhYmxlLCBldmVudEFmZml4KSB7XHJcbiAgICB2YXIgY29udHJvbEJveCA9IG1vdmVhYmxlLmNvbnRyb2xCb3g7XHJcbiAgICB2YXIgdGFyZ2V0cyA9IFtdO1xyXG4gICAgdGFyZ2V0cy5wdXNoKGNvbnRyb2xCb3gpO1xyXG4gICAgdmFyIGNoZWNrVGFyZ2V0ID0gY2hlY2tNb3ZlYWJsZVRhcmdldChtb3ZlYWJsZSwgdHJ1ZSk7XHJcbiAgICB2YXIgY2hlY2tDb250cm9sVGFyZ2V0ID0gZnVuY3Rpb24gKGUsIHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSBlLmlucHV0RXZlbnQudGFyZ2V0OyB9XHJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gY29udHJvbEJveCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNoZWNrVGFyZ2V0KGUsIHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGdldEFibGVHZXN0byhtb3ZlYWJsZSwgdGFyZ2V0cywgXCJjb250cm9sQWJsZXNcIiwgZXZlbnRBZmZpeCwge1xyXG4gICAgICAgIGRyYWdTdGFydDogY2hlY2tDb250cm9sVGFyZ2V0LFxyXG4gICAgICAgIHBpbmNoU3RhcnQ6IGNoZWNrQ29udHJvbFRhcmdldCxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFibGVHZXN0byhtb3ZlYWJsZSwgdGFyZ2V0LCBhYmxlVHlwZSwgZXZlbnRBZmZpeCwgY29uZGl0aW9uRnVuY3Rpb25zKSB7XHJcbiAgICBpZiAoY29uZGl0aW9uRnVuY3Rpb25zID09PSB2b2lkIDApIHsgY29uZGl0aW9uRnVuY3Rpb25zID0ge307IH1cclxuICAgIHZhciBpc1RhcmdldEFibGVzID0gYWJsZVR5cGUgPT09IFwidGFyZ2V0QWJsZXNcIjtcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLCBwaW5jaE91dHNpZGUgPSBfYS5waW5jaE91dHNpZGUsIHBpbmNoVGhyZXNob2xkID0gX2EucGluY2hUaHJlc2hvbGQsIHByZXZlbnRDbGlja0V2ZW50T25EcmFnID0gX2EucHJldmVudENsaWNrRXZlbnRPbkRyYWcsIHByZXZlbnRDbGlja0RlZmF1bHQgPSBfYS5wcmV2ZW50Q2xpY2tEZWZhdWx0LCBjaGVja0lucHV0ID0gX2EuY2hlY2tJbnB1dCwgZHJhZ0ZvY3VzZWRJbnB1dCA9IF9hLmRyYWdGb2N1c2VkSW5wdXQsIF9iID0gX2EucHJldmVudERlZmF1bHQsIHByZXZlbnREZWZhdWx0ID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgX2MgPSBfYS5wcmV2ZW50UmlnaHRDbGljaywgcHJldmVudFJpZ2h0Q2xpY2sgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IF9hLnByZXZlbnRXaGVlbENsaWNrLCBwcmV2ZW50V2hlZWxDbGljayA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsIGRyYWdDb250YWllbnJPcHRpb24gPSBfYS5kcmFnQ29udGFpbmVyO1xyXG4gICAgdmFyIGRyYWdDb250YWluZXIgPSBnZXRSZWZUYXJnZXQoZHJhZ0NvbnRhaWVuck9wdGlvbiwgdHJ1ZSk7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogcHJldmVudERlZmF1bHQsXHJcbiAgICAgICAgcHJldmVudFJpZ2h0Q2xpY2s6IHByZXZlbnRSaWdodENsaWNrLFxyXG4gICAgICAgIHByZXZlbnRXaGVlbENsaWNrOiBwcmV2ZW50V2hlZWxDbGljayxcclxuICAgICAgICBjb250YWluZXI6IGRyYWdDb250YWluZXIgfHwgZ2V0V2luZG93KG1vdmVhYmxlLmdldENvbnRyb2xCb3hFbGVtZW50KCkpLFxyXG4gICAgICAgIHBpbmNoVGhyZXNob2xkOiBwaW5jaFRocmVzaG9sZCxcclxuICAgICAgICBwaW5jaE91dHNpZGU6IHBpbmNoT3V0c2lkZSxcclxuICAgICAgICBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZzogaXNUYXJnZXRBYmxlcyA/IHByZXZlbnRDbGlja0V2ZW50T25EcmFnIDogZmFsc2UsXHJcbiAgICAgICAgcHJldmVudENsaWNrRXZlbnRPbkRyYWdTdGFydDogaXNUYXJnZXRBYmxlcyA/IHByZXZlbnRDbGlja0RlZmF1bHQgOiBmYWxzZSxcclxuICAgICAgICBwcmV2ZW50Q2xpY2tFdmVudEJ5Q29uZGl0aW9uOiBpc1RhcmdldEFibGVzID8gbnVsbCA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb3ZlYWJsZS5jb250cm9sQm94LmNvbnRhaW5zKGUudGFyZ2V0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNoZWNrSW5wdXQ6IGlzVGFyZ2V0QWJsZXMgPyBjaGVja0lucHV0IDogZmFsc2UsXHJcbiAgICAgICAgZHJhZ0ZvY3VzZWRJbnB1dDogZHJhZ0ZvY3VzZWRJbnB1dCxcclxuICAgIH07XHJcbiAgICB2YXIgZ2VzdG8gPSBuZXcgR2VzdG8odGFyZ2V0LCBvcHRpb25zKTtcclxuICAgIHZhciBpc0NvbnRyb2wgPSBldmVudEFmZml4ID09PSBcIkNvbnRyb2xcIjtcclxuICAgIFtcImRyYWdcIiwgXCJwaW5jaFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE9wZXJhdGlvbikge1xyXG4gICAgICAgIFtcIlN0YXJ0XCIsIFwiXCIsIFwiRW5kXCJdLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xyXG4gICAgICAgICAgICBnZXN0by5vbihcIlwiLmNvbmNhdChldmVudE9wZXJhdGlvbikuY29uY2F0KGV2ZW50VHlwZSksIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZS5ldmVudFR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNQaW5jaFNjaGVkdWxlZCA9IGV2ZW50T3BlcmF0aW9uID09PSBcImRyYWdcIiAmJiBlLmlzUGluY2g7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uRnVuY3Rpb25zW2V2ZW50TmFtZV0gJiYgIWNvbmRpdGlvbkZ1bmN0aW9uc1tldmVudE5hbWVdKGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUGluY2hTY2hlZHVsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRPcGVyYXRpb25zID0gZXZlbnRPcGVyYXRpb24gPT09IFwiZHJhZ1wiID8gW2V2ZW50T3BlcmF0aW9uXSA6IFtcImRyYWdcIiwgZXZlbnRPcGVyYXRpb25dO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vdmVhYmxlQWJsZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobW92ZWFibGVbYWJsZVR5cGVdKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJBYmxlKG1vdmVhYmxlLCBtb3ZlYWJsZUFibGVzLCBldmVudE9wZXJhdGlvbnMsIGV2ZW50QWZmaXgsIGV2ZW50VHlwZSwgZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW92ZWFibGUucHJvcHMuc3RvcFByb3BhZ2F0aW9uIHx8IChldmVudFR5cGUgPT09IFwiU3RhcnRcIiAmJiBpc0NvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmlucHV0RXZlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBnZXN0bztcclxufVxuXG52YXIgRXZlbnRNYW5hZ2VyID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKHRhcmdldCwgbW92ZWFibGUsIGV2ZW50TmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5tb3ZlYWJsZSA9IG1vdmVhYmxlO1xyXG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xyXG4gICAgICAgIHRoaXMuYWJsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9vbkV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IF90aGlzLmV2ZW50TmFtZTtcclxuICAgICAgICAgICAgdmFyIG1vdmVhYmxlID0gX3RoaXMubW92ZWFibGU7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlYWJsZS5zdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5hYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBhYmxlW2V2ZW50TmFtZV0obW92ZWFibGUsIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dEV2ZW50OiBlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLnRvTG93ZXJDYXNlKCksIHRoaXMuX29uRXZlbnQpO1xyXG4gICAgfVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZXRBYmxlcyA9IGZ1bmN0aW9uIChhYmxlcykge1xyXG4gICAgICAgIHRoaXMuYWJsZXMgPSBhYmxlcztcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpLCB0aGlzLl9vbkV2ZW50KTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3ZlYWJsZSA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50TWFuYWdlcjtcclxufSgpKTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4U3RhY2sodGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIsIGlzQWJzb2x1dGUzZCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgaWYgKHJvb3RDb250YWluZXIgPT09IHZvaWQgMCkgeyByb290Q29udGFpbmVyID0gY29udGFpbmVyOyB9XHJcbiAgICB2YXIgX2IgPSBnZXRNYXRyaXhTdGFja0luZm8odGFyZ2V0LCBjb250YWluZXIpLCBtYXRyaXhlcyA9IF9iLm1hdHJpeGVzLCBpczNkID0gX2IuaXMzZCwgcHJldlRhcmdldE1hdHJpeCA9IF9iLnRhcmdldE1hdHJpeCwgdHJhbnNmb3JtT3JpZ2luID0gX2IudHJhbnNmb3JtT3JpZ2luLCB0YXJnZXRPcmlnaW4gPSBfYi50YXJnZXRPcmlnaW4sIG9mZnNldENvbnRhaW5lciA9IF9iLm9mZnNldENvbnRhaW5lciwgaGFzRml4ZWQgPSBfYi5oYXNGaXhlZCwgY29udGFpbmVyWm9vbSA9IF9iLnpvb207IC8vIHByZXZNYXRyaXhcclxuICAgIHZhciBfYyA9IGdldENhY2hlZE1hdHJpeENvbnRhaW5lckluZm8ob2Zmc2V0Q29udGFpbmVyLCByb290Q29udGFpbmVyKSwgcm9vdE1hdHJpeGVzID0gX2MubWF0cml4ZXMsIGlzUm9vdDNkID0gX2MuaXMzZCwgb2Zmc2V0Um9vdENvbnRhaW5lciA9IF9jLm9mZnNldENvbnRhaW5lciwgcm9vdFpvb20gPSBfYy56b29tOyAvLyBwcmV2Um9vdE1hdHJpeFxyXG4gICAgLy8gaWYgKHJvb3RDb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuICAgIC8vICAgICBjb25zb2xlLmxvZyhvZmZzZXRDb250YWluZXIsIHJvb3RDb250YWluZXIsIHJvb3RNYXRyaXhlcyk7XHJcbiAgICAvLyB9XHJcbiAgICB2YXIgaXNOZXh0M2QgPSBpc0Fic29sdXRlM2QgfHwgaXNSb290M2QgfHwgaXMzZDtcclxuICAgIHZhciBuID0gaXNOZXh0M2QgPyA0IDogMztcclxuICAgIHZhciBpc1NWR0dyYXBoaWNFbGVtZW50ID0gdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJzdmdcIiAmJiBcIm93bmVyU1ZHRWxlbWVudFwiIGluIHRhcmdldDtcclxuICAgIHZhciB0YXJnZXRNYXRyaXggPSBwcmV2VGFyZ2V0TWF0cml4O1xyXG4gICAgLy8gbGV0IGFsbE1hdHJpeCA9IHByZXZNYXRyaXggPyBjb252ZXJ0RGltZW5zaW9uKHByZXZNYXRyaXgsIHByZXZOISwgbikgOiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcclxuICAgIC8vIGxldCByb290TWF0cml4ID0gcHJldlJvb3RNYXRyaXggPyBjb252ZXJ0RGltZW5zaW9uKHByZXZSb290TWF0cml4LCBwcmV2TiEsIG4pIDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XHJcbiAgICAvLyBsZXQgYmVmb3JlTWF0cml4ID0gcHJldk1hdHJpeCA/IGNvbnZlcnREaW1lbnNpb24ocHJldk1hdHJpeCwgcHJldk4hLCBuKSA6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xyXG4gICAgdmFyIGFsbE1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xyXG4gICAgdmFyIHJvb3RNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcclxuICAgIHZhciBiZWZvcmVNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcclxuICAgIHZhciBvZmZzZXRNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcclxuICAgIHZhciBsZW5ndGggPSBtYXRyaXhlcy5sZW5ndGg7XHJcbiAgICB2YXIgbmV4dFJvb3RNYXRyaXhlcyA9IHJvb3RNYXRyaXhlcy5tYXAoZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGluZm8pLCB7IG1hdHJpeDogaW5mby5tYXRyaXggPyBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoaW5mby5tYXRyaXgpLCBmYWxzZSkgOiB1bmRlZmluZWQgfSk7XHJcbiAgICB9KS5yZXZlcnNlKCk7XHJcbiAgICBtYXRyaXhlcy5yZXZlcnNlKCk7XHJcbiAgICBpZiAoIWlzM2QgJiYgaXNOZXh0M2QpIHtcclxuICAgICAgICB0YXJnZXRNYXRyaXggPSBjb252ZXJ0RGltZW5zaW9uKHRhcmdldE1hdHJpeCwgMywgNCk7XHJcbiAgICAgICAgY29udmVydDNETWF0cml4ZXMobWF0cml4ZXMpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1Jvb3QzZCAmJiBpc05leHQzZCkge1xyXG4gICAgICAgIGNvbnZlcnQzRE1hdHJpeGVzKG5leHRSb290TWF0cml4ZXMpO1xyXG4gICAgfVxyXG4gICAgLy8gcm9vdE1hdHJpeCA9ICguLi4pIC0+IGNvbnRhaW5lciAtPiBvZmZzZXQgLT4gYWJzb2x1dGUgLT4gb2Zmc2V0IC0+IGFic29sdXRlKHRhcmdldE1hdHJpeClcclxuICAgIC8vIHJvb3RNYXRyaXhCZWZvcmVPZmZzZXQgPSBsYXN0T2Zmc2V0TWF0cml4IC0+ICguLi4pIC0+IGNvbnRhaW5lclxyXG4gICAgLy8gYmVmb3JlTWF0cml4ID0gKC4uLiAtPiBjb250YWluZXIgLT4gb2Zmc2V0IC0+IGFic29sdXRlKSAtPiBvZmZzZXQgLT4gYWJzb2x1dGUodGFyZ2V0TWF0cml4KVxyXG4gICAgLy8gb2Zmc2V0TWF0cml4ID0gKC4uLiAtPiBjb250YWluZXIgLT4gb2Zmc2V0IC0+IGFic29sdXRlIC0+IG9mZnNldCkgLT4gYWJzb2x1dGUodGFyZ2V0TWF0cml4KVxyXG4gICAgbmV4dFJvb3RNYXRyaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgcm9vdE1hdHJpeCA9IG11bHRpcGx5KHJvb3RNYXRyaXgsIGluZm8ubWF0cml4LCBuKTtcclxuICAgIH0pO1xyXG4gICAgdmFyIG9yaWdpbmFsUm9vdENvbnRhaW5lciA9IHJvb3RDb250YWluZXIgfHwgZ2V0RG9jdW1lbnRCb2R5KHRhcmdldCk7XHJcbiAgICB2YXIgZW5kQ29udGFpbmVyID0gKChfYSA9IG5leHRSb290TWF0cml4ZXNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50YXJnZXQpXHJcbiAgICAgICAgfHwgZ2V0T2Zmc2V0SW5mbyhvcmlnaW5hbFJvb3RDb250YWluZXIsIG9yaWdpbmFsUm9vdENvbnRhaW5lciwgdHJ1ZSkub2Zmc2V0UGFyZW50O1xyXG4gICAgdmFyIHJvb3RNYXRyaXhCZWZvcmVPZmZzZXQgPSBuZXh0Um9vdE1hdHJpeGVzLnNsaWNlKDEpLnJlZHVjZShmdW5jdGlvbiAobWF0cml4LCBpbmZvKSB7XHJcbiAgICAgICAgcmV0dXJuIG11bHRpcGx5KG1hdHJpeCwgaW5mby5tYXRyaXgsIG4pO1xyXG4gICAgfSwgY3JlYXRlSWRlbnRpdHlNYXRyaXgobikpO1xyXG4gICAgbWF0cml4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5mbywgaSkge1xyXG4gICAgICAgIGlmIChsZW5ndGggLSAyID09PSBpKSB7XHJcbiAgICAgICAgICAgIC8vIGxlbmd0aCAtIDNcclxuICAgICAgICAgICAgYmVmb3JlTWF0cml4ID0gYWxsTWF0cml4LnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggLSAxID09PSBpKSB7XHJcbiAgICAgICAgICAgIC8vIGxlbmd0aCAtIDJcclxuICAgICAgICAgICAgb2Zmc2V0TWF0cml4ID0gYWxsTWF0cml4LnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmb3IgU1ZHRWxlbWVudFxyXG4gICAgICAgIGlmICghaW5mby5tYXRyaXgpIHtcclxuICAgICAgICAgICAgdmFyIG5leHRJbmZvID0gbWF0cml4ZXNbaSArIDFdO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZ2V0U1ZHT2Zmc2V0KGluZm8sIG5leHRJbmZvLCBlbmRDb250YWluZXIsIG4sIG11bHRpcGx5KHJvb3RNYXRyaXhCZWZvcmVPZmZzZXQsIGFsbE1hdHJpeCwgbikpO1xyXG4gICAgICAgICAgICBpbmZvLm1hdHJpeCA9IGNyZWF0ZU9yaWdpbk1hdHJpeChvZmZzZXQsIG4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhbGxNYXRyaXggPSBtdWx0aXBseShhbGxNYXRyaXgsIGluZm8ubWF0cml4LCBuKTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGlzTWF0cml4M2QgPSAhaXNTVkdHcmFwaGljRWxlbWVudCAmJiBpczNkO1xyXG4gICAgaWYgKCF0YXJnZXRNYXRyaXgpIHtcclxuICAgICAgICB0YXJnZXRNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChpc01hdHJpeDNkID8gNCA6IDMpO1xyXG4gICAgfVxyXG4gICAgdmFyIHRhcmdldFRyYW5zZm9ybSA9IG1ha2VNYXRyaXhDU1MoaXNTVkdHcmFwaGljRWxlbWVudCAmJiB0YXJnZXRNYXRyaXgubGVuZ3RoID09PSAxNlxyXG4gICAgICAgID8gY29udmVydERpbWVuc2lvbih0YXJnZXRNYXRyaXgsIDQsIDMpIDogdGFyZ2V0TWF0cml4LCBpc01hdHJpeDNkKTtcclxuICAgIHZhciBvcmlnaW5hbFJvb3RNYXRyaXggPSByb290TWF0cml4O1xyXG4gICAgcm9vdE1hdHJpeCA9IGlnbm9yZURpbWVuc2lvbihyb290TWF0cml4LCBuLCBuKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGFzWm9vbTogY29udGFpbmVyWm9vbSAhPT0gMSB8fCByb290Wm9vbSAhPT0gMSxcclxuICAgICAgICBoYXNGaXhlZDogaGFzRml4ZWQsXHJcbiAgICAgICAgbWF0cml4ZXM6IG1hdHJpeGVzLFxyXG4gICAgICAgIHJvb3RNYXRyaXg6IHJvb3RNYXRyaXgsXHJcbiAgICAgICAgb3JpZ2luYWxSb290TWF0cml4OiBvcmlnaW5hbFJvb3RNYXRyaXgsXHJcbiAgICAgICAgYmVmb3JlTWF0cml4OiBiZWZvcmVNYXRyaXgsXHJcbiAgICAgICAgb2Zmc2V0TWF0cml4OiBvZmZzZXRNYXRyaXgsXHJcbiAgICAgICAgYWxsTWF0cml4OiBhbGxNYXRyaXgsXHJcbiAgICAgICAgdGFyZ2V0TWF0cml4OiB0YXJnZXRNYXRyaXgsXHJcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtOiB0YXJnZXRUcmFuc2Zvcm0sXHJcbiAgICAgICAgaW5saW5lVHJhbnNmb3JtOiB0YXJnZXQuc3R5bGUudHJhbnNmb3JtLFxyXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogdHJhbnNmb3JtT3JpZ2luLFxyXG4gICAgICAgIHRhcmdldE9yaWdpbjogdGFyZ2V0T3JpZ2luLFxyXG4gICAgICAgIGlzM2Q6IGlzTmV4dDNkLFxyXG4gICAgICAgIG9mZnNldENvbnRhaW5lcjogb2Zmc2V0Q29udGFpbmVyLFxyXG4gICAgICAgIG9mZnNldFJvb3RDb250YWluZXI6IG9mZnNldFJvb3RDb250YWluZXIsXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVsZW1lbnRJbmZvKHRhcmdldCwgY29udGFpbmVyLCByb290Q29udGFpbmVyLCBpc0Fic29sdXRlM2QpIHtcclxuICAgIGlmIChyb290Q29udGFpbmVyID09PSB2b2lkIDApIHsgcm9vdENvbnRhaW5lciA9IGNvbnRhaW5lcjsgfVxyXG4gICAgdmFyIHdpZHRoID0gMDtcclxuICAgIHZhciBoZWlnaHQgPSAwO1xyXG4gICAgdmFyIHJvdGF0aW9uID0gMDtcclxuICAgIHZhciBhbGxSZXN1bHQgPSB7fTtcclxuICAgIHZhciBzaXplcyA9IGdldFNpemUodGFyZ2V0KTtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICB3aWR0aCA9IHNpemVzLm9mZnNldFdpZHRoO1xyXG4gICAgICAgIGhlaWdodCA9IHNpemVzLm9mZnNldEhlaWdodDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsY3VsYXRlTWF0cml4U3RhY2sodGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIsIGlzQWJzb2x1dGUzZCk7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gY2FsY3VsYXRlRWxlbWVudFBvc2l0aW9uKHJlc3VsdC5hbGxNYXRyaXgsIHJlc3VsdC50cmFuc2Zvcm1PcmlnaW4sIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIGFsbFJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCBwb3NpdGlvbik7XHJcbiAgICAgICAgdmFyIHJvdGF0aW9uUG9zaXRpb24gPSBjYWxjdWxhdGVFbGVtZW50UG9zaXRpb24ocmVzdWx0LmFsbE1hdHJpeCwgWzUwLCA1MF0sIDEwMCwgMTAwKTtcclxuICAgICAgICByb3RhdGlvbiA9IGdldFJvdGF0aW9uUmFkKFtyb3RhdGlvblBvc2l0aW9uLnBvczEsIHJvdGF0aW9uUG9zaXRpb24ucG9zMl0sIHJvdGF0aW9uUG9zaXRpb24uZGlyZWN0aW9uKTtcclxuICAgIH1cclxuICAgIHZhciBuID0gaXNBYnNvbHV0ZTNkID8gNCA6IDM7XHJcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oeyBoYXNab29tOiBmYWxzZSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgcm90YXRpb246IHJvdGF0aW9uIH0sIHNpemVzKSwgeyBvcmlnaW5hbFJvb3RNYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLCByb290TWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSwgYmVmb3JlTWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSwgb2Zmc2V0TWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSwgYWxsTWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSwgdGFyZ2V0TWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSwgdGFyZ2V0VHJhbnNmb3JtOiBcIlwiLCBpbmxpbmVUcmFuc2Zvcm06IFwiXCIsIHRyYW5zZm9ybU9yaWdpbjogWzAsIDBdLCB0YXJnZXRPcmlnaW46IFswLCAwXSwgaXMzZDogISFpc0Fic29sdXRlM2QsIGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgb3JpZ2luOiBbMCwgMF0sIHBvczE6IFswLCAwXSwgcG9zMjogWzAsIDBdLCBwb3MzOiBbMCwgMF0sIHBvczQ6IFswLCAwXSwgZGlyZWN0aW9uOiAxLCBoYXNGaXhlZDogZmFsc2UsIG9mZnNldENvbnRhaW5lcjogbnVsbCwgb2Zmc2V0Um9vdENvbnRhaW5lcjogbnVsbCwgbWF0cml4ZXM6IFtdIH0pLCBhbGxSZXN1bHQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVsZW1lbnRJbmZvKHRhcmdldCwgY29udGFpbmVyLCByb290Q29udGFpbmVyKSB7XHJcbiAgICBpZiAocm9vdENvbnRhaW5lciA9PT0gdm9pZCAwKSB7IHJvb3RDb250YWluZXIgPSBjb250YWluZXI7IH1cclxuICAgIHJldHVybiBjYWxjdWxhdGVFbGVtZW50SW5mbyh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgdHJ1ZSk7XHJcbn1cblxuZnVuY3Rpb24gZ2V0TW92ZWFibGVUYXJnZXRJbmZvKG1vdmVhYmxlRWxlbWVudCwgdGFyZ2V0LCBjb250YWluZXIsIHBhcmVudENvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgcmVxdWVzdFN0eWxlcykge1xyXG4gICAgaWYgKHJlcXVlc3RTdHlsZXMgPT09IHZvaWQgMCkgeyByZXF1ZXN0U3R5bGVzID0gW107IH1cclxuICAgIHZhciBiZWZvcmVEaXJlY3Rpb24gPSAxO1xyXG4gICAgdmFyIGJlZm9yZU9yaWdpbiA9IFswLCAwXTtcclxuICAgIHZhciB0YXJnZXRDbGllbnRSZWN0ID0gcmVzZXRDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgbW92ZWFibGVDbGllbnRSZWN0ID0gcmVzZXRDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgY29udGFpbmVyQ2xpZW50UmVjdCA9IHJlc2V0Q2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIHJvb3RDb250YWluZXJDbGllbnRSZWN0ID0gcmVzZXRDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgb2Zmc2V0RGVsdGEgPSBbMCwgMF07XHJcbiAgICB2YXIgc3R5bGUgPSB7fTtcclxuICAgIHZhciByZXN1bHQgPSBjYWxjdWxhdGVFbGVtZW50SW5mbyh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgdHJ1ZSk7XHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIGdldFN0eWxlXzEgPSBnZXRDYWNoZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgICAgIHJlcXVlc3RTdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBzdHlsZVtuYW1lXSA9IGdldFN0eWxlXzEobmFtZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG4gPSByZXN1bHQuaXMzZCA/IDQgOiAzO1xyXG4gICAgICAgIHZhciBiZWZvcmVQb3NpdGlvbiA9IGNhbGN1bGF0ZUVsZW1lbnRQb3NpdGlvbihyZXN1bHQub2Zmc2V0TWF0cml4LCBwbHVzKHJlc3VsdC50cmFuc2Zvcm1PcmlnaW4sIGdldE9yaWdpbihyZXN1bHQudGFyZ2V0TWF0cml4LCBuKSksIHJlc3VsdC53aWR0aCwgcmVzdWx0LmhlaWdodCk7XHJcbiAgICAgICAgYmVmb3JlRGlyZWN0aW9uID0gYmVmb3JlUG9zaXRpb24uZGlyZWN0aW9uO1xyXG4gICAgICAgIGJlZm9yZU9yaWdpbiA9IHBsdXMoYmVmb3JlUG9zaXRpb24ub3JpZ2luLCBbYmVmb3JlUG9zaXRpb24ubGVmdCAtIHJlc3VsdC5sZWZ0LCBiZWZvcmVQb3NpdGlvbi50b3AgLSByZXN1bHQudG9wXSk7XHJcbiAgICAgICAgcm9vdENvbnRhaW5lckNsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0KHJlc3VsdC5vZmZzZXRSb290Q29udGFpbmVyKTtcclxuICAgICAgICB2YXIgb2Zmc2V0Q29udGFpbmVyID0gZ2V0T2Zmc2V0SW5mbyhwYXJlbnRDb250YWluZXIsIHBhcmVudENvbnRhaW5lciwgdHJ1ZSkub2Zmc2V0UGFyZW50XHJcbiAgICAgICAgICAgIHx8IHJlc3VsdC5vZmZzZXRSb290Q29udGFpbmVyO1xyXG4gICAgICAgIGlmIChyZXN1bHQuaGFzWm9vbSkge1xyXG4gICAgICAgICAgICB2YXIgYWJzb2x1dGVUYXJnZXRQb3NpdGlvbiA9IGNhbGN1bGF0ZUVsZW1lbnRQb3NpdGlvbihtdWx0aXBseShyZXN1bHQub3JpZ2luYWxSb290TWF0cml4LCByZXN1bHQuYWxsTWF0cml4KSwgcmVzdWx0LnRyYW5zZm9ybU9yaWdpbiwgcmVzdWx0LndpZHRoLCByZXN1bHQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIGFic29sdXRlQ29udGFpbmVyUG9zaXRpb24gPSBjYWxjdWxhdGVFbGVtZW50UG9zaXRpb24ocmVzdWx0Lm9yaWdpbmFsUm9vdE1hdHJpeCwgZ2V0VHJhbnNmb3JtT3JpZ2luQXJyYXkoZ2V0Q2FjaGVkU3R5bGUob2Zmc2V0Q29udGFpbmVyKShcInRyYW5zZm9ybU9yaWdpblwiKSkubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBhcnNlRmxvYXQocG9zKTsgfSksIG9mZnNldENvbnRhaW5lci5vZmZzZXRXaWR0aCwgb2Zmc2V0Q29udGFpbmVyLm9mZnNldEhlaWdodCk7XHJcbiAgICAgICAgICAgIHRhcmdldENsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0QnlQb3NpdGlvbihhYnNvbHV0ZVRhcmdldFBvc2l0aW9uLCByb290Q29udGFpbmVyQ2xpZW50UmVjdCk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckNsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0QnlQb3NpdGlvbihhYnNvbHV0ZUNvbnRhaW5lclBvc2l0aW9uLCByb290Q29udGFpbmVyQ2xpZW50UmVjdCwgb2Zmc2V0Q29udGFpbmVyLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKG1vdmVhYmxlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBhYnNvbHV0ZVRhcmdldFBvc2l0aW9uLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9wXzEgPSBhYnNvbHV0ZVRhcmdldFBvc2l0aW9uLnRvcDtcclxuICAgICAgICAgICAgICAgIG1vdmVhYmxlQ2xpZW50UmVjdCA9IGdldENsaWVudFJlY3RCeVBvc2l0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdG9wXzEsXHJcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiB0b3BfMSxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogdG9wXzEsXHJcbiAgICAgICAgICAgICAgICB9LCByb290Q29udGFpbmVyQ2xpZW50UmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldENsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0KHRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckNsaWVudFJlY3QgPSBnZXRDYWNoZWRDbGllbnRSZWN0KG9mZnNldENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlYWJsZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIG1vdmVhYmxlQ2xpZW50UmVjdCA9IGdldENsaWVudFJlY3QobW92ZWFibGVFbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyQ2xpZW50UmVjdExlZnQgPSBjb250YWluZXJDbGllbnRSZWN0LmxlZnQsIGNvbnRhaW5lckNsaWVudFJlY3RUb3AgPSBjb250YWluZXJDbGllbnRSZWN0LnRvcCwgY29udGFpbnRlckNsaWVudExlZnQgPSBjb250YWluZXJDbGllbnRSZWN0LmNsaWVudExlZnQsIGNvbnRhaW5lckNsaWVudFRvcCA9IGNvbnRhaW5lckNsaWVudFJlY3QuY2xpZW50VG9wO1xyXG4gICAgICAgICAgICB2YXIgY2xpZW50RGVsdGEgPSBbXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRDbGllbnRSZWN0LmxlZnQgLSBjb250YWluZXJDbGllbnRSZWN0TGVmdCxcclxuICAgICAgICAgICAgICAgIHRhcmdldENsaWVudFJlY3QudG9wIC0gY29udGFpbmVyQ2xpZW50UmVjdFRvcCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgb2Zmc2V0RGVsdGEgPSBtaW51cyhjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocmVzdWx0LnJvb3RNYXRyaXgsIGNsaWVudERlbHRhLCA0KSwgW2NvbnRhaW50ZXJDbGllbnRMZWZ0ICsgcmVzdWx0LmxlZnQsIGNvbnRhaW5lckNsaWVudFRvcCArIHJlc3VsdC50b3BdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24oeyB0YXJnZXRDbGllbnRSZWN0OiB0YXJnZXRDbGllbnRSZWN0LCBjb250YWluZXJDbGllbnRSZWN0OiBjb250YWluZXJDbGllbnRSZWN0LCBtb3ZlYWJsZUNsaWVudFJlY3Q6IG1vdmVhYmxlQ2xpZW50UmVjdCwgcm9vdENvbnRhaW5lckNsaWVudFJlY3Q6IHJvb3RDb250YWluZXJDbGllbnRSZWN0LCBiZWZvcmVEaXJlY3Rpb246IGJlZm9yZURpcmVjdGlvbiwgYmVmb3JlT3JpZ2luOiBiZWZvcmVPcmlnaW4sIG9yaWdpbmFsQmVmb3JlT3JpZ2luOiBiZWZvcmVPcmlnaW4sIHRhcmdldDogdGFyZ2V0LCBzdHlsZTogc3R5bGUsIG9mZnNldERlbHRhOiBvZmZzZXREZWx0YSB9LCByZXN1bHQpO1xyXG59XG5cbmZ1bmN0aW9uIGdldFBlcnNpc3RTdGF0ZShyZWN0KSB7XHJcbiAgICB2YXIgcG9zMSA9IHJlY3QucG9zMSwgcG9zMiA9IHJlY3QucG9zMiwgcG9zMyA9IHJlY3QucG9zMywgcG9zNCA9IHJlY3QucG9zNDtcclxuICAgIGlmICghcG9zMSB8fCAhcG9zMiB8fCAhcG9zMyB8fCAhcG9zNCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdmFyIG1pblBvcyA9IGdldE1pbk1heHMoW3BvczEsIHBvczIsIHBvczMsIHBvczRdKTtcclxuICAgIHZhciBwb3NEZWx0YSA9IFttaW5Qb3MubWluWCwgbWluUG9zLm1pblldO1xyXG4gICAgdmFyIG9yaWdpbiA9IG1pbnVzKHJlY3Qub3JpZ2luLCBwb3NEZWx0YSk7XHJcbiAgICBwb3MxID0gbWludXMocG9zMSwgcG9zRGVsdGEpO1xyXG4gICAgcG9zMiA9IG1pbnVzKHBvczIsIHBvc0RlbHRhKTtcclxuICAgIHBvczMgPSBtaW51cyhwb3MzLCBwb3NEZWx0YSk7XHJcbiAgICBwb3M0ID0gbWludXMocG9zNCwgcG9zRGVsdGEpO1xyXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCByZWN0KSwgeyBsZWZ0OiByZWN0LmxlZnQsIHRvcDogcmVjdC50b3AsIHBvc0RlbHRhOiBwb3NEZWx0YSwgcG9zMTogcG9zMSwgcG9zMjogcG9zMiwgcG9zMzogcG9zMywgcG9zNDogcG9zNCwgb3JpZ2luOiBvcmlnaW4sIGJlZm9yZU9yaWdpbjogb3JpZ2luLCBcclxuICAgICAgICAvLyBvcmlnaW5hbEJlZm9yZU9yaWdpbjogb3JpZ2luLFxyXG4gICAgICAgIGlzUGVyc2lzdGVkOiB0cnVlIH0pO1xyXG59XG5cbnZhciBNb3ZlYWJsZU1hbmFnZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTW92ZWFibGVNYW5hZ2VyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW92ZWFibGVNYW5hZ2VyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnN0YXRlID0gX19hc3NpZ24oeyBjb250YWluZXI6IG51bGwsIGdlc3Rvczoge30sIHJlbmRlckxpbmVzOiBbXHJcbiAgICAgICAgICAgICAgICBbWzAsIDBdLCBbMCwgMF1dLFxyXG4gICAgICAgICAgICAgICAgW1swLCAwXSwgWzAsIDBdXSxcclxuICAgICAgICAgICAgICAgIFtbMCwgMF0sIFswLCAwXV0sXHJcbiAgICAgICAgICAgICAgICBbWzAsIDBdLCBbMCwgMF1dLFxyXG4gICAgICAgICAgICBdLCByZW5kZXJQb3NlczogW1swLCAwXSwgWzAsIDBdLCBbMCwgMF0sIFswLCAwXV0sIGRpc2FibGVOYXRpdmVFdmVudDogZmFsc2UsIHBvc0RlbHRhOiBbMCwgMF0gfSwgZ2V0TW92ZWFibGVUYXJnZXRJbmZvKG51bGwpKTtcclxuICAgICAgICBfdGhpcy5yZW5kZXJTdGF0ZSA9IHt9O1xyXG4gICAgICAgIF90aGlzLmVuYWJsZWRBYmxlcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRhcmdldEFibGVzID0gW107XHJcbiAgICAgICAgX3RoaXMuY29udHJvbEFibGVzID0gW107XHJcbiAgICAgICAgX3RoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgIF90aGlzLnNjYWxlID0gWzEsIDFdO1xyXG4gICAgICAgIF90aGlzLmlzTW92ZWFibGVNb3VudGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuaXNVbm1vdW50ZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgIFwibW91c2VFbnRlclwiOiBudWxsLFxyXG4gICAgICAgICAgICBcIm1vdXNlTGVhdmVcIjogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLl9lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLl9wcmV2T3JpZ2luYWxEcmFnVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5fb3JpZ2luYWxEcmFnVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5fcHJldkRyYWdUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLl9kcmFnVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5fcHJldlByb3BUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLl9wcm9wVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5fcHJldkRyYWdBcmVhID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuX2lzUHJvcFRhcmdldENoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5faGFzRmlyc3RUYXJnZXQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5fcmVpc3plT2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLl9vYnNlcnZlcklkID0gMDtcclxuICAgICAgICBfdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMuX3Jvb3RDb250YWluZXIgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLl92aWV3Q29udGFpbmVyID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5fdmlld0NsYXNzTmFtZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy5fc3RvcmUgPSB7fTtcclxuICAgICAgICBfdGhpcy5jaGVja1VwZGF0ZVJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyZW50TW92ZWFibGUgPSBfdGhpcy5wcm9wcy5wYXJlbnRNb3ZlYWJsZTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudE1vdmVhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRNb3ZlYWJsZS5jaGVja1VwZGF0ZVJlY3QoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShfdGhpcy5fb2JzZXJ2ZXJJZCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9vYnNlcnZlcklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVSZWN0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuX29uUHJldmVudENsaWNrID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAvLyByZW1vdmVFdmVudCh3aW5kb3csIFwiY2xpY2tcIiwgdGhpcy5fb25QcmV2ZW50Q2xpY2ssIHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XHJcbiAgICAgICAgdmFyIHBhcmVudFBvc2l0aW9uID0gcHJvcHMucGFyZW50UG9zaXRpb24sIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSwgcHJvcHNUYXJnZXQgPSBwcm9wcy50YXJnZXQsIHpvb20gPSBwcm9wcy56b29tLCBjc3BOb25jZSA9IHByb3BzLmNzcE5vbmNlLCB0cmFuc2xhdGVaID0gcHJvcHMudHJhbnNsYXRlWiwgQ29udHJvbEJveEVsZW1lbnQgPSBwcm9wcy5jc3NTdHlsZWQsIGdyb3VwYWJsZSA9IHByb3BzLmdyb3VwYWJsZSwgbGluZVBhZGRpbmcgPSBwcm9wcy5saW5lUGFkZGluZywgY29udHJvbFBhZGRpbmcgPSBwcm9wcy5jb250cm9sUGFkZGluZztcclxuICAgICAgICB0aGlzLl9jaGVja1VwZGF0ZVJvb3RDb250YWluZXIoKTtcclxuICAgICAgICB0aGlzLmNoZWNrVXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVSZW5kZXJQb3NlcygpO1xyXG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChwYXJlbnRQb3NpdGlvbiB8fCBbMCwgMF0sIDIpLCBwYXJlbnRMZWZ0ID0gX2FbMF0sIHBhcmVudFRvcCA9IF9hWzFdO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gc3RhdGUubGVmdCwgdG9wID0gc3RhdGUudG9wLCBzdGF0ZVRhcmdldCA9IHN0YXRlLnRhcmdldCwgZGlyZWN0aW9uID0gc3RhdGUuZGlyZWN0aW9uLCBoYXNGaXhlZCA9IHN0YXRlLmhhc0ZpeGVkLCBvZmZzZXREZWx0YSA9IHN0YXRlLm9mZnNldERlbHRhO1xyXG4gICAgICAgIHZhciBncm91cFRhcmdldHMgPSBwcm9wcy50YXJnZXRzO1xyXG4gICAgICAgIHZhciBpc0RyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCk7XHJcbiAgICAgICAgdmFyIGFibGVBdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgdGhpcy5nZXRFbmFibGVkQWJsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgIGFibGVBdHRyaWJ1dGVzW1wiZGF0YS1hYmxlLVwiLmNvbmNhdChhYmxlLm5hbWUudG9Mb3dlckNhc2UoKSldID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgYWJsZUNsYXNzTmFtZSA9IHRoaXMuX2dldEFibGVDbGFzc05hbWUoKTtcclxuICAgICAgICB2YXIgaXNEaXNwbGF5ID0gKGdyb3VwVGFyZ2V0cyAmJiBncm91cFRhcmdldHMubGVuZ3RoICYmIChzdGF0ZVRhcmdldCB8fCBncm91cGFibGUpKVxyXG4gICAgICAgICAgICB8fCBwcm9wc1RhcmdldFxyXG4gICAgICAgICAgICB8fCAoIXRoaXMuX2hhc0ZpcnN0VGFyZ2V0ICYmIHRoaXMuc3RhdGUuaXNQZXJzaXN0ZWQpO1xyXG4gICAgICAgIHZhciBpc1Zpc2libGUgPSB0aGlzLmNvbnRyb2xCb3ggfHwgdGhpcy5wcm9wcy5maXJzdFJlbmRlclN0YXRlIHx8IHRoaXMucHJvcHMucGVyc2lzdERhdGE7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IFtsZWZ0IC0gcGFyZW50TGVmdCwgdG9wIC0gcGFyZW50VG9wXTtcclxuICAgICAgICBpZiAoIWdyb3VwYWJsZSAmJiBwcm9wcy51c2VBY2N1cmF0ZVBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVswXSArPSBvZmZzZXREZWx0YVswXTtcclxuICAgICAgICAgICAgdHJhbnNsYXRlWzFdICs9IG9mZnNldERlbHRhWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3R5bGUgPSB7XHJcbiAgICAgICAgICAgIFwicG9zaXRpb25cIjogaGFzRml4ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBpc0Rpc3BsYXkgPyBcImJsb2NrXCIgOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgXCJ2aXNpYmlsaXR5XCI6IGlzVmlzaWJsZSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgXCJ0cmFuc2Zvcm1cIjogXCJ0cmFuc2xhdGUzZChcIi5jb25jYXQodHJhbnNsYXRlWzBdLCBcInB4LCBcIikuY29uY2F0KHRyYW5zbGF0ZVsxXSwgXCJweCwgXCIpLmNvbmNhdCh0cmFuc2xhdGVaLCBcIilcIiksXHJcbiAgICAgICAgICAgIFwiLS16b29tXCI6IHpvb20sXHJcbiAgICAgICAgICAgIFwiLS16b29tcHhcIjogXCJcIi5jb25jYXQoem9vbSwgXCJweFwiKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChsaW5lUGFkZGluZykge1xyXG4gICAgICAgICAgICBzdHlsZVtcIi0tbW92ZWFibGUtbGluZS1wYWRkaW5nXCJdID0gbGluZVBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250cm9sUGFkZGluZykge1xyXG4gICAgICAgICAgICBzdHlsZVtcIi0tbW92ZWFibGUtY29udHJvbC1wYWRkaW5nXCJdID0gY29udHJvbFBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb250cm9sQm94RWxlbWVudCwgX19hc3NpZ24oeyBjc3BOb25jZTogY3NwTm9uY2UsIHJlZjogcmVmKHRoaXMsIFwiY29udHJvbEJveFwiKSwgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXgoXCJjb250cm9sLWJveFwiLCBkaXJlY3Rpb24gPT09IC0xID8gXCJyZXZlcnNlXCIgOiBcIlwiLCBpc0RyYWdnaW5nID8gXCJkcmFnZ2luZ1wiIDogXCJcIiksIFwiIFwiKS5jb25jYXQoYWJsZUNsYXNzTmFtZSwgXCIgXCIpLmNvbmNhdChjbGFzc05hbWUpIH0sIGFibGVBdHRyaWJ1dGVzLCB7IG9uQ2xpY2s6IHRoaXMuX29uUHJldmVudENsaWNrLCBzdHlsZTogc3R5bGUgfSksXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQWJsZXMoKSxcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGluZXMoKSkpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc01vdmVhYmxlTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc1VubW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIHBhcmVudE1vdmVhYmxlID0gcHJvcHMucGFyZW50TW92ZWFibGUsIGNvbnRhaW5lciA9IHByb3BzLmNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLl9jaGVja1VwZGF0ZVJvb3RDb250YWluZXIoKTtcclxuICAgICAgICB0aGlzLl9jaGVja1VwZGF0ZVZpZXdDb250YWluZXIoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVUYXJnZXRzKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTmF0aXZlRXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDaGVja0lucHV0KCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JzZXJ2ZXIodGhpcy5wcm9wcyk7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIgJiYgIXBhcmVudE1vdmVhYmxlICYmICF0aGlzLnN0YXRlLmlzUGVyc2lzdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVjdChcIlwiLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrVXBkYXRlUm9vdENvbnRhaW5lcigpO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrVXBkYXRlVmlld0NvbnRhaW5lcigpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU5hdGl2ZUV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVRhcmdldHMoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVFdmVudHMoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNoZWNrSW5wdXQoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVPYnNlcnZlcihwcmV2UHJvcHMpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0aGlzLmlzTW92ZWFibGVNb3VudGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1VubW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZW1pdHRlci5vZmYoKTtcclxuICAgICAgICAoX2EgPSB0aGlzLl9yZWlzemVPYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAoX2IgPSB0aGlzLl9tdXRhdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIHZhciB2aWV3Q29udGFpbmVyID0gdGhpcy5fdmlld0NvbnRhaW5lcjtcclxuICAgICAgICBpZiAodmlld0NvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VBYmxlVmlld0NsYXNzTmFtZXMoW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1bnNldEdlc3RvKHRoaXMsIGZhbHNlKTtcclxuICAgICAgICB1bnNldEdlc3RvKHRoaXMsIHRydWUpO1xyXG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcclxuICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gZXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHZhciBtYW5hZ2VyID0gZXZlbnRzW25hbWVfMV07XHJcbiAgICAgICAgICAgIG1hbmFnZXIgJiYgbWFuYWdlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuZ2V0VGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5wcm9wcy50YXJnZXQ7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldCA/IFt0YXJnZXRdIDogW107XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGFibGUgdXNlZCBpbiBNb3ZlYWJsZU1hbmFnZXIuXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2dldEFibGVcclxuICAgICAqIEBwYXJhbSAtIGFibGUgbmFtZVxyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmdldEFibGUgPSBmdW5jdGlvbiAoYWJsZU5hbWUpIHtcclxuICAgICAgICB2YXIgYWJsZXMgPSB0aGlzLnByb3BzLmFibGVzIHx8IFtdO1xyXG4gICAgICAgIHJldHVybiBmaW5kKGFibGVzLCBmdW5jdGlvbiAoYWJsZSkgeyByZXR1cm4gYWJsZS5uYW1lID09PSBhYmxlTmFtZTsgfSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgcGFyZW50TW92ZWFibGUgPSBfYS5wYXJlbnRNb3ZlYWJsZSwgd3JhcHBlck1vdmVhYmxlID0gX2Eud3JhcHBlck1vdmVhYmxlLCBjb250YWluZXIgPSBfYS5jb250YWluZXI7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lclxyXG4gICAgICAgICAgICB8fCAod3JhcHBlck1vdmVhYmxlICYmIHdyYXBwZXJNb3ZlYWJsZS5nZXRDb250YWluZXIoKSlcclxuICAgICAgICAgICAgfHwgKHBhcmVudE1vdmVhYmxlICYmIHBhcmVudE1vdmVhYmxlLmdldENvbnRhaW5lcigpKVxyXG4gICAgICAgICAgICB8fCB0aGlzLmNvbnRyb2xCb3gucGFyZW50RWxlbWVudDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGVsZW1lbnQgb2YgdGhlIGNvbnRyb2wgYm94LlxyXG4gICAgICogQG1ldGhvZCBNb3ZlYWJsZSNnZXRDb250cm9sQm94RWxlbWVudFxyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmdldENvbnRyb2xCb3hFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xCb3g7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUYXJnZXQgZWxlbWVudCB0byBiZSBkcmFnZ2VkIGluIG1vdmVhYmxlXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2dldERyYWdFbGVtZW50XHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuZ2V0RHJhZ0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYWdUYXJnZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGFuIGVsZW1lbnQgaW5jbHVkZWQgaW4gdGhlIG1vdmVhYmxlLlxyXG4gICAgICogQG1ldGhvZCBNb3ZlYWJsZSNpc01vdmVhYmxlRWxlbWVudFxyXG4gICAgICogQHBhcmFtIC0gdGhlIHRhcmdldFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4ge1xyXG4gICAgICogICAgIGlmICghbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoZS50YXJnZXQpKSB7XHJcbiAgICAgKiAgICAgICAgIG1vdmVhYmxlLnRhcmdldCA9IGUudGFyZ2V0O1xyXG4gICAgICogICAgIH1cclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmlzTW92ZWFibGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0ICYmICgoKF9hID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGFyZ2V0LCBcImNsYXNzXCIpKSB8fCBcIlwiKS5pbmRleE9mKFBSRUZJWCkgPiAtMTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFlvdSBjYW4gZHJhZyBzdGFydCB0aGUgTW92ZWFibGUgdGhyb3VnaCB0aGUgZXh0ZXJuYWwgYE1vdXNlRXZlbnRgb3IgYFRvdWNoRXZlbnRgLiAoQW5ndWxhcjogbmdEcmFnU3RhcnQpXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2RyYWdTdGFydFxyXG4gICAgICogQHBhcmFtIC0gZXh0ZXJuYWwgYE1vdXNlRXZlbnRgb3IgYFRvdWNoRXZlbnRgXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcclxuICAgICAqICAgICBpZiAoIW1vdmVhYmxlLmlzTW92ZWFibGVFbGVtZW50KGUudGFyZ2V0KSkge1xyXG4gICAgICogICAgICAgICAgbW92ZWFibGUuZHJhZ1N0YXJ0KGUpO1xyXG4gICAgICogICAgIH1cclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsgdGFyZ2V0ID0gZS50YXJnZXQ7IH1cclxuICAgICAgICB2YXIgdGFyZ2V0R2VzdG8gPSB0aGlzLnRhcmdldEdlc3RvO1xyXG4gICAgICAgIHZhciBjb250cm9sR2VzdG8gPSB0aGlzLmNvbnRyb2xHZXN0bztcclxuICAgICAgICBpZiAodGFyZ2V0R2VzdG8gJiYgY2hlY2tNb3ZlYWJsZVRhcmdldCh0aGlzKSh7IGlucHV0RXZlbnQ6IGUgfSwgdGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdldEdlc3RvLmlzRmxhZygpKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRHZXN0by50cmlnZ2VyRHJhZ1N0YXJ0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbnRyb2xHZXN0byAmJiB0aGlzLmlzTW92ZWFibGVFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgaWYgKCFjb250cm9sR2VzdG8uaXNGbGFnKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xHZXN0by50cmlnZ2VyRHJhZ1N0YXJ0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSGl0IHRlc3QgYW4gZWxlbWVudCBvciByZWN0IG9uIGEgbW92ZWFibGUgdGFyZ2V0LlxyXG4gICAgICogKDEwMCUgPSAxMDApXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2hpdFRlc3RcclxuICAgICAqIEBwYXJhbSAtIGVsZW1lbnQgb3IgcmVjdCB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJuIC0gR2V0IGhpdCB0ZXN0IHJhdGUgKHJhdGUgPiAwIGlzIGhpdHRlZClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgKlxyXG4gICAgICogZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xyXG4gICAgICogICAgIGlmIChtb3ZlYWJsZS5oaXRUZXN0KGUudGFyZ2V0KSA+IDApIHtcclxuICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiaGlpdGVkXCIpO1xyXG4gICAgICogICAgIH1cclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCB0YXJnZXQgPSBfYS50YXJnZXQsIHBvczEgPSBfYS5wb3MxLCBwb3MyID0gX2EucG9zMiwgcG9zMyA9IF9hLnBvczMsIHBvczQgPSBfYS5wb3M0LCB0YXJnZXRDbGllbnRSZWN0ID0gX2EudGFyZ2V0Q2xpZW50UmVjdDtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlY3Q7XHJcbiAgICAgICAgaWYgKGlzTm9kZShlbCkpIHtcclxuICAgICAgICAgICAgdmFyIGNsaWVudFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgcmVjdCA9IHtcclxuICAgICAgICAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCxcclxuICAgICAgICAgICAgICAgIHRvcDogY2xpZW50UmVjdC50b3AsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWN0ID0gX19hc3NpZ24oeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sIGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlY3RMZWZ0ID0gcmVjdC5sZWZ0LCByZWN0VG9wID0gcmVjdC50b3AsIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGgsIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICB2YXIgcG9pbnRzID0gZml0UG9pbnRzKFtwb3MxLCBwb3MyLCBwb3M0LCBwb3MzXSwgdGFyZ2V0Q2xpZW50UmVjdCk7XHJcbiAgICAgICAgdmFyIHNpemUgPSBnZXRPdmVybGFwU2l6ZShwb2ludHMsIFtcclxuICAgICAgICAgICAgW3JlY3RMZWZ0LCByZWN0VG9wXSxcclxuICAgICAgICAgICAgW3JlY3RMZWZ0ICsgcmVjdFdpZHRoLCByZWN0VG9wXSxcclxuICAgICAgICAgICAgW3JlY3RMZWZ0ICsgcmVjdFdpZHRoLCByZWN0VG9wICsgcmVjdEhlaWdodF0sXHJcbiAgICAgICAgICAgIFtyZWN0TGVmdCwgcmVjdFRvcCArIHJlY3RIZWlnaHRdLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHZhciB0b3RhbFNpemUgPSBnZXRBcmVhU2l6ZShwb2ludHMpO1xyXG4gICAgICAgIGlmICghc2l6ZSB8fCAhdG90YWxTaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oMTAwLCBzaXplIC8gdG90YWxTaXplICogMTAwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBpbnNpZGUgTW92ZWFibGVcclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjaXNJbnNpZGVcclxuICAgICAqIEBwYXJhbSAtIHggY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIC0geSBjb29yZGluYXRlXHJcbiAgICAgKiBAcmV0dXJuIC0gVHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZSBpcyBpbiBtb3ZlYWJsZSBvciBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB7XHJcbiAgICAgKiAgICAgaWYgKG1vdmVhYmxlLmlzSW5zaWRlKGUuY2xpZW50WCwgZS5jbGllbnRZKSkge1xyXG4gICAgICogICAgICAgICAgY29uc29sZS5sb2coXCJpbnNpZGVcIik7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuaXNJbnNpZGUgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIHRhcmdldCA9IF9hLnRhcmdldCwgcG9zMSA9IF9hLnBvczEsIHBvczIgPSBfYS5wb3MyLCBwb3MzID0gX2EucG9zMywgcG9zNCA9IF9hLnBvczQsIHRhcmdldENsaWVudFJlY3QgPSBfYS50YXJnZXRDbGllbnRSZWN0O1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzSW5zaWRlKFtjbGllbnRYLCBjbGllbnRZXSwgZml0UG9pbnRzKFtwb3MxLCBwb3MyLCBwb3M0LCBwb3MzXSwgdGFyZ2V0Q2xpZW50UmVjdCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIHdpZHRoLCBoZWlnaHQsIGxlZnQsIGFuZCB0b3Agb2YgYWxsIGVsZW1lbnRzIGNoYW5nZSwgdXBkYXRlIHRoZSBzaGFwZSBvZiB0aGUgbW92ZWFibGUuXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI3VwZGF0ZVJlY3RcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgKlxyXG4gICAgICogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZSA9PiB7XHJcbiAgICAgKiAgICAgbW92ZWFibGUudXBkYXRlUmVjdCgpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlUmVjdCA9IGZ1bmN0aW9uICh0eXBlLCBpc1RhcmdldCwgaXNTZXRTdGF0ZSkge1xyXG4gICAgICAgIGlmIChpc1NldFN0YXRlID09PSB2b2lkIDApIHsgaXNTZXRTdGF0ZSA9IHRydWU7IH1cclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciBpc1NpbmdsZSA9ICFwcm9wcy5wYXJlbnRQb3NpdGlvbiAmJiAhcHJvcHMud3JhcHBlck1vdmVhYmxlO1xyXG4gICAgICAgIGlmIChpc1NpbmdsZSkge1xyXG4gICAgICAgICAgICBzZXRTdG9yZUNhY2hlKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyZW50TW92ZWFibGUgPSBwcm9wcy5wYXJlbnRNb3ZlYWJsZTtcclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSAoc3RhdGUudGFyZ2V0IHx8IHByb3BzLnRhcmdldCk7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XHJcbiAgICAgICAgdmFyIHJvb3RDb250YWluZXIgPSBwYXJlbnRNb3ZlYWJsZVxyXG4gICAgICAgICAgICA/IHBhcmVudE1vdmVhYmxlLl9yb290Q29udGFpbmVyXHJcbiAgICAgICAgICAgIDogdGhpcy5fcm9vdENvbnRhaW5lcjtcclxuICAgICAgICB2YXIgbmV4dFN0YXRlID0gZ2V0TW92ZWFibGVUYXJnZXRJbmZvKHRoaXMuY29udHJvbEJveCwgdGFyZ2V0LCBjb250YWluZXIsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciB8fCBjb250YWluZXIsIHRoaXMuX2dldFJlcXVlc3RTdHlsZXMoKSk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgJiYgdGhpcy5faGFzRmlyc3RUYXJnZXQgJiYgcHJvcHMucGVyc2lzdERhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHBlcnNpc3RTdGF0ZSA9IGdldFBlcnNpc3RTdGF0ZShwcm9wcy5wZXJzaXN0RGF0YSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMiBpbiBwZXJzaXN0U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZVtuYW1lXzJdID0gcGVyc2lzdFN0YXRlW25hbWVfMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU2luZ2xlKSB7XHJcbiAgICAgICAgICAgIHNldFN0b3JlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXh0U3RhdGUsIHBhcmVudE1vdmVhYmxlID8gZmFsc2UgOiBpc1NldFN0YXRlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBtb3ZlYWJsZSBzdGF0ZSBpcyBiZWluZyBkcmFnZ2VkLlxyXG4gICAgICogQG1ldGhvZCBNb3ZlYWJsZSNpc0RyYWdnaW5nXHJcbiAgICAgKiBAcGFyYW0gLSBJZiB5b3Ugd2FudCB0byBjaGVjayBpZiBhYmxlIGlzIGRyYWdnaW5nLCBzcGVjaWZ5IGFibGVOYW1lLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBmYWxzZVxyXG4gICAgICogY29uc29sZS5sb2cobW92ZWFibGUuaXNEcmFnZ2luZygpKTtcclxuICAgICAqXHJcbiAgICAgKiBtb3ZlYWJsZS5vbihcImRyYWdcIiwgKCkgPT4ge1xyXG4gICAgICogICAvLyB0cnVlXHJcbiAgICAgKiAgIGNvbnNvbGUubG9nKG1vdmVhYmxlLmlzRHJhZ2dpbmcoKSk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKGFibGVOYW1lKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB2YXIgdGFyZ2V0R2VzdG8gPSB0aGlzLnRhcmdldEdlc3RvO1xyXG4gICAgICAgIHZhciBjb250cm9sR2VzdG8gPSB0aGlzLmNvbnRyb2xHZXN0bztcclxuICAgICAgICBpZiAodGFyZ2V0R2VzdG8gPT09IG51bGwgfHwgdGFyZ2V0R2VzdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldEdlc3RvLmlzRmxhZygpKSB7XHJcbiAgICAgICAgICAgIGlmICghYWJsZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGFyZ2V0R2VzdG8uZ2V0RXZlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiAhISgoX2EgPSBkYXRhW2FibGVOYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRXZlbnRTdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250cm9sR2VzdG8gPT09IG51bGwgfHwgY29udHJvbEdlc3RvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250cm9sR2VzdG8uaXNGbGFnKCkpIHtcclxuICAgICAgICAgICAgaWYgKCFhYmxlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBjb250cm9sR2VzdG8uZ2V0RXZlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiAhISgoX2IgPSBkYXRhW2FibGVOYW1lXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlzRXZlbnRTdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCBhbmQgdG9wIG9mIHRoZSBvbmx5IHRhcmdldCBjaGFuZ2UsIHVwZGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG1vdmVhYmxlLlxyXG4gICAgICogVXNlIGAudXBkYXRlUmVjdCgpYCBtZXRob2RcclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjdXBkYXRlVGFyZ2V0XHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiBtb3ZlYWJsZS51cGRhdGVUYXJnZXQoKTtcclxuICAgICAqL1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVUYXJnZXQgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlUmVjdCh0eXBlLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFlvdSBjYW4gZ2V0IHRoZSB2ZXJ0ZXggaW5mb3JtYXRpb24sIHBvc2l0aW9uIGFuZCBvZmZzZXQgc2l6ZSBpbmZvcm1hdGlvbiBvZiB0aGUgdGFyZ2V0IGJhc2VkIG9uIHRoZSBjb250YWluZXIuXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2dldFJlY3RcclxuICAgICAqIEByZXR1cm4gLSBUaGUgUmVjdCBJbmZvXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHJlY3RJbmZvID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICB2YXIgcG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZSh0aGlzLnN0YXRlKTtcclxuICAgICAgICB2YXIgX2EgPSBfX3JlYWQocG9zZXMsIDQpLCBwb3MxID0gX2FbMF0sIHBvczIgPSBfYVsxXSwgcG9zMyA9IF9hWzJdLCBwb3M0ID0gX2FbM107XHJcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRSZWN0KHBvc2VzKTtcclxuICAgICAgICB2YXIgb2Zmc2V0V2lkdGggPSBzdGF0ZS53aWR0aCwgb2Zmc2V0SGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGgsIGhlaWdodCA9IHJlY3QuaGVpZ2h0LCBsZWZ0ID0gcmVjdC5sZWZ0LCB0b3AgPSByZWN0LnRvcDtcclxuICAgICAgICB2YXIgc3RhdGVQb3MgPSBbc3RhdGUubGVmdCwgc3RhdGUudG9wXTtcclxuICAgICAgICB2YXIgb3JpZ2luID0gcGx1cyhzdGF0ZVBvcywgc3RhdGUub3JpZ2luKTtcclxuICAgICAgICB2YXIgYmVmb3JlT3JpZ2luID0gcGx1cyhzdGF0ZVBvcywgc3RhdGUuYmVmb3JlT3JpZ2luKTtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgICAgICBwb3MxOiBwb3MxLFxyXG4gICAgICAgICAgICBwb3MyOiBwb3MyLFxyXG4gICAgICAgICAgICBwb3MzOiBwb3MzLFxyXG4gICAgICAgICAgICBwb3M0OiBwb3M0LFxyXG4gICAgICAgICAgICBvZmZzZXRXaWR0aDogb2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgICAgIG9mZnNldEhlaWdodDogb2Zmc2V0SGVpZ2h0LFxyXG4gICAgICAgICAgICBiZWZvcmVPcmlnaW46IGJlZm9yZU9yaWdpbixcclxuICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogdHJhbnNmb3JtT3JpZ2luLFxyXG4gICAgICAgICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBtYW5hZ2VyIHRoYXQgbWFuYWdlcyB0aGUgbW92ZWFibGUncyBzdGF0ZSBhbmQgcHJvcHMuXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2dldE1hbmFnZXJcclxuICAgICAqIEByZXR1cm4gLSBUaGUgUmVjdCBJbmZvXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1hbmFnZXIgPSBtb3ZlYWJsZS5nZXRNYW5hZ2VyKCk7IC8vIHJlYWwgbW92ZWFibGUgY2xhc3MgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogWW91IGNhbiBzdG9wIHRoZSBkcmFnZ2luZyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MgdGhyb3VnaCBhIG1ldGhvZCBmcm9tIG91dHNpZGUuXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI3N0b3BEcmFnXHJcbiAgICAgKiBAcmV0dXJuIC0gVGhlIFJlY3QgSW5mb1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiBtb3ZlYWJsZS5zdG9wRHJhZygpO1xyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLnN0b3BEcmFnID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gXCJ0YXJnZXRcIikge1xyXG4gICAgICAgICAgICB2YXIgZ2VzdG8gPSB0aGlzLnRhcmdldEdlc3RvO1xyXG4gICAgICAgICAgICBpZiAoKGdlc3RvID09PSBudWxsIHx8IGdlc3RvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXN0by5pc0lkbGUoKSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICB1bnNldEFibGVzKHRoaXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXN0byA9PT0gbnVsbCB8fCBnZXN0byA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VzdG8uc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gXCJjb250cm9sXCIpIHtcclxuICAgICAgICAgICAgdmFyIGdlc3RvID0gdGhpcy5jb250cm9sR2VzdG87XHJcbiAgICAgICAgICAgIGlmICgoZ2VzdG8gPT09IG51bGwgfHwgZ2VzdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlc3RvLmlzSWRsZSgpKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHVuc2V0QWJsZXModGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2VzdG8gPT09IG51bGwgfHwgZ2VzdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlc3RvLnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBwb3MxID0gX2EucG9zMSwgcG9zMiA9IF9hLnBvczIsIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbjtcclxuICAgICAgICByZXR1cm4gZ2V0QWJzb2x1dGVSb3RhdGlvbihwb3MxLCBwb3MyLCBkaXJlY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdCBhYmxlIHRocm91Z2ggYSBtZXRob2QgcmF0aGVyIHRoYW4gYW4gZXZlbnQuXHJcbiAgICAgKiBBdCB0aGUgbW9tZW50IG9mIGV4ZWN1dGlvbiwgcmVxdWVzdFN0YXJ0IGlzIGV4ZWN1dGVkLFxyXG4gICAgICogYW5kIHRoZW4gcmVxdWVzdCBhbmQgcmVxdWVzdEVuZCBjYW4gYmUgZXhlY3V0ZWQgdGhyb3VnaCBSZXF1ZXN0ZXIuXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI3JlcXVlc3RcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5EcmFnZ2FibGUuaHRtbCNyZXF1ZXN0fERyYWdnYWJsZSBSZXF1ZXN0ZXJ9XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuUmVzaXphYmxlLmh0bWwjcmVxdWVzdHxSZXNpemFibGUgUmVxdWVzdGVyfVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNjYWxhYmxlLmh0bWwjcmVxdWVzdHxTY2FsYWJsZSBSZXF1ZXN0ZXJ9XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuUm90YXRhYmxlLmh0bWwjcmVxdWVzdHxSb3RhdGFibGUgUmVxdWVzdGVyfVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZS5odG1sI3JlcXVlc3R8T3JpZ2luRHJhZ2dhYmxlIFJlcXVlc3Rlcn1cclxuICAgICAqIEBwYXJhbSAtIGFibGVOYW1lXHJcbiAgICAgKiBAcGFyYW0gLSByZXF1ZXN0IHRvIGJlIGFibGUgcGFyYW1zLlxyXG4gICAgICogQHBhcmFtIC0gSWYgaXNJbnN0YW50IGlzIHRydWUsIHJlcXVlc3QgYW5kIHJlcXVlc3RFbmQgYXJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxyXG4gICAgICogQHJldHVybiAtIEFibGUgUmVxdWVzdGVyLiBJZiB0aGVyZSBpcyBubyByZXF1ZXN0IGluIGFibGUsIG5vdGhpbmcgd2lsbCB3b3JrLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXHJcbiAgICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwiZHJhZ2dhYmxlXCIsIHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9LCB0cnVlKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTdGFydCBtb3ZlXHJcbiAgICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwiZHJhZ2dhYmxlXCIpO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcclxuICAgICAqL1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKGFibGVOYW1lLCBwYXJhbSwgaXNJbnN0YW50KSB7XHJcbiAgICAgICAgaWYgKHBhcmFtID09PSB2b2lkIDApIHsgcGFyYW0gPSB7fTsgfVxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvcHMgPSBzZWxmLnByb3BzO1xyXG4gICAgICAgIHZhciBtYW5hZ2VyID0gcHJvcHMucGFyZW50TW92ZWFibGUgfHwgcHJvcHMud3JhcHBlck1vdmVhYmxlIHx8IHNlbGY7XHJcbiAgICAgICAgdmFyIGFsbEFibGVzID0gbWFuYWdlci5wcm9wcy5hYmxlcztcclxuICAgICAgICB2YXIgZ3JvdXBhYmxlID0gcHJvcHMuZ3JvdXBhYmxlO1xyXG4gICAgICAgIHZhciByZXF1c2V0QWJsZSA9IGZpbmQoYWxsQWJsZXMsIGZ1bmN0aW9uIChhYmxlKSB7IHJldHVybiBhYmxlLm5hbWUgPT09IGFibGVOYW1lOyB9KTtcclxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkgfHwgIXJlcXVzZXRBYmxlIHx8ICFyZXF1c2V0QWJsZS5yZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFibGVSZXF1ZXN0ZXIgPSByZXF1c2V0QWJsZS5yZXF1ZXN0KHNlbGYpO1xyXG4gICAgICAgIHZhciByZXF1ZXN0SW5zdGFudCA9IGlzSW5zdGFudCB8fCBwYXJhbS5pc0luc3RhbnQ7XHJcbiAgICAgICAgdmFyIGFibGVUeXBlID0gYWJsZVJlcXVlc3Rlci5pc0NvbnRyb2wgPyBcImNvbnRyb2xBYmxlc1wiIDogXCJ0YXJnZXRBYmxlc1wiO1xyXG4gICAgICAgIHZhciBldmVudEFmZml4ID0gXCJcIi5jb25jYXQoKGdyb3VwYWJsZSA/IFwiR3JvdXBcIiA6IFwiXCIpKS5jb25jYXQoYWJsZVJlcXVlc3Rlci5pc0NvbnRyb2wgPyBcIkNvbnRyb2xcIiA6IFwiXCIpO1xyXG4gICAgICAgIHZhciBtb3ZlYWJsZUFibGVzID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG1hbmFnZXJbYWJsZVR5cGVdKSwgZmFsc2UpO1xyXG4gICAgICAgIHZhciByZXF1ZXN0ZXIgPSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChhYmxlUGFyYW0pIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJBYmxlKHNlbGYsIG1vdmVhYmxlQWJsZXMsIFtcImRyYWdcIl0sIGV2ZW50QWZmaXgsIFwiXCIsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhYmxlUmVxdWVzdGVyLnJlcXVlc3QoYWJsZVBhcmFtKSksIHsgcmVxdWVzdEFibGU6IGFibGVOYW1lLCBpc1JlcXVlc3Q6IHRydWUgfSksIHJlcXVlc3RJbnN0YW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZXI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJBYmxlKHNlbGYsIG1vdmVhYmxlQWJsZXMsIFtcImRyYWdcIl0sIGV2ZW50QWZmaXgsIFwiRW5kXCIsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhYmxlUmVxdWVzdGVyLnJlcXVlc3RFbmQoKSksIHsgcmVxdWVzdEFibGU6IGFibGVOYW1lLCBpc1JlcXVlc3Q6IHRydWUgfSksIHJlcXVlc3RJbnN0YW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZXI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cmlnZ2VyQWJsZShzZWxmLCBtb3ZlYWJsZUFibGVzLCBbXCJkcmFnXCJdLCBldmVudEFmZml4LCBcIlN0YXJ0XCIsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhYmxlUmVxdWVzdGVyLnJlcXVlc3RTdGFydChwYXJhbSkpLCB7IHJlcXVlc3RBYmxlOiBhYmxlTmFtZSwgaXNSZXF1ZXN0OiB0cnVlIH0pLCByZXF1ZXN0SW5zdGFudCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RJbnN0YW50ID8gcmVxdWVzdGVyLnJlcXVlc3QocGFyYW0pLnJlcXVlc3RFbmQoKSA6IHJlcXVlc3RlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIG1vdmVhYmxlIGlzIHRoZSB0b3AgbGV2ZWwgdGhhdCBtYW5hZ2VzIHRhcmdldHNcclxuICAgICAqIGBTaW5nbGVgOiBNb3ZlYWJsZU1hbmFnZXIgaW5zdGFuY2VcclxuICAgICAqIGBHcm91cGA6IE1vdmVhYmxlR3JvdXAgaW5zdGFuY2VcclxuICAgICAqIGBJbmRpdmlkdWFsR3JvdXBgOiBNb3ZlYWJsZUluZGl2aWRhdWxHcm91cCBpbnN0YW5jZVxyXG4gICAgICogUmV0dXJucyBsZWFmIHRhcmdldCBNb3ZlYWJsZU1hbmFnZXJzLlxyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmdldE1vdmVhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoZSBNb3ZlYWJsZSBvYmplY3QgYW5kIHRoZSBldmVudHMuXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2Rlc3Ryb3lcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgKlxyXG4gICAgICogbW92ZWFibGUuZGVzdHJveSgpO1xyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlUmVuZGVyUG9zZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBwcm9wcy5wYWRkaW5nO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbEJlZm9yZU9yaWdpbiA9IHN0YXRlLm9yaWdpbmFsQmVmb3JlT3JpZ2luLCB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW4sIGFsbE1hdHJpeCA9IHN0YXRlLmFsbE1hdHJpeCwgaXMzZCA9IHN0YXRlLmlzM2QsIHBvczEgPSBzdGF0ZS5wb3MxLCBwb3MyID0gc3RhdGUucG9zMiwgcG9zMyA9IHN0YXRlLnBvczMsIHBvczQgPSBzdGF0ZS5wb3M0LCBzdGF0ZUxlZnQgPSBzdGF0ZS5sZWZ0LCBzdGF0ZVRvcCA9IHN0YXRlLnRvcCwgaXNQZXJzaXN0ZWQgPSBzdGF0ZS5pc1BlcnNpc3RlZDtcclxuICAgICAgICB2YXIgem9vbSA9IHByb3BzLnpvb20gfHwgMTtcclxuICAgICAgICBpZiAoIXBhZGRpbmcgJiYgem9vbSA8PSAxKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLnJlbmRlclBvc2VzID0gW1xyXG4gICAgICAgICAgICAgICAgcG9zMSxcclxuICAgICAgICAgICAgICAgIHBvczIsXHJcbiAgICAgICAgICAgICAgICBwb3MzLFxyXG4gICAgICAgICAgICAgICAgcG9zNCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgc3RhdGUucmVuZGVyTGluZXMgPSBbXHJcbiAgICAgICAgICAgICAgICBbcG9zMSwgcG9zMl0sXHJcbiAgICAgICAgICAgICAgICBbcG9zMiwgcG9zNF0sXHJcbiAgICAgICAgICAgICAgICBbcG9zNCwgcG9zM10sXHJcbiAgICAgICAgICAgICAgICBbcG9zMywgcG9zMV0sXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9hID0gZ2V0UGFkZGluZ0JveChwYWRkaW5nIHx8IHt9KSwgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcCwgYm90dG9tID0gX2EuYm90dG9tLCByaWdodCA9IF9hLnJpZ2h0O1xyXG4gICAgICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgICAgIC8vIGNvbnN0IGNsaXBQYXRoSW5mbyA9IGdldENsaXBQYXRoKFxyXG4gICAgICAgIC8vICAgICBwcm9wcy50YXJnZXQsXHJcbiAgICAgICAgLy8gICAgIG9mZnNldFdpZHRoLFxyXG4gICAgICAgIC8vICAgICBvZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgLy8gKTtcclxuICAgICAgICAvLyBpZiAoY2xpcFBhdGhJbmZvKSB7XHJcbiAgICAgICAgLy8gICAgIGxlZnQgLT0gTWF0aC5tYXgoMCwgY2xpcFBhdGhJbmZvLmxlZnQpO1xyXG4gICAgICAgIC8vICAgICB0b3AgLT0gTWF0aC5tYXgoMCwgY2xpcFBhdGhJbmZvLnRvcCk7XHJcbiAgICAgICAgLy8gICAgIGJvdHRvbSAtPSBNYXRoLm1heCgwLCBvZmZzZXRIZWlnaHQgLSBjbGlwUGF0aEluZm8uYm90dG9tKTtcclxuICAgICAgICAvLyAgICAgcmlnaHQgLT0gTWF0aC5tYXgoMCwgb2Zmc2V0V2lkdGggLSBjbGlwUGF0aEluZm8ucmlnaHQpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICB2YXIgYWJzb2x1dGVPcmlnaW4gPSBbXTtcclxuICAgICAgICBpZiAoaXNQZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgYWJzb2x1dGVPcmlnaW4gPSB0cmFuc2Zvcm1PcmlnaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udHJvbEJveCAmJiBwcm9wcy5ncm91cGFibGUpIHtcclxuICAgICAgICAgICAgYWJzb2x1dGVPcmlnaW4gPSBvcmlnaW5hbEJlZm9yZU9yaWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFic29sdXRlT3JpZ2luID0gcGx1cyhvcmlnaW5hbEJlZm9yZU9yaWdpbiwgW3N0YXRlTGVmdCwgc3RhdGVUb3BdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5leHRNYXRyaXggPSBtdWx0aXBsaWVzKG4sIGNyZWF0ZU9yaWdpbk1hdHJpeChhYnNvbHV0ZU9yaWdpbi5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIC12OyB9KSwgbiksIGFsbE1hdHJpeCwgY3JlYXRlT3JpZ2luTWF0cml4KHRyYW5zZm9ybU9yaWdpbiwgbikpO1xyXG4gICAgICAgIHZhciByZW5kZXJQb3MxID0gY2FsY3VsYXRlUGFkZGluZyhuZXh0TWF0cml4LCBwb3MxLCBbLWxlZnQsIC10b3BdLCBuKTtcclxuICAgICAgICB2YXIgcmVuZGVyUG9zMiA9IGNhbGN1bGF0ZVBhZGRpbmcobmV4dE1hdHJpeCwgcG9zMiwgW3JpZ2h0LCAtdG9wXSwgbik7XHJcbiAgICAgICAgdmFyIHJlbmRlclBvczMgPSBjYWxjdWxhdGVQYWRkaW5nKG5leHRNYXRyaXgsIHBvczMsIFstbGVmdCwgYm90dG9tXSwgbik7XHJcbiAgICAgICAgdmFyIHJlbmRlclBvczQgPSBjYWxjdWxhdGVQYWRkaW5nKG5leHRNYXRyaXgsIHBvczQsIFtyaWdodCwgYm90dG9tXSwgbik7XHJcbiAgICAgICAgc3RhdGUucmVuZGVyUG9zZXMgPSBbXHJcbiAgICAgICAgICAgIHJlbmRlclBvczEsXHJcbiAgICAgICAgICAgIHJlbmRlclBvczIsXHJcbiAgICAgICAgICAgIHJlbmRlclBvczMsXHJcbiAgICAgICAgICAgIHJlbmRlclBvczQsXHJcbiAgICAgICAgXTtcclxuICAgICAgICBzdGF0ZS5yZW5kZXJMaW5lcyA9IFtcclxuICAgICAgICAgICAgW3JlbmRlclBvczEsIHJlbmRlclBvczJdLFxyXG4gICAgICAgICAgICBbcmVuZGVyUG9zMiwgcmVuZGVyUG9zNF0sXHJcbiAgICAgICAgICAgIFtyZW5kZXJQb3M0LCByZW5kZXJQb3MzXSxcclxuICAgICAgICAgICAgW3JlbmRlclBvczMsIHJlbmRlclBvczFdLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKHpvb20pIHtcclxuICAgICAgICAgICAgdmFyIHpvb21PZmZzZXQgPSB6b29tIC8gMjtcclxuICAgICAgICAgICAgc3RhdGUucmVuZGVyTGluZXMgPSBbXHJcbiAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlUGFkZGluZyhuZXh0TWF0cml4LCBwb3MxLCBbLWxlZnQgLSB6b29tT2Zmc2V0LCAtdG9wXSwgbiksXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlUGFkZGluZyhuZXh0TWF0cml4LCBwb3MyLCBbcmlnaHQgKyB6b29tT2Zmc2V0LCAtdG9wXSwgbiksXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVBhZGRpbmcobmV4dE1hdHJpeCwgcG9zMiwgW3JpZ2h0LCAtdG9wIC0gem9vbU9mZnNldF0sIG4pLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVBhZGRpbmcobmV4dE1hdHJpeCwgcG9zNCwgW3JpZ2h0LCBib3R0b20gKyB6b29tT2Zmc2V0XSwgbiksXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVBhZGRpbmcobmV4dE1hdHJpeCwgcG9zNCwgW3JpZ2h0ICsgem9vbU9mZnNldCwgYm90dG9tXSwgbiksXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlUGFkZGluZyhuZXh0TWF0cml4LCBwb3MzLCBbLWxlZnQgLSB6b29tT2Zmc2V0LCBib3R0b21dLCBuKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlUGFkZGluZyhuZXh0TWF0cml4LCBwb3MzLCBbLWxlZnQsIGJvdHRvbSArIHpvb21PZmZzZXRdLCBuKSxcclxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVQYWRkaW5nKG5leHRNYXRyaXgsIHBvczEsIFstbGVmdCwgLXRvcCAtIHpvb21PZmZzZXRdLCBuKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuY2hlY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5faXNQcm9wVGFyZ2V0Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHRhcmdldCA9IF9hLnRhcmdldCwgY29udGFpbmVyID0gX2EuY29udGFpbmVyLCBwYXJlbnRNb3ZlYWJsZSA9IF9hLnBhcmVudE1vdmVhYmxlO1xyXG4gICAgICAgIHZhciBfYiA9IHRoaXMuc3RhdGUsIHN0YXRlVGFyZ2V0ID0gX2IudGFyZ2V0LCBzdGF0ZUNvbnRhaW5lciA9IF9iLmNvbnRhaW5lcjtcclxuICAgICAgICBpZiAoIXN0YXRlVGFyZ2V0ICYmICF0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZUFibGVzKCk7XHJcbiAgICAgICAgdmFyIGlzVGFyZ2V0Q2hhbmdlZCA9ICFlcXVhbHMoc3RhdGVUYXJnZXQsIHRhcmdldCk7XHJcbiAgICAgICAgdmFyIGlzQ2hhbmdlZCA9IGlzVGFyZ2V0Q2hhbmdlZCB8fCAhZXF1YWxzKHN0YXRlQ29udGFpbmVyLCBjb250YWluZXIpO1xyXG4gICAgICAgIGlmICghaXNDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1vdmVhYmxlQ29udGFpbmVyID0gY29udGFpbmVyIHx8IHRoaXMuY29udHJvbEJveDtcclxuICAgICAgICBpZiAobW92ZWFibGVDb250YWluZXIpIHtcclxuICAgICAgICAgICAgdGhpcy51bnNldEFibGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyB0YXJnZXQ6IHRhcmdldCwgY29udGFpbmVyOiBjb250YWluZXIgfSk7XHJcbiAgICAgICAgaWYgKCFwYXJlbnRNb3ZlYWJsZSAmJiBtb3ZlYWJsZUNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlY3QoXCJFbmRcIiwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNQcm9wVGFyZ2V0Q2hhbmdlZCA9IGlzVGFyZ2V0Q2hhbmdlZDtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLndhaXRUb0NoYW5nZVRhcmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKCkgeyB9KTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBlKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICB0aGlzLl9lbWl0dGVyLnRyaWdnZXIobmFtZSwgZSk7XHJcbiAgICAgICAgaWYgKHByb3BzLnBhcmVudE1vdmVhYmxlICYmIGUuaXNSZXF1ZXN0ICYmICFlLmlzUmVxdWVzdENoaWxkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5wYXJlbnRNb3ZlYWJsZS50cmlnZ2VyRXZlbnQobmFtZSwgZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYWxsYmFjayA9IHByb3BzW25hbWVdO1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjayhlKTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLnVzZUNTUyA9IGZ1bmN0aW9uICh0YWcsIGNzcykge1xyXG4gICAgICAgIHZhciBjdXN0b21TdHlsZU1hcCA9IHRoaXMucHJvcHMuY3VzdG9tU3R5bGVkTWFwO1xyXG4gICAgICAgIHZhciBrZXkgPSB0YWcgKyBjc3M7XHJcbiAgICAgICAgaWYgKCFjdXN0b21TdHlsZU1hcFtrZXldKSB7XHJcbiAgICAgICAgICAgIGN1c3RvbVN0eWxlTWFwW2tleV0gPSBzdHlsZWQodGFnLCBjc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VzdG9tU3R5bGVNYXBba2V5XTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGlmIChwcm9wcy50YXJnZXQgfHwgKChfYSA9IHByb3BzLnRhcmdldHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0ZpcnN0VGFyZ2V0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGhhc0NvbnRyb2xCb3ggPSB0aGlzLmNvbnRyb2xCb3g7XHJcbiAgICAgICAgdmFyIHBlcnNpc3REYXRhID0gcHJvcHMucGVyc2lzdERhdGE7XHJcbiAgICAgICAgdmFyIGZpcnN0UmVuZGVyU3RhdGUgPSBwcm9wcy5maXJzdFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChmaXJzdFJlbmRlclN0YXRlICYmICFoYXNDb250cm9sQm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaXJzdFJlbmRlclN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2hhc0ZpcnN0VGFyZ2V0ICYmIHBlcnNpc3REYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBwZXJzaXN0U3RhdGUgPSBnZXRQZXJzaXN0U3RhdGUocGVyc2lzdERhdGEpO1xyXG4gICAgICAgICAgICBpZiAocGVyc2lzdFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHBlcnNpc3RTdGF0ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5pc1BlcnNpc3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU2VsZWN0b3JzID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS51bnNldEFibGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy50YXJnZXRBYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChhYmxlLnVuc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBhYmxlLnVuc2V0KF90aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlQWJsZXMgPSBmdW5jdGlvbiAoYWJsZXMsIGV2ZW50QWZmaXgpIHtcclxuICAgICAgICBpZiAoYWJsZXMgPT09IHZvaWQgMCkgeyBhYmxlcyA9IHRoaXMucHJvcHMuYWJsZXM7IH1cclxuICAgICAgICBpZiAoZXZlbnRBZmZpeCA9PT0gdm9pZCAwKSB7IGV2ZW50QWZmaXggPSBcIlwiOyB9XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICB2YXIgdHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHkgPSBwcm9wcy50cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseTtcclxuICAgICAgICB2YXIgZW5hYmxlZEFibGVzID0gdGhpcy5nZXRFbmFibGVkQWJsZXMoYWJsZXMpO1xyXG4gICAgICAgIHZhciBkcmFnU3RhcnQgPSBcImRyYWdcIi5jb25jYXQoZXZlbnRBZmZpeCwgXCJTdGFydFwiKTtcclxuICAgICAgICB2YXIgcGluY2hTdGFydCA9IFwicGluY2hcIi5jb25jYXQoZXZlbnRBZmZpeCwgXCJTdGFydFwiKTtcclxuICAgICAgICB2YXIgZHJhZ0NvbnRyb2xTdGFydCA9IFwiZHJhZ1wiLmNvbmNhdChldmVudEFmZml4LCBcIkNvbnRyb2xTdGFydFwiKTtcclxuICAgICAgICB2YXIgdGFyZ2V0QWJsZXMgPSBmaWx0ZXJBYmxlcyhlbmFibGVkQWJsZXMsIFtkcmFnU3RhcnQsIHBpbmNoU3RhcnRdLCB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSk7XHJcbiAgICAgICAgdmFyIGNvbnRyb2xBYmxlcyA9IGZpbHRlckFibGVzKGVuYWJsZWRBYmxlcywgW2RyYWdDb250cm9sU3RhcnRdLCB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSk7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkQWJsZXMgPSBlbmFibGVkQWJsZXM7XHJcbiAgICAgICAgdGhpcy50YXJnZXRBYmxlcyA9IHRhcmdldEFibGVzO1xyXG4gICAgICAgIHRoaXMuY29udHJvbEFibGVzID0gY29udHJvbEFibGVzO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAobmV4dFN0YXRlLCBpc1NldFN0YXRlKSB7XHJcbiAgICAgICAgaWYgKGlzU2V0U3RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5leHRTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzMgaW4gbmV4dFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZVtuYW1lXzNdID0gbmV4dFN0YXRlW25hbWVfM107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRFbmFibGVkQWJsZXMgPSBmdW5jdGlvbiAoYWJsZXMpIHtcclxuICAgICAgICBpZiAoYWJsZXMgPT09IHZvaWQgMCkgeyBhYmxlcyA9IHRoaXMucHJvcHMuYWJsZXM7IH1cclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHJldHVybiBhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHsgcmV0dXJuIGFibGUgJiYgKChhYmxlLmFsd2F5cyAmJiBwcm9wc1thYmxlLm5hbWVdICE9PSBmYWxzZSlcclxuICAgICAgICAgICAgfHwgcHJvcHNbYWJsZS5uYW1lXSk7IH0pO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUucmVuZGVyQWJsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSA9IHByb3BzLnRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5O1xyXG4gICAgICAgIHZhciBSZW5kZXJlciA9IHtcclxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVuZGVyU3RhdGUgPSB7fTtcclxuICAgICAgICByZXR1cm4gZ3JvdXBCeU1hcChmbGF0KGZpbHRlckFibGVzKHRoaXMuZ2V0RW5hYmxlZEFibGVzKCksIFtcInJlbmRlclwiXSwgdHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHkpLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHJlbmRlciA9IF9hLnJlbmRlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcihfdGhpcywgUmVuZGVyZXIpIHx8IFtdO1xyXG4gICAgICAgIH0pKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbDsgfSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gX2Eua2V5O1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZ3JvdXApIHsgcmV0dXJuIGdyb3VwWzBdOyB9KTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUNoZWNrSW5wdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXRHZXN0byAmJiAodGhpcy50YXJnZXRHZXN0by5vcHRpb25zLmNoZWNrSW5wdXQgPSB0aGlzLnByb3BzLmNoZWNrSW5wdXQpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuX2dldFJlcXVlc3RTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlTmFtZXMgPSB0aGlzLmdldEVuYWJsZWRBYmxlcygpLnJlZHVjZShmdW5jdGlvbiAobmFtZXMsIGFibGUpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgdmFyIGFibGVTdHlsZU5hbWVzID0gKChfYiA9IChfYSA9IGFibGUucmVxdWVzdFN0eWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChhYmxlKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pO1xyXG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobmFtZXMpLCBmYWxzZSksIF9fcmVhZChhYmxlU3R5bGVOYW1lcyksIGZhbHNlKTtcclxuICAgICAgICB9LCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoKHRoaXMucHJvcHMucmVxdWVzdFN0eWxlcyB8fCBbXSkpLCBmYWxzZSkpO1xyXG4gICAgICAgIHJldHVybiBzdHlsZU5hbWVzO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuX3VwZGF0ZU9ic2VydmVyID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlc2l6ZU9ic2VydmVyKHByZXZQcm9wcyk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTXV0YXRpb25PYnNlcnZlcihwcmV2UHJvcHMpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuX3VwZGF0ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGFzVGFyZ2V0QWJsZSA9IHRoaXMudGFyZ2V0QWJsZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBoYXNDb250cm9sQWJsZSA9IHRoaXMuY29udHJvbEFibGVzLmxlbmd0aDtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fZHJhZ1RhcmdldDtcclxuICAgICAgICB2YXIgaXNVbnNldCA9ICghaGFzVGFyZ2V0QWJsZSAmJiB0aGlzLnRhcmdldEdlc3RvKVxyXG4gICAgICAgICAgICB8fCB0aGlzLl9pc1RhcmdldENoYW5nZWQodHJ1ZSk7XHJcbiAgICAgICAgaWYgKGlzVW5zZXQpIHtcclxuICAgICAgICAgICAgdW5zZXRHZXN0byh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyBnZXN0b3M6IHt9IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWhhc0NvbnRyb2xBYmxlKSB7XHJcbiAgICAgICAgICAgIHVuc2V0R2VzdG8odGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXQgJiYgaGFzVGFyZ2V0QWJsZSAmJiAhdGhpcy50YXJnZXRHZXN0bykge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldEdlc3RvID0gZ2V0VGFyZ2V0QWJsZUdlc3RvKHRoaXMsIHRhcmdldCwgXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5jb250cm9sR2VzdG8gJiYgaGFzQ29udHJvbEFibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sR2VzdG8gPSBnZXRDb250cm9sQWJsZUdlc3RvKHRoaXMsIFwiQ29udHJvbFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5fdXBkYXRlVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHRoaXMuX3ByZXZQcm9wVGFyZ2V0ID0gdGhpcy5fcHJvcFRhcmdldDtcclxuICAgICAgICB0aGlzLl9wcmV2RHJhZ1RhcmdldCA9IHRoaXMuX2RyYWdUYXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fcHJldk9yaWdpbmFsRHJhZ1RhcmdldCA9IHRoaXMuX29yaWdpbmFsRHJhZ1RhcmdldDtcclxuICAgICAgICB0aGlzLl9wcmV2RHJhZ0FyZWEgPSBwcm9wcy5kcmFnQXJlYTtcclxuICAgICAgICB0aGlzLl9wcm9wVGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsRHJhZ1RhcmdldCA9IHByb3BzLmRyYWdUYXJnZXQgfHwgcHJvcHMudGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuX2RyYWdUYXJnZXQgPSBnZXRSZWZUYXJnZXQodGhpcy5fb3JpZ2luYWxEcmFnVGFyZ2V0LCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLl9yZW5kZXJMaW5lcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciBfYSA9IHByb3BzLCB6b29tID0gX2Euem9vbSwgaGlkZURlZmF1bHRMaW5lcyA9IF9hLmhpZGVEZWZhdWx0TGluZXMsIGhpZGVDaGlsZE1vdmVhYmxlRGVmYXVsdExpbmVzID0gX2EuaGlkZUNoaWxkTW92ZWFibGVEZWZhdWx0TGluZXMsIHBhcmVudE1vdmVhYmxlID0gX2EucGFyZW50TW92ZWFibGU7XHJcbiAgICAgICAgaWYgKGhpZGVEZWZhdWx0TGluZXMgfHwgKHBhcmVudE1vdmVhYmxlICYmIGhpZGVDaGlsZE1vdmVhYmxlRGVmYXVsdExpbmVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcclxuICAgICAgICB2YXIgUmVuZGVyZXIgPSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gc3RhdGUucmVuZGVyTGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJMaW5lKFJlbmRlcmVyLCBcIlwiLCBsaW5lWzBdLCBsaW5lWzFdLCB6b29tLCBcInJlbmRlci1saW5lLVwiLmNvbmNhdChpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5faXNUYXJnZXRDaGFuZ2VkID0gZnVuY3Rpb24gKHVzZURyYWdBcmVhKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICB2YXIgbmV4dFRhcmdldCA9IHByb3BzLmRyYWdUYXJnZXQgfHwgcHJvcHMudGFyZ2V0O1xyXG4gICAgICAgIHZhciBwcmV2VGFyZ2V0ID0gdGhpcy5fcHJldk9yaWdpbmFsRHJhZ1RhcmdldDtcclxuICAgICAgICB2YXIgcHJldkRyYWdBcmVhID0gdGhpcy5fcHJldkRyYWdBcmVhO1xyXG4gICAgICAgIHZhciBkcmFnQXJlYSA9IHByb3BzLmRyYWdBcmVhO1xyXG4gICAgICAgIC8vIGNoZWNrIHRhcmdldCB3aXRob3V0IGRyYWdBcmVhXHJcbiAgICAgICAgdmFyIGlzRHJhZ1RhcmdldENoYW5nZWQgPSAhZHJhZ0FyZWEgJiYgcHJldlRhcmdldCAhPT0gbmV4dFRhcmdldDtcclxuICAgICAgICB2YXIgaXNEcmFnQXJlYUNoYW5nZWQgPSAodXNlRHJhZ0FyZWEgfHwgZHJhZ0FyZWEpICYmIHByZXZEcmFnQXJlYSAhPT0gZHJhZ0FyZWE7XHJcbiAgICAgICAgcmV0dXJuIGlzRHJhZ1RhcmdldENoYW5nZWQgfHwgaXNEcmFnQXJlYUNoYW5nZWQgfHwgdGhpcy5fcHJldlByb3BUYXJnZXQgIT0gdGhpcy5fcHJvcFRhcmdldDtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLl91cGRhdGVOYXRpdmVFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBwcm9wcy5kcmFnQXJlYSA/IHRoaXMuYXJlYUVsZW1lbnQgOiB0aGlzLnN0YXRlLnRhcmdldDtcclxuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XHJcbiAgICAgICAgdmFyIGV2ZW50S2V5cyA9IGdldEtleXMoZXZlbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5faXNUYXJnZXRDaGFuZ2VkKCkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBldmVudHNbZXZlbnROYW1lXTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIgJiYgbWFuYWdlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZW5hYmxlZEFibGVzID0gdGhpcy5lbmFibGVkQWJsZXM7XHJcbiAgICAgICAgZXZlbnRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgYWJsZXMgPSBmaWx0ZXJBYmxlcyhlbmFibGVkQWJsZXMsIFtldmVudE5hbWVdKTtcclxuICAgICAgICAgICAgdmFyIGhhc0FibGVzID0gYWJsZXMubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBldmVudHNbZXZlbnROYW1lXTtcclxuICAgICAgICAgICAgaWYgKCFoYXNBYmxlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFtYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcih0YXJnZXQsIF90aGlzLCBldmVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSBtYW5hZ2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hbmFnZXIuc2V0QWJsZXMoYWJsZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuX2NoZWNrVXBkYXRlUm9vdENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcm9vdENvbnRhaW5lciA9IHRoaXMucHJvcHMucm9vdENvbnRhaW5lcjtcclxuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RDb250YWluZXIgJiYgcm9vdENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290Q29udGFpbmVyID0gZ2V0UmVmVGFyZ2V0KHJvb3RDb250YWluZXIsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLl9jaGVja1VwZGF0ZVZpZXdDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXJPcHRpb24gPSB0aGlzLnByb3BzLnZpZXdDb250YWluZXI7XHJcbiAgICAgICAgaWYgKCF0aGlzLl92aWV3Q29udGFpbmVyICYmIHZpZXdDb250YWluZXJPcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lciA9IGdldFJlZlRhcmdldCh2aWV3Q29udGFpbmVyT3B0aW9uLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXIgPSB0aGlzLl92aWV3Q29udGFpbmVyO1xyXG4gICAgICAgIGlmICh2aWV3Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFibGVWaWV3Q2xhc3NOYW1lcyhfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh0aGlzLl9nZXRBYmxlVmlld0NsYXNzTmFtZXMoKSksIGZhbHNlKSwgW1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nKCkgPyBWSUVXX0RSQUdHSU5HIDogXCJcIixcclxuICAgICAgICAgICAgXSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5fY2hhbmdlQWJsZVZpZXdDbGFzc05hbWVzID0gZnVuY3Rpb24gKGNsYXNzTmFtZXMpIHtcclxuICAgICAgICB2YXIgdmlld0NvbnRhaW5lciA9IHRoaXMuX3ZpZXdDb250YWluZXI7XHJcbiAgICAgICAgdmFyIG5leHRDbGFzc05hbWVzID0gZ3JvdXBCeShjbGFzc05hbWVzLmZpbHRlcihCb29sZWFuKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbDsgfSkubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDEpLCBjbGFzc05hbWUgPSBfYlswXTtcclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcHJldkNsYXNzTmFtZXMgPSB0aGlzLl92aWV3Q2xhc3NOYW1lcztcclxuICAgICAgICB2YXIgX2EgPSBkaWZmJDEocHJldkNsYXNzTmFtZXMsIG5leHRDbGFzc05hbWVzKSwgcmVtb3ZlZCA9IF9hLnJlbW92ZWQsIGFkZGVkID0gX2EuYWRkZWQ7XHJcbiAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICByZW1vdmVDbGFzcyh2aWV3Q29udGFpbmVyLCBwcmV2Q2xhc3NOYW1lc1tpbmRleF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZGVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKHZpZXdDb250YWluZXIsIG5leHRDbGFzc05hbWVzW2luZGV4XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdmlld0NsYXNzTmFtZXMgPSBuZXh0Q2xhc3NOYW1lcztcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLl9nZXRBYmxlVmlld0NsYXNzTmFtZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0RW5hYmxlZEFibGVzKCkubWFwKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuICgoKF9hID0gYWJsZS52aWV3Q2xhc3NOYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChhYmxlLCBfdGhpcykpIHx8IFwiXCIpO1xyXG4gICAgICAgIH0pLmpvaW4oXCIgXCIpICsgXCIgXCIuY29uY2F0KHRoaXMuX2dldEFibGVDbGFzc05hbWUoXCItdmlld1wiKSkpLnNwbGl0KC9cXHMrL2cpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuX2dldEFibGVDbGFzc05hbWUgPSBmdW5jdGlvbiAoY2xhc3NQcmVmaXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChjbGFzc1ByZWZpeCA9PT0gdm9pZCAwKSB7IGNsYXNzUHJlZml4ID0gXCJcIjsgfVxyXG4gICAgICAgIHZhciBhYmxlcyA9IHRoaXMuZ2V0RW5hYmxlZEFibGVzKCk7XHJcbiAgICAgICAgdmFyIHRhcmdldEdlc3RvID0gdGhpcy50YXJnZXRHZXN0bztcclxuICAgICAgICB2YXIgY29udHJvbEdlc3RvID0gdGhpcy5jb250cm9sR2VzdG87XHJcbiAgICAgICAgdmFyIHRhcmdldEdlc3RvRGF0YSA9ICh0YXJnZXRHZXN0byA9PT0gbnVsbCB8fCB0YXJnZXRHZXN0byA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0R2VzdG8uaXNGbGFnKCkpXHJcbiAgICAgICAgICAgID8gdGFyZ2V0R2VzdG8uZ2V0RXZlbnREYXRhKCkgOiB7fTtcclxuICAgICAgICB2YXIgY29udHJvbEdlc3RvRGF0YSA9IChjb250cm9sR2VzdG8gPT09IG51bGwgfHwgY29udHJvbEdlc3RvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250cm9sR2VzdG8uaXNGbGFnKCkpXHJcbiAgICAgICAgICAgID8gY29udHJvbEdlc3RvLmdldEV2ZW50RGF0YSgpIDoge307XHJcbiAgICAgICAgcmV0dXJuIGFibGVzLm1hcChmdW5jdGlvbiAoYWJsZSkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBhYmxlLm5hbWU7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAoKF9hID0gYWJsZS5jbGFzc05hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFibGUsIF90aGlzKSkgfHwgXCJcIjtcclxuICAgICAgICAgICAgaWYgKCgoX2IgPSB0YXJnZXRHZXN0b0RhdGFbbmFtZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pc0V2ZW50U3RhcnQpXHJcbiAgICAgICAgICAgICAgICB8fCAoKF9jID0gY29udHJvbEdlc3RvRGF0YVtuYW1lXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlzRXZlbnRTdGFydCkpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSArPSBcIiBcIi5jb25jYXQocHJlZml4KFwiXCIuY29uY2F0KG5hbWUpLmNvbmNhdChjbGFzc1ByZWZpeCwgXCItZHJhZ2dpbmdcIikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lLnRyaW0oKTtcclxuICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5fdXBkYXRlUmVzaXplT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHByb3BzLnRhcmdldDtcclxuICAgICAgICB2YXIgd2luID0gZ2V0V2luZG93KHRoaXMuZ2V0Q29udHJvbEJveEVsZW1lbnQoKSk7XHJcbiAgICAgICAgaWYgKCF3aW4uUmVzaXplT2JzZXJ2ZXIgfHwgIXRhcmdldCB8fCAhcHJvcHMudXNlUmVzaXplT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5fcmVpc3plT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXZQcm9wcy50YXJnZXQgPT09IHRhcmdldCAmJiB0aGlzLl9yZWlzemVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyB3aW4uUmVzaXplT2JzZXJ2ZXIodGhpcy5jaGVja1VwZGF0ZVJlY3QpO1xyXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0LCB7XHJcbiAgICAgICAgICAgIGJveDogXCJib3JkZXItYm94XCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcmVpc3plT2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLl91cGRhdGVNdXRhdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHByb3BzLnRhcmdldDtcclxuICAgICAgICB2YXIgd2luID0gZ2V0V2luZG93KHRoaXMuZ2V0Q29udHJvbEJveEVsZW1lbnQoKSk7XHJcbiAgICAgICAgaWYgKCF3aW4uTXV0YXRpb25PYnNlcnZlciB8fCAhdGFyZ2V0IHx8ICFwcm9wcy51c2VNdXRhdGlvbk9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXZQcm9wcy50YXJnZXQgPT09IHRhcmdldCAmJiB0aGlzLl9tdXRhdGlvbk9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IHdpbi5NdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChyZWNvcmRzKSB7XHJcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcmVjb3Jkc18xID0gX192YWx1ZXMocmVjb3JkcyksIHJlY29yZHNfMV8xID0gcmVjb3Jkc18xLm5leHQoKTsgIXJlY29yZHNfMV8xLmRvbmU7IHJlY29yZHNfMV8xID0gcmVjb3Jkc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbiA9IHJlY29yZHNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSBcImF0dHJpYnV0ZXNcIiAmJiBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSBcInN0eWxlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tVcGRhdGVSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3Jkc18xXzEgJiYgIXJlY29yZHNfMV8xLmRvbmUgJiYgKF9hID0gcmVjb3Jkc18xLnJldHVybikpIF9hLmNhbGwocmVjb3Jkc18xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0LCB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgICAgICAgZHJhZ1RhcmdldFNlbGY6IGZhbHNlLFxyXG4gICAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgICBkcmFnVGFyZ2V0OiBudWxsLFxyXG4gICAgICAgIGNvbnRhaW5lcjogbnVsbCxcclxuICAgICAgICByb290Q29udGFpbmVyOiBudWxsLFxyXG4gICAgICAgIG9yaWdpbjogdHJ1ZSxcclxuICAgICAgICBwYXJlbnRNb3ZlYWJsZTogbnVsbCxcclxuICAgICAgICB3cmFwcGVyTW92ZWFibGU6IG51bGwsXHJcbiAgICAgICAgaXNXcmFwcGVyTW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgcGFyZW50UG9zaXRpb246IG51bGwsXHJcbiAgICAgICAgd2FycFNlbGY6IGZhbHNlLFxyXG4gICAgICAgIHN2Z09yaWdpbjogXCJcIixcclxuICAgICAgICBkcmFnQ29udGFpbmVyOiBudWxsLFxyXG4gICAgICAgIHVzZVJlc2l6ZU9ic2VydmVyOiBmYWxzZSxcclxuICAgICAgICB1c2VNdXRhdGlvbk9ic2VydmVyOiBmYWxzZSxcclxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcclxuICAgICAgICBwcmV2ZW50UmlnaHRDbGljazogdHJ1ZSxcclxuICAgICAgICBwcmV2ZW50V2hlZWxDbGljazogdHJ1ZSxcclxuICAgICAgICBsaW5lUGFkZGluZzogMCxcclxuICAgICAgICBjb250cm9sUGFkZGluZzogMCxcclxuICAgICAgICBhYmxlczogW10sXHJcbiAgICAgICAgcGluY2hUaHJlc2hvbGQ6IDIwLFxyXG4gICAgICAgIGRyYWdBcmVhOiBmYWxzZSxcclxuICAgICAgICBwYXNzRHJhZ0FyZWE6IGZhbHNlLFxyXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCJcIixcclxuICAgICAgICBjbGFzc05hbWU6IFwiXCIsXHJcbiAgICAgICAgem9vbTogMSxcclxuICAgICAgICB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseTogZmFsc2UsXHJcbiAgICAgICAgcGFkZGluZzoge30sXHJcbiAgICAgICAgcGluY2hPdXRzaWRlOiB0cnVlLFxyXG4gICAgICAgIGNoZWNrSW5wdXQ6IGZhbHNlLFxyXG4gICAgICAgIGRyYWdGb2N1c2VkSW5wdXQ6IGZhbHNlLFxyXG4gICAgICAgIGdyb3VwYWJsZTogZmFsc2UsXHJcbiAgICAgICAgaGlkZURlZmF1bHRMaW5lczogZmFsc2UsXHJcbiAgICAgICAgY3NwTm9uY2U6IFwiXCIsXHJcbiAgICAgICAgdHJhbnNsYXRlWjogMCxcclxuICAgICAgICBjc3NTdHlsZWQ6IG51bGwsXHJcbiAgICAgICAgY3VzdG9tU3R5bGVkTWFwOiB7fSxcclxuICAgICAgICBwcm9wczoge30sXHJcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZSxcclxuICAgICAgICBwcmV2ZW50Q2xpY2tEZWZhdWx0OiBmYWxzZSxcclxuICAgICAgICBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZzogdHJ1ZSxcclxuICAgICAgICBmbHVzaFN5bmM6IGRlZmF1bHRTeW5jLFxyXG4gICAgICAgIGZpcnN0UmVuZGVyU3RhdGU6IG51bGwsXHJcbiAgICAgICAgcGVyc2lzdERhdGE6IG51bGwsXHJcbiAgICAgICAgdmlld0NvbnRhaW5lcjogbnVsbCxcclxuICAgICAgICByZXF1ZXN0U3R5bGVzOiBbXSxcclxuICAgICAgICB1c2VBY2N1cmF0ZVBvc2l0aW9uOiBmYWxzZSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gTW92ZWFibGVNYW5hZ2VyO1xyXG59KFJlYWN0LlB1cmVDb21wb25lbnQpKTtcclxuLyoqXHJcbiAqIFRoZSB0YXJnZXQgdG8gaW5kaWNhdGUgTW92ZWFibGUgQ29udHJvbCBCb3guXHJcbiAqIEBuYW1lIE1vdmVhYmxlI3RhcmdldFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKiBtb3ZlYWJsZS50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKTtcclxuICovXHJcbi8qKlxyXG4gKiBab29tcyBpbiB0aGUgZWxlbWVudHMgb2YgYSBtb3ZlYWJsZS5cclxuICogQG5hbWUgTW92ZWFibGUjem9vbVxyXG4gKiBAZGVmYXVsdCAxXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqIG1vdmVhYmxlLnpvb20gPSAyO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIHRhcmdldCBzaXplIGlzIGRldGVjdGVkIGFuZCB1cGRhdGVkIHdoZW5ldmVyIGl0IGNoYW5nZXMuXHJcbiAqIEBuYW1lIE1vdmVhYmxlI3VzZVJlc2l6ZU9ic2VydmVyXHJcbiAqIEBkZWZhdWx0IGZhbHNlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqIG1vdmVhYmxlLnVzZVJlc2l6ZU9ic2VydmVyID0gdHJ1ZTtcclxuICovXHJcbi8qKlxyXG4gKiBSZXNpemUsIFNjYWxlIEV2ZW50cyBhdCBlZGdlc1xyXG4gKiBAbmFtZSBNb3ZlYWJsZSNlZGdlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqIG1vdmVhYmxlLmVkZ2UgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgY2xhc3NOYW1lIG9mIHRoZSBtb3ZlYWJsZSBjb250cm9sYm94LlxyXG4gKiBAbmFtZSBNb3ZlYWJsZSNjbGFzc05hbWVcclxuICogQGRlZmF1bHQgXCJcIlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICBjbGFzc05hbWU6IFwiXCIsXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5jbGFzc05hbWUgPSBcIm1vdmVhYmxlMVwiO1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSB0YXJnZXQocykgdG8gZHJhZyBNb3ZlYWJsZSB0YXJnZXQocylcclxuICogQG5hbWUgTW92ZWFibGUjZHJhZ1RhcmdldFxyXG4gKiBAZGVmYXVsdCB0YXJnZXRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICogbW92ZWFibGUudGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIik7XHJcbiAqIG1vdmVhYmxlLmRyYWdUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmRyYWdUYXJnZXRcIik7XHJcbiAqL1xyXG4vKipcclxuICogYHJlbmRlclN0YXJ0YCBldmVudCBvY2N1cnMgYXQgdGhlIGZpcnN0IHN0YXJ0IG9mIGFsbCBldmVudHMuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxyXG4gKiBAZXZlbnQgcmVuZGVyU3RhcnRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlclN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVuZGVyU3RhcnRgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicmVuZGVyU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJTdGFydFwiLCB0YXJnZXQpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBgcmVuZGVyYCBldmVudCBvY2N1cnMgYmVmb3JlIHRoZSB0YXJnZXQgaXMgZHJhd24gb24gdGhlIHNjcmVlbi5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlXHJcbiAqIEBldmVudCByZW5kZXJcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlcn0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlbmRlcmAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyZW5kZXJcIiwgKHsgdGFyZ2V0IH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJcIiwgdGFyZ2V0KTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogYHJlbmRlckVuZGAgZXZlbnQgb2NjdXJzIGF0IHRoZSBlbmQgb2YgYWxsIGV2ZW50cy5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlXHJcbiAqIEBldmVudCByZW5kZXJFbmRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlckVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlbmRlckVuZGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyZW5kZXJFbmRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJFbmRcIiwgdGFyZ2V0KTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogYHJlbmRlckdyb3VwU3RhcnRgIGV2ZW50IG9jY3VycyBhdCB0aGUgZmlyc3Qgc3RhcnQgb2YgYWxsIGV2ZW50cyBpbiBncm91cC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlXHJcbiAqIEBldmVudCByZW5kZXJHcm91cFN0YXJ0XHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuT25SZW5kZXJHcm91cFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVuZGVyR3JvdXBTdGFydGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyZW5kZXJHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlckdyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIGByZW5kZXJHcm91cGAgZXZlbnQgb2NjdXJzIGJlZm9yZSB0aGUgdGFyZ2V0IGlzIGRyYXduIG9uIHRoZSBzY3JlZW4gaW4gZ3JvdXAuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxyXG4gKiBAZXZlbnQgcmVuZGVyR3JvdXBcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlckdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVuZGVyR3JvdXBgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicmVuZGVyR3JvdXBcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUmVuZGVyR3JvdXBcIiwgdGFyZ2V0cyk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIGByZW5kZXJHcm91cEVuZGAgZXZlbnQgb2NjdXJzIGF0IHRoZSBlbmQgb2YgYWxsIGV2ZW50cyBpbiBncm91cC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlXHJcbiAqIEBldmVudCByZW5kZXJHcm91cEVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJHcm91cEVuZGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyZW5kZXJHcm91cEVuZFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJHcm91cEVuZFwiLCB0YXJnZXRzKTtcclxuICogfSk7XHJcbiAqL1xuXG52YXIgR3JvdXBhYmxlID0ge1xyXG4gICAgbmFtZTogXCJncm91cGFibGVcIixcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJkZWZhdWx0R3JvdXBSb3RhdGVcIixcclxuICAgICAgICBcInVzZURlZmF1bHRHcm91cFJvdGF0ZVwiLFxyXG4gICAgICAgIFwiZGVmYXVsdEdyb3VwT3JpZ2luXCIsXHJcbiAgICAgICAgXCJncm91cGFibGVcIixcclxuICAgICAgICBcImdyb3VwYWJsZVByb3BzXCIsXHJcbiAgICAgICAgXCJ0YXJnZXRHcm91cHNcIixcclxuICAgICAgICBcImhpZGVDaGlsZE1vdmVhYmxlRGVmYXVsdExpbmVzXCIsXHJcbiAgICBdLFxyXG4gICAgZXZlbnRzOiBbXSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcclxuICAgICAgICB2YXIgdGFyZ2V0cyA9IHByb3BzLnRhcmdldHMgfHwgW107XHJcbiAgICAgICAgdmFyIF9iID0gbW92ZWFibGUuZ2V0U3RhdGUoKSwgbGVmdCA9IF9iLmxlZnQsIHRvcCA9IF9iLnRvcCwgaXNQZXJzaXN0ZWQgPSBfYi5pc1BlcnNpc3RlZDtcclxuICAgICAgICB2YXIgem9vbSA9IHByb3BzLnpvb20gfHwgMTtcclxuICAgICAgICB2YXIgcmVuZGVyR3JvdXBSZWN0cyA9IG1vdmVhYmxlLnJlbmRlckdyb3VwUmVjdHM7XHJcbiAgICAgICAgdmFyIHBlcnNpc3REYXRDaGlsZHJlbiA9ICgoX2EgPSBwcm9wcy5wZXJzaXN0RGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkcmVuKSB8fCBbXTtcclxuICAgICAgICBpZiAoaXNQZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0cyA9IHBlcnNpc3REYXRDaGlsZHJlbi5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJzaXN0RGF0Q2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmVudFBvc2l0aW9uID0gd2F0Y2hWYWx1ZShtb3ZlYWJsZSwgXCJwYXJlbnRQb3NpdGlvblwiLCBbbGVmdCwgdG9wXSwgZnVuY3Rpb24gKHN0eWxlcykgeyByZXR1cm4gc3R5bGVzLmpvaW4oXCIsXCIpOyB9KTtcclxuICAgICAgICB2YXIgcmVxdWVzdFN0eWxlcyA9IHdhdGNoVmFsdWUobW92ZWFibGUsIFwicmVxdWVzdFN0eWxlc1wiLCBtb3ZlYWJsZS5nZXRSZXF1ZXN0Q2hpbGRTdHlsZXMoKSwgZnVuY3Rpb24gKHN0eWxlcykgeyByZXR1cm4gc3R5bGVzLmpvaW4oXCIsXCIpOyB9KTtcclxuICAgICAgICBtb3ZlYWJsZS5tb3ZlYWJsZXMgPSBtb3ZlYWJsZS5tb3ZlYWJsZXMuc2xpY2UoMCwgdGFyZ2V0cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh0YXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0LCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1vdmVhYmxlTWFuYWdlciwgeyBrZXk6IFwibW92ZWFibGVcIiArIGksIHJlZjogcmVmcyhtb3ZlYWJsZSwgXCJtb3ZlYWJsZXNcIiwgaSksIHRhcmdldDogdGFyZ2V0LCBvcmlnaW46IGZhbHNlLCByZXF1ZXN0U3R5bGVzOiByZXF1ZXN0U3R5bGVzLCBjc3NTdHlsZWQ6IHByb3BzLmNzc1N0eWxlZCwgY3VzdG9tU3R5bGVkTWFwOiBwcm9wcy5jdXN0b21TdHlsZWRNYXAsIHVzZVJlc2l6ZU9ic2VydmVyOiBwcm9wcy51c2VSZXNpemVPYnNlcnZlciwgdXNlTXV0YXRpb25PYnNlcnZlcjogcHJvcHMudXNlTXV0YXRpb25PYnNlcnZlciwgaGlkZUNoaWxkTW92ZWFibGVEZWZhdWx0TGluZXM6IHByb3BzLmhpZGVDaGlsZE1vdmVhYmxlRGVmYXVsdExpbmVzLCBwYXJlbnRNb3ZlYWJsZTogbW92ZWFibGUsIHBhcmVudFBvc2l0aW9uOiBbbGVmdCwgdG9wXSwgcGVyc2lzdERhdGE6IHBlcnNpc3REYXRDaGlsZHJlbltpXSwgem9vbTogem9vbSB9KTtcclxuICAgICAgICB9KSksIGZhbHNlKSwgX19yZWFkKGZsYXQocmVuZGVyR3JvdXBSZWN0cy5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MxID0gX2EucG9zMSwgcG9zMiA9IF9hLnBvczIsIHBvczMgPSBfYS5wb3MzLCBwb3M0ID0gX2EucG9zNDtcclxuICAgICAgICAgICAgdmFyIHBvc2VzID0gW3BvczEsIHBvczIsIHBvczMsIHBvczRdO1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgWzAsIDFdLFxyXG4gICAgICAgICAgICAgICAgWzEsIDNdLFxyXG4gICAgICAgICAgICAgICAgWzMsIDJdLFxyXG4gICAgICAgICAgICAgICAgWzIsIDBdLFxyXG4gICAgICAgICAgICBdLm1hcChmdW5jdGlvbiAoX2EsIGopIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGZyb20gPSBfYlswXSwgdG8gPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJMaW5lKFJlYWN0LCBcIlwiLCBtaW51cyhwb3Nlc1tmcm9tXSwgcGFyZW50UG9zaXRpb24pLCBtaW51cyhwb3Nlc1t0b10sIHBhcmVudFBvc2l0aW9uKSwgem9vbSwgXCJncm91cC1yZWN0LVwiLmNvbmNhdChpLCBcIi1cIikuY29uY2F0KGopKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpKSwgZmFsc2UpO1xyXG4gICAgfSxcclxufTtcblxudmFyIENsaWNrYWJsZSA9IG1ha2VBYmxlKFwiY2xpY2thYmxlXCIsIHtcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJjbGlja2FibGVcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcImNsaWNrXCIsXHJcbiAgICAgICAgXCJjbGlja0dyb3VwXCIsXHJcbiAgICBdLFxyXG4gICAgYWx3YXlzOiB0cnVlLFxyXG4gICAgZHJhZ1JlbGF0aW9uOiBcIndlYWtcIixcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICBlLmRhdGFzLmlucHV0VGFyZ2V0ID0gZS5pbnB1dEV2ZW50ICYmIGUuaW5wdXRFdmVudC50YXJnZXQ7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IG1vdmVhYmxlLnByb3BzLnRhcmdldDtcclxuICAgICAgICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcclxuICAgICAgICB2YXIgaW5wdXRUYXJnZXQgPSBlLmlucHV0VGFyZ2V0O1xyXG4gICAgICAgIHZhciBpc01vdmVhYmxlRWxlbWVudCA9IG1vdmVhYmxlLmlzTW92ZWFibGVFbGVtZW50KGlucHV0VGFyZ2V0KTtcclxuICAgICAgICB2YXIgY29udGFpbnNFbGVtZW50ID0gIWlzTW92ZWFibGVFbGVtZW50ICYmIG1vdmVhYmxlLmNvbnRyb2xCb3guY29udGFpbnMoaW5wdXRUYXJnZXQpO1xyXG4gICAgICAgIGlmICghaW5wdXRFdmVudCB8fCAhaW5wdXRUYXJnZXQgfHwgZS5pc0RyYWdcclxuICAgICAgICAgICAgfHwgbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoaW5wdXRUYXJnZXQpXHJcbiAgICAgICAgICAgIHx8IGNvbnRhaW5zRWxlbWVudFxyXG4gICAgICAgIC8vIEV4dGVybmFsIGV2ZW50IGR1cGxpY2F0ZSB0YXJnZXQgb3IgZHJhZ0FyZWFFbGVtZW50XHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRhaW5zVGFyZ2V0ID0gdGFyZ2V0LmNvbnRhaW5zKGlucHV0VGFyZ2V0KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlja1wiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIGlzRG91YmxlOiBlLmlzRG91YmxlLFxyXG4gICAgICAgICAgICBpbnB1dFRhcmdldDogaW5wdXRUYXJnZXQsXHJcbiAgICAgICAgICAgIGlzVGFyZ2V0OiB0YXJnZXQgPT09IGlucHV0VGFyZ2V0LFxyXG4gICAgICAgICAgICBtb3ZlYWJsZVRhcmdldDogbW92ZWFibGUucHJvcHMudGFyZ2V0LFxyXG4gICAgICAgICAgICBjb250YWluc1RhcmdldDogY29udGFpbnNUYXJnZXQsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XHJcbiAgICAgICAgdmFyIGlucHV0VGFyZ2V0ID0gZS5pbnB1dFRhcmdldDtcclxuICAgICAgICBpZiAoIWlucHV0RXZlbnQgfHwgIWlucHV0VGFyZ2V0IHx8IGUuaXNEcmFnXHJcbiAgICAgICAgICAgIHx8IG1vdmVhYmxlLmlzTW92ZWFibGVFbGVtZW50KGlucHV0VGFyZ2V0KVxyXG4gICAgICAgICAgICAvLyBFeHRlcm5hbCBldmVudCBkdXBsaWNhdGUgdGFyZ2V0IG9yIGRyYWdBcmVhRWxlbWVudFxyXG4gICAgICAgICAgICB8fCBlLmRhdGFzLmlucHV0VGFyZ2V0ID09PSBpbnB1dFRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0YXJnZXRzID0gbW92ZWFibGUucHJvcHMudGFyZ2V0cztcclxuICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSB0YXJnZXRzLmluZGV4T2YoaW5wdXRUYXJnZXQpO1xyXG4gICAgICAgIHZhciBpc1RhcmdldCA9IHRhcmdldEluZGV4ID4gLTE7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5zVGFyZ2V0ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICB0YXJnZXRJbmRleCA9IGZpbmRJbmRleCh0YXJnZXRzLCBmdW5jdGlvbiAocGFyZW50VGFyZ2V0KSB7IHJldHVybiBwYXJlbnRUYXJnZXQuY29udGFpbnMoaW5wdXRUYXJnZXQpOyB9KTtcclxuICAgICAgICAgICAgY29udGFpbnNUYXJnZXQgPSB0YXJnZXRJbmRleCA+IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlja0dyb3VwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgaXNEb3VibGU6IGUuaXNEb3VibGUsXHJcbiAgICAgICAgICAgIHRhcmdldHM6IHRhcmdldHMsXHJcbiAgICAgICAgICAgIGlucHV0VGFyZ2V0OiBpbnB1dFRhcmdldCxcclxuICAgICAgICAgICAgdGFyZ2V0SW5kZXg6IHRhcmdldEluZGV4LFxyXG4gICAgICAgICAgICBpc1RhcmdldDogaXNUYXJnZXQsXHJcbiAgICAgICAgICAgIGNvbnRhaW5zVGFyZ2V0OiBjb250YWluc1RhcmdldCxcclxuICAgICAgICAgICAgbW92ZWFibGVUYXJnZXQ6IHRhcmdldHNbdGFyZ2V0SW5kZXhdLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxufSk7XHJcbi8qKlxyXG4gKiBXaGVuIHlvdSBjbGljayBvbiB0aGUgZWxlbWVudCwgdGhlIGBjbGlja2AgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcclxuICogQGV2ZW50IGNsaWNrXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuT25DbGlja30gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaWNrYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImNsaWNrXCIsICh7IGhhc1RhcmdldCwgY29udGFpbnNUYXJnZXQsIHRhcmdldEluZGV4IH0pID0+IHtcclxuICogICAgIC8vIElmIHlvdSBjbGljayBvbiBhbiBlbGVtZW50IG90aGVyIHRoYW4gdGhlIHRhcmdldCBhbmQgbm90IGluY2x1ZGVkIGluIHRoZSB0YXJnZXQsIGluZGV4IGlzIC0xLlxyXG4gKiAgICAgY29uc29sZS5sb2coXCJvbkNsaWNrR3JvdXBcIiwgdGFyZ2V0LCBoYXNUYXJnZXQsIGNvbnRhaW5zVGFyZ2V0LCB0YXJnZXRJbmRleCk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4geW91IGNsaWNrIG9uIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgZ3JvdXAsIHRoZSBgY2xpY2tHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcclxuICogQGV2ZW50IGNsaWNrR3JvdXBcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5PbkNsaWNrR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBjbGlja0dyb3VwYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImNsaWNrR3JvdXBcIiwgKHsgaW5wdXRUYXJnZXQsIGlzVGFyZ2V0LCBjb250YWluc1RhcmdldCwgdGFyZ2V0SW5kZXggfSkgPT4ge1xyXG4gKiAgICAgLy8gSWYgeW91IGNsaWNrIG9uIGFuIGVsZW1lbnQgb3RoZXIgdGhhbiB0aGUgdGFyZ2V0IGFuZCBub3QgaW5jbHVkZWQgaW4gdGhlIHRhcmdldCwgaW5kZXggaXMgLTEuXHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uQ2xpY2tHcm91cFwiLCBpbnB1dFRhcmdldCwgaXNUYXJnZXQsIGNvbnRhaW5zVGFyZ2V0LCB0YXJnZXRJbmRleCk7XHJcbiAqIH0pO1xyXG4gKi9cblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlRXZlbnQoZSkge1xyXG4gICAgdmFyIGRhdGFzID0gZS5vcmlnaW5hbERhdGFzLmRyYWdnYWJsZTtcclxuICAgIGlmICghZGF0YXMpIHtcclxuICAgICAgICBlLm9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlID0ge307XHJcbiAgICAgICAgZGF0YXMgPSBlLm9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBkYXRhczogZGF0YXMgfSk7XHJcbn1cclxudmFyIGVkZ2VEcmFnZ2FibGUgPSBtYWtlQWJsZShcImVkZ2VEcmFnZ2FibGVcIiwge1xyXG4gICAgY3NzOiBbXHJcbiAgICAgICAgXCIuZWRnZS5lZGdlRHJhZ2dhYmxlLmxpbmUge1xcbmN1cnNvcjogbW92ZTtcXG59XCIsXHJcbiAgICBdLFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICAgICAgdmFyIGVkZ2UgPSBwcm9wcy5lZGdlRHJhZ2dhYmxlO1xyXG4gICAgICAgIGlmICghZWRnZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJFZGdlTGluZXMoUmVhY3QsIFwiZWRnZURyYWdnYWJsZVwiLCBlZGdlLCBtb3ZlYWJsZS5nZXRTdGF0ZSgpLnJlbmRlclBvc2VzLCBwcm9wcy56b29tKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IChfYSA9IGUuaW5wdXRFdmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhcmdldDtcclxuICAgICAgICBpZiAoIXByb3BzLmVkZ2VEcmFnZ2FibGUgfHwgIXRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhcHJvcHMuZHJhZ2dhYmxlXHJcbiAgICAgICAgICAgICYmIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwiZGlyZWN0aW9uXCIpKVxyXG4gICAgICAgICAgICAmJiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcImVkZ2VcIikpXHJcbiAgICAgICAgICAgICYmIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwiZWRnZURyYWdnYWJsZVwiKSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdTdGFydChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWc6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiBEcmFnZ2FibGUuZHJhZyhtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiBEcmFnZ2FibGUuZHJhZ0VuZChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSAoX2EgPSBlLmlucHV0RXZlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50YXJnZXQ7XHJcbiAgICAgICAgaWYgKCFwcm9wcy5lZGdlRHJhZ2dhYmxlIHx8ICF0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gIXByb3BzLmRyYWdnYWJsZSAmJiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcImRpcmVjdGlvblwiKSkgJiYgaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJsaW5lXCIpKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIERyYWdnYWJsZS5kcmFnR3JvdXBTdGFydChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIERyYWdnYWJsZS5kcmFnR3JvdXAobW92ZWFibGUsIGdldERyYWdnYWJsZUV2ZW50KGUpKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiBEcmFnZ2FibGUuZHJhZ0dyb3VwRW5kKG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XHJcbiAgICB9LFxyXG4gICAgdW5zZXQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHJldHVybiBEcmFnZ2FibGUudW5zZXQobW92ZWFibGUpO1xyXG4gICAgfSxcclxufSk7XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRvIG1vdmUgYnkgZHJhZ2dpbmcgdGhlIGVkZ2UgbGluZSAoZGVmYXVsdDogZmFsc2UpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLkRyYWdnYWJsZSNlZGdlRHJhZ2dhYmxlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gKiAgZWRnZURyYWdnYWJsZTogZmFsc2UsXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5lZGdlRHJhZ2dhYmxlID0gdHJ1ZTtcclxuICovXG5cbnZhciBJbmRpdmlkdWFsR3JvdXBhYmxlID0ge1xyXG4gICAgbmFtZTogXCJpbmRpdmlkdWFsR3JvdXBhYmxlXCIsXHJcbiAgICBwcm9wczogW1xyXG4gICAgICAgIFwiaW5kaXZpZHVhbEdyb3VwYWJsZVwiLFxyXG4gICAgICAgIFwiaW5kaXZpZHVhbEdyb3VwYWJsZVByb3BzXCIsXHJcbiAgICBdLFxyXG4gICAgZXZlbnRzOiBbXSxcclxufTtcblxudmFyIE1PVkVBQkxFX0FCTEVTID0gIFtcclxuICAgIEJlZm9yZVJlbmRlcmFibGUsXHJcbiAgICBEZWZhdWx0LCBTbmFwcGFibGUsIFBpbmNoYWJsZSxcclxuICAgIERyYWdnYWJsZSwgZWRnZURyYWdnYWJsZSxcclxuICAgIFJlc2l6YWJsZSwgU2NhbGFibGUsIFdhcnBhYmxlLCBSb3RhdGFibGUsXHJcbiAgICBTY3JvbGxhYmxlLCBQYWRkaW5nLCBPcmlnaW4sXHJcbiAgICBPcmlnaW5EcmFnZ2FibGUsXHJcbiAgICBDbGlwcGFibGUsIFJvdW5kYWJsZSwgR3JvdXBhYmxlLCBJbmRpdmlkdWFsR3JvdXBhYmxlLFxyXG4gICAgQ2xpY2thYmxlLFxyXG4gICAgRHJhZ0FyZWEsXHJcbiAgICBSZW5kZXJhYmxlLFxyXG5dO1xyXG52YXIgTU9WRUFCTEVfRVZFTlRTID0gLyojX19QVVJFX18qLyBNT1ZFQUJMRV9BQkxFUy5yZWR1Y2UoZnVuY3Rpb24gKGN1cnJlbnQsIGFibGUpIHtcclxuICAgIChhYmxlLmV2ZW50cyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHB1c2hTZXQoY3VycmVudCwgbmFtZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjdXJyZW50O1xyXG59LCBbXSk7XHJcbnZhciBNT1ZFQUJMRV9QUk9QUyA9IC8qI19fUFVSRV9fKi8gTU9WRUFCTEVfQUJMRVMucmVkdWNlKGZ1bmN0aW9uIChjdXJyZW50LCBhYmxlKSB7XHJcbiAgICAoYWJsZS5wcm9wcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHB1c2hTZXQoY3VycmVudCwgbmFtZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjdXJyZW50O1xyXG59LCBbXSk7XG5cbmZ1bmN0aW9uIHNvbHZlQ29uc3RhbnRzRGlzdGFuY2UoX2EsIHBvcykge1xyXG4gICAgdmFyIF9iID0gX19yZWFkKF9hLCAzKSwgYSA9IF9iWzBdLCBiID0gX2JbMV0sIGMgPSBfYlsyXTtcclxuICAgIHJldHVybiAoYSAqIHBvc1swXSArIGIgKiBwb3NbMV0gKyBjKSAvIE1hdGguc3FydChhICogYSArIGIgKiBiKTtcclxufVxyXG5mdW5jdGlvbiBzb2x2ZUMoX2EsIHBvcykge1xyXG4gICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgYSA9IF9iWzBdLCBiID0gX2JbMV07XHJcbiAgICAvLyBheCArIGJ5ICsgYyA9IDBcclxuICAgIC8vIC1heCAtYnk7XHJcbiAgICByZXR1cm4gLWEgKiBwb3NbMF0gLSBiICogcG9zWzFdO1xyXG59XG5cbmZ1bmN0aW9uIGdldE1heFBvcyhwb3NlcywgaW5kZXgpIHtcclxuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocG9zZXMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgNCksIHBvczEgPSBfYlswXSwgcG9zMiA9IF9iWzFdLCBwb3MzID0gX2JbMl0sIHBvczQgPSBfYlszXTtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgocG9zMVtpbmRleF0sIHBvczJbaW5kZXhdLCBwb3MzW2luZGV4XSwgcG9zNFtpbmRleF0pO1xyXG4gICAgfSkpLCBmYWxzZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1pblBvcyhwb3NlcywgaW5kZXgpIHtcclxuICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocG9zZXMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgNCksIHBvczEgPSBfYlswXSwgcG9zMiA9IF9iWzFdLCBwb3MzID0gX2JbMl0sIHBvczQgPSBfYlszXTtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4ocG9zMVtpbmRleF0sIHBvczJbaW5kZXhdLCBwb3MzW2luZGV4XSwgcG9zNFtpbmRleF0pO1xyXG4gICAgfSkpLCBmYWxzZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEdyb3VwUmVjdChwYXJlbnRQb3Nlcywgcm90YXRpb24pIHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgdmFyIHBvczEgPSBbMCwgMF07XHJcbiAgICB2YXIgcG9zMiA9IFswLCAwXTtcclxuICAgIHZhciBwb3MzID0gWzAsIDBdO1xyXG4gICAgdmFyIHBvczQgPSBbMCwgMF07XHJcbiAgICB2YXIgd2lkdGggPSAwO1xyXG4gICAgdmFyIGhlaWdodCA9IDA7XHJcbiAgICBpZiAoIXBhcmVudFBvc2VzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBvczE6IHBvczEsXHJcbiAgICAgICAgICAgIHBvczI6IHBvczIsXHJcbiAgICAgICAgICAgIHBvczM6IHBvczMsXHJcbiAgICAgICAgICAgIHBvczQ6IHBvczQsXHJcbiAgICAgICAgICAgIG1pblg6IDAsXHJcbiAgICAgICAgICAgIG1pblk6IDAsXHJcbiAgICAgICAgICAgIG1heFg6IDAsXHJcbiAgICAgICAgICAgIG1heFk6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGZpeGVkUm90YXRpb24gPSB0aHJvdHRsZShyb3RhdGlvbiwgVElOWV9OVU0pO1xyXG4gICAgaWYgKGZpeGVkUm90YXRpb24gJSA5MCkge1xyXG4gICAgICAgIHZhciByYWQgPSBmaXhlZFJvdGF0aW9uIC8gMTgwICogTWF0aC5QSTtcclxuICAgICAgICB2YXIgYTFfMSA9IE1hdGgudGFuKHJhZCk7XHJcbiAgICAgICAgdmFyIGEyXzEgPSAtMSAvIGExXzE7XHJcbiAgICAgICAgLy8gYXggPSB5ICAvLyAtYXggKyB5ID0gMCAvLyAwID0+IDFcclxuICAgICAgICAvLyAtYXggPSB5IC8vIGF4ICsgeSA9IDAgIC8vIDAgPT4gM1xyXG4gICAgICAgIHZhciBhMU1pbk1heF8xID0gW01BWF9OVU0sIE1JTl9OVU1dO1xyXG4gICAgICAgIHZhciBhMU1pbk1heFBvc18xID0gW1swLCAwXSwgWzAsIDBdXTtcclxuICAgICAgICB2YXIgYTJNaW5NYXhfMSA9IFtNQVhfTlVNLCBNSU5fTlVNXTtcclxuICAgICAgICB2YXIgYTJNaW5NYXhQb3NfMSA9IFtbMCwgMF0sIFswLCAwXV07XHJcbiAgICAgICAgcGFyZW50UG9zZXMuZm9yRWFjaChmdW5jdGlvbiAocG9zZXMpIHtcclxuICAgICAgICAgICAgcG9zZXMuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBiMSA9IHBvc1sxXSAtIGExICogcG9zWzBdO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgYjIgPSBwb3NbMV0gLSBhMiAqIHBvc1swXTtcclxuICAgICAgICAgICAgICAgIHZhciBhMURpc3QgPSBzb2x2ZUNvbnN0YW50c0Rpc3RhbmNlKFstYTFfMSwgMSwgMF0sIHBvcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYTJEaXN0ID0gc29sdmVDb25zdGFudHNEaXN0YW5jZShbLWEyXzEsIDEsIDBdLCBwb3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGExTWluTWF4XzFbMF0gPiBhMURpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBhMU1pbk1heFBvc18xWzBdID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIGExTWluTWF4XzFbMF0gPSBhMURpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYTFNaW5NYXhfMVsxXSA8IGExRGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGExTWluTWF4UG9zXzFbMV0gPSBwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgYTFNaW5NYXhfMVsxXSA9IGExRGlzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhMk1pbk1heF8xWzBdID4gYTJEaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYTJNaW5NYXhQb3NfMVswXSA9IHBvcztcclxuICAgICAgICAgICAgICAgICAgICBhMk1pbk1heF8xWzBdID0gYTJEaXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGEyTWluTWF4XzFbMV0gPCBhMkRpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBhMk1pbk1heFBvc18xWzFdID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIGEyTWluTWF4XzFbMV0gPSBhMkRpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBfZCA9IF9fcmVhZChhMU1pbk1heFBvc18xLCAyKSwgYTFNaW5Qb3MgPSBfZFswXSwgYTFNYXhQb3MgPSBfZFsxXTtcclxuICAgICAgICB2YXIgX2UgPSBfX3JlYWQoYTJNaW5NYXhQb3NfMSwgMiksIGEyTWluUG9zID0gX2VbMF0sIGEyTWF4UG9zID0gX2VbMV07XHJcbiAgICAgICAgdmFyIG1pbkhvcml6b250YWxMaW5lID0gWy1hMV8xLCAxLCBzb2x2ZUMoWy1hMV8xLCAxXSwgYTFNaW5Qb3MpXTtcclxuICAgICAgICB2YXIgbWF4SG9yaXpvbnRhbExpbmUgPSBbLWExXzEsIDEsIHNvbHZlQyhbLWExXzEsIDFdLCBhMU1heFBvcyldO1xyXG4gICAgICAgIHZhciBtaW5WZXJ0aWNhbExpbmUgPSBbLWEyXzEsIDEsIHNvbHZlQyhbLWEyXzEsIDFdLCBhMk1pblBvcyldO1xyXG4gICAgICAgIHZhciBtYXhWZXJ0aWNhbExpbmUgPSBbLWEyXzEsIDEsIHNvbHZlQyhbLWEyXzEsIDFdLCBhMk1heFBvcyldO1xyXG4gICAgICAgIF9hID0gX19yZWFkKFtcclxuICAgICAgICAgICAgW21pbkhvcml6b250YWxMaW5lLCBtaW5WZXJ0aWNhbExpbmVdLFxyXG4gICAgICAgICAgICBbbWluSG9yaXpvbnRhbExpbmUsIG1heFZlcnRpY2FsTGluZV0sXHJcbiAgICAgICAgICAgIFttYXhIb3Jpem9udGFsTGluZSwgbWluVmVydGljYWxMaW5lXSxcclxuICAgICAgICAgICAgW21heEhvcml6b250YWxMaW5lLCBtYXhWZXJ0aWNhbExpbmVdLFxyXG4gICAgICAgIF0ubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBsaW5lMSA9IF9iWzBdLCBsaW5lMiA9IF9iWzFdO1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uUG9pbnRzQnlDb25zdGFudHMobGluZTEsIGxpbmUyKVswXTtcclxuICAgICAgICB9KSwgNCksIHBvczEgPSBfYVswXSwgcG9zMiA9IF9hWzFdLCBwb3MzID0gX2FbMl0sIHBvczQgPSBfYVszXTtcclxuICAgICAgICB3aWR0aCA9IGEyTWluTWF4XzFbMV0gLSBhMk1pbk1heF8xWzBdO1xyXG4gICAgICAgIGhlaWdodCA9IGExTWluTWF4XzFbMV0gLSBhMU1pbk1heF8xWzBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIG1pblhfMSA9IGdldE1pblBvcyhwYXJlbnRQb3NlcywgMCk7XHJcbiAgICAgICAgdmFyIG1pbllfMSA9IGdldE1pblBvcyhwYXJlbnRQb3NlcywgMSk7XHJcbiAgICAgICAgdmFyIG1heFhfMSA9IGdldE1heFBvcyhwYXJlbnRQb3NlcywgMCk7XHJcbiAgICAgICAgdmFyIG1heFlfMSA9IGdldE1heFBvcyhwYXJlbnRQb3NlcywgMSk7XHJcbiAgICAgICAgcG9zMSA9IFttaW5YXzEsIG1pbllfMV07XHJcbiAgICAgICAgcG9zMiA9IFttYXhYXzEsIG1pbllfMV07XHJcbiAgICAgICAgcG9zMyA9IFttaW5YXzEsIG1heFlfMV07XHJcbiAgICAgICAgcG9zNCA9IFttYXhYXzEsIG1heFlfMV07XHJcbiAgICAgICAgd2lkdGggPSBtYXhYXzEgLSBtaW5YXzE7XHJcbiAgICAgICAgaGVpZ2h0ID0gbWF4WV8xIC0gbWluWV8xO1xyXG4gICAgICAgIGlmIChmaXhlZFJvdGF0aW9uICUgMTgwKSB7XHJcbiAgICAgICAgICAgIC8vIDBcclxuICAgICAgICAgICAgLy8gMSAyXHJcbiAgICAgICAgICAgIC8vIDMgNFxyXG4gICAgICAgICAgICAvLyA5MFxyXG4gICAgICAgICAgICAvLyAzIDFcclxuICAgICAgICAgICAgLy8gNCAyXHJcbiAgICAgICAgICAgIC8vIDE4MFxyXG4gICAgICAgICAgICAvLyA0IDNcclxuICAgICAgICAgICAgLy8gMiAxXHJcbiAgICAgICAgICAgIC8vIDI3MFxyXG4gICAgICAgICAgICAvLyAyIDRcclxuICAgICAgICAgICAgLy8gMSAzXHJcbiAgICAgICAgICAgIC8vIDEsIDIsIDMsNCA9IDMgMSA0IDJcclxuICAgICAgICAgICAgdmFyIGNoYW5nZWRYID0gW3BvczMsIHBvczEsIHBvczQsIHBvczJdO1xyXG4gICAgICAgICAgICBfYiA9IF9fcmVhZChjaGFuZ2VkWCwgNCksIHBvczEgPSBfYlswXSwgcG9zMiA9IF9iWzFdLCBwb3MzID0gX2JbMl0sIHBvczQgPSBfYlszXTtcclxuICAgICAgICAgICAgd2lkdGggPSBtYXhZXzEgLSBtaW5ZXzE7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IG1heFhfMSAtIG1pblhfMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZml4ZWRSb3RhdGlvbiAlIDM2MCA+IDE4MCkge1xyXG4gICAgICAgIC8vIDEgMiAgIDQgM1xyXG4gICAgICAgIC8vIDMgNCAgIDIgMVxyXG4gICAgICAgIHZhciBjaGFuZ2VkWCA9IFtwb3M0LCBwb3MzLCBwb3MyLCBwb3MxXTtcclxuICAgICAgICBfYyA9IF9fcmVhZChjaGFuZ2VkWCwgNCksIHBvczEgPSBfY1swXSwgcG9zMiA9IF9jWzFdLCBwb3MzID0gX2NbMl0sIHBvczQgPSBfY1szXTtcclxuICAgIH1cclxuICAgIHZhciBfZiA9IGdldE1pbk1heHMoW3BvczEsIHBvczIsIHBvczMsIHBvczRdKSwgbWluWCA9IF9mLm1pblgsIG1pblkgPSBfZi5taW5ZLCBtYXhYID0gX2YubWF4WCwgbWF4WSA9IF9mLm1heFk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBvczE6IHBvczEsXHJcbiAgICAgICAgcG9zMjogcG9zMixcclxuICAgICAgICBwb3MzOiBwb3MzLFxyXG4gICAgICAgIHBvczQ6IHBvczQsXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIG1pblg6IG1pblgsXHJcbiAgICAgICAgbWluWTogbWluWSxcclxuICAgICAgICBtYXhYOiBtYXhYLFxyXG4gICAgICAgIG1heFk6IG1heFksXHJcbiAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmaW5kTW92ZWFibGVHcm91cHMobW92ZWFibGVzLCBjaGlsZFRhcmdldEdyb3Vwcykge1xyXG4gICAgdmFyIGdyb3VwcyA9IGNoaWxkVGFyZ2V0R3JvdXBzLm1hcChmdW5jdGlvbiAodGFyZ2V0R3JvdXApIHtcclxuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXRHcm91cCkpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTW92ZWFibGVHcm91cHMgPSBmaW5kTW92ZWFibGVHcm91cHMobW92ZWFibGVzLCB0YXJnZXRHcm91cCk7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IGNoaWxkTW92ZWFibGVHcm91cHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAobGVuZ3RoXzEgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRNb3ZlYWJsZUdyb3VwcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGhfMSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTW92ZWFibGVHcm91cHNbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGNoZWNrZWQgPSBmaW5kKG1vdmVhYmxlcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFuYWdlciA9IF9hLm1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlci5wcm9wcy50YXJnZXQgPT09IHRhcmdldEdyb3VwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrZWQuZmluZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja2VkLm1hbmFnZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgaWYgKGdyb3Vwcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShncm91cHNbMF0pKSB7XHJcbiAgICAgICAgcmV0dXJuIGdyb3Vwc1swXTtcclxuICAgIH1cclxuICAgIHJldHVybiBncm91cHM7XHJcbn1cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuR3JvdXBcclxuICogQGRlc2NyaXB0aW9uIFlvdSBjYW4gbWFrZSB0YXJnZXRzIG1vdmVhYmxlLlxyXG4gKi9cclxudmFyIE1vdmVhYmxlR3JvdXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTW92ZWFibGVHcm91cCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1vdmVhYmxlR3JvdXAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGlmZmVyID0gbmV3IENoaWxkcmVuRGlmZmVyKCk7XHJcbiAgICAgICAgX3RoaXMubW92ZWFibGVzID0gW107XHJcbiAgICAgICAgX3RoaXMudHJhbnNmb3JtT3JpZ2luID0gXCI1MCUgNTAlXCI7XHJcbiAgICAgICAgX3RoaXMucmVuZGVyR3JvdXBSZWN0cyA9IFtdO1xyXG4gICAgICAgIF90aGlzLl90YXJnZXRHcm91cHMgPSBbXTtcclxuICAgICAgICBfdGhpcy5faGFzRmlyc3RUYXJnZXRzID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTW92ZWFibGVHcm91cC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlR3JvdXAucHJvdG90eXBlLmNoZWNrVXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2lzUHJvcFRhcmdldENoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFibGVzKCk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVHcm91cC5wcm90b3R5cGUuZ2V0VGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy50YXJnZXRzO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlR3JvdXAucHJvdG90eXBlLnVwZGF0ZVJlY3QgPSBmdW5jdGlvbiAodHlwZSwgaXNUYXJnZXQsIGlzU2V0U3RhdGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKGlzU2V0U3RhdGUgPT09IHZvaWQgMCkgeyBpc1NldFN0YXRlID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xCb3ggfHwgc3RhdGUuaXNQZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRTdG9yZUNhY2hlKHRydWUpO1xyXG4gICAgICAgIHRoaXMubW92ZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QodHlwZSwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciBtb3ZlYWJsZXMgPSB0aGlzLm1vdmVhYmxlcztcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0IHx8IHByb3BzLnRhcmdldDtcclxuICAgICAgICB2YXIgY2hlY2tlZHMgPSBtb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChtb3ZlYWJsZSkgeyByZXR1cm4gKHsgZmluZGVkOiBmYWxzZSwgbWFuYWdlcjogbW92ZWFibGUgfSk7IH0pO1xyXG4gICAgICAgIHZhciB0YXJnZXRHcm91cHMgPSB0aGlzLnByb3BzLnRhcmdldEdyb3VwcyB8fCBbXTtcclxuICAgICAgICB2YXIgbW92ZWFibGVHcm91cHMgPSBmaW5kTW92ZWFibGVHcm91cHMoY2hlY2tlZHMsIHRhcmdldEdyb3Vwcyk7XHJcbiAgICAgICAgdmFyIHVzZURlZmF1bHRHcm91cFJvdGF0ZSA9IHByb3BzLnVzZURlZmF1bHRHcm91cFJvdGF0ZTtcclxuICAgICAgICBtb3ZlYWJsZUdyb3Vwcy5wdXNoLmFwcGx5KG1vdmVhYmxlR3JvdXBzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoY2hlY2tlZHMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgZmluZGVkID0gX2EuZmluZGVkO1xyXG4gICAgICAgICAgICByZXR1cm4gIWZpbmRlZDtcclxuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBtYW5hZ2VyID0gX2EubWFuYWdlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXI7XHJcbiAgICAgICAgfSkpLCBmYWxzZSkpO1xyXG4gICAgICAgIHZhciByZW5kZXJHcm91cFJlY3RzID0gW107XHJcbiAgICAgICAgdmFyIGlzUmVzZXQgPSAhaXNUYXJnZXQgfHwgKHR5cGUgIT09IFwiXCIgJiYgcHJvcHMudXBkYXRlR3JvdXApO1xyXG4gICAgICAgIHZhciBkZWZhdWx0R3JvdXBSb3RhdGUgPSBwcm9wcy5kZWZhdWx0R3JvdXBSb3RhdGUgfHwgMDtcclxuICAgICAgICBpZiAoIXRoaXMuX2hhc0ZpcnN0VGFyZ2V0cykge1xyXG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVkUm9hdGF0aW9uID0gKF9hID0gcHJvcHMucGVyc2lzdERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgaWYgKHBlcnNpc3RlZFJvYXRhdGlvbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0R3JvdXBSb3RhdGUgPSBwZXJzaXN0ZWRSb2F0YXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0TW92ZWFibGVHcm91cFJlY3QoZ3JvdXAsIHBhcmVudFJvdGF0aW9uLCBpc1Jvb3QpIHtcclxuICAgICAgICAgICAgdmFyIHBvc2VzUm90YXRpb25zID0gZ3JvdXAubWFwKGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkobW92ZWFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBnZXRNb3ZlYWJsZUdyb3VwUmVjdChtb3ZlYWJsZSwgcGFyZW50Um90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NlcyA9IFtyZWN0LnBvczEsIHJlY3QucG9zMiwgcmVjdC5wb3MzLCByZWN0LnBvczRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckdyb3VwUmVjdHMucHVzaChyZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwb3NlczogcG9zZXMsIHJvdGF0aW9uOiByZWN0LnJvdGF0aW9uIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NlczogZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUobW92ZWFibGUuc3RhdGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogbW92ZWFibGUuZ2V0Um90YXRpb24oKSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHJvdGF0aW9ucyA9IHBvc2VzUm90YXRpb25zLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IF9hLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdGF0aW9uO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwUm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RSb3RhdGlvbiA9IHJvdGF0aW9uc1swXTtcclxuICAgICAgICAgICAgdmFyIGlzU2FtZVJvdGF0aW9uID0gcm90YXRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChuZXh0Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhmaXJzdFJvdGF0aW9uIC0gbmV4dFJvdGF0aW9uKSA8IDAuMTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBncm91cFJvdGF0aW9uID0gIXVzZURlZmF1bHRHcm91cFJvdGF0ZSAmJiBpc1NhbWVSb3RhdGlvbiA/IGZpcnN0Um90YXRpb24gOiBkZWZhdWx0R3JvdXBSb3RhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBncm91cFJvdGF0aW9uID0gIXVzZURlZmF1bHRHcm91cFJvdGF0ZSAmJiAhaXNSb290ICYmIGlzU2FtZVJvdGF0aW9uID8gZmlyc3RSb3RhdGlvbiA6IHBhcmVudFJvdGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBncm91cFBvc2VzID0gcG9zZXNSb3RhdGlvbnMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2VzID0gX2EucG9zZXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zZXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBSZWN0ID0gZ2V0R3JvdXBSZWN0KGdyb3VwUG9zZXMsIGdyb3VwUm90YXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBSZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcm9vdEdyb3VwUmVjdCA9IGdldE1vdmVhYmxlR3JvdXBSZWN0KG1vdmVhYmxlR3JvdXBzLCB0aGlzLnJvdGF0aW9uLCB0cnVlKTtcclxuICAgICAgICBpZiAoaXNSZXNldCkge1xyXG4gICAgICAgICAgICAvLyByZXNldCByb3RhdGFpb25cclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJvb3RHcm91cFJlY3Qucm90YXRpb247XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtT3JpZ2luID0gcHJvcHMuZGVmYXVsdEdyb3VwT3JpZ2luIHx8IFwiNTAlIDUwJVwiO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gWzEsIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90YXJnZXRHcm91cHMgPSB0YXJnZXRHcm91cHM7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJHcm91cFJlY3RzID0gcmVuZGVyR3JvdXBSZWN0cztcclxuICAgICAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gdGhpcy50cmFuc2Zvcm1PcmlnaW47XHJcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJvb3RHcm91cFJlY3Qud2lkdGgsIGhlaWdodCA9IHJvb3RHcm91cFJlY3QuaGVpZ2h0LCBtaW5YID0gcm9vdEdyb3VwUmVjdC5taW5YLCBtaW5ZID0gcm9vdEdyb3VwUmVjdC5taW5ZO1xyXG4gICAgICAgIHZhciBwb3Nlc0luZm8gPSByb3RhdGVQb3Nlc0luZm8oW1xyXG4gICAgICAgICAgICBbMCwgMF0sXHJcbiAgICAgICAgICAgIFt3aWR0aCwgMF0sXHJcbiAgICAgICAgICAgIFswLCBoZWlnaHRdLFxyXG4gICAgICAgICAgICBbd2lkdGgsIGhlaWdodF0sXHJcbiAgICAgICAgXSwgY29udmVydFRyYW5zZm9ybU9yaWdpbkFycmF5KHRyYW5zZm9ybU9yaWdpbiwgd2lkdGgsIGhlaWdodCksIHRoaXMucm90YXRpb24gLyAxODAgKiBNYXRoLlBJKTtcclxuICAgICAgICB2YXIgX2IgPSBnZXRNaW5NYXhzKHBvc2VzSW5mby5yZXN1bHQpLCBkZWx0YVggPSBfYi5taW5YLCBkZWx0YVkgPSBfYi5taW5ZO1xyXG4gICAgICAgIHZhciByb3RhdGVTY2FsZSA9IFwiIHJvdGF0ZShcIi5jb25jYXQocm90YXRpb24sIFwiZGVnKVwiKVxyXG4gICAgICAgICAgICArIFwiIHNjYWxlKFwiLmNvbmNhdChzaWduKHNjYWxlWzBdKSwgXCIsIFwiKS5jb25jYXQoc2lnbihzY2FsZVsxXSksIFwiKVwiKTtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KC1kZWx0YVgsIFwicHgsIFwiKS5jb25jYXQoLWRlbHRhWSwgXCJweClcIikuY29uY2F0KHJvdGF0ZVNjYWxlKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xCb3guc3R5bGUudHJhbnNmb3JtXHJcbiAgICAgICAgICAgID0gXCJ0cmFuc2xhdGUzZChcIi5jb25jYXQobWluWCwgXCJweCwgXCIpLmNvbmNhdChtaW5ZLCBcInB4LCBcIikuY29uY2F0KHRoaXMucHJvcHMudHJhbnNsYXRlWiB8fCAwLCBcIilcIik7XHJcbiAgICAgICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gXCJsZWZ0OjBweDt0b3A6MHB4O1wiXHJcbiAgICAgICAgICAgICsgXCJ0cmFuc2Zvcm0tb3JpZ2luOlwiLmNvbmNhdCh0cmFuc2Zvcm1PcmlnaW4sIFwiO1wiKVxyXG4gICAgICAgICAgICArIFwid2lkdGg6XCIuY29uY2F0KHdpZHRoLCBcInB4O2hlaWdodDpcIikuY29uY2F0KGhlaWdodCwgXCJweDtcIilcclxuICAgICAgICAgICAgKyBcInRyYW5zZm9ybTogXCIuY29uY2F0KHRyYW5zZm9ybSk7XHJcbiAgICAgICAgc3RhdGUud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBzdGF0ZS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XHJcbiAgICAgICAgdmFyIGluZm8gPSBnZXRNb3ZlYWJsZVRhcmdldEluZm8odGhpcy5jb250cm9sQm94LCB0YXJnZXQsIHRoaXMuY29udHJvbEJveCwgdGhpcy5nZXRDb250YWluZXIoKSwgdGhpcy5fcm9vdENvbnRhaW5lciB8fCBjb250YWluZXIsIFtdKTtcclxuICAgICAgICB2YXIgcG9zID0gW2luZm8ubGVmdCwgaW5mby50b3BdO1xyXG4gICAgICAgIHZhciBfYyA9IF9fcmVhZChnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShpbmZvKSwgNCksIHBvczEgPSBfY1swXSwgcG9zMiA9IF9jWzFdLCBwb3MzID0gX2NbMl0sIHBvczQgPSBfY1szXTsgLy8gaW5mby5sZWZ0ICsgaW5mby5wb3MoMSB+IDQpXHJcbiAgICAgICAgdmFyIG1pblBvcyA9IGdldE1pbk1heHMoW3BvczEsIHBvczIsIHBvczMsIHBvczRdKTtcclxuICAgICAgICB2YXIgZGVsdGEgPSBbbWluUG9zLm1pblgsIG1pblBvcy5taW5ZXTtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gc2lnbihzY2FsZVswXSAqIHNjYWxlWzFdKTtcclxuICAgICAgICBpbmZvLnBvczEgPSBtaW51cyhwb3MxLCBkZWx0YSk7XHJcbiAgICAgICAgaW5mby5wb3MyID0gbWludXMocG9zMiwgZGVsdGEpO1xyXG4gICAgICAgIGluZm8ucG9zMyA9IG1pbnVzKHBvczMsIGRlbHRhKTtcclxuICAgICAgICBpbmZvLnBvczQgPSBtaW51cyhwb3M0LCBkZWx0YSk7XHJcbiAgICAgICAgLy8gaW5mby5sZWZ0ID0gaW5mby5sZWZ0ICsgZGVsdGFbMF07XHJcbiAgICAgICAgLy8gaW5mby50b3AgPSBpbmZvLnRvcCArIGRlbHRhWzFdO1xyXG4gICAgICAgIGluZm8ubGVmdCA9IG1pblggLSBpbmZvLmxlZnQgKyBkZWx0YVswXTtcclxuICAgICAgICBpbmZvLnRvcCA9IG1pblkgLSBpbmZvLnRvcCArIGRlbHRhWzFdO1xyXG4gICAgICAgIGluZm8ub3JpZ2luID0gbWludXMocGx1cyhwb3MsIGluZm8ub3JpZ2luKSwgZGVsdGEpO1xyXG4gICAgICAgIGluZm8uYmVmb3JlT3JpZ2luID0gbWludXMocGx1cyhwb3MsIGluZm8uYmVmb3JlT3JpZ2luKSwgZGVsdGEpO1xyXG4gICAgICAgIGluZm8ub3JpZ2luYWxCZWZvcmVPcmlnaW4gPSBwbHVzKHBvcywgaW5mby5vcmlnaW5hbEJlZm9yZU9yaWdpbik7XHJcbiAgICAgICAgaW5mby50cmFuc2Zvcm1PcmlnaW4gPSBtaW51cyhwbHVzKHBvcywgaW5mby50cmFuc2Zvcm1PcmlnaW4pLCBkZWx0YSk7XHJcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybVxyXG4gICAgICAgICAgICA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCgtZGVsdGFYIC0gZGVsdGFbMF0sIFwicHgsIFwiKS5jb25jYXQoLWRlbHRhWSAtIGRlbHRhWzFdLCBcInB4KVwiKVxyXG4gICAgICAgICAgICAgICAgKyByb3RhdGVTY2FsZTtcclxuICAgICAgICBzZXRTdG9yZUNhY2hlKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5mbyksIHsgcG9zRGVsdGE6IGRlbHRhLCBkaXJlY3Rpb246IGRpcmVjdGlvbiwgYmVmb3JlRGlyZWN0aW9uOiBkaXJlY3Rpb24gfSksIGlzU2V0U3RhdGUpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlR3JvdXAucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBfc3VwZXIucHJvdG90eXBlLmdldFJlY3QuY2FsbCh0aGlzKSksIHsgY2hpbGRyZW46IHRoaXMubW92ZWFibGVzLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmdldFJlY3QoKTsgfSkgfSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVHcm91cC5wcm90b3R5cGUudHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGUsIGlzTWFuYWdlcikge1xyXG4gICAgICAgIGlmIChpc01hbmFnZXIgfHwgbmFtZS5pbmRleE9mKFwiR3JvdXBcIikgPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS50cmlnZ2VyRXZlbnQuY2FsbCh0aGlzLCBuYW1lLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIudHJpZ2dlcihuYW1lLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVHcm91cC5wcm90b3R5cGUuZ2V0UmVxdWVzdENoaWxkU3R5bGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdHlsZU5hbWVzID0gdGhpcy5nZXRFbmFibGVkQWJsZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKG5hbWVzLCBhYmxlKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIHZhciBhYmxlU3R5bGVOYW1lcyA9ICgoX2IgPSAoX2EgPSBhYmxlLnJlcXVlc3RDaGlsZFN0eWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChhYmxlKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pO1xyXG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobmFtZXMpLCBmYWxzZSksIF9fcmVhZChhYmxlU3R5bGVOYW1lcyksIGZhbHNlKTtcclxuICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgcmV0dXJuIHN0eWxlTmFtZXM7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVHcm91cC5wcm90b3R5cGUuZ2V0TW92ZWFibGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodGhpcy5tb3ZlYWJsZXMpLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVHcm91cC5wcm90b3R5cGUudXBkYXRlQWJsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVBYmxlcy5jYWxsKHRoaXMsIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHRoaXMucHJvcHMuYWJsZXMpLCBmYWxzZSksIFtHcm91cGFibGVdLCBmYWxzZSksIFwiR3JvdXBcIik7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVHcm91cC5wcm90b3R5cGUuX3VwZGF0ZVRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fdXBkYXRlVGFyZ2V0cy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsRHJhZ1RhcmdldCA9IHRoaXMucHJvcHMuZHJhZ1RhcmdldCB8fCB0aGlzLmFyZWFFbGVtZW50O1xyXG4gICAgICAgIHRoaXMuX2RyYWdUYXJnZXQgPSBnZXRSZWZUYXJnZXQodGhpcy5fb3JpZ2luYWxEcmFnVGFyZ2V0LCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUdyb3VwLnByb3RvdHlwZS5fdXBkYXRlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICB2YXIgcHJldlRhcmdldCA9IHRoaXMuX3ByZXZEcmFnVGFyZ2V0O1xyXG4gICAgICAgIHZhciBuZXh0VGFyZ2V0ID0gcHJvcHMuZHJhZ1RhcmdldCB8fCB0aGlzLmFyZWFFbGVtZW50O1xyXG4gICAgICAgIHZhciB0YXJnZXRzID0gcHJvcHMudGFyZ2V0cztcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLmRpZmZlci51cGRhdGUodGFyZ2V0cyksIGFkZGVkID0gX2EuYWRkZWQsIGNoYW5nZWQgPSBfYS5jaGFuZ2VkLCByZW1vdmVkID0gX2EucmVtb3ZlZDtcclxuICAgICAgICB2YXIgaXNUYXJnZXRDaGFuZ2VkID0gYWRkZWQubGVuZ3RoIHx8IHJlbW92ZWQubGVuZ3RoO1xyXG4gICAgICAgIGlmIChpc1RhcmdldENoYW5nZWQgfHwgdGhpcy5fcHJldk9yaWdpbmFsRHJhZ1RhcmdldCAhPT0gdGhpcy5fb3JpZ2luYWxEcmFnVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHVuc2V0R2VzdG8odGhpcywgZmFsc2UpO1xyXG4gICAgICAgICAgICB1bnNldEdlc3RvKHRoaXMsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHsgZ2VzdG9zOiB7fSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXZUYXJnZXQgIT09IG5leHRUYXJnZXQpIHtcclxuICAgICAgICAgICAgc3RhdGUudGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdGF0ZS50YXJnZXQpIHtcclxuICAgICAgICAgICAgc3RhdGUudGFyZ2V0ID0gdGhpcy5hcmVhRWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sQm94LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS50YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRhcmdldEdlc3RvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldEdlc3RvID0gZ2V0VGFyZ2V0QWJsZUdlc3RvKHRoaXMsIHRoaXMuX2RyYWdUYXJnZXQsIFwiR3JvdXBcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xHZXN0bykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sR2VzdG8gPSBnZXRDb250cm9sQWJsZUdlc3RvKHRoaXMsIFwiR3JvdXBDb250cm9sXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpc0NvbnRhaW5lckNoYW5nZWQgPSAhZXF1YWxzKHN0YXRlLmNvbnRhaW5lciwgcHJvcHMuY29udGFpbmVyKTtcclxuICAgICAgICBpZiAoaXNDb250YWluZXJDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmNvbnRhaW5lciA9IHByb3BzLmNvbnRhaW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQ29udGFpbmVyQ2hhbmdlZFxyXG4gICAgICAgICAgICB8fCBpc1RhcmdldENoYW5nZWRcclxuICAgICAgICAgICAgfHwgdGhpcy50cmFuc2Zvcm1PcmlnaW4gIT09IChwcm9wcy5kZWZhdWx0R3JvdXBPcmlnaW4gfHwgXCI1MCUgNTAlXCIpXHJcbiAgICAgICAgICAgIHx8IGNoYW5nZWQubGVuZ3RoXHJcbiAgICAgICAgICAgIHx8IHRhcmdldHMubGVuZ3RoICYmICFpc0RlZXBBcnJheUVxdWFscyh0aGlzLl90YXJnZXRHcm91cHMsIHByb3BzLnRhcmdldEdyb3VwcyB8fCBbXSkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVSZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0ZpcnN0VGFyZ2V0cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzUHJvcFRhcmdldENoYW5nZWQgPSAhIWlzVGFyZ2V0Q2hhbmdlZDtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUdyb3VwLnByb3RvdHlwZS5fdXBkYXRlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBNb3ZlYWJsZUdyb3VwLmRlZmF1bHRQcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBNb3ZlYWJsZU1hbmFnZXIuZGVmYXVsdFByb3BzKSwgeyB0cmFuc2Zvcm1PcmlnaW46IFtcIjUwJVwiLCBcIjUwJVwiXSwgZ3JvdXBhYmxlOiB0cnVlLCBkcmFnQXJlYTogdHJ1ZSwga2VlcFJhdGlvOiB0cnVlLCB0YXJnZXRzOiBbXSwgZGVmYXVsdEdyb3VwUm90YXRlOiAwLCBkZWZhdWx0R3JvdXBPcmlnaW46IFwiNTAlIDUwJVwiIH0pO1xyXG4gICAgcmV0dXJuIE1vdmVhYmxlR3JvdXA7XHJcbn0oTW92ZWFibGVNYW5hZ2VyKSk7XG5cbi8qKlxyXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLkluZGl2aWR1YWxHcm91cFxyXG4gKiBAZGVzY3JpcHRpb24gQ3JlYXRlIHRhcmdldHMgaW5kaXZpZHVhbGx5LCBub3QgYXMgYSBncm91cC5DcmVhdGUgdGFyZ2V0cyBpbmRpdmlkdWFsbHksIG5vdCBhcyBhIGdyb3VwLlxyXG4gKi9cclxudmFyIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubW92ZWFibGVzID0gW107XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciBjc3BOb25jZSA9IHByb3BzLmNzcE5vbmNlLCBDb250cm9sQm94RWxlbWVudCA9IHByb3BzLmNzc1N0eWxlZCwgcGVyc2lzdERhdGEgPSBwcm9wcy5wZXJzaXN0RGF0YTtcclxuICAgICAgICB2YXIgdGFyZ2V0cyA9IHByb3BzLnRhcmdldHMgfHwgW107XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRhcmdldHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBjYW5QZXJzaXN0ID0gdGhpcy5pc1VubW91bnRlZCB8fCAhbGVuZ3RoO1xyXG4gICAgICAgIHZhciBwZXJzaXN0RGF0Q2hpbGRyZW4gPSAoX2EgPSBwZXJzaXN0RGF0YSA9PT0gbnVsbCB8fCBwZXJzaXN0RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVyc2lzdERhdGEuY2hpbGRyZW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xyXG4gICAgICAgIGlmIChjYW5QZXJzaXN0ICYmICFsZW5ndGggJiYgcGVyc2lzdERhdENoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0YXJnZXRzID0gcGVyc2lzdERhdENoaWxkcmVuLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWNhblBlcnNpc3QpIHtcclxuICAgICAgICAgICAgcGVyc2lzdERhdENoaWxkcmVuID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRyb2xCb3hFbGVtZW50LCB7IGNzcE5vbmNlOiBjc3BOb25jZSwgcmVmOiByZWYodGhpcywgXCJjb250cm9sQm94XCIpLCBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2wtYm94XCIpIH0sIHRhcmdldHMubWFwKGZ1bmN0aW9uICh0YXJnZXQsIGkpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgdmFyIGluZGl2aWR1YWxQcm9wcyA9IChfYiA9IChfYSA9IHByb3BzLmluZGl2aWR1YWxHcm91cGFibGVQcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvcHMsIHRhcmdldCwgaSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNb3ZlYWJsZU1hbmFnZXIsIF9fYXNzaWduKHsga2V5OiBcIm1vdmVhYmxlXCIgKyBpLCByZWY6IHJlZnMoX3RoaXMsIFwibW92ZWFibGVzXCIsIGkpIH0sIHByb3BzLCBpbmRpdmlkdWFsUHJvcHMsIHsgdGFyZ2V0OiB0YXJnZXQsIHdyYXBwZXJNb3ZlYWJsZTogX3RoaXMsIGlzV3JhcHBlck1vdW50ZWQ6IF90aGlzLmlzTW92ZWFibGVNb3VudGVkLCBwZXJzaXN0RGF0YTogcGVyc2lzdERhdENoaWxkcmVuW2ldIH0pKTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLnByb3RvdHlwZS5nZXRUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnRhcmdldHM7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLnVwZGF0ZVJlY3QgPSBmdW5jdGlvbiAodHlwZSwgaXNUYXJnZXQsIGlzU2V0U3RhdGUpIHtcclxuICAgICAgICBpZiAoaXNTZXRTdGF0ZSA9PT0gdm9pZCAwKSB7IGlzU2V0U3RhdGUgPSB0cnVlOyB9XHJcbiAgICAgICAgc2V0U3RvcmVDYWNoZSh0cnVlKTtcclxuICAgICAgICB0aGlzLm1vdmVhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgICAgICBtb3ZlYWJsZS51cGRhdGVSZWN0KHR5cGUsIGlzVGFyZ2V0LCBpc1NldFN0YXRlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXRTdG9yZUNhY2hlKCk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBfc3VwZXIucHJvdG90eXBlLmdldFJlY3QuY2FsbCh0aGlzKSksIHsgY2hpbGRyZW46IHRoaXMubW92ZWFibGVzLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmdldFJlY3QoKTsgfSkgfSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoYWJsZU5hbWUsIHBhcmFtLCBpc0luc3RhbnQpIHtcclxuICAgICAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkgeyBwYXJhbSA9IHt9OyB9XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLm1vdmVhYmxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ucmVxdWVzdChhYmxlTmFtZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtKSwgeyBpc0luc3RhbnQ6IGZhbHNlIH0pLCBmYWxzZSk7IH0pO1xyXG4gICAgICAgIHZhciByZXF1ZXN0SW5zdGFudCA9IGlzSW5zdGFudCB8fCBwYXJhbS5pc0luc3RhbnQ7XHJcbiAgICAgICAgdmFyIHJlcXVlc3RlciA9IHtcclxuICAgICAgICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGFibGVQYXJhbSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnJlcXVlc3QoYWJsZVBhcmFtKTsgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnJlcXVlc3RFbmQoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXF1ZXN0SW5zdGFudCA/IHJlcXVlc3Rlci5yZXF1ZXN0KHBhcmFtKS5yZXF1ZXN0RW5kKCkgOiByZXF1ZXN0ZXI7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsgdGFyZ2V0ID0gZS50YXJnZXQ7IH1cclxuICAgICAgICB2YXIgaW5wdXRUYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdmFyIGNoaWxkTW92ZWFibGUgPSBmaW5kKHRoaXMubW92ZWFibGVzLCBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGNoaWxkLmdldFRhcmdldHMoKVswXTtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xCb3hFbGVtZW50ID0gY2hpbGQuZ2V0Q29udHJvbEJveEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgdmFyIGRyYWdFbGVtZW50ID0gY2hpbGQuZ2V0RHJhZ0VsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQgfHwgIWRyYWdFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRyYWdFbGVtZW50ID09PSBpbnB1dFRhcmdldCB8fCBkcmFnRWxlbWVudC5jb250YWlucyhpbnB1dFRhcmdldClcclxuICAgICAgICAgICAgICAgIHx8IChkcmFnRWxlbWVudCAhPT0gdGFyZ2V0ICYmIHRhcmdldCA9PT0gaW5wdXRUYXJnZXQgfHwgdGFyZ2V0LmNvbnRhaW5zKGlucHV0VGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHx8IGNvbnRyb2xCb3hFbGVtZW50ID09PSBpbnB1dFRhcmdldCB8fCBjb250cm9sQm94RWxlbWVudC5jb250YWlucyhpbnB1dFRhcmdldCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGNoaWxkTW92ZWFibGUpIHtcclxuICAgICAgICAgICAgY2hpbGRNb3ZlYWJsZS5kcmFnU3RhcnQoZSwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLmlzSW5zaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuaXNEcmFnZ2luZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLmdldERyYWdFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLnByb3RvdHlwZS5nZXRNb3ZlYWJsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh0aGlzLm1vdmVhYmxlcyksIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUudXBkYXRlUmVuZGVyUG9zZXMgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuY2hlY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUudHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLnVwZGF0ZUFibGVzID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLl91cGRhdGVFdmVudHMgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuX3VwZGF0ZU9ic2VydmVyID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgcmV0dXJuIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwO1xyXG59KE1vdmVhYmxlTWFuYWdlcikpO1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50VGFyZ2V0cyhyZWZUYXJnZXRzLCBzZWxlY3Rvck1hcCkge1xyXG4gICAgdmFyIGVsZW1lbnRUYXJnZXRzID0gW107XHJcbiAgICByZWZUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yTWFwW3RhcmdldF0pIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRUYXJnZXRzLnB1c2guYXBwbHkoZWxlbWVudFRhcmdldHMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChzZWxlY3Rvck1hcFt0YXJnZXRdKSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgZWxlbWVudFRhcmdldHMucHVzaC5hcHBseShlbGVtZW50VGFyZ2V0cywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGdldEVsZW1lbnRUYXJnZXRzKHRhcmdldCwgc2VsZWN0b3JNYXApKSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRUYXJnZXRzLnB1c2godGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBlbGVtZW50VGFyZ2V0cztcclxufVxyXG5mdW5jdGlvbiBnZXRUYXJnZXRHcm91cHMocmVmVGFyZ2V0cywgc2VsZWN0b3JNYXApIHtcclxuICAgIHZhciB0YXJnZXRHcm91cHMgPSBbXTtcclxuICAgIHJlZlRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTdHJpbmcodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JNYXBbdGFyZ2V0XSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0R3JvdXBzLnB1c2guYXBwbHkodGFyZ2V0R3JvdXBzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoc2VsZWN0b3JNYXBbdGFyZ2V0XSksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHRhcmdldEdyb3Vwcy5wdXNoKGdldFRhcmdldEdyb3Vwcyh0YXJnZXQsIHNlbGVjdG9yTWFwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXRHcm91cHMucHVzaCh0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhcmdldEdyb3VwcztcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlUmVmVGFyZ2V0cyhwcmV2UmVmVGFyZ2V0cywgbmV4dFJlZlRhcmdldHMpIHtcclxuICAgIHJldHVybiAocHJldlJlZlRhcmdldHMubGVuZ3RoICE9PSBuZXh0UmVmVGFyZ2V0cy5sZW5ndGgpIHx8IHByZXZSZWZUYXJnZXRzLnNvbWUoZnVuY3Rpb24gKHRhcmdldCwgaSkge1xyXG4gICAgICAgIHZhciBuZXh0VGFyZ2V0ID0gbmV4dFJlZlRhcmdldHNbaV07XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgJiYgIW5leHRUYXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgIT0gbmV4dFRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzQXJyYXkobmV4dFRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlUmVmVGFyZ2V0cyh0YXJnZXQsIG5leHRUYXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxufVxyXG52YXIgSW5pdGlhbE1vdmVhYmxlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEluaXRpYWxNb3ZlYWJsZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEluaXRpYWxNb3ZlYWJsZSgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5yZWZUYXJnZXRzID0gW107XHJcbiAgICAgICAgX3RoaXMuc2VsZWN0b3JNYXAgPSB7fTtcclxuICAgICAgICBfdGhpcy5fZGlmZmVyID0gbmV3IENoaWxkcmVuRGlmZmVyKCk7XHJcbiAgICAgICAgX3RoaXMuX2VsZW1lbnRUYXJnZXRzID0gW107XHJcbiAgICAgICAgX3RoaXMuX3RtcFJlZlRhcmdldHMgPSBbXTtcclxuICAgICAgICBfdGhpcy5fdG1wU2VsZWN0b3JNYXAgPSB7fTtcclxuICAgICAgICBfdGhpcy5fb25DaGFuZ2VUYXJnZXRzID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBJbml0aWFsTW92ZWFibGUubWFrZVN0eWxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3NzTWFwID0ge307XHJcbiAgICAgICAgdmFyIGFibGVzID0gdGhpcy5nZXRUb3RhbEFibGVzKCk7XHJcbiAgICAgICAgYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIGNzcyA9IF9hLmNzcztcclxuICAgICAgICAgICAgaWYgKCFjc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjc3MuZm9yRWFjaChmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgICAgICAgICAgY3NzTWFwW3RleHRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gZ2V0S2V5cyhjc3NNYXApLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0U3R5bGVkID0gc3R5bGVkKFwiZGl2XCIsIHByZWZpeENTUyhQUkVGSVgsIE1PVkVBQkxFX0NTUyArIHN0eWxlKSk7XHJcbiAgICB9O1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLmdldFRvdGFsQWJsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoW0RlZmF1bHQsIEdyb3VwYWJsZSwgSW5kaXZpZHVhbEdyb3VwYWJsZSwgRHJhZ0FyZWFdLCBfX3JlYWQodGhpcy5kZWZhdWx0QWJsZXMpLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBtb3ZlYWJsZUNvbnRydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIGlmICghbW92ZWFibGVDb250cnVjdG9yLmRlZmF1bHRTdHlsZWQpIHtcclxuICAgICAgICAgICAgbW92ZWFibGVDb250cnVjdG9yLm1ha2VTdHlsZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9iID0gdGhpcy5wcm9wcywgdXNlckFibGVzID0gX2IuYWJsZXMsIHVzZXJQcm9wcyA9IF9iLnByb3BzLCBwcm9wcyA9IF9fcmVzdChfYiwgW1wiYWJsZXNcIiwgXCJwcm9wc1wiXSk7XHJcbiAgICAgICAgdmFyIF9jID0gX19yZWFkKHRoaXMuX3VwZGF0ZVJlZnModHJ1ZSksIDIpLCByZWZUYXJnZXRzID0gX2NbMF0sIG5leHRTZWxlY3Rvck1hcCA9IF9jWzFdO1xyXG4gICAgICAgIHZhciBlbGVtZW50VGFyZ2V0cyA9IGdldEVsZW1lbnRUYXJnZXRzKHJlZlRhcmdldHMsIG5leHRTZWxlY3Rvck1hcCk7XHJcbiAgICAgICAgdmFyIGlzR3JvdXAgPSBlbGVtZW50VGFyZ2V0cy5sZW5ndGggPiAxO1xyXG4gICAgICAgIHZhciB0b3RhbEFibGVzID0gbW92ZWFibGVDb250cnVjdG9yLmdldFRvdGFsQWJsZXMoKTtcclxuICAgICAgICB2YXIgYWJsZXMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh0b3RhbEFibGVzKSwgZmFsc2UpLCBfX3JlYWQoKHVzZXJBYmxlcyB8fCBbXSkpLCBmYWxzZSk7XHJcbiAgICAgICAgdmFyIG5leHRQcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcm9wcyksICh1c2VyUHJvcHMgfHwge30pKSwgeyBhYmxlczogYWJsZXMsIGNzc1N0eWxlZDogbW92ZWFibGVDb250cnVjdG9yLmRlZmF1bHRTdHlsZWQsIGN1c3RvbVN0eWxlZE1hcDogbW92ZWFibGVDb250cnVjdG9yLmN1c3RvbVN0eWxlZE1hcCB9KTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50VGFyZ2V0cyA9IGVsZW1lbnRUYXJnZXRzO1xyXG4gICAgICAgIHZhciBmaXJzdFJlbmRlclN0YXRlID0gbnVsbDtcclxuICAgICAgICB2YXIgcHJldk1vdmVhYmxlID0gdGhpcy5tb3ZlYWJsZTtcclxuICAgICAgICB2YXIgcGVyc2lzdERhdGEgPSBwcm9wcy5wZXJzaXN0RGF0YTtcclxuICAgICAgICBpZiAocGVyc2lzdERhdGEgPT09IG51bGwgfHwgcGVyc2lzdERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlcnNpc3REYXRhLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlzR3JvdXAgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFdmVuIG9uZSBjaGlsZCBpcyB0cmVhdGVkIGFzIGEgZ3JvdXAgaWYgaW5kaXZpZHVhbEdyb3VwYWJsZSBpcyBlbmFibGVkLiAjODY3XHJcbiAgICAgICAgaWYgKHByb3BzLmluZGl2aWR1YWxHcm91cGFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAsIF9fYXNzaWduKHsga2V5OiBcImluZGl2aWR1YWwtZ3JvdXBcIiwgcmVmOiByZWYodGhpcywgXCJtb3ZlYWJsZVwiKSB9LCBuZXh0UHJvcHMsIHsgdGFyZ2V0OiBudWxsLCB0YXJnZXRzOiBlbGVtZW50VGFyZ2V0cyB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0dyb3VwKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRHcm91cHMgPSBnZXRUYXJnZXRHcm91cHMocmVmVGFyZ2V0cywgbmV4dFNlbGVjdG9yTWFwKTtcclxuICAgICAgICAgICAgLy8gbWFuYWdlclxyXG4gICAgICAgICAgICBpZiAocHJldk1vdmVhYmxlICYmICFwcmV2TW92ZWFibGUucHJvcHMuZ3JvdXBhYmxlICYmICFwcmV2TW92ZWFibGUucHJvcHMuaW5kaXZpZHVhbEdyb3VwYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHByZXZNb3ZlYWJsZS5wcm9wcy50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICYmIGVsZW1lbnRUYXJnZXRzLmluZGV4T2YodGFyZ2V0KSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZW5kZXJTdGF0ZSA9IF9fYXNzaWduKHt9LCBwcmV2TW92ZWFibGUuc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1vdmVhYmxlR3JvdXAsIF9fYXNzaWduKHsga2V5OiBcImdyb3VwXCIsIHJlZjogcmVmKHRoaXMsIFwibW92ZWFibGVcIikgfSwgbmV4dFByb3BzLCAoX2EgPSBwcm9wcy5ncm91cGFibGVQcm9wcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIHsgdGFyZ2V0OiBudWxsLCB0YXJnZXRzOiBlbGVtZW50VGFyZ2V0cywgdGFyZ2V0R3JvdXBzOiB0YXJnZXRHcm91cHMsIGZpcnN0UmVuZGVyU3RhdGU6IGZpcnN0UmVuZGVyU3RhdGUgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldF8xID0gZWxlbWVudFRhcmdldHNbMF07XHJcbiAgICAgICAgICAgIC8vIG1hbmFnZXJcclxuICAgICAgICAgICAgaWYgKHByZXZNb3ZlYWJsZSAmJiAocHJldk1vdmVhYmxlLnByb3BzLmdyb3VwYWJsZSB8fCBwcmV2TW92ZWFibGUucHJvcHMuaW5kaXZpZHVhbEdyb3VwYWJsZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb3ZlYWJsZXMgPSBwcmV2TW92ZWFibGUubW92ZWFibGVzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZUYXJnZXRNb3ZlYWJsZSA9IGZpbmQobW92ZWFibGVzLCBmdW5jdGlvbiAobXYpIHsgcmV0dXJuIG12LnByb3BzLnRhcmdldCA9PT0gdGFyZ2V0XzE7IH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZUYXJnZXRNb3ZlYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVuZGVyU3RhdGUgPSBfX2Fzc2lnbih7fSwgcHJldlRhcmdldE1vdmVhYmxlLnN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNb3ZlYWJsZU1hbmFnZXIsIF9fYXNzaWduKHsga2V5OiBcInNpbmdsZVwiLCByZWY6IHJlZih0aGlzLCBcIm1vdmVhYmxlXCIpIH0sIG5leHRQcm9wcywgeyB0YXJnZXQ6IHRhcmdldF8xLCBmaXJzdFJlbmRlclN0YXRlOiBmaXJzdFJlbmRlclN0YXRlIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9jaGVja0NoYW5nZVRhcmdldHMoKTtcclxuICAgIH07XHJcbiAgICBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9jaGVja0NoYW5nZVRhcmdldHMoKTtcclxuICAgIH07XHJcbiAgICBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0b3JNYXAgPSB7fTtcclxuICAgICAgICB0aGlzLnJlZlRhcmdldHMgPSBbXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0YXJnZXRzIHNldCBpbiBtb3ZlYWJsZSB0aHJvdWdoIHRhcmdldCBvciB0YXJnZXRzIG9mIHByb3BzLlxyXG4gICAgICogQG1ldGhvZCBNb3ZlYWJsZSNnZXRUYXJnZXRzXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICAgICAqICAgIHRhcmdldDogW3RhcmdldFJlZiwgXCIudGFyZ2V0XCIsIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpXSxcclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKG1vdmVhYmxlLmdldFRhcmdldHMoKSk7XHJcbiAgICAgKi9cclxuICAgIEluaXRpYWxNb3ZlYWJsZS5wcm90b3R5cGUuZ2V0VGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm1vdmVhYmxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VGFyZ2V0cygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBlbGVtZW50IGxpc3QgY29ycmVzcG9uZGluZyB0byB0aGUgc2VsZWN0b3IgYW1vbmcgdGhlIHRhcmdldHMgaXMgY2hhbmdlZCwgaXQgaXMgdXBkYXRlZC5cclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjdXBkYXRlU2VsZWN0b3JzXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICAgICAqICAgIHRhcmdldDogXCIudGFyZ2V0XCIsXHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiBtb3ZlYWJsZS51cGRhdGVTZWxlY3RvcnMoKTtcclxuICAgICAqL1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZS51cGRhdGVTZWxlY3RvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rvck1hcCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlZnMoKTtcclxuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VyIGNoYW5nZXMgdGFyZ2V0IGFuZCB3YWl0cyBmb3IgdGFyZ2V0IHRvIGNoYW5nZS5cclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjd2FpdFRvQ2hhbmdlVGFyZ2V0XHJcbiAgICAgKiBAc3RvcnkgY29tYmluYXRpb24td2l0aC1vdGhlci1jb21wb25lbnRzLS1jb21wb25lbnRzLXNlbGVjdG9cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xyXG4gICAgICogICBtb3ZlYWJsZS53YWl0VG9DaGFuZ2VUYXJnZXQoKS50aGVuKCgpID0+IHtcclxuICAgICAqICAgICAgbW92ZWFibGUuZHJhZ1N0YXJ0KGUsIGUuY3VycmVudFRhcmdldCk7XHJcbiAgICAgKiAgIH0pO1xyXG4gICAgICogICBtb3ZlYWJsZS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZS53YWl0VG9DaGFuZ2VUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gbGV0IHJlc29sdmVQcm9taXNlOiAoZTogT25DaGFuZ2VUYXJnZXQpID0+IHZvaWQ7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyB0aGlzLl9vbkNoYW5nZVRhcmdldHMgPSAoKSA9PiB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuX29uQ2hhbmdlVGFyZ2V0cyA9IG51bGw7XHJcbiAgICAgICAgLy8gICAgIHJlc29sdmVQcm9taXNlKHtcclxuICAgICAgICAvLyAgICAgICAgIG1vdmVhYmxlOiB0aGlzLmdldE1hbmFnZXIoKSxcclxuICAgICAgICAvLyAgICAgICAgIHRhcmdldHM6IHRoaXMuX2VsZW1lbnRUYXJnZXRzLFxyXG4gICAgICAgIC8vICAgICB9KTtcclxuICAgICAgICAvLyB9O1xyXG4gICAgICAgIC8vIHJldHVybiBuZXcgUHJvbWlzZTxPbkNoYW5nZVRhcmdldD4ocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgLy8gICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcclxuICAgICAgICAvLyB9KTtcclxuICAgICAgICB2YXIgcmVzb2x2ZVByb21pc2U7XHJcbiAgICAgICAgdGhpcy5fb25DaGFuZ2VUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fb25DaGFuZ2VUYXJnZXRzID0gbnVsbDtcclxuICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZS53YWl0VG9DaGFuZ2VUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndhaXRUb0NoYW5nZVRhcmdldCgpO1xyXG4gICAgfTtcclxuICAgIEluaXRpYWxNb3ZlYWJsZS5wcm90b3R5cGUuZ2V0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlYWJsZTtcclxuICAgIH07XHJcbiAgICBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLmdldE1vdmVhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlYWJsZS5nZXRNb3ZlYWJsZXMoKTtcclxuICAgIH07XHJcbiAgICBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLmdldERyYWdFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVhYmxlLmdldERyYWdFbGVtZW50KCk7XHJcbiAgICB9O1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZS5fdXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChpc1JlbmRlcikge1xyXG4gICAgICAgIHZhciBwcmV2UmVmVGFyZ2V0cyA9IHRoaXMucmVmVGFyZ2V0cztcclxuICAgICAgICB2YXIgbmV4dFJlZlRhcmdldHMgPSBnZXRSZWZUYXJnZXRzKCh0aGlzLnByb3BzLnRhcmdldCB8fCB0aGlzLnByb3BzLnRhcmdldHMpKTtcclxuICAgICAgICB2YXIgaXNCcm93c2VyID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xyXG4gICAgICAgIHZhciBpc1VwZGF0ZSA9IGNvbXBhcmVSZWZUYXJnZXRzKHByZXZSZWZUYXJnZXRzLCBuZXh0UmVmVGFyZ2V0cyk7XHJcbiAgICAgICAgdmFyIHNlbGVjdG9yTWFwID0gdGhpcy5zZWxlY3Rvck1hcDtcclxuICAgICAgICB2YXIgbmV4dFNlbGVjdG9yTWFwID0ge307XHJcbiAgICAgICAgdGhpcy5yZWZUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gdXBkYXRlU2VsZWN0b3JNYXAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JUYXJnZXQgPSBzZWxlY3Rvck1hcFt0YXJnZXRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNlbGVjdG9yTWFwW3RhcmdldF0gPSBzZWxlY3Rvck1hcFt0YXJnZXRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNCcm93c2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTZWxlY3Rvck1hcFt0YXJnZXRdID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmZvckVhY2godXBkYXRlU2VsZWN0b3JNYXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdG1wUmVmVGFyZ2V0cyA9IG5leHRSZWZUYXJnZXRzO1xyXG4gICAgICAgIHRoaXMuX3RtcFNlbGVjdG9yTWFwID0gbmV4dFNlbGVjdG9yTWFwO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5leHRSZWZUYXJnZXRzLFxyXG4gICAgICAgICAgICBuZXh0U2VsZWN0b3JNYXAsXHJcbiAgICAgICAgICAgICFpc1JlbmRlciAmJiBpc1VwZGF0ZSxcclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIEluaXRpYWxNb3ZlYWJsZS5wcm90b3R5cGUuX2NoZWNrQ2hhbmdlVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB0aGlzLnJlZlRhcmdldHMgPSB0aGlzLl90bXBSZWZUYXJnZXRzO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0b3JNYXAgPSB0aGlzLl90bXBTZWxlY3Rvck1hcDtcclxuICAgICAgICB2YXIgX2QgPSB0aGlzLl9kaWZmZXIudXBkYXRlKHRoaXMuX2VsZW1lbnRUYXJnZXRzKSwgYWRkZWQgPSBfZC5hZGRlZCwgcmVtb3ZlZCA9IF9kLnJlbW92ZWQ7XHJcbiAgICAgICAgdmFyIGlzVGFyZ2V0Q2hhbmdlZCA9IGFkZGVkLmxlbmd0aCB8fCByZW1vdmVkLmxlbmd0aDtcclxuICAgICAgICBpZiAoaXNUYXJnZXRDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMucHJvcHMpLm9uQ2hhbmdlVGFyZ2V0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcclxuICAgICAgICAgICAgICAgIG1vdmVhYmxlOiB0aGlzLm1vdmVhYmxlLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0czogdGhpcy5fZWxlbWVudFRhcmdldHMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAoX2MgPSB0aGlzLl9vbkNoYW5nZVRhcmdldHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2UgPSBfX3JlYWQodGhpcy5fdXBkYXRlUmVmcygpLCAzKSwgcmVmVGFyZ2V0cyA9IF9lWzBdLCBzZWxlY3Rvck1hcCA9IF9lWzFdLCBpc1VwZGF0ZSA9IF9lWzJdO1xyXG4gICAgICAgIHRoaXMucmVmVGFyZ2V0cyA9IHJlZlRhcmdldHM7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rvck1hcCA9IHNlbGVjdG9yTWFwO1xyXG4gICAgICAgIGlmIChpc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluaXRpYWxNb3ZlYWJsZS5kZWZhdWx0QWJsZXMgPSBbXTtcclxuICAgIEluaXRpYWxNb3ZlYWJsZS5jdXN0b21TdHlsZWRNYXAgPSB7fTtcclxuICAgIEluaXRpYWxNb3ZlYWJsZS5kZWZhdWx0U3R5bGVkID0gbnVsbDtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIHdpdGhNZXRob2RzKE1PVkVBQkxFX01FVEhPRFMpXHJcbiAgICBdLCBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLCBcIm1vdmVhYmxlXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gSW5pdGlhbE1vdmVhYmxlO1xyXG59KFJlYWN0LlB1cmVDb21wb25lbnQpKTtcblxudmFyIE1vdmVhYmxlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1vdmVhYmxlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW92ZWFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgTW92ZWFibGUuZGVmYXVsdEFibGVzID0gTU9WRUFCTEVfQUJMRVM7XHJcbiAgICByZXR1cm4gTW92ZWFibGU7XHJcbn0oSW5pdGlhbE1vdmVhYmxlKSk7XG5cbmZ1bmN0aW9uIG1ha2VNb3ZlYWJsZShhYmxlcykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIF9hID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoTW92ZWFibGUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE1vdmVhYmxlKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBNb3ZlYWJsZTtcclxuICAgICAgICB9KEluaXRpYWxNb3ZlYWJsZSkpLFxyXG4gICAgICAgIF9hLmRlZmF1bHRBYmxlcyA9IGFibGVzLFxyXG4gICAgICAgIF9hO1xyXG59XG5cbmV4cG9ydCB7IENsaXBwYWJsZSwgRElSRUNUSU9OUywgRHJhZ2dhYmxlLCBlZGdlRHJhZ2dhYmxlIGFzIEVkZ2VEcmFnZ2FibGUsIEluaXRpYWxNb3ZlYWJsZSwgTU9WRUFCTEVfQUJMRVMsIE1PVkVBQkxFX0VWRU5UUywgTU9WRUFCTEVfTUVUSE9EUywgTU9WRUFCTEVfUFJPUFMsIFBpbmNoYWJsZSwgUmVzaXphYmxlLCBSb3RhdGFibGUsIFJvdW5kYWJsZSwgU2NhbGFibGUsIFNuYXBwYWJsZSwgV2FycGFibGUsIGNhbGN1bGF0ZUVsZW1lbnRQb3NpdGlvbiwgTW92ZWFibGUgYXMgZGVmYXVsdCwgZ2V0RWxlbWVudEluZm8sIG1ha2VBYmxlLCBtYWtlTW92ZWFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vdmVhYmxlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZXRBZ2VudCIsInByZWZpeE5hbWVzIiwicmVmIiwicmVmcyIsInByZWZpeENTUyIsIndpdGhNZXRob2RzIiwiZmluZEluZGV4IiwiZmluZCIsImlzQXJyYXkiLCJzcGxpdFNwYWNlIiwic3BsaXRVbml0IiwiZG90IiwiaXNTdHJpbmciLCJnZXREb2N1bWVudEVsZW1lbnQiLCJnZXREb2N1bWVudEJvZHkiLCJnZXRXaW5kb3ciLCJ0aHJvdHRsZSIsImdldEtleXMiLCJnZXRSYWQiLCJUSU5ZX05VTSIsIlRJTllfTlVNJDEiLCJhdmVyYWdlIiwiZ2V0RGlzdCIsImdldERpc3QkMSIsInRocm90dGxlQXJyYXkiLCJjYWxjdWxhdGVCb3VuZFNpemUiLCJjb252ZXJ0VW5pdFNpemUiLCJpc051bWJlciIsImhhc0NsYXNzIiwiaXNPYmplY3QiLCJmbGF0IiwiZmxhdCQxIiwiZGVjYW1lbGl6ZSIsImlzTm9kZSIsImlzRnVuY3Rpb24iLCJpc1dpbmRvdyIsImNvdW50ZXIiLCJpc1VuZGVmaW5lZCIsImJldHdlZW4iLCJhZGRDbGFzcyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlbW92ZUNsYXNzIiwic3BsaXRCcmFja2V0Iiwic3BsaXRDb21tYSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicHVzaFNldCIsIm1pbnVzIiwiaW52ZXJ0IiwiY29udmVydFBvc2l0aW9uTWF0cml4IiwicGx1cyIsImNhbGN1bGF0ZSIsImZyb21UcmFuc2xhdGlvbiIsIm11bHRpcGx5IiwiY29udmVydERpbWVuc2lvbiIsImNyZWF0ZVNjYWxlTWF0cml4IiwiY29udmVydENTU3RvTWF0cml4IiwiY3JlYXRlSWRlbnRpdHlNYXRyaXgiLCJjcmVhdGVPcmlnaW5NYXRyaXgiLCJjcmVhdGVSb3RhdGVNYXRyaXgiLCJyb3RhdGUiLCJnZXRPcmlnaW4iLCJtdWx0aXBsaWVzIiwiY29udmVydE1hdHJpeHRvQ1NTIiwiaWdub3JlRGltZW5zaW9uIiwiY3JlYXRlV2FycE1hdHJpeCIsInBhcnNlIiwicGFyc2VNYXQiLCJ0b01hdCIsImNhbGN1bGF0ZU1hdHJpeERpc3QiLCJDaGlsZHJlbkRpZmZlciIsImRpZmYiLCJEcmFnU2Nyb2xsIiwiZ2V0TWluTWF4cyIsImZpdFBvaW50cyIsImdldE92ZXJsYXBTaXplIiwiZ2V0QXJlYVNpemUiLCJpc0luc2lkZSIsImdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzIiwiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwiR2VzdG8iLCJzdHlsZWQiLCJFdmVudEVtaXR0ZXIiLCJkaWZmJDEiLCJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9fZXh0ZW5kcyIsIlR5cGVFcnJvciIsIlN0cmluZyIsIl9fIiwiY29uc3RydWN0b3IiLCJjcmVhdGUiLCJfX2Fzc2lnbiIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2RlY29yYXRlIiwiZGVjb3JhdG9ycyIsInRhcmdldCIsImtleSIsImRlc2MiLCJjIiwiciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIlJlZmxlY3QiLCJkZWNvcmF0ZSIsImRlZmluZVByb3BlcnR5IiwiX192YWx1ZXMiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJtIiwibmV4dCIsInZhbHVlIiwiZG9uZSIsIl9fcmVhZCIsImFyIiwicHVzaCIsImVycm9yIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJsIiwic2xpY2UiLCJjb25jYXQiLCJtYWtlQWJsZSIsIm5hbWUiLCJhYmxlIiwiZXZlbnRzIiwicHJvcHMiLCJESVJFQ1RJT05TNCIsIkRJUkVDVElPTlMiLCJnZXRTVkdDdXJzb3IiLCJzY2FsZSIsImRlZ3JlZSIsImdldEN1cnNvckNTUyIsIngxIiwiZGVncmVlNDUiLCJNYXRoIiwicm91bmQiLCJkZWZhdWx0Q3Vyc29yIiwiYWdlbnQiLCJJU19XRUJLSVQiLCJicm93c2VyIiwid2Via2l0IiwiSVNfV0VCS0lUNjA1IiwibmF2aSIsInVzZXJBZ2VudCIsIndpbmRvdyIsIm5hdmlnYXRvciIsInJlcyIsImV4ZWMiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlRmxvYXQiLCJicm93c2VyTmFtZSIsImJyb3dzZXJWZXJzaW9uIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwiSVNfQ0hST01FIiwiSVNfQ0hST01JVU0iLCJjaHJvbWl1bSIsImNocm9taXVtVmVyc2lvbiIsIklTX0NIUk9NSVVNMTA5IiwiSVNfRklSRUZPWCIsIklTX1NBRkFSSV9BQk9WRTE1Iiwid2Via2l0VmVyc2lvbiIsIlBSRUZJWCIsImRpcmVjdGlvbkNTUyIsIm1hcCIsImRpciIsInRvcCIsImxlZnQiLCJvcmlnaW5YIiwib3JpZ2luWSIsIm9mZnNldCIsImpvaW4iLCJNT1ZFQUJMRV9DU1MiLCJORUFSQllfUE9TIiwiRkxPQVRfUE9JTlRfTlVNIiwiTUlOX1NDQUxFIiwiTUFYX05VTSIsInBvdyIsIk1JTl9OVU0iLCJESVJFQ1RJT05fUkVHSU9OX1RPX0RJUkVDVElPTiIsInciLCJudyIsIm5lIiwic3ciLCJzZSIsIkRJUkVDVElPTl9JTkRFWEVTIiwiRElSRUNUSU9OX1JPVEFUSU9OUyIsIk1PVkVBQkxFX01FVEhPRFMiLCJzZXRDdXN0b21EcmFnIiwic3RhdGUiLCJkZWx0YSIsImlzUGluY2giLCJpc0NvbnZlcnQiLCJhYmxlTmFtZSIsIl9hIiwiX2IiLCJyZXN1bHQiLCJnZXN0b3MiLCJtb3ZlIiwiaW5wdXRFdmVudCIsImRhdGFzIiwib3JpZ2luYWxEYXRhcyIsImFibGVEYXRhcyIsImNvbnZlcnREcmFnRGlzdCIsInBhcmVudEV2ZW50IiwiQ3VzdG9tR2VzdG8iLCJwcmV2WCIsInByZXZZIiwic3RhcnRYIiwic3RhcnRZIiwiaXNEcmFnIiwiaXNGbGFnIiwiZHJhZ2dhYmxlIiwiZHJhZ1N0YXJ0IiwiY2xpZW50IiwidHlwZSIsImRyYWciLCJjbGllbnRYIiwiY2xpZW50WSIsImlzRmlyc3REcmFnIiwiaXNQcmV2RHJhZyIsImRpc3RYIiwiZGlzdFkiLCJkZWx0YVgiLCJkZWx0YVkiLCJwYXJlbnRHZXN0byIsImNhbGN1bGF0ZUVsZW1lbnRQb3NpdGlvbiIsIm1hdHJpeCIsIm9yaWdpbiIsIndpZHRoIiwiaGVpZ2h0IiwiaXMzZCIsInBvc2VzIiwiY2FsY3VsYXRlUG9zZXMiLCJ5MSIsIl9jIiwieDIiLCJ5MiIsIl9kIiwieDMiLCJ5MyIsIl9lIiwieDQiLCJ5NCIsIl9mIiwiY2FsY3VsYXRlUG9zaXRpb24iLCJtaW4iLCJyaWdodCIsIm1heCIsImJvdHRvbSIsInN4Iiwic3kiLCJkaXJlY3Rpb24iLCJzaWduIiwicG9zMSIsInBvczIiLCJwb3MzIiwicG9zNCIsImNhbGN1bGF0ZVBvaW50ZXJEaXN0IiwibW92ZWFibGUiLCJtb3ZlYWJsZUNsaWVudFJlY3QiLCJyb290TWF0cml4IiwiY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uIiwicG9zWCIsInBvc1kiLCJnZXREcmFnRGlzdCIsInNldERyYWdTdGFydCIsImFsbE1hdHJpeCIsImJlZm9yZU1hdHJpeCIsIm9mZnNldE1hdHJpeCIsInRhcmdldE1hdHJpeCIsInRyYW5zZm9ybU9yaWdpbiIsImludmVyc2VNYXRyaXgiLCJpbnZlcnNlQmVmb3JlTWF0cml4IiwiYWJzb2x1dGVPcmlnaW4iLCJzdGFydERyYWdCZWZvcmVEaXN0Iiwic3RhcnREcmFnRGlzdCIsImdldFRyYW5zZm9ybURpcmVjdGlvbiIsImJlZm9yZVRyYW5zZm9ybSIsInJlc29sdmVUcmFuc2Zvcm1FdmVudCIsImV2ZW50IiwiZnVuY3Rpb25OYW1lIiwiYmVmb3JlUmVuZGVyYWJsZSIsImluZGV4IiwidHJhbnNmb3JtSW5kZXgiLCJuZXh0VHJhbnNmb3JtcyIsIm5leHRUcmFuc2Zvcm1BcHBlbmRlZEluZGV4ZXMiLCJuZXh0SW5kZXgiLCJ0ZXh0IiwibWF0Y2giLCJpbmZvIiwiZmlsdGVyIiwiY29udmVydFRyYW5zZm9ybUluZm8iLCJ0YXJnZXRGdW5jdGlvbiIsIm1hdEZ1bmN0aW9uTmFtZSIsImJlZm9yZUZ1bmN0aW9uVGV4dHMiLCJhZnRlckZ1bmN0aW9uVGV4dHMiLCJiZWZvcmVGdW5jdGlvbk1hdHJpeCIsImJlZm9yZVRyYW5zZm9ybTIiLCJiZWZvcmVGdW5jdGlvbk1hdHJpeDIiLCJ0YXJnZXRUYW5zZm9ybSIsInRhcmdldEZ1bmN0aW9uTWF0cml4IiwiYWZ0ZXJUcmFuc2Zvcm0iLCJhZnRlckZ1bmN0aW9uTWF0cml4IiwiYWZ0ZXJUcmFuc2Zvcm0yIiwiYWZ0ZXJGdW5jdGlvbk1hdHJpeDIiLCJ0YXJnZXRBbGxUcmFuc2Zvcm0iLCJhbGxGdW5jdGlvbk1hdHJpeCIsInNwbGljZSIsImlzQXBwZW5kVHJhbnNmb3JtIiwiaXNBcHBlbmQiLCJjb252ZXJ0VHJhbnNmb3JtRm9ybWF0IiwiZGlzdCIsImdldFRyYW5zZm9ybURpc3QiLCJnZXRCZWZvcmVEcmFnRGlzdCIsImJ4IiwiYnkiLCJnZXRUcmFuc2Zyb21NYXRyaXgiLCJpc0FmdGVyIiwibmV4dFRhcmdldE1hdHJpeCIsInJlczEiLCJhZnRlclRhcmdldE1hdHJpeCIsImlzQmVmb3JlIiwiZ2V0SW52ZXJzZURyYWdEaXN0IiwiY2FsY3VsYXRlVHJhbnNmb3JtT3JpZ2luIiwicHJldldpZHRoIiwicHJldkhlaWdodCIsInByZXZPcmlnaW4iLCJwb3MiLCJ1bml0IiwicHJldlNpemUiLCJzaXplIiwiaXNOYU4iLCJtZWFzdXJlUmF0aW8iLCJnZXRQb3NJbmRleGVzQnlEaXJlY3Rpb24iLCJpbmRleGVzIiwiZ2V0UG9zZXNCeURpcmVjdGlvbiIsImdldFBvc0J5U2luZ2xlRGlyZWN0aW9uIiwicmF0aW8iLCJnZXRQb3NCeURpcmVjdGlvbiIsInN0YXJ0UG9zIiwiZml4ZWREaXJlY3Rpb24iLCJmaXhlZFBvcyIsImdldE5leHRNYXRyaXgiLCJnZXRBYnNvbHV0ZU1hdHJpeCIsImdldE5leHRUcmFuc2Zvcm1NYXRyaXgiLCJ0cmFuc2Zvcm0iLCJpc0FsbFRyYW5zZm9ybSIsInRhcmdldFRyYW5zZm9ybSIsInNjYWxlTWF0cml4IiwiZmlsbFRyYW5zZm9ybVN0YXJ0RXZlbnQiLCJnZXRCZWZvcmVSZW5kZXJhYmxlRGF0YXMiLCJzZXRUcmFuc2Zvcm0iLCJzdGFydFRyYW5zZm9ybXMiLCJzZXRUcmFuc2Zvcm1JbmRleCIsInNldERlZmF1bHRUcmFuc2Zvcm1JbmRleCIsInByb3BlcnR5IiwiZnVuYyIsInYiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInN0YXJ0VmFsdWUiLCJmdW5jdGlvblZhbHVlIiwiZmlsbE9yaWdpbmFsVHJhbnNmb3JtIiwiZ2V0TmV4dFRyYW5zZm9ybXMiLCJnZXROZXh0VHJhbnNmb3JtVGV4dCIsImdldE5leHRTdHlsZSIsIm5leHRTdHlsZSIsImZpbGxUcmFuc2Zvcm1FdmVudCIsIm5leHRUcmFuc2Zvcm0iLCJEcmFnZ2FibGUiLCJmaWxsQ1NTT2JqZWN0IiwiZ2V0VHJhbnNsYXRlRml4ZWRQb3NpdGlvbiIsImZpeGVkT2Zmc2V0IiwibmV4dE1hdHJpeCIsIm5leHRGaXhlZFBvc2l0aW9uIiwiZ2V0RGlyZWN0aW9uT2Zmc2V0IiwiZ2V0VHJhbnNsYXRlRGlzdCIsImZpeGVkUG9zaXRpb24iLCJncm91cGFibGUiLCJncm91cExlZnQiLCJncm91cFRvcCIsImdldFNjYWxlRGlzdCIsImdldERpcmVjdGlvbkJ5UG9zIiwiZml4ZWRPZmZzZXRQb3NpdGlvbiIsImdldFJvdGF0ZURpc3QiLCJyb3RhdGVEaXN0IiwiZ2V0UmVzaXplRGlzdCIsIm5leHRPcmlnaW4iLCJnZXRBYnNvbHV0ZVBvc2l0aW9uIiwiZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUiLCJnZXRHZXN0b0RhdGEiLCJ0YXJnZXRHZXN0byIsImNvbnRyb2xHZXN0byIsImRhdGEiLCJnZXRFdmVudERhdGEiLCJnZXRTaGFkb3dSb290IiwicGFyZW50RWxlbWVudCIsImdldFJvb3ROb2RlIiwicm9vdE5vZGUiLCJub2RlVHlwZSIsImdldEluZGl2aWR1YWxUcmFuc2Zvcm1zIiwiZ2V0U3R5bGUiLCJ0cmFuc2xhdGUiLCJpbmRpdmlkdWFsVHJhbnNmb3JtcyIsInNwbGl0IiwiZ2V0TWF0cml4U3RhY2tJbmZvIiwiY29udGFpbmVyIiwiY2hlY2tDb250YWluZXIiLCJlbCIsIm1hdHJpeGVzIiwiZG9jdW1lbnRFbGVtZW50IiwicmVxdWVzdEVuZCIsImlzRW5kIiwidGFyZ2V0VHJhbnNmb3JtT3JpZ2luIiwiaGFzRml4ZWQiLCJvZmZzZXRDb250YWluZXIiLCJnZXRPZmZzZXRJbmZvIiwib2Zmc2V0UGFyZW50Iiwiem9vbSIsImdldENhY2hlZFN0eWxlIiwicG9zaXRpb24iLCJnZXRFbGVtZW50VHJhbnNmb3JtIiwiaXNGaXhlZCIsImdldFRyYW5zZm9ybU1hdHJpeCIsImlzT2Zmc2V0RW5kIiwiaXNTdGF0aWMiLCJwYXJlbnRDbGllbnRMZWZ0IiwicGFyZW50Q2xpZW50VG9wIiwiZml4ZWRDbGllbnRMZWZ0IiwiZml4ZWRDbGllbnRUb3AiLCJmaXhlZEluZm8iLCJoYXNUcmFuc2Zvcm0iLCJmaXhlZENvbnRhaW5lciIsImdldFBvc2l0aW9uRml4ZWRJbmZvIiwibGVuZ3RoXzEiLCJjb252ZXJ0M0RNYXRyaXhlcyIsImdldE9mZnNldFBvc0luZm8iLCJ0YWdOYW1lIiwiaGFzT2Zmc2V0IiwiaXNTVkciLCJvcmlnaW5fMSIsInRhcmdldE9yaWdpbiIsIm9mZnNldFBvcyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJvd25lclNWR0VsZW1lbnQiLCJnZXRTVkdNYXRyaXgiLCJ0YXJnZXRab29tIiwib2Zmc2V0SW5mbyIsIm9mZnNldFpvb20iLCJpc0N1c3RvbUVsZW1lbnQiLCJwYXJlbnRTbG90RWxlbWVudCIsImN1c3RvbU9mZnNldFBhcmVudCIsImN1c3RvbU9mZnNldExlZnQiLCJjdXN0b21PZmZzZXRUb3AiLCJjbGllbnRMZWZ0IiwiY2xpZW50VG9wIiwibWFyZ2luIiwiZ2V0Qm9keU9mZnNldCIsImlzRWxlbWVudFRhcmdldCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJjYWNoZVN0eWxlTWFwIiwiY2xpZW50UmVjdFN0eWxlTWFwIiwibWF0cml4Q29udGFpbmVySW5mb3MiLCJzZXRTdG9yZUNhY2hlIiwidXNlQ2FjaGUiLCJNYXAiLCJnZXRDYWNoZWRDbGllbnRSZWN0IiwiY2xpZW50UmVjdCIsImdldCIsIm5leHRDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdCIsInNldCIsImdldENhY2hlZE1hdHJpeENvbnRhaW5lckluZm8iLCJyZXN1bHRfMSIsImVsZW1lbnQiLCJjYWNoZSIsIm5leHRTdHlsZV8xIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInN0eWxlIiwiY2FjaGVkIiwiZmlsbENoaWxkRXZlbnRzIiwiZ3JvdXBhYmxlRGF0YXMiLCJjaGlsZERhdGFzIiwibW92ZWFibGVzIiwiXyIsImlzUmVxdWVzdENoaWxkIiwidHJpZ2dlckNoaWxkR2VzdG8iLCJpc1N0YXJ0IiwiY2hpbGRFdmVudHMiLCJldmVudFBhcmFtcyIsImV2IiwiY2hpbGRNb3ZlYWJsZSIsImNoaWxkRXZlbnQiLCJjaGlsZEdlc3RvcyIsInBhcmVudEZsYWciLCJjaGlsZCIsInRyaWdnZXJDaGlsZEFibGVzIiwiZWFjaEV2ZW50IiwiY2FsbGJhY2siLCJjaGlsZHMiLCJzdGFydENoaWxkRGlzdCIsInBhcmVudERhdGFzIiwic3RhcnRQb3NpdGlvbnMiLCJyb3RhdGlvbiIsIlBJIiwib3JpZ2luYWxYIiwib3JpZ2luYWxZIiwicmVuZGVyRGlyZWN0aW9uQ29udHJvbHNCeUluZm9zIiwicmVuZGVyRGlyZWN0aW9ucyIsImdldFN0YXRlIiwicmVuZGVyUG9zZXMiLCJyb3RhdGlvblJhZCIsImdldFByb3BzIiwiZGVnUm90YXRpb24iLCJhYnNEZWdyZWUiLCJkaXJlY3Rpb25NYXAiLCJyZW5kZXJTdGF0ZSIsInJlbmRlckRpcmVjdGlvbk1hcCIsImZvckVhY2giLCJkaXJlY3Rpb25TaWduIiwiY2xhc3NOYW1lcyIsImRpcmVjdGlvblJvdGF0aW9uIiwiZGF0YUF0dHJzIiwiY2xhc3NOYW1lIiwicHJlZml4IiwiZ2V0Q29udHJvbFRyYW5zZm9ybSIsInJlbmRlckRpcmVjdGlvbkNvbnRyb2xzIiwiZGVmYXVsdERpcmVjdGlvbnMiLCJkaXJlY3Rpb25zIiwiZGlzcGxheUFyb3VuZENvbnRyb2xzIiwicmVuZGVyQXJvdW5kQ29udHJvbHMiLCJyZW5kZXJMaW5lIiwiX2kiLCJyYWQiLCJnZXRMaW5lU3R5bGUiLCJyZW5kZXJFZGdlTGluZXMiLCJlZGdlIiwiaW5kZXgxIiwiaW5kZXgyIiwiQm9vbGVhbiIsImdldFJlbmRlckRpcmVjdGlvbnMiLCJyZW5kZXJEaWFnb25hbERpcmVjdGlvbnMiLCJyZW5kZXJBbGxEaXJlY3Rpb25zIiwiY2hlY2tCb3VuZFBvc2VzIiwiYm91bmRzIiwidmVydGljYWxQb3NlcyIsImhvcml6b250YWxQb3NlcyIsIkluZmluaXR5IiwibmV4dEJvdW5kcyIsInZlcnRpY2FsIiwiY2hlY2tCb3VuZHMiLCJob3Jpem9udGFsIiwiZ2V0Qm91bmRzIiwiZXh0ZXJuYWxCb3VuZHMiLCJjb250YWluZXJDbGllbnRSZWN0IiwiY29udGFpbmVySGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY29udGFpbmVyV2lkdGgiLCJjbGllbnRXaWR0aCIsInNuYXBPZmZzZXQiLCJzbmFwT2Zmc2V0TGVmdCIsInNuYXBPZmZzZXRUb3AiLCJzbmFwT2Zmc2V0UmlnaHQiLCJzbmFwT2Zmc2V0Qm90dG9tIiwiaXNDU1MiLCJfZyIsImNoZWNrQm91bmRLZWVwUmF0aW8iLCJlbmRQb3MiLCJlbmRYIiwiZW5kWSIsImR4IiwiZHkiLCJhYnMiLCJpc0JvdHRvbSIsImlzUmlnaHQiLCJ2ZXJ0aWNhbEluZm8iLCJpc0JvdW5kIiwiaG9yaXpvbnRhbEluZm8iLCJhIiwieSIsIngiLCJpc1ZlcnRpY2FsIiwic3RhcnRCb3VuZFBvcyIsImVuZEJvdW5kUG9zIiwibWluUG9zIiwibWF4UG9zIiwiYm91bmRJbmZvcyIsInNvcnQiLCJpc0JvdW5kUm90YXRlJDEiLCJyZWxhdGl2ZVBvc2VzIiwiYm91bmRSZWN0IiwibmV4dFBvc2VzIiwic29tZSIsImJvdW5kUm90YXRlIiwidmVjIiwiYm91bmRQb3MiLCJnZXREaXN0U2l6ZSIsIm5leHRQb3MiLCJzcXJ0IiwiY2hlY2tSb3RhdGVCb3VuZHMiLCJwcmV2UG9zZXMiLCJyZWxhdGl2ZUxlZnQiLCJyZWxhdGl2ZVJpZ2h0IiwicmVsYXRpdmVUb3AiLCJyZWxhdGl2ZUJvdHRvbSIsInJlbGF0aXZlUmFkMSIsInJlbGF0aXZlUmFkMiIsIm5leHRSYWQiLCJWRVJUSUNBTF9OQU1FUyIsIkhPUklaT05UQUxfTkFNRVMiLCJTTkFQX1NLSVBfTkFNRVNfTUFQIiwiVkVSVElDQUxfTkFNRVNfTUFQIiwic3RhcnQiLCJlbmQiLCJjZW50ZXIiLCJIT1JJWk9OVEFMX05BTUVTX01BUCIsImdldEluaXRpYWxCb3VuZHMiLCJoYXNHdWlkZWxpbmVzIiwic25hcHBhYmxlIiwiaW5uZXJCb3VuZHMiLCJ2ZXJ0aWNhbEd1aWRlbGluZXMiLCJob3Jpem9udGFsR3VpZGVsaW5lcyIsInNuYXBHcmlkV2lkdGgiLCJzbmFwR3JpZEhlaWdodCIsImd1aWRlbGluZXMiLCJlbmFibGVTbmFwIiwiZ2V0U25hcERpcmVjdGlvbnMiLCJzbmFwRGlyZWN0aW9ucyIsIm1hcFNuYXBEaXJlY3Rpb25Qb3NlcyIsInNuYXBQb3NlcyIsIm5leHRTbmFwRGlyZWN0aW9ucyIsIm5leHRTbmFwUG9zZXMiLCJuYW1lXzEiLCJzcGxpdFNuYXBEaXJlY3Rpb25Qb3NlcyIsImhvcml6b250YWxOYW1lcyIsInZlcnRpY2FsTmFtZXMiLCJjYWxjdWxhdGVDb250YWluZXJQb3MiLCJjb250YWluZXJSZWN0IiwiY2xpZW50UG9zIiwic29sdmVMaW5lQ29uc3RhbnRzIiwicG9pbnQxIiwicG9pbnQyIiwiTkFNRV9zbmFwUm90YXRpb25UaHJlc2hvbGQiLCJOQU1FX3NuYXBSb3RhdGlvbkRlZ3JlZXMiLCJOQU1FX3NuYXBIb3Jpem9udGFsVGhyZXNob2xkIiwiTkFNRV9zbmFwVmVydGljYWxUaHJlc2hvbGQiLCJjaGVja01vdmVhYmxlU25hcFBvc2VzIiwicG9zZXNYIiwicG9zZXNZIiwiZGlyWHMiLCJkaXJZcyIsImN1c3RvbVNuYXBWZXJ0aWNhbFRocmVzaG9sZCIsImN1c3RvbVNuYXBIb3Jpem9udGFsVGhyZXNob2xkIiwic25hcFRocmVzaG9sZE11bHRpcGxlcyIsInNuYXBUaHJlc2hvbGRJbmZvIiwibXVsdGlwbGVzIiwic25hcEhvcml6b250YWxUaHJlc2hvbGQiLCJzZWxlY3RWYWx1ZSIsInNuYXBWZXJ0aWNhbFRocmVzaG9sZCIsImNoZWNrU25hcFBvc2VzIiwiY2hlY2tTbmFwIiwiY2hlY2tTbmFwS2VlcFJhdGlvIiwiZ2V0VGlueURpc3QiLCJpc1NuYXAiLCJ1bmRlZmluZWQiLCJ2ZXJ0aWNhbFNuYXBJbmZvIiwiaG9yaXpvbnRhbFNuYXBJbmZvIiwicG9zSW5mb3MiLCJnZXROZWFyZXN0U25hcEd1aWRlbGluZUluZm8iLCJpc1ZlcnRpY2FsU25hcCIsInZlcnRpY2FsR3VpZGVsaW5lIiwiZ3VpZGVsaW5lIiwiaXNIb3Jpem9udGFsU25hcCIsImhvcml6b250YWxHdWlkZWxpbmUiLCJob3Jpem9udGFsUG9zIiwidmVydGljYWxQb3MiLCJnZXRTdHJpbmdEaXJlY3Rpb24iLCJzdHJpbmdEaXJlY3Rpb24iLCJjaGVja1NuYXBzIiwicmVjdCIsImhvcml6b250YWxEaXJlY3Rpb24iLCJ2ZXJ0aWNhbERpcmVjdGlvbiIsInNuYXBJbmZvIiwicG9zSW5mbyIsImd1aWRlbGluZUluZm8iLCJndWlkZWxpbmVJbmZvcyIsInRhcmdldFR5cGUiLCJ0YXJnZXRQb3NlcyIsInNuYXBUaHJlc2hvbGQiLCJkaXJzIiwicG9zVHlwZSIsInNuYXBQb3NJbmZvcyIsInRhcmdldFBvcyIsInNuYXBQb3NJbmZvIiwiZ2V0U25hcEluZm9zQnlEaXJlY3Rpb24iLCJzbmFwRGlyZWN0aW9uIiwiYXJyIiwibmV4dERpciIsImtlZXBSYXRpbyIsInhzIiwieXMiLCJjaGVja1NuYXBCb3VuZFByaW9yaXR5IiwiYURpc3QiLCJiRGlzdCIsImdldE5lYXJPZmZzZXRJbmZvIiwib2Zmc2V0cyIsImFTaWduIiwiYlNpZ24iLCJhT2Zmc2V0IiwiYk9mZnNldCIsImdldENoZWNrU25hcERpcmVjdGlvbnMiLCJlbmREaXJlY3Rpb25fMSIsInNpZ25YIiwic2lnblkiLCJuZXh0RGlyZWN0aW9uIiwic2lnbnMiLCJpc1N0YXJ0TGluZSIsImxpbmUiLCJjeCIsImN5IiwiaGl0VGVzdExpbmUiLCJ0ZXN0MSIsInRlc3QyIiwiaXNTYW1lU3RhcnRMaW5lIiwiZG90cyIsImNlbnRlclNpZ24iLCJldmVyeSIsImNoZWNrSW5uZXJCb3VuZERvdCIsInRocmVzaG9sZCIsImNoZWNrSW5uZXJCb3VuZCIsInZlcnRpY2FsU2lnbiIsImhvcml6b250YWxTaWduIiwibGluZUNvbnN0YW50cyIsImlzQWxsQm91bmQiLCJpc1ZlcnRpY2FsQm91bmQiLCJpc0hvcml6b250YWxCb3VuZCIsImxlZnRMaW5lIiwidG9wTGluZSIsInJpZ2h0TGluZSIsImJvdHRvbUxpbmUiLCJ0b3BCb3VuZEluZm8iLCJjaGVja0xpbmVCb3VuZENvbGxpc2lvbiIsImJvdHRvbUJvdW5kSW5mbyIsImxlZnRCb3VuZEluZm8iLCJyaWdodEJvdW5kSW5mbyIsImlzQWxsVmVydGljYWxCb3VuZCIsImlzQWxsSG9yaXpvbnRhbEJvdW5kIiwidmVydGljYWxPZmZzZXQiLCJtYXhPZmZzZXQiLCJob3Jpem9udGFsT2Zmc2V0IiwiYm91bmRMaW5lIiwiaXNSZW5kZXIiLCJkb3QxIiwiYm91bmREb3QxIiwiYm91bmREb3QyIiwiZHkyIiwiZHgyIiwiaGFzRHgiLCJoYXNEeSIsInNsb3BlIiwiZ2V0SW5uZXJCb3VuZEluZm8iLCJsaW5lSW5mb3MiLCJtdWx0aXBsZSIsInNpemVPZmZzZXQiLCJnZXRJbm5lckJvdW5kRHJhZ0luZm8iLCJsaW5lcyIsImdldENoZWNrSW5uZXJCb3VuZExpbmVJbmZvcyIsImlubmVyQm91bmRJbmZvIiwid2lkdGhPZmZzZXRJbmZvIiwiaGVpZ2h0T2Zmc2V0SW5mbyIsImdldENoZWNrU25hcExpbmVEaXJlY3Rpb25zIiwibGluZURpcmVjdGlvbnMiLCJ2aXJ0dWFsUG9zZXMiLCJkaXIxIiwiZGlyMiIsInZpcnR1YWxMaW5lIiwiaXNCb3VuZFJvdGF0ZSIsImJvdW5kRG90cyIsImdldERpc3RQb2ludExpbmUiLCJzb2x2ZVJldmVyc2VMaW5lIiwiY2hlY2tSb3RhdGVJbm5lckJvdW5kcyIsImRvdEluZm9zIiwibGluZVJhZCIsImxpbmVEaXN0IiwiZG90RGlzdCIsImRvdFJhZCIsImRpc3RSYWQiLCJhY29zIiwibmV4dFJhZDEiLCJuZXh0UmFkMiIsInJlZHVjZSIsInByZXYiLCJjdXIiLCJjaGVja0lubmVyQm91bmRQb3NlcyIsImJvdW5kTWFwIiwiZ2V0UmVjdCIsImxpbmVJbmZvIiwiaXNIb3Jpem9udGFsU3RhcnQiLCJpc1ZlcnRpY2FsU3RhcnQiLCJzb2x2ZUVxdWF0aW9uIiwic29sdmVOZXh0T2Zmc2V0IiwiaXNPdXRzaWRlIiwiZGlzdDEiLCJkaXN0MiIsIndpZHRoT2Zmc2V0IiwiaGVpZ2h0T2Zmc2V0IiwiZ2V0U25hcEJvdW5kIiwiYm91bmRJbmZvIiwiY2hlY2tUaHJvdHRsZURyYWdSb3RhdGUiLCJ0aHJvdHRsZURyYWdSb3RhdGUiLCJfaCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiYWRqdXN0UG9zZXMiLCJhZGp1c3RQb3MiLCJwcmV2RGlzdFkiLCJjaGVja1NuYXBCb3VuZHNEcmFnIiwiaWdub3JlU25hcCIsImdldEFic29sdXRlUG9zZXMiLCJhYnNvbHV0ZVBvc2VzIiwiYm91bmRQb3NlcyIsIm1pZGRsZSIsImNoZWNrTW92ZWFibGVTbmFwQm91bmRzIiwidmVydGljYWxTbmFwQm91bmRJbmZvIiwiaG9yaXpvbnRhbFNuYXBCb3VuZEluZm8iLCJ2ZXJ0aWNhbElubmVyQm91bmRJbmZvIiwiaG9yaXpvbnRhbElubmVyQm91bmRJbmZvIiwiaG9yaXpvbnRhbEJvdW5kSW5mb3MiLCJ2ZXJ0aWNhbEJvdW5kSW5mb3MiLCJob3Jpem9udGFsRGlzdCIsInZlcnRpY2FsRGlzdCIsInNuYXBJbmRleCIsInNuYXAiLCJjaGVja1NuYXBCb3VuZHMiLCJndWlkZWluZXMiLCJjaGVja1NuYXBSaWdodExpbmUiLCJzbmFwQm91bmRJbmZvIiwicmFkMTgwIiwiaXNIb3Jpem9udGFsTGluZSIsImlzVmVydGljYWxMaW5lIiwiZ2V0U25hcEJvdW5kSW5mbyIsImlzUmVxdWVzdCIsInN0YXJ0RGlyZWN0aW9uIiwiZW5kRGlyZWN0aW9uIiwib3RoZXJTdGFydFBvcyIsIm90aGVyRW5kUG9zIiwiY2hlY2tTbmFwQm91bmRzS2VlcFJhdGlvIiwib3RoZXJIb3Jpem9udGFsT2Zmc2V0IiwiaXNPdGhlckhvcml6b250YWxCb3VuZCIsImlzT3RoZXJIb3Jpem9udGFsU25hcCIsIm90aGVyVmVydGljYWxPZmZzZXQiLCJpc090aGVyVmVydGljYWxCb3VuZCIsImlzT3RoZXJWZXJ0aWNhbFNuYXAiLCJzbmFwTGluZSIsImdldFNuYXBCb3VuZE9mZnNldCIsImhvcml6b250YWxCb3VuZEluZm8iLCJ2ZXJ0aWNhbEJvdW5kSW5mbyIsImNoZWNrTWF4Qm91bmRzIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJsZWZ0XzEiLCJ0b3BfMSIsInJpZ2h0XzEiLCJib3R0b21fMSIsIm90aGVyRGlyZWN0aW9uIiwiaXNDaGVja1ZlcnRpY2FsIiwiaXNDaGVja0hvcml6b250YWwiLCJvdGhlclBvcyIsImRlZyIsIm5leHRPdGhlclBvcyIsImlzSGVpZ2h0T3V0c2lkZSIsImlzV2lkdGhPdXRzaWRlIiwicmVxdWVzdFN0eWxlIiwicmVxdWVzdENoaWxkU3R5bGUiLCJyZW5kZXIiLCJoaWRlVGhyb3R0bGVEcmFnUm90YXRlTGluZSIsImRyYWdJbmZvIiwiYmVmb3JlT3JpZ2luIiwic3RhcnRDaGVja1NuYXBEcmFnIiwicHJldkRpc3QiLCJwcmV2QmVmb3JlRGlzdCIsImRlbHRhT2Zmc2V0IiwicGFyYW1zIiwiZmlsbFBhcmFtcyIsInRyaWdnZXJFdmVudCIsInN0YXJ0UmVjdCIsInVzZVNuYXAiLCJpc0dyb3VwIiwicGFyZW50VGhyb3R0bGVEcmFnIiwicGFyZW50TW92ZWFibGUiLCJ0aHJvdHRsZURyYWciLCJkcmFnUm90YXRlUmFkIiwic3RhcnREcmFnUm90YXRlIiwicnkiLCJjb3MiLCJyeCIsInNpbiIsImJlZm9yZVRyYW5zbGF0ZSIsImJlZm9yZURpc3QiLCJiZWZvcmVEZWx0YSIsInBhc3NEZWx0YSIsInBhc3NEaXN0IiwibnVtIiwiZHJhZ0FmdGVyIiwiZHJhZ0VuZCIsInBhcmFtIiwiZmlsbEVuZFBhcmFtcyIsImRyYWdHcm91cFN0YXJ0IiwibmV4dFBhcmFtcyIsInRhcmdldHMiLCJ0aHJvdHRsZU9mZnNldCIsImRyYWdHcm91cCIsImRyYWdHcm91cEVuZCIsInJlcXVlc3QiLCJpc0NvbnRyb2wiLCJyZXF1ZXN0U3RhcnQiLCJ1bnNldCIsImdldEZpeGVkRGlyZWN0aW9uSW5mbyIsImdldE9mZnNldEZpeGVkRGlyZWN0aW9uSW5mbyIsIm5leHRGaXhlZE9mZnNldCIsImdldE9mZnNldEZpeGVkUG9zaXRpb25JbmZvIiwib2Zmc2V0Rml4ZWRQb3NpdGlvbiIsImRpcmVjdGlvbkNvbmRpdGlvbiQyIiwiZ2V0RGlyZWN0aW9uQ29uZGl0aW9uIiwiUmVzaXphYmxlIiwiYWJsZUdyb3VwIiwiY2FuUGluY2giLCJkcmFnQ29udHJvbENvbmRpdGlvbiIsInZpZXdDbGFzc05hbWUiLCJnZXREaXJlY3Rpb25WaWV3Q2xhc3NOYW1lIiwiZHJhZ0NvbnRyb2xTdGFydCIsInBhcmVudERpcmVjdGlvbiIsInBhcmVudEZpeGVkRGlyZWN0aW9uIiwiZ2V0VG90YWxEaXJlY3Rpb24iLCJyZXNpemFibGUiLCJzdGFydE9mZnNldFdpZHRoIiwic3RhcnRPZmZzZXRIZWlnaHQiLCJtaW5TaXplIiwic3RhcnRXaWR0aCIsImlubGluZUNTU1dpZHRoIiwiY3NzV2lkdGgiLCJzdGFydEhlaWdodCIsImlubGluZUNTU0hlaWdodCIsImNzc0hlaWdodCIsIm1heFNpemUiLCJtaW5PZmZzZXRXaWR0aCIsIm1pbk9mZnNldEhlaWdodCIsIm1heE9mZnNldFdpZHRoIiwibWF4T2Zmc2V0SGVpZ2h0Iiwic3RhcnRPZmZzZXRNYXRyaXgiLCJzdGFydFRyYW5zZm9ybU9yaWdpbiIsImlzV2lkdGgiLCJwYXJlbnRJc1dpZHRoIiwic2V0UmF0aW8iLCJpc0Zpbml0ZSIsInNldEZpeGVkRGlyZWN0aW9uIiwic2V0Rml4ZWRQb3NpdGlvbiIsInNldE1pbiIsInNldE1heCIsIm5leHRNYXhTaXplIiwic3RhcnRSYXRpbyIsInNldE9yaWdpbiIsInN0YXJ0Rml4ZWREaXJlY3Rpb24iLCJzdGFydEZpeGVkUG9zaXRpb24iLCJpc1Jlc2l6ZSIsInNuYXBSZW5kZXJJbmZvIiwiZHJhZ0NvbnRyb2wiLCJwYXJlbnRLZWVwUmF0aW8iLCJkcmFnQ2xpZW50IiwicGFyZW50RGlzdCIsInJlc29sdmVNYXRyaXgiLCJ0YXJnZXROIiwibmV4dEFsbE1hdHJpeCIsInJlc2l6ZUZvcm1hdCIsInRocm90dGxlUmVzaXplIiwia2VlcFJhdGlvRmluYWxseSIsInNpemVEaXJlY3Rpb24iLCJkaXN0V2lkdGgiLCJkaXN0SGVpZ2h0IiwiZ2V0TmV4dEJvdW5kaW5nU2l6ZSIsIm5leHRTaXplIiwiZ2V0T2Zmc2V0U2l6ZURpc3QiLCJuZXh0V2lkdGgiLCJuZXh0SGVpZ2h0IiwiYm91bmRpbmdXaWR0aCIsImJvdW5kaW5nSGVpZ2h0IiwibmV4dEZpeGVkRGlyZWN0aW9uIiwic2V0U2l6ZSIsInNuYXBEaXN0IiwiY2hlY2tTbmFwUmVzaXplIiwiY29tcHV0ZVNpemUiLCJpc05vU25hcCIsImludmVyc2VEZWx0YSIsImZpbGxBZnRlclRyYW5zZm9ybSIsImRyYWdDb250cm9sQWZ0ZXIiLCJjaGVja1Jlc2l6YWJsZUVycm9yIiwiZXJyb3JXaWR0aCIsImVycm9ySGVpZ2h0IiwiaXNFcnJvcldpZHRoIiwiaXNFcnJvckhlaWdodCIsImRyYWdDb250cm9sRW5kIiwiZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbiIsImRyYWdHcm91cENvbnRyb2xTdGFydCIsIm9yaWdpbmFsRXZlbnRzIiwicGFyZW50U3RhcnRPZmZzZXRXaWR0aCIsInBhcmVudFN0YXJ0T2Zmc2V0SGVpZ2h0IiwidXBkYXRlR3JvdXBNaW4iLCJvcmlnaW5hbE1pblNpemUiLCJjaGlsZE1pblNpemUiLCJjaGlsZFN0YXJ0T2Zmc2V0V2lkdGgiLCJjaGlsZFN0YXJ0T2Zmc2V0SGVpZ2h0IiwicGFyZW50TWluV2lkdGgiLCJwYXJlbnRNaW5IZWlnaHQiLCJ1cGRhdGVHcm91cE1heCIsIm9yaWdpbmFsTWF4U2l6ZSIsImNoaWxkTWF4U2l6ZSIsInBhcmVudE1heFdpZHRoIiwicGFyZW50TWF4SGVpZ2h0IiwiZHJhZ0dyb3VwQ29udHJvbCIsImNhdGNoRXZlbnQiLCJwYXJlbnRTY2FsZSIsImRyYWdHcm91cENvbnRyb2xFbmQiLCJkZWx0YVdpZHRoIiwiZGVsdGFIZWlnaHQiLCJzZXRSb3RhdGVTdGFydEluZm8iLCJzdGFydEFic29sdXRlT3JpZ2luIiwicHJldkRlZyIsImRlZmF1bHREZWciLCJwcmV2U25hcERlZyIsImxvb3AiLCJzdGFydERpc3QiLCJnZXRBYnNvbHV0ZURpc3QiLCJub3JtYWxpemVkUHJldkRlZyIsImZsb29yIiwiZ2V0QWJzb2x1dGVEaXN0QnlDbGllbnQiLCJnZXRSb3RhdGVJbmZvIiwibW92ZWFibGVSZWN0IiwidGhyb3R0bGVSb3RhdGUiLCJzbmFwUm90YXRpb24iLCJjaGVja1NuYXBSb3RhdGUiLCJzbmFwRGVnIiwiZ2V0Um90YXRpb25Qb3NpdGlvbnMiLCJyb3RhdGlvblBvc2l0aW9uIiwicmFkUG9zZXMiLCJnZXRSb3RhdGlvblJhZCIsImlzUmV2ZXJzZSIsInJlcXVlc3RBYmxlIiwicm90YXRlQXJvdW5kQ29udHJvbHMiLCJyb3RhdGlvblRhcmdldCIsImdldFJlZlRhcmdldHMiLCJjb250YWlucyIsImNzcyIsIlJvdGF0YWJsZSIsImlzRHJhZ2dpbmciLCJyb3RhdGFibGUiLCJyZXNvbHZlQWJsZXNXaXRoUm90YXRhYmxlIiwicG9zaXRpb25zIiwianN4cyIsImFibGVzIiwicmVzb2x2ZU1hcF8xIiwiZGlyZWN0aW9uQ29udHJvbEluZm9zIiwicmVzb2x2ZSIsInBhcmVudFJvdGF0ZSIsImJlZm9yZURpcmVjdGlvbiIsInJlc2l6ZVN0YXJ0Iiwic3RhcnRDbGllbnRYIiwic3RhcnRDbGllbnRZIiwiZXh0ZXJuYWxSb3RhdGUiLCJiZWZvcmVJbmZvIiwiYWZ0ZXJJbmZvIiwiYWJzb2x1dGVJbmZvIiwiaW5wdXRUYXJnZXQiLCJyZWdpb25EaXJlY3Rpb24iLCJnZXRBdHRyaWJ1dGUiLCJjb250cm9sRGlyZWN0aW9uIiwiaXNBcm91bmRDb250cm9sIiwicmVzb2x2ZUFibGUiLCJjbGllbnRQb3NlcyIsImNhbGN1bGF0ZU1vdmVhYmxlQ2xpZW50UG9zaXRpb25zIiwib3JpZ2luYWxGaXhlZFBvc2l0aW9uXzEiLCJmaXhlZEJlZm9yZU9yaWdpbiIsImZpeGVkQWZ0ZXJPcmlnaW4iLCJwb3NEZWx0YSIsInBhcmVudFBvc2l0aW9uIiwiY29udHJvbFBvc2l0aW9uIiwicGFyZW50Rml4ZWRQb3NpdGlvbiIsImdldFRvdGFsT3JpZ2luIiwicm90YXRhdGlvbiIsImlzUm90YXRlIiwiY2xpZW50RGlzdFgiLCJjbGllbnREaXN0WSIsImdyb3VwRGVsdGEiLCJ0YXJnZXREaXJlY3Rpb24iLCJiZWZvcmVSb3RhdGlvbiIsImFic29sdXRlRGVsdGEiLCJhYnNvbHV0ZURpc3QiLCJhYnNvbHV0ZVJvdGF0aW9uIiwic3RhcnRSb3RhdGlvbiIsImFic29sdXRlU3RhcnRSb3RhdGlvbiIsIm5leHRDbGllbnRYIiwibmV4dENsaWVudFkiLCJzZXRSb3RhdGlvbiIsIm5leHRSb3RhdGlvbiIsImludmVyc2VEaXN0IiwicHJldkludmVyc2VEaXN0IiwicmVxdWVzdFZhbHVlIiwiZHJhZ0V2ZW50IiwidHJhbnNmb3JtRXZlbnQiLCJwYXJlbnREaXN0YW5jZSIsInJlc2l6ZSIsInJlc2l6ZUV2ZW50IiwiYmVmb3JlUm90YXRlIiwiYWJzb2x1dGVSb3RhdGUiLCJwYXJlbnRMZWZ0IiwicGFyZW50VG9wIiwicGFyZW50QmVmb3JlT3JpZ2luIiwiY2hpbGRDbGllbnQiLCJzdGFydEdyb3VwQ2xpZW50IiwiZ3JvdXBDbGllbnQiLCJwcmV2Q2xpZW50WCIsInByZXZDbGllbnRZIiwic2V0R3JvdXBSb3RhdGlvbiIsImRpc3RSb3RhdGUiLCJnZXRSb3RhdGlvbiIsImRlbHRhUm90YXRlIiwicmVuZGVyR3VpZGVsaW5lIiwiaXNIb3Jpem9udGFsIiwic2NhbGVUeXBlIiwicmVuZGVySW5uZXJHdWlkZWxpbmUiLCJzaXplVmFsdWUiLCJwb3NWYWx1ZSIsInJlbmRlclNuYXBQb3NlcyIsInJlbmRlclBvcyIsInJlbmRlckd1aWRlbGluZXMiLCJ0YXJnZXRSZWN0IiwiaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQiLCJtYWluTmFtZXMiLCJ0YXJnZXRTdGFydCIsInRhcmdldEVuZCIsImhpZGUiLCJlbGVtZW50UmVjdCIsInJlbmRlckRpZ2l0TGluZSIsImxpbmVUeXBlIiwiZ2FwIiwic25hcERpZ2l0IiwiaXNEaXNwbGF5U25hcERpZ2l0Iiwic25hcERpc3RGb3JtYXQiLCJzaXplTmFtZSIsImFic0dhcCIsInNuYXBTaXplIiwidG9GaXhlZCIsImdyb3VwQnlFbGVtZW50R3VpZGVsaW5lcyIsIm90aGVySW5kZXgiLCJuYW1lcyIsImdyb3VwQnkiLCJuZXh0R3VpZGVsaW5lcyIsImlubmVyIiwiZWxlbWVudFJlY3QxIiwiZWxlbWVudFJlY3QyIiwibmV4dFBvczEiLCJuZXh0UG9zMiIsImVsZW1lbnREaXJlY3Rpb24iLCJ0b3RhbCIsInJlbmRlckRhc2hlZEd1aWRlbGluZXMiLCJyZW5kZXJlZCIsImdyb3VwcyIsInNpZGVOYW1lcyIsInNpZGVQb3MiLCJwcmV2UmVjdCIsIm5leHRSZWN0Iiwic2l6ZTEiLCJzaXplMiIsInJlbmRlclBvczEiLCJyZW5kZXJQb3MyIiwicmVuZGVyR2FwR3VpZGVsaW5lcyIsInRhcmdldFNpZGVTdGFydCIsInRhcmdldFNpZGVFbmQiLCJnYXBSZWN0cyIsInNpZGVTdGFydFBvcyIsInNpZGVFbmRQb3MiLCJzaWRlQ2VudGVyUG9zIiwiZ2V0VG90YWxHdWlkZWxpbmVzIiwib3ZlcmZsb3ciLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxXaWR0aCIsImNvbnRhaW5lckNsaWVudEhlaWdodCIsImNvbnRhaW5lckNsaWVudFdpZHRoIiwic25hcEdhcCIsIm1heFNuYXBFbGVtZW50R3VpZGVsaW5lRGlzdGFuY2UiLCJpc0Rpc3BsYXlHcmlkR3VpZGVsaW5lcyIsImVsZW1lbnRHdWlkZWxpbmVzIiwiZ2V0RWxlbWVudEd1aWRlbGluZXMiLCJ0b3RhbEd1aWRlbGluZXMiLCJnZXRHYXBHdWlkZWxpbmVzIiwiZ2V0R3JpZEd1aWRlbGluZXMiLCJnZXREZWZhdWx0R3VpZGVsaW5lcyIsImNoZWNrQmV0d2VlblJlY3RzIiwic25hcFRocmVzaG9sZHMiLCJtYXhTbmFwRWxlbWVudEdhcERpc3RhbmNlIiwiZWxlbWVudFJlY3RzIiwiZ2FwR3VpZGVsaW5lcyIsInRhcmdldENlbnRlciIsInRhcmdldFN0YXJ0MiIsInRhcmdldEVuZDIiLCJzbmFwVGhyZXNob2xkTWFwIiwibmV4dEVsZW1lbnRSZWN0cyIsInNuYXBSZWN0MSIsInNuYXBSZWN0MiIsInJlY3QxIiwicmVjdDIiLCJyZWN0MVN0YXJ0IiwicmVjdDFFbmQiLCJyZWN0MlN0YXJ0IiwicmVjdDJFbmQiLCJpc0NlbnRlciIsInN0YXJ0R3JpZEdyb3VwR3VpZGVsaW5lcyIsInNuYXBHcmlkQWxsIiwiaGFzRGlyZWN0aW9uIiwicmVjdF8xIiwiY2hpbGRyZW5fMSIsImNoaWxkcmVuIiwicG9zTmFtZSIsImNsaWVudE9mZnNldCIsInJlY3RTaXplIiwicmVjdFBvcyIsImNoaWxkU2l6ZXMiLCJmaXJzdENoaWxkU2l6ZSIsImNoaWxkU25hcFNpemVzIiwicmVjdFJhdGlvIiwiY2hpbGRTaXplIiwic3RhcnRPZmZzZXQiLCJkZWZhdWx0U25hcEdyaWRXaWR0aCIsImRlZmF1bHRTbmFwR3JpZEhlaWdodCIsInB1c2hHdWlkZWxpbmUiLCJncmlkIiwiZGlzdGFuY2UiLCJwcmV2VmFsdWVzIiwic25hcFJlY3QiLCJyZWZyZXNoIiwibmV4dEVsZW1lbnRHdWlkZWxpbmVzIiwiZ2V0UmVmVGFyZ2V0IiwibWFpbnRhaW5lZCIsImFkZGVkIiwibmV4dFZhbHVlcyIsInByZXZJbmRleCIsImdldFNuYXBFbGVtZW50UmVjdHMiLCJlbGVtZW50U25hcERpcmVjdGlvbnMiLCJ0b3BWYWx1ZSIsImxlZnRWYWx1ZSIsInJpZ2h0VmFsdWUiLCJib3R0b21WYWx1ZSIsImNlbnRlclZhbHVlIiwibWlkZGxlVmFsdWUiLCJyZWN0VG9wIiwicmVjdExlZnQiLCJzaXplcyIsImdldE9iamVjdEd1aWRlbGluZXMiLCJjb250YWluZXJTaXplIiwicG9zR3VpZGVsaW5lIiwic25hcFdpZHRoIiwic25hcEhlaWdodCIsInZhbHVlcyIsIm9mZnNldERlbHRhIiwiY29udGFpbmVyTGVmdCIsImNvbnRhaW5lclRvcCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsZW1lbnRMZWZ0IiwiZWxlbWVudFRvcCIsImVsZW1lbnRSaWdodCIsImVsZW1lbnRCb3R0b20iLCJjaGVja1NuYXBJbmZvIiwic25hcENvbnRhaW5lciIsInNuYXBDb250YWluZXJUYXJnZXQiLCJzbmFwQ29udGFpbmVyUmVjdCIsIm9mZnNldDEiLCJnZXREcmFnRGlzdEJ5U3RhdGUiLCJvZmZzZXQyIiwiZ2V0TmV4dEZpeGVkUG9zZXMiLCJuZXh0Rml4ZWRQb3MiLCJub3JtYWxpemVkIiwiZ2V0U2l6ZU9mZnNldEluZm8iLCJpbm5lckJvdW5kTGluZUluZm9zIiwicmVjaGVja1NpemVCeVR3b0RpcmVjdGlvbiIsInNuYXBQb3MiLCJuZXh0V2lkdGhPZmZzZXQiLCJuZXh0SGVpZ2h0T2Zmc2V0IiwiY2hlY2tTaXplRGlzdCIsImdldE5leHRQb3NlcyIsImlzV2lkdGhCb3VuZCIsImlzSGVpZ2h0Qm91bmQiLCJ3aWR0aERpc3QiLCJoZWlnaHREaXN0IiwiaXNHZXRXaWR0aE9mZnNldCIsImJ1bXBEZWdyZWUiLCJiYXNlRGVnIiwiY291bnQiLCJkZWcxIiwiZGVnMiIsImdldE1pbkRlZ3JlZURpc3RhbmNlIiwiZGVnMyIsInNuYXBSb3RhdGlvblRocmVzaG9sZCIsInNuYXBSb3RhdGlvbkRlZ3JlZXMiLCJvcmlnaW4yXzEiLCJyYWRfMSIsInNvcnRlZCIsImZpcnN0RGVncmVlIiwiY2hlY2tTbmFwU2NhbGUiLCJzaXplRGlzdCIsImdldFNuYXBHdWlkZWxpbmVzIiwiYWRkQm91bmRHdWlkZWxpbmVzIiwidmVydGljYWxTbmFwUG9zZXMiLCJob3Jpem9udGFsU25hcFBvc2VzIiwiaW5uZXJCb3VuZE1hcCIsInZlcnRpY2FsSW5uZXJCb3VuZFBvc2VzIiwiaG9yaXpvbnRhbElubmVyQm91bmRQb3NlcyIsImlubmVyUG9zIiwiZGlyZWN0aW9uQ29uZGl0aW9uJDEiLCJTbmFwcGFibGUiLCJkcmFnUmVsYXRpb24iLCJ0YXJnZXRUb3AiLCJ0YXJnZXRMZWZ0Iiwic25hcFJlbmRlclRocmVzaG9sZCIsIndhdGNoVmFsdWUiLCJKU09OIiwic3RyaW5naWZ5IiwibWluTGVmdCIsIm1pblRvcCIsImV4dGVybmFsUG9zZXMiLCJzbmFwSW5mb3MiLCJoYXNFeHRlcm5hbFBvc2VzIiwiZXh0ZXJuYWxSZWN0IiwidmVydGljYWxQb3NJbmZvcyIsImhvcml6b250YWxQb3NJbmZvcyIsImFsbEd1aWRlbGluZXMiLCJlbGVtZW50cyIsImdhcHMiLCJuZXh0Qm91bmRNYXAiLCJuZXh0SW5uZXJCb3VuZE1hcCIsInBpbmNoU3RhcnQiLCJtdWx0aXBseTIiLCJkZWZhdWx0U3luYyIsImZuIiwibWVhc3VyZVNWR1NpemUiLCJ2aWV3Qm94IiwiZ2V0U1ZHVmlld0JveCIsImdldEJlZm9yZVRyYW5zZm9ybU9yaWdpbiIsInJlbGF0aXZlT3JpZ2luIiwiZ2V0VHJhbnNmb3JtT3JpZ2luIiwiZ2V0VHJhbnNmb3JtT3JpZ2luQXJyYXkiLCJjb21wdXRlZFRyYW5zZm9ybSIsImxpc3QiLCJiYXNlVmFsIiwiX2xvb3BfMSIsImNociIsImxhc3RQYXJlbnQiLCJpc1BhcmVudCIsImNoZWNrWm9vbSIsImdldFRhcmdldFN0eWxlIiwiaGFzU2xvdCIsImFzc2lnbmVkU2xvdFBhcmVudEVsZW1lbnQiLCJhc3NpZ25lZFNsb3QiLCJ0YXJnZXRQb3NpdGlvbiIsIndpbGxDaGFuZ2UiLCJzbG90UGFyZW50Tm9kZSIsInBhcmVudE5vZGUiLCJ0YXJnZXRQYXJlbnROb2RlIiwiaG9zdCIsImdldFNWR0dyYXBoaWNzT2Zmc2V0IiwiZ2V0Qm9keVN0eWxlIiwiYm9keVBvc2l0aW9uIiwibWFyZ2luTGVmdCIsIm1hcmdpblRvcCIsImJvZHkiLCJtYWtlTWF0cml4Q1NTIiwidmlld0JveFdpZHRoIiwidmlld0JveEhlaWdodCIsInNjYWxlWCIsInNjYWxlWSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJhbGlnbiIsIm1lZXRPclNsaWNlIiwic3ZnT3JpZ2luIiwieEFsaWduIiwieUFsaWduIiwic2NhbGVEaW1lbnNpb24iLCJpc0dUYXJnZXQiLCJnZXRCQm94IiwiaXNGaWxsQm94IiwiYmJveCIsInJlY3RXaWR0aCIsInJlY3RIZWlnaHQiLCJjYWxjdWxhdGVSZWN0IiwiZ2V0U1ZHT2Zmc2V0IiwidGFyZ2V0SW5mbyIsImdldFNpemUiLCJtYXQiLCJwcmV2TGVmdCIsInByZXZUb3AiLCJwb3NPcmlnaW4iLCJyZWN0T3JpZ2luIiwibWF0MiIsIm5leHRMZWZ0IiwibmV4dFRvcCIsImRpc3RMZWZ0IiwiZGlzdFRvcCIsInJvb3RDbGllbnRSZWN0Iiwicm9vdFBvc2VzIiwiZ2V0RGlhZ29uYWxTaXplIiwic2VsZiIsImNvbnRlbnRXaWR0aCIsImNvbnRlbnRIZWlnaHQiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsInN2ZyIsInRhcmdldFN0eWxlIiwiYm94U2l6aW5nIiwiYm9yZGVyTGVmdCIsImJvcmRlclJpZ2h0IiwiYm9yZGVyVG9wIiwiYm9yZGVyQm90dG9tIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImhvcml6b250YWxQYWRkaW5nIiwidmVydGljYWxQYWRkaW5nIiwiaG9yaXpvbnRhbEJvcmRlciIsInZlcnRpY2FsQm9yZGVyIiwiZ2V0UGFyZW50U3R5bGUiLCJyZXNldENsaWVudFJlY3QiLCJnZXRFeHRlbmRzUmVjdCIsImlzUm9vdCIsImV4dGVuZHNSZWN0IiwiZ2V0Q2xpZW50UmVjdEJ5UG9zaXRpb24iLCJiYXNlIiwiaXNFeHRlbmRzIiwiYmFzZVRvcCIsImJhc2VMZWZ0IiwiY29udmVydFRyYW5zZm9ybU9yaWdpbkFycmF5IiwiZ2V0RGlyZWN0aW9uIiwiZGlyZWNpdG9uIiwidW5zZXRBYmxlcyIsInVuc2V0R2VzdG8iLCJnZXN0b05hbWUiLCJnZXN0byIsImlzSWRsZSIsInJlc29sdmVkRXZlbnQiLCJjc3NUZXh0IiwicHJldkV2ZW50IiwibmV4dEV2ZW50IiwiaXNCZWZvcmVFdmVudCIsImN1cnJlbnRUYXJnZXQiLCJpc1RydXN0ZWQiLCJzdG9wQWJsZSIsImlzRXZlbnRTdGFydCIsInN0b3BEcmFnIiwic3RvcCIsImlzU3RhcnRFdmVudCIsImxhc3RFdmVudCIsImlzRG91YmxlIiwiX2VtaXR0ZXIiLCJvbiIsImlzTWFuYWdlciIsInBzZXVkb0VsdCIsImZpbHRlckFibGVzIiwibWV0aG9kcyIsInRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5IiwiZW5hYmxlZEFibGVzIiwiYWJsZUdyb3VwcyIsIm1ldGhvZCIsImVxdWFscyIsImExIiwiYTIiLCJncm91cEtleXMiLCJncm91cEtleSIsImtleUluZGV4IiwiZ3JvdXAiLCJncm91cEJ5TWFwIiwiYXJncyIsImNhbGN1bGF0ZVBhZGRpbmciLCJ4QWRkZWQiLCJ5QWRkZWQiLCJuZXh0QWRkZWQiLCJjb252ZXJ0Q1NTU2l6ZSIsImlzUmVsYXRpdmUiLCJjaGVja0FibGVzIiwidHJhbnNmb3JtcyIsIm1hdHJpeEluZm9zIiwiYmVmb3JlRnVuY3Rpb25UZXh0czIiLCJ0YXJnZXRGdW5jdGlvblRleHQiLCJhZnRlckZ1bmN0aW9uVGV4dHMyIiwiYmVmb3JlRnVuY3Rpb25zIiwiYmVmb3JlRnVuY3Rpb25zMiIsImFmdGVyRnVuY3Rpb25zIiwiYWZ0ZXJGdW5jdGlvbnMyIiwidGFyZ2V0RnVuY3Rpb25zIiwiaXNBcnJheUZvcm1hdCIsImlzU2VsZWN0b3IiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJjdXJyZW50IiwidXNlclRhcmdldHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0QWJzb2x1dGVSb3RhdGlvbiIsImdldFNpemVEaXN0QnlEaXN0Iiwic3RhcnRTaXplIiwic3RhbmRhcmRSYWQiLCJzaWduU2l6ZSIsInN0YXJ0V2lkdGhTaXplIiwic3RhcnRIZWlnaHRTaXplIiwic2Vjb25kUmFkIiwiYXRhbjIiLCJmaXJzdFJhZCIsImRpc3RTaXplIiwicGluY2hTY2FsZSIsImRpcmVjdGlvbnNEaXN0cyIsImRpcmVjdGlvblJhdGlvcyIsInJhdGlvRGlzdGFuY2UiLCJkaXN0XzEiLCJjb252ZXJ0VHJhbnNmb3JtVW5pdCIsInh5IiwibGVmdE9yaWdpbiIsInJpZ2h0T3JpZ2luIiwib3JpZ2luT2JqZWN0IiwibmV4dE9yaWdpbk9iamVjdCIsInJvdGF0ZVBvc2VzSW5mbyIsImlzRGVlcEFycmF5RXF1YWxzIiwiYXJyMSIsImFycjIiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJpc0FycmF5MSIsImlzQXJyYXkyIiwibmV4dFZhbHVlIiwidmFsdWVLZXkiLCJkZWZhdWx0VmFsdWUiLCJzdG9yZSIsIl9zdG9yZSIsInByZXZWYWx1ZSIsImNvdW50RWFjaCIsImdldFBhZGRpbmdCb3giLCJwYWRkaW5nIiwiUGluY2hhYmxlIiwiYW5nbGUiLCJwaW5jaGFibGUiLCJldmVudE5hbWUiLCJjb250cm9sRXZlbnROYW1lIiwicGluY2hBYmxlcyIsImNvbnRyb2xBYmxlcyIsImFibGVFdmVudCIsInBpbmNoIiwicGluY2hFbmQiLCJwaW5jaEdyb3VwU3RhcnQiLCJwaW5jaEdyb3VwIiwicGluY2hHcm91cEVuZCIsImRpcmVjdGlvbkNvbmRpdGlvbiIsIlNjYWxhYmxlIiwic2V0TWluU2NhbGVTaXplIiwibWluU2NhbGVTaXplIiwic2V0TWF4U2NhbGVTaXplIiwibWF4U2NhbGVTaXplIiwiaXNTY2FsZSIsInRocm90dGxlU2NhbGUiLCJ0ZW1wU2NhbGVWYWx1ZSIsImdldE5leHRTY2FsZSIsInN0YXRlRGlyZWN0aW9uIiwic2V0U2NhbGUiLCJuZXh0U2NhbGUiLCJkaXN0U2lnbiIsImlzU2VsZlBpbmNoIiwic3RhcnRPZmZzZXRTaXplIiwic2NhbGVTaXplIiwiZGlzdFRleHQiLCJzY2FsZVRleHQiLCJpc1plcm9TY2FsZSIsInNjYWxlRW5kUGFyYW0iLCJtb3ZlYWJsZVNjYWxlIiwiZ2V0TWlkZGxlTGluZVBvcyIsImdldFRyaWFuZ2xlUmFkIiwicmFkMSIsInJhZDIiLCJpc1ZhbGlkUG9zIiwicG9zZXMxIiwicG9zZXMyIiwicGkiLCJXYXJwYWJsZSIsInNjYWxhYmxlIiwid2FycGFibGUiLCJsaW5lUG9zRnJvbTEiLCJsaW5lUG9zRnJvbTIiLCJsaW5lUG9zRnJvbTMiLCJsaW5lUG9zRnJvbTQiLCJsaW5lUG9zVG8xIiwibGluZVBvc1RvMiIsImxpbmVQb3NUbzMiLCJsaW5lUG9zVG80Iiwid2FycFRhcmdldE1hdHJpeCIsInRhcmdldEludmVyc2VNYXRyaXgiLCJwcmV2TWF0cml4IiwicG9zSW5kZXhlcyIsImlzV2FycCIsInNlbGVjdGVkUG9zZXMiLCJuZWFyQnlQb3NlcyIsImgiLCJhZnRlck1hdHJpeCIsInRvdGFsTWF0cml4IiwiQVJFQV9QSUVDRVMiLCJBUkVBX1BJRUNFIiwiQVZPSUQiLCJWSUVXX0RSQUdHSU5HIiwicmVzdG9yZVN0eWxlIiwiYXJlYUVsZW1lbnQiLCJyZW5kZXJQaWVjZXMiLCJEcmFnQXJlYSIsImRyYWdBcmVhIiwicGFzc0RyYWdBcmVhIiwiaXNEcmFnQXJlYSIsInJlY3RzIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiZGlzYWJsZU5hdGl2ZUV2ZW50IiwiZW5hYmxlTmF0aXZlRXZlbnQiLCJPcmlnaW4iLCJvcmlnaW5TdHlsZSIsImdldERlZmF1bHRTY3JvbGxQb3NpdGlvbiIsInNjcm9sbENvbnRhaW5lciIsIlNjcm9sbGFibGUiLCJnZXRDb250YWluZXIiLCJzY3JvbGxPcHRpb25zIiwiZHJhZ1Njcm9sbCIsInNjcm9sbENvbnRhaW5lckVsZW1lbnQiLCJzY3JvbGxCeSIsImdldEN1cnJlbnRFdmVudCIsImNoZWNrU2Nyb2xsIiwic2Nyb2xsVGhyZXNob2xkIiwic2Nyb2xsVGhyb3R0bGVUaW1lIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJ0aHJvdHRsZVRpbWUiLCJkcmFnR3JvdXBDb250cm9FbmQiLCJEZWZhdWx0IiwiUGFkZGluZyIsInBhZGRpbmdEaXJlY3Rpb25zIiwicGFkZGluZ1BvczEiLCJwYWRkaW5nUG9zMiIsInBhZGRpbmdQb3MzIiwicGFkZGluZ1BvczQiLCJSQURJVVNfRElSRUNUSU9OUyIsImNhbGN1bGF0ZVJhdGlvIiwic3VtU2l6ZSIsInN1bVJhdGlvIiwiSE9SSVpPTlRBTF9SQURJVVNfT1JERVIiLCJWRVJUSUNBTF9SQURJVVNfT1JERVIiLCJIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TIiwiVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlMiLCJnZXRSYWRpdXNTdHlsZXMiLCJjbGlwU3R5bGVzIiwicmFkaXVzUG9zZXMiLCJ2aXJ0dWFsIiwicmF3cyIsInJhd1BvcyIsInN0eWxlcyIsImdldFJhZGl1c1JhbmdlIiwiY29udHJvbFBvc2VzIiwiaG9yaXpvbnRhbFJhbmdlIiwidmVydGljYWxSYW5nZSIsImNsaXBQb3NlIiwic3ViIiwiZ2V0UmFkaXVzVmFsdWVzIiwibWluQ291bnRzIiwiZnVsbCIsInNwbGl0SW5kZXgiLCJzcGxpdExlbmd0aCIsImhvcml6b250YWxWYWx1ZXMiLCJ2ZXJ0aWNhbFZhbHVlcyIsImhvcml6b250YWxWYWx1ZXNMZW5ndGgiLCJ2ZXJ0aWNhbFZhbHVlc0xlbmd0aCIsImhhc1ZlcnRpY2FsVmFsdWVzIiwibndWYWx1ZSIsIm5lVmFsdWUiLCJzZVZhbHVlIiwiX2oiLCJzd1ZhbHVlIiwiX2siLCJfbCIsInduVmFsdWUiLCJfbSIsImVuVmFsdWUiLCJfbyIsImVzVmFsdWUiLCJfcCIsIndzVmFsdWUiLCJob3Jpem9udGFsUmF3UG9zZXMiLCJ2ZXJ0aWNhbFJhd1Bvc2VzIiwibmV4dEhvcml6b250YWxQb3NlcyIsIm5leHRWZXJ0aWNhbFBvc2VzIiwicmF3IiwicmVtb3ZlUmFkaXVzUG9zIiwic3RhcnRJbmRleCIsInJhZGl1c2xJbmRleCIsImRlbGV0ZUNvdW50IiwiYWRkUmFkaXVzUG9zIiwiaG9yaXpvbnRhbEluZGV4IiwidmVydGljYWxJbmRleCIsInJhZGl1c1giLCJyYWRpdXNZIiwic3RhcnRWZXJ0aWNhbEluZGV4Iiwic3BsaXRSYWRpdXNQb3NlcyIsImhvcml6b250YWxzIiwidmVydGljYWxzIiwiQ0xJUF9ESVJFQ1RJT05TIiwiQ0xJUF9SRUNUX0RJUkVDVElPTlMiLCJnZXRDbGlwU3R5bGVzIiwiY2xpcFBhdGgiLCJjbGlwUmVsYXRpdmUiLCJjbGlwVHlwZSIsImNsaXBQb3NlcyIsImlzUmVjdCIsImlzQ2lyY2xlIiwic3ViV2lkdGgiLCJzdWJIZWlnaHQiLCJnZXRSZWN0UG9zZXMiLCJkaXJ4IiwiZGlyeSIsImdldENvbnRyb2xTaXplIiwieFJhbmdlIiwieVJhbmdlIiwiZ2V0Q2xpcFBhdGgiLCJkZWZhdWx0Q2xpcCIsImN1c3RvbUNsaXAiLCJjbGlwVGV4dCIsImNsaXBQcmVmaXgiLCJzcGxpdHRlciIsInhQb3MiLCJ5UG9zIiwibWluTWF4cyIsIm1pblgiLCJtYXhYIiwibWluWSIsIm1heFkiLCJyYWRpdXNYXzEiLCJyYWRpdXNZXzEiLCJyYWRpdXMiLCJ4UmFkaXVzIiwieVJhZGl1cyIsImNlbnRlclBvc18xIiwicm91bmRJbmRleCIsInJlY3RMZW5ndGgiLCJyYWRpdXNWYWx1ZXMiLCJfcSIsIl9yIiwiX3MiLCJ0b3BfMiIsIl90IiwibmV4dFJpZ2h0IiwibmV4dEJvdHRvbSIsIl91IiwidG9wXzMiLCJtb3ZlQ29udHJvbFBvcyIsImRpc3RzIiwidmVydGljYWxEaXJlY3Rpb25zIiwiaG9yaXpvbnRhbERpcmVjdGlvbnMiLCJ2ZXJ0aWNhbERpcmVjdGlvbl8xIiwiaG9yaXpvbnRhbERpcmVjdGlvbl8xIiwiZml4ZWRJbmRleCIsIm5leHREaXN0IiwibmV4dENvbnRyb2xQb3Nlc18xIiwiY29udHJvbFBvc2UiLCJjb250cm9sRGlyIiwiZGlyRGlyIiwiZGlySG9yaXpvbnRhbCIsImRpclZlcnRpY2FsIiwiYWRkQ2xpcFBhdGgiLCJjbGlwSW5kZXgiLCJjbGlwU3R5bGUiLCJjbGlwRXZlbnRUeXBlIiwicmVtb3ZlQ2xpcFBhdGgiLCJDbGlwcGFibGUiLCJjdXN0b21DbGlwUGF0aCIsImRlZmF1bHRDbGlwUGF0aCIsImNsaXBBcmVhIiwiY2xpcFBhdGhTdGF0ZSIsInNuYXBCb3VuZEluZm9zIiwiY2FsY3VsYXRlZFBvcyIsImNvbnRyb2xzIiwiaXNJbnNldCIsImlzUG9seWdvbiIsImxpbmVQb3Nlc18xIiwiY2xpcExlZnQiLCJjbGlwVG9wIiwiZWxsaXBzZUNsaXBQYXRoIiwicGllY2UiLCJhcmVhUG9zZXMiLCJhbGxXaWR0aCIsImFsbEhlaWdodCIsImFsbExlZnRfMSIsImFsbFRvcF8xIiwiZGlyZWN0aW9uVHlwZSIsInNuYXBQb3MxIiwic25hcFBvczIiLCJkcmFnV2l0aENsaXAiLCJpc0RyYWdUYXJnZXQiLCJpc0NsaXBTdGFydCIsImlzTGluZSIsImlzQXJlYSIsIm9yaWdpbmFsRHJhZ2dhYmxlIiwib3JpZ2luYWxEaXN0IiwiZmlyc3REaXN0IiwiaXNEcmFnV2l0aFRhcmdldCIsImlzQWxsIiwiZ3VpZGVQb3NlcyIsImlzRWxsaXBzZSIsImd1aWRlUmVjdCIsImNsaXBIb3Jpem9udGFsR3VpZGVsaW5lcyIsImNsaXBWZXJ0aWNhbEd1aWRlbGluZXMiLCJndWlkZVhQb3NlcyIsImd1aWRlWVBvc2VzIiwicmVjdFBvc2VzIiwicmVjdERpc3RzXzEiLCJib3VuZERlbHRhIiwiY2xpcFRhcmdldEJvdW5kcyIsInNuYXBPZmZzZXRZIiwic25hcE9mZnNldFgiLCJkaXN0U25hcFgiLCJkaXN0U25hcFkiLCJ3aWR0aF8xIiwiaGVpZ2h0XzEiLCJuZXh0Q29udHJvbFBvc2VzXzIiLCJqIiwibmV4dENsaXBTdHlsZXMiLCJkcmFnRGlzdCIsIk9yaWdpbkRyYWdnYWJsZSIsInN0YXJ0T3JpZ2luIiwic3RhcnRUYXJnZXRPcmlnaW4iLCJpc0RyYWdPcmlnaW4iLCJvcmlnaW5SZWxhdGl2ZSIsImRpc3RPcmlnaW4iLCJkcmFnRGVsdGEiLCJkZWx0YU9yaWdpbiIsImFkZEJvcmRlclJhZGl1c0J5TGluZSIsImxpbmVJbmRleCIsImhvcml6b250YWxzTGVuZ3RoIiwidmVydGljYWxzTGVuZ3RoIiwiY29udHJvbEluZGV4IiwiY29udHJvbFBvc2VJbmZvIiwiYWRkQm9yZGVyUmFkaXVzIiwicmVtb3ZlQm9yZGVyUmFkaXVzIiwiZ2V0Qm9yZGVyUmFkaXVzIiwiYm9yZGVyUmFkaXVzIiwidHJpZ2dlclJvdW5kRXZlbnQiLCJyb3VuZFJlbGF0aXZlIiwiYm9yZGVyUmFkaXVzU3RhdGUiLCJnZXRTdHlsZUJvcmRlclJhZGl1cyIsImZpcnN0TW92ZWFibGUiLCJmaXJzdFRhcmdldCIsImdldFRhcmdldHMiLCJSb3VuZGFibGUiLCJyb3VuZENsaWNrYWJsZSIsIm1pblJvdW5kQ29udHJvbHMiLCJtYXhSb3VuZENvbnRyb2xzIiwicm91bmRQYWRkaW5nIiwiaXNEaXNwbGF5U2hhZG93Um91bmRDb250cm9scyIsInZlcnRpY2FsQ291bnQiLCJob3Jpem9udGFsQ291bnQiLCJiYXNlUG9zIiwib3JpZ2luYWxQb3MiLCJpc0Rpc3BsYXlWZXJ0aWNhbFNoYWRvdyIsImlzRGlzcGxheSIsImRpc3BsYXkiLCJpbmRleEF0dHIiLCJyZXBsYWNlIiwiaXNSb3VuZCIsInNlbGVjdGVkQ29udHJvbFBvc2UiLCJzZWxlY3RlZFZlcnRpY2FsIiwic2VsZWN0ZWRIb3Jpem9udGFsIiwicG9zZSIsInBvc2VEaXN0IiwiaXNJZGVudGl0eU1hdHJpeCIsImlkZW50aXR5TWF0cml4IiwiQmVmb3JlUmVuZGVyYWJsZSIsImlubGluZVRyYW5zZm9ybSIsImNzc01hdHJpeCIsInN0YXJ0VHJhbnNmb3JtIiwicmVzZXRTdHlsZSIsImZpbGxEcmFnU3RhcnRQYXJhbXMiLCJmaWxsRHJhZ1BhcmFtcyIsIl90aGlzIiwiUmVuZGVyYWJsZSIsImZpbGxEcmFnRW5kUGFyYW1zIiwidHJhbnNmb3JtT2JqZWN0IiwibWF0cml4SW5mbyIsInRyaWdnZXJBYmxlIiwibW92ZWFibGVBYmxlcyIsImV2ZW50T3BlcmF0aW9ucyIsImV2ZW50QWZmaXgiLCJldmVudFR5cGUiLCJyZXF1ZXN0SW5zdGFudCIsInJlcXVlc3RBYmxlXzEiLCJlbGVtZW50RnJvbVBvaW50IiwiaXNEcmFnU3RvcCIsImlzRmlyc3RTdGFydCIsInVwZGF0ZVJlY3QiLCJnZXN0b1R5cGUiLCJwcmV2R2VzdG8iLCJ0cmlnZ2VyIiwiY29uZGl0aW9uTmFtZSIsIm5leHREYXRhcyIsIm9mZiIsImZvcmNlRW5kZWRDb3VudCIsInVwZGF0ZWRDb3VudCIsImV2ZW50T3BlcmF0aW9uIiwiZXZlbnRBYmxlcyIsInJlc3VsdHMiLCJpc1VwZGF0ZSIsImlzRm9yY2VFbmQiLCJwcmV2ZW50RGVmYXVsdCIsImlzVW5tb3VudGVkIiwiZmx1c2hTeW5jIiwiZm9yY2VVcGRhdGUiLCJjaGVja01vdmVhYmxlVGFyZ2V0IiwiZXZlbnRUYXJnZXQiLCJkcmFnVGFyZ2V0RWxlbWVudCIsIl9kcmFnVGFyZ2V0IiwiaXNNb3ZlYWJsZUVsZW1lbnQiLCJjb250cm9sQm94IiwiZ2V0VGFyZ2V0QWJsZUdlc3RvIiwibW92ZWFibGVUYXJnZXQiLCJkcmFnVGFyZ2V0IiwiZHJhZ1RhcmdldFNlbGYiLCJjaGVja1RhcmdldCIsImdldEFibGVHZXN0byIsImdldENvbnRyb2xBYmxlR2VzdG8iLCJjaGVja0NvbnRyb2xUYXJnZXQiLCJhYmxlVHlwZSIsImNvbmRpdGlvbkZ1bmN0aW9ucyIsImlzVGFyZ2V0QWJsZXMiLCJwaW5jaE91dHNpZGUiLCJwaW5jaFRocmVzaG9sZCIsInByZXZlbnRDbGlja0V2ZW50T25EcmFnIiwicHJldmVudENsaWNrRGVmYXVsdCIsImNoZWNrSW5wdXQiLCJkcmFnRm9jdXNlZElucHV0IiwicHJldmVudFJpZ2h0Q2xpY2siLCJwcmV2ZW50V2hlZWxDbGljayIsImRyYWdDb250YWllbnJPcHRpb24iLCJkcmFnQ29udGFpbmVyIiwib3B0aW9ucyIsImdldENvbnRyb2xCb3hFbGVtZW50IiwicHJldmVudENsaWNrRXZlbnRPbkRyYWdTdGFydCIsInByZXZlbnRDbGlja0V2ZW50QnlDb25kaXRpb24iLCJpc1BpbmNoU2NoZWR1bGVkIiwic3RvcFByb3BhZ2F0aW9uIiwiRXZlbnRNYW5hZ2VyIiwiX29uRXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwic2V0QWJsZXMiLCJkZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbGN1bGF0ZU1hdHJpeFN0YWNrIiwicm9vdENvbnRhaW5lciIsImlzQWJzb2x1dGUzZCIsInByZXZUYXJnZXRNYXRyaXgiLCJjb250YWluZXJab29tIiwicm9vdE1hdHJpeGVzIiwiaXNSb290M2QiLCJvZmZzZXRSb290Q29udGFpbmVyIiwicm9vdFpvb20iLCJpc05leHQzZCIsImlzU1ZHR3JhcGhpY0VsZW1lbnQiLCJuZXh0Um9vdE1hdHJpeGVzIiwicmV2ZXJzZSIsIm9yaWdpbmFsUm9vdENvbnRhaW5lciIsImVuZENvbnRhaW5lciIsInJvb3RNYXRyaXhCZWZvcmVPZmZzZXQiLCJuZXh0SW5mbyIsImlzTWF0cml4M2QiLCJvcmlnaW5hbFJvb3RNYXRyaXgiLCJoYXNab29tIiwiY2FsY3VsYXRlRWxlbWVudEluZm8iLCJhbGxSZXN1bHQiLCJnZXRFbGVtZW50SW5mbyIsImdldE1vdmVhYmxlVGFyZ2V0SW5mbyIsIm1vdmVhYmxlRWxlbWVudCIsInBhcmVudENvbnRhaW5lciIsInJlcXVlc3RTdHlsZXMiLCJ0YXJnZXRDbGllbnRSZWN0Iiwicm9vdENvbnRhaW5lckNsaWVudFJlY3QiLCJnZXRTdHlsZV8xIiwiYmVmb3JlUG9zaXRpb24iLCJhYnNvbHV0ZVRhcmdldFBvc2l0aW9uIiwiYWJzb2x1dGVDb250YWluZXJQb3NpdGlvbiIsImNvbnRhaW5lckNsaWVudFJlY3RMZWZ0IiwiY29udGFpbmVyQ2xpZW50UmVjdFRvcCIsImNvbnRhaW50ZXJDbGllbnRMZWZ0IiwiY29udGFpbmVyQ2xpZW50VG9wIiwiY2xpZW50RGVsdGEiLCJvcmlnaW5hbEJlZm9yZU9yaWdpbiIsImdldFBlcnNpc3RTdGF0ZSIsImlzUGVyc2lzdGVkIiwiTW92ZWFibGVNYW5hZ2VyIiwiX3N1cGVyIiwicmVuZGVyTGluZXMiLCJ0YXJnZXRBYmxlcyIsImlzTW92ZWFibGVNb3VudGVkIiwiX3ByZXZPcmlnaW5hbERyYWdUYXJnZXQiLCJfb3JpZ2luYWxEcmFnVGFyZ2V0IiwiX3ByZXZEcmFnVGFyZ2V0IiwiX3ByZXZQcm9wVGFyZ2V0IiwiX3Byb3BUYXJnZXQiLCJfcHJldkRyYWdBcmVhIiwiX2lzUHJvcFRhcmdldENoYW5nZWQiLCJfaGFzRmlyc3RUYXJnZXQiLCJfcmVpc3plT2JzZXJ2ZXIiLCJfb2JzZXJ2ZXJJZCIsIl9tdXRhdGlvbk9ic2VydmVyIiwiX3Jvb3RDb250YWluZXIiLCJfdmlld0NvbnRhaW5lciIsIl92aWV3Q2xhc3NOYW1lcyIsImNoZWNrVXBkYXRlUmVjdCIsIl9vblByZXZlbnRDbGljayIsInByb3BzVGFyZ2V0IiwiY3NwTm9uY2UiLCJ0cmFuc2xhdGVaIiwiQ29udHJvbEJveEVsZW1lbnQiLCJjc3NTdHlsZWQiLCJsaW5lUGFkZGluZyIsImNvbnRyb2xQYWRkaW5nIiwiX2NoZWNrVXBkYXRlUm9vdENvbnRhaW5lciIsImNoZWNrVXBkYXRlIiwidXBkYXRlUmVuZGVyUG9zZXMiLCJzdGF0ZVRhcmdldCIsImdyb3VwVGFyZ2V0cyIsImFibGVBdHRyaWJ1dGVzIiwiZ2V0RW5hYmxlZEFibGVzIiwiYWJsZUNsYXNzTmFtZSIsIl9nZXRBYmxlQ2xhc3NOYW1lIiwiaXNWaXNpYmxlIiwiZmlyc3RSZW5kZXJTdGF0ZSIsInBlcnNpc3REYXRhIiwidXNlQWNjdXJhdGVQb3NpdGlvbiIsIm9uQ2xpY2siLCJyZW5kZXJBYmxlcyIsIl9yZW5kZXJMaW5lcyIsImNvbXBvbmVudERpZE1vdW50IiwiX2NoZWNrVXBkYXRlVmlld0NvbnRhaW5lciIsIl91cGRhdGVUYXJnZXRzIiwiX3VwZGF0ZU5hdGl2ZUV2ZW50cyIsIl91cGRhdGVFdmVudHMiLCJ1cGRhdGVDaGVja0lucHV0IiwiX3VwZGF0ZU9ic2VydmVyIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJkaXNjb25uZWN0Iiwidmlld0NvbnRhaW5lciIsIl9jaGFuZ2VBYmxlVmlld0NsYXNzTmFtZXMiLCJtYW5hZ2VyIiwiZ2V0QWJsZSIsIndyYXBwZXJNb3ZlYWJsZSIsImdldERyYWdFbGVtZW50IiwidHJpZ2dlckRyYWdTdGFydCIsImhpdFRlc3QiLCJwb2ludHMiLCJ0b3RhbFNpemUiLCJpc1RhcmdldCIsImlzU2V0U3RhdGUiLCJpc1NpbmdsZSIsIm5leHRTdGF0ZSIsIl9nZXRSZXF1ZXN0U3R5bGVzIiwicGVyc2lzdFN0YXRlIiwibmFtZV8yIiwidXBkYXRlU3RhdGUiLCJ1cGRhdGVUYXJnZXQiLCJzdGF0ZVBvcyIsImdldE1hbmFnZXIiLCJpc0luc3RhbnQiLCJhbGxBYmxlcyIsInJlcXVzZXRBYmxlIiwiYWJsZVJlcXVlc3RlciIsInJlcXVlc3RlciIsImFibGVQYXJhbSIsImdldE1vdmVhYmxlcyIsInN0YXRlTGVmdCIsInN0YXRlVG9wIiwicmVuZGVyUG9zMyIsInJlbmRlclBvczQiLCJ6b29tT2Zmc2V0Iiwic3RhdGVDb250YWluZXIiLCJ1cGRhdGVBYmxlcyIsImlzVGFyZ2V0Q2hhbmdlZCIsImlzQ2hhbmdlZCIsIm1vdmVhYmxlQ29udGFpbmVyIiwid2FpdFRvQ2hhbmdlVGFyZ2V0IiwiUHJvbWlzZSIsInVzZUNTUyIsInRhZyIsImN1c3RvbVN0eWxlTWFwIiwiY3VzdG9tU3R5bGVkTWFwIiwiaGFzQ29udHJvbEJveCIsInVwZGF0ZVNlbGVjdG9ycyIsInNldFN0YXRlIiwibmFtZV8zIiwiYWx3YXlzIiwiUmVuZGVyZXIiLCJzdHlsZU5hbWVzIiwiYWJsZVN0eWxlTmFtZXMiLCJfdXBkYXRlUmVzaXplT2JzZXJ2ZXIiLCJfdXBkYXRlTXV0YXRpb25PYnNlcnZlciIsImhhc1RhcmdldEFibGUiLCJoYXNDb250cm9sQWJsZSIsImlzVW5zZXQiLCJfaXNUYXJnZXRDaGFuZ2VkIiwiaGlkZURlZmF1bHRMaW5lcyIsImhpZGVDaGlsZE1vdmVhYmxlRGVmYXVsdExpbmVzIiwidXNlRHJhZ0FyZWEiLCJuZXh0VGFyZ2V0IiwicHJldlRhcmdldCIsInByZXZEcmFnQXJlYSIsImlzRHJhZ1RhcmdldENoYW5nZWQiLCJpc0RyYWdBcmVhQ2hhbmdlZCIsImV2ZW50S2V5cyIsImhhc0FibGVzIiwidmlld0NvbnRhaW5lck9wdGlvbiIsIl9nZXRBYmxlVmlld0NsYXNzTmFtZXMiLCJuZXh0Q2xhc3NOYW1lcyIsInByZXZDbGFzc05hbWVzIiwicmVtb3ZlZCIsImNsYXNzUHJlZml4IiwidGFyZ2V0R2VzdG9EYXRhIiwiY29udHJvbEdlc3RvRGF0YSIsInRyaW0iLCJ3aW4iLCJSZXNpemVPYnNlcnZlciIsInVzZVJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYm94IiwiTXV0YXRpb25PYnNlcnZlciIsInVzZU11dGF0aW9uT2JzZXJ2ZXIiLCJyZWNvcmRzIiwiZV8xIiwicmVjb3Jkc18xIiwicmVjb3Jkc18xXzEiLCJtdXRhdGlvbiIsImF0dHJpYnV0ZU5hbWUiLCJlXzFfMSIsInJldHVybiIsImF0dHJpYnV0ZXMiLCJkZWZhdWx0UHJvcHMiLCJpc1dyYXBwZXJNb3VudGVkIiwid2FycFNlbGYiLCJQdXJlQ29tcG9uZW50IiwiR3JvdXBhYmxlIiwicmVuZGVyR3JvdXBSZWN0cyIsInBlcnNpc3REYXRDaGlsZHJlbiIsImdldFJlcXVlc3RDaGlsZFN0eWxlcyIsIkNsaWNrYWJsZSIsImNvbnRhaW5zRWxlbWVudCIsImNvbnRhaW5zVGFyZ2V0IiwidGFyZ2V0SW5kZXgiLCJwYXJlbnRUYXJnZXQiLCJnZXREcmFnZ2FibGVFdmVudCIsImVkZ2VEcmFnZ2FibGUiLCJkcmFnQ29uZGl0aW9uIiwiZHJhZ0dyb3VwQ29uZGl0aW9uIiwiSW5kaXZpZHVhbEdyb3VwYWJsZSIsIk1PVkVBQkxFX0FCTEVTIiwiTU9WRUFCTEVfRVZFTlRTIiwiTU9WRUFCTEVfUFJPUFMiLCJzb2x2ZUNvbnN0YW50c0Rpc3RhbmNlIiwic29sdmVDIiwiZ2V0TWF4UG9zIiwiZ2V0TWluUG9zIiwiZ2V0R3JvdXBSZWN0IiwicGFyZW50UG9zZXMiLCJmaXhlZFJvdGF0aW9uIiwiYTFfMSIsInRhbiIsImEyXzEiLCJhMU1pbk1heF8xIiwiYTFNaW5NYXhQb3NfMSIsImEyTWluTWF4XzEiLCJhMk1pbk1heFBvc18xIiwiYTFEaXN0IiwiYTJEaXN0IiwiYTFNaW5Qb3MiLCJhMU1heFBvcyIsImEyTWluUG9zIiwiYTJNYXhQb3MiLCJtaW5Ib3Jpem9udGFsTGluZSIsIm1heEhvcml6b250YWxMaW5lIiwibWluVmVydGljYWxMaW5lIiwibWF4VmVydGljYWxMaW5lIiwibGluZTEiLCJsaW5lMiIsIm1pblhfMSIsIm1pbllfMSIsIm1heFhfMSIsIm1heFlfMSIsImNoYW5nZWRYIiwiZmluZE1vdmVhYmxlR3JvdXBzIiwiY2hpbGRUYXJnZXRHcm91cHMiLCJ0YXJnZXRHcm91cCIsImNoaWxkTW92ZWFibGVHcm91cHMiLCJjaGVja2VkIiwiZmluZGVkIiwiTW92ZWFibGVHcm91cCIsImRpZmZlciIsIl90YXJnZXRHcm91cHMiLCJfaGFzRmlyc3RUYXJnZXRzIiwiY2hlY2tlZHMiLCJ0YXJnZXRHcm91cHMiLCJtb3ZlYWJsZUdyb3VwcyIsInVzZURlZmF1bHRHcm91cFJvdGF0ZSIsImlzUmVzZXQiLCJ1cGRhdGVHcm91cCIsImRlZmF1bHRHcm91cFJvdGF0ZSIsInBlcnNpc3RlZFJvYXRhdGlvbiIsImdldE1vdmVhYmxlR3JvdXBSZWN0IiwicGFyZW50Um90YXRpb24iLCJwb3Nlc1JvdGF0aW9ucyIsInJvdGF0aW9ucyIsImdyb3VwUm90YXRpb24iLCJmaXJzdFJvdGF0aW9uIiwiaXNTYW1lUm90YXRpb24iLCJncm91cFBvc2VzIiwiZ3JvdXBSZWN0Iiwicm9vdEdyb3VwUmVjdCIsImRlZmF1bHRHcm91cE9yaWdpbiIsInBvc2VzSW5mbyIsInJvdGF0ZVNjYWxlIiwidXBkYXRlIiwiY2hhbmdlZCIsImlzQ29udGFpbmVyQ2hhbmdlZCIsIk1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwIiwiY2FuUGVyc2lzdCIsImluZGl2aWR1YWxQcm9wcyIsImluZGl2aWR1YWxHcm91cGFibGVQcm9wcyIsImNvbnRyb2xCb3hFbGVtZW50IiwiZHJhZ0VsZW1lbnQiLCJnZXRFbGVtZW50VGFyZ2V0cyIsInJlZlRhcmdldHMiLCJzZWxlY3Rvck1hcCIsImVsZW1lbnRUYXJnZXRzIiwiZ2V0VGFyZ2V0R3JvdXBzIiwiY29tcGFyZVJlZlRhcmdldHMiLCJwcmV2UmVmVGFyZ2V0cyIsIm5leHRSZWZUYXJnZXRzIiwiSW5pdGlhbE1vdmVhYmxlIiwiX2RpZmZlciIsIl9lbGVtZW50VGFyZ2V0cyIsIl90bXBSZWZUYXJnZXRzIiwiX3RtcFNlbGVjdG9yTWFwIiwiX29uQ2hhbmdlVGFyZ2V0cyIsIm1ha2VTdHlsZWQiLCJjc3NNYXAiLCJnZXRUb3RhbEFibGVzIiwiZGVmYXVsdFN0eWxlZCIsImRlZmF1bHRBYmxlcyIsIm1vdmVhYmxlQ29udHJ1Y3RvciIsInVzZXJBYmxlcyIsInVzZXJQcm9wcyIsIl91cGRhdGVSZWZzIiwibmV4dFNlbGVjdG9yTWFwIiwidG90YWxBYmxlcyIsIm5leHRQcm9wcyIsInByZXZNb3ZlYWJsZSIsImluZGl2aWR1YWxHcm91cGFibGUiLCJncm91cGFibGVQcm9wcyIsInRhcmdldF8xIiwicHJldlRhcmdldE1vdmVhYmxlIiwibXYiLCJfY2hlY2tDaGFuZ2VUYXJnZXRzIiwicmVzb2x2ZVByb21pc2UiLCJ3YWl0VG9DaGFuZ2VUYXJnZXRzIiwiaXNCcm93c2VyIiwidXBkYXRlU2VsZWN0b3JNYXAiLCJzZWxlY3RvclRhcmdldCIsIm9uQ2hhbmdlVGFyZ2V0cyIsIk1vdmVhYmxlIiwibWFrZU1vdmVhYmxlIiwiRWRnZURyYWdnYWJsZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-moveable/dist/moveable.esm.js\n");

/***/ })

};
;